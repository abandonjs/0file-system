[{"name":"Back-End","path":"../guanruihua.github.io","data":"","children":[{"name":"C语言","path":"../guanruihua.github.io/Back-End","data":"","children":[{"name":"C++","path":"../guanruihua.github.io/Back-End/C语言","data":"","children":[{"name":"C++basic.md","path":"../guanruihua.github.io/Back-End/C语言/C++","data":"# C++ basic\n\n## 前言\n\n> - C++ 是一种中级语言，它是由 Bjarne Stroustrup 于 1979 年在贝尔实验室开始设计开发的。\n> - C++ 进一步扩充和完善了 C 语言，是一种面向对象的程序设计语言。\n>- C++ 可运行于多种平台上，如 Windows、MAC 操作系统以及 UNIX 的各种版本。\n> - 源码文件通用使用拓展名.cpp, .cp 或 .c\n\n### 四大特性\n\n> - 封装\n> - 抽象\n> - 继承\n> - 多态\n\n### 标准库\n\n> - 三个重要部分组成\n>   - 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。\n>   - C++ 标准库，提供了大量的函数，用于操作文件、字符串等。\n>   - 标准模板库（STL），提供了大量的方法，用于操作数据结构等。\n\n## 基础\n\n> - **对象 -** 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。\n> - **类 -** 类可以定义为描述对象行为/状态的模板/蓝图。\n> - **方法 -** 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。\n> - **即时变量 -** 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。\n\n```c++\n#include <iostream> // 定义头文件\nusing namespace std; // 告诉编译器使用std命名空间\n \n// main() 是程序开始执行的地方\n \nint main()\n{\n   cout << \"Hello World\"; // 输出 Hello World\n   return 0;\n}\n```\n\n### 关键词\n\n| asm          | else      | new              | this     |\n| ------------ | --------- | ---------------- | -------- |\n| auto         | enum      | operator         | throw    |\n| bool         | explicit  | private          | true     |\n| break        | export    | protected        | try      |\n| case         | extern    | public           | typedef  |\n| catch        | false     | register         | typeid   |\n| char         | float     | reinterpret_cast | typename |\n| class        | for       | return           | union    |\n| const        | friend    | short            | unsigned |\n| const_cast   | goto      | signed           | using    |\n| continue     | if        | sizeof           | virtual  |\n| default      | inline    | static           | void     |\n| delete       | int       | static_cast      | volatile |\n| do           | long      | struct           | wchar_t  |\n| double       | mutable   | switch           | while    |\n| dynamic_cast | namespace | template         |          |\n\n### 数据结构\n\n| 类型     | 关键字                                |\n| :------- | :------------------------------------ |\n| 布尔型   | bool                                  |\n| 字符型   | char                                  |\n| 整型     | int                                   |\n| 浮点型   | float                                 |\n| 双浮点型 | double                                |\n| 无类型   | void                                  |\n| 宽字符型 | wchar_t(`typedef short int wchar_t;`) |\n\n| 类型               | 位            | 范围                                                         |\n| :----------------- | :------------ | :----------------------------------------------------------- |\n| char               | 1 个字节      | -128 到 127 或者 0 到 255                                    |\n| unsigned char      | 1 个字节      | 0 到 255                                                     |\n| signed char        | 1 个字节      | -128 到 127                                                  |\n| int                | 4 个字节      | -2147483648 到 2147483647                                    |\n| unsigned int       | 4 个字节      | 0 到 4294967295                                              |\n| signed int         | 4 个字节      | -2147483648 到 2147483647                                    |\n| short int          | 2 个字节      | -32768 到 32767                                              |\n| unsigned short int | 2 个字节      | 0 到 65,535                                                  |\n| signed short int   | 2 个字节      | -32768 到 32767                                              |\n| long int           | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |\n| signed long int    | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |\n| unsigned long int  | 8 个字节      | 0 到 18,446,744,073,709,551,615                              |\n| float              | 4 个字节      | 精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字) |\n| double             | 8 个字节      | 双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字) |\n| long double        | 16 个字节     | 长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 |\n| wchar_t            | 2 或 4 个字节 | 1 个宽字符                                                   |\n\n#### typedef声明\n\n> 给已有的类型取一个新的名字\n\n```c++\n#include <iostream>\nusing namespace std;\ntypedef int newname;\nint main()\n{\n    newname a = 1;\n    cout << a << endl;  \n    return 0;  \n}\n\n// 1 \n```\n\n#### 枚举类型\n\n```c++\nenum 枚举名{ \n     标识符[=整型常数], \n     标识符[=整型常数], \n... \n    标识符[=整型常数]\n} 枚举变量;\n```\n\neg:\n\n```c++\nenum color { red, green, blue } c;\nc = blue;// 2\n\n// 可以自己赋值\nenum color { red, green=5, blue };\n```\n\n##### 初始值\n\n```c++\nenum week{ Mon = 1, Tues, Wed, Thurs = 6 , Fri, Sat, Sun } day;\nday = Wed ; // 3\nday = Fri ; // 7\n```\n\n> - 默认值(但是前面的值没有赋值的情况下, 有则是往后加一)\n>   - 第一个名称为0\n>   - 第二个名称为1\n>   - 以此类推\n\n<https://www.runoob.com/cplusplus/cpp-variable-types.html>\n\n<http://c.biancheng.net/view/1367.html>\n","children":[]}]}]},{"name":"GoLang","path":"../guanruihua.github.io/Back-End","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Back-End/GoLang","data":"# Go\n","children":[]}]},{"name":"Java","path":"../guanruihua.github.io/Back-End","data":"","children":[{"name":"java-basis.md","path":"../guanruihua.github.io/Back-End/Java","data":"# java\n\n> [文档](http://c.biancheng.net/view/6262.html)\n>\n> cmd界面运行java文件\n>\n> 1. 创建.java文件\n> 2. cmd界面到该文件路径下,  运行`javac 文件名.java`\n> 3. 运行成功会生成一个.class文件\n> 4. 再运行`java 文件名`就可以看到结果\n\n## 基础\n\n### 标识符\n\n> - 标识符由数字（0\\~9）和字母（A~Z 和 a~z）、美元符号（$）、下划线（_）以及 Unicode 字符集中符号大于 0xC0 的所有符号组合构成（各符号之间没有空格）。\n> - 标识符的第一个符号为字母、下划线和美元符号，后面可以是任何字母、数字、美元符号或下划线。\n\n### 关键字\n\n> 1. 数据类型：boolean、int、long、short、byte、float、double、char、class、interface。\n> 2. 流程控制：if、else、do、while、for、switch、case、default、break、continue、return、try、catch、finally。\n> 3. 修饰符：public、protected、private、final、void、static、strict、abstract、transient、synchronized、volatile、native。\n> 4. 动作：package、import、throw、throws、extends、implements、this、supper、instanceof、new。\n> 5. 保留字：true、false、null、goto、const。\n\n### 注释\n\n```java\n单行注释\n//注释\n\n多行注释\n/* \n 注释 \n*/\n文档注释\n/**\n * 文档注释\n*/\n```\n\n### 基本数据类型\n\n> null： 基本数据类型直接量只有一个值（null), 可以给任何数据类型赋值\n\n| 名称    | 包装类    | 字节数  | 栗子        | 直接量                    |\n| ------- | --------- | ------- | ----------- | ------------------------- |\n| byte    | Byte      | 1       | 1           | 012(八进制)、0x12(16进制) |\n| short   | Short     | 2       | 2           |                           |\n| int     | Interger  | 4       | 123         |                           |\n| long    | Long      | 8       | 123         |                           |\n| float   | Float     | 4       | 3.14f       | 5.34F、3.14E5f            |\n| double  | Double    | 8       | 1.1         | 5.34、3.14E5              |\n| char    | Character | 2       | \"关\"        | ‘a’，‘\\n’和‘\\u0061’       |\n| String  | /         | /       | \"华\"        |                           |\n| boolean | Boolean   | 一般是4 | true\\|flase |                           |\n\n### 包装类和基本数据类型\n\n> 包装类 : 能够直接将简单类型的变量表示为一个类，在执行变量类型的相互转换时，我们会大量使用这些包装类\n\n#### 包装类的用途\n\n> 1. 集合中不可以存放基本数据类型, 故常用包装类\n> 2. 包含了每种基本类型的相关属性, 如最大值, 最小值, 所占位符数\n> 3. 作为基本数据类型对应的类类型, 提供了一系列的对象操作, 如类型转换, 进制转换等\n\n#### 基本类型与包装类型的区别\n\n> 1、在Java中，一切皆对象，但八大基本类型却不是对象。\n>\n> 2、声明方式的不同，基本类型无需通过new关键字来创建，而封装类型需new关键字。\n> 3、存储方式及位置的不同，基本类型是直接存储变量的值保存在堆栈中能高效的存取，封装类型需要通过引用指向实例，具体的实例保存在堆中。\n> 4、初始值的不同，封装类型的初始值为null，基本类型的的初始值视具体的类型而定，比如int类型的初始值为0，boolean类型为false；\n> 5、使用方式的不同，比如与集合类合作使用时只能使用包装类型。\n> 6、什么时候该用包装类，什么时候用基本类型，看基本的业务来定：这个字段允许null值，就需要使用包装类型，如果不允许null值，使用基本类型就可以了，用到比如泛型和反射调用函数，就需要用包装类！\n>\n> 7、Ingeter是int的包装类,初始值null, int 初始值为0\n\n### 引用数据类型\n\n> - 类 class\n> - 接口 interface\n> - 数组 []\n\n#### 数组\n\n常用定义方法\n\n```java\n//一维数组\nint[] str;\nint str = new int[]{1, 2, 3, 4 };\nint str = {1, 2, 3, 4, 5};\nint[] str = new String[5];\n//二维数组\nint[][] str = new int[][]{{1, 2, 3, 4}, {1, 2, 3, 4} }\nint[][] str = new int[2][3];\nint[][] str = new int[2][];\n```\n\n### 类型转换\n\n#### 隐式转换(自动类型转换)\n\n- 数值型数据的转换：byte→short→int→long→float→double。\n- 字符型转换为整型：char→int。\n\n#### 显示转换(强制类型转换)\n\n> 当转换的两种类型不兼容, 或目标类型的取值范围小于源数据类型时, 自动转换键无法进行, 这时需要进行强制类型转换\n\n```java\n(type)variableName\n```\n\n### java运算符\n\n#### 一元运算符\n\n| 运 算 符 | 名 称    | 说 明                        | 例 子      |\n| -------- | -------- | ---------------------------- | ---------- |\n| -        | 取反符号 | 取反运算                     | b=-a       |\n| ++       | 自加一   | 先取值再加一，或先加一再取值 | a++ 或 ++a |\n| --       | 自减一   | 先取值再减一，或先减一再取值 | a-- 或 --a |\n\n> ++/ - - : 在前要先进行自加(减)\n\n#### 二元运算符\n\n| 运 算 符 | 名 称 | 说 明                                                    | 例 子 |\n| -------- | ----- | -------------------------------------------------------- | ----- |\n| +        | 加    | 求 a 加 b 的和，还可用于 String 类型，进行字符串连接操作 | a + b |\n| -        | 减    | 求 a 减 b 的差                                           | a - b |\n| *        | 乘    | 求 a 乘以 b 的积                                         | a * b |\n| /        | 除    | 求 a 除以 b 的商                                         | a / b |\n| %        | 取余  | 求 a 除以 b 的余数                                       | a % b |\n\n#### 算术赋值运算符\n\n| 运 算 符 | 名 称    | 例 子            |\n| -------- | -------- | ---------------- |\n| +=       | 加赋值   | a += b、a += b+3 |\n| -=       | 减赋值   | a -= b           |\n| *=       | 乘赋值   | a *= b           |\n| /=       | 除赋值   | a /= b           |\n| %=       | 取余赋值 | a %= b           |\n\n#### 逻辑运算符\n\n| 运算符 | 用法   | 含义   | 说明                                               | 实例       | 结果  |\n| :----- | :----- | :----- | :------------------------------------------------- | :--------- | :---- |\n| &&     | a&&b   | 短路与 | ab 全为 true 时，计算结果为 true，否则为 false。   | 2>1&&3<4   | true  |\n| \\|\\|   | a\\|\\|b | 短路或 | ab 全为 false 时，计算结果为 false，否则为 true。  | 2<1\\|\\|3>4 | false |\n| !      | !a     | 逻辑非 | a 为 true 时，值为 false，a 为 false 时，值为 true | !(2>4)     | true  |\n| \\|     | a\\|b   | 逻辑或 | ab 全为 false 时，计算结果为 false，否则为 true    | 1>2\\|3>5   | false |\n| &      | a&b    | 逻辑与 | ab 全为 true 时，计算结果为 true，否则为 false     | 1<2&3<5    | true  |\n\n#### 关系运算符\n\n| 运算符 | 含义       | 说明                                                         | 实例                            | 结果                 |\n| ------ | ---------- | ------------------------------------------------------------ | ------------------------------- | -------------------- |\n| >      | 大于       | 只支持左右两边操作数是数值类型。如果前面变量的值大于后面变量的值， 则返回 true。 | 2>3                             | false                |\n| >=     | 大于或等于 | 只支持左右两边操作数是数值类型。如果前面变量的值大于等于后面变量的值， 则返回 true。 | 4>=2                            | true                 |\n| <      | 小于       | 只支持左右两边操作数是数值类型。如果前面变量的值小于后面变量的值，则返回 true。 | 2<3                             | true                 |\n| <=     | 小于或等于 | 只支持左右两边操作数是数值类型。如果前面变量的值小于等于后面变量的值， 则返回 true。 | 4<=2                            | false                |\n| ==     | 相等       | 如果进行比较的两个操作数都是数值类型，无论它们的数据类型是否相同，只要它们的值相等，也都将返回 true。 如果两个操作数都是引用类型，只有当两个引用变量的类型具有父子关系时才可以比较，只要两个引用指向的不是同一个对象就会返回 true。 [Java](http://c.biancheng.net/java/) 也支持两个 boolean 类型的值进行比较。 | 4==4 97=='a' 5.0==5 true==false | true true true false |\n| !=     | 不相等     | 如果进行比较的两个操作数都是数值类型，**无论它们的数据类型是否相同**，只要它们的**值不相等**，也都将返回 true。<br> 如果两个操作数都是引用类型，只有当两个引用变量的类型具有父子关系时才可以比较，只要两个引用指向的不是同一个对象就会返回 true。 | 4!=2                            | true                 |\n\n#### 位运算符\n\n| 运算符 | 含义                    | 实例   | 结果 |\n| ------ | ----------------------- | ------ | ---- |\n| &      | 按位进行与运算（AND）   | 4 & 5  | 4    |\n| \\|     | 按位进行或运算（OR）    | 4 \\| 5 | 5    |\n| ^      | 按位进行异或运算（XOR） | 4 ^ 5  | 1    |\n| ~      | 按位进行取反运算（NOT） | ~ 4    | -5   |\n\n#### 三目运算符\n\n> `result = <expression> ? <statement1> : <statement3>;`\n\n#### 运算符优先级\n\n| 优先级 | 运算符                                           | 结合性   |\n| ------ | ------------------------------------------------ | -------- |\n| 1      | ()、[]、{}                                       | 从左向右 |\n| 2      | !、+、-、~、++、--                               | 从右向左 |\n| 3      | *、/、%                                          | 从左向右 |\n| 4      | +、-                                             | 从左向右 |\n| 5      | «、»、>>>                                        | 从左向右 |\n| 6      | <、<=、>、>=、instanceof                         | 从左向右 |\n| 7      | ==、!=                                           | 从左向右 |\n| 8      | &                                                | 从左向右 |\n| 9      | ^                                                | 从左向右 |\n| 10     | \\|                                               | 从左向右 |\n| 11     | &&                                               | 从左向右 |\n| 12     | \\|\\|                                             | 从左向右 |\n| 13     | ?:                                               | 从右向左 |\n| 14     | =、+=、-=、*=、/=、&=、\\|=、^=、~=、«=、»=、>>>= | 从右向左 |\n\n### 流程控制语句\n\n> if else\n>\n> switch case\n>\n> while\n>\n> do…while\n>\n> for\n>\n> foreach\n>\n> ```java\n> for(类型 变量名:集合) {\n>     语句块;\n> }\n> ```\n>\n> break\n>\n> continue\n\n### 字符串处理\n\n> 不可变的好处\n>\n> - String的hash值经常被使用, 例如String 用做HashMap的key,不可以变的特性可以使得hash值也不可以变, 因此只需要进行一次计算\n> - String Pool的需要\n>   - 如果一个String对象已经被创建过了, 那么就会从String Pool中去的应用,只有String是不可以变的, 才可能使用String Pool\n\n#### 直接定义字符串\n\n```java\nString str = \"hello\";\n```\n\n#### 使用String类定义\n\n```java\n// String()\nnew String(); // 空字符序列\n\n// String(String original)\nString str1 = new String(\"Hello Java\"); // 新建字符串序列\nString str2 = new String(str1); // 这可以说是str1的一个副本\n\n// String(char[] value)\nchar a[] = {'H','e','l','l','0'};\nString sChar = new String(a);\na[1] = 's'; // 不会影响sChar的值\n\n// String(char[] value, int offset, int count)\nchar a[]={'H','e','l','l','o'};\nString sChar=new String(a,1,4); // ello\na[1]='s';  // 不会影响sChar的值\n```\n\n#### String转换为int\n\n> - Integer.parseInt(str)\n> - Integer.valueOf(str).intValue()\n\n#### int转换为String\n\n> - String s = String.valueOf(i);\n> - String s = Integer.toString(i);\n> - String s = \"\" + i;\n\n#### String, StringBuffer 和 StringBuilder类区别\n\n> - 可变性\n>   - String 不可变\n>   - StringBuffer和StringBuilder可变\n> - 线程安全\n>   - String不可变, so 线程安全\n>   - StringBuilder不是线程安全的\n>   - StringBuffer 是线程安全, 内部使用synchronized 进行同步\n\n![](https://images.gitee.com/uploads/images/2020/1102/010927_dfdaec78_7984151.png)\n\n### 数字和日期处理\n\n### 内置安装包\n\n### 数组处理\n\n### 类和对象\n\n### 继承和多态\n\n### 异常处理\n\n### 集合、泛型和枚举\n\n### 反射机制\n\n### 输入输出流\n\n### 注解\n\n## 队列\n\n> 队列: 先进先出(First IN First Out, FIFO)\n>\n> 常用方法:\n>\n> - 去队(enqueque)\n> - 出队(dequeue)\n>\n> 入口端口叫队尾(rear)\n>\n> 出口端口叫队首(front)\n>\n> 常见使用场景\n>\n> - 存储多线程中等待排队执行的任务\n> - 存储多线程公平说中等待执行任务的线程\n> - 常见消息中间件的任务队列等\n\n### 自定义队列\n\n```java\npublic class MyQueue<E> {\n\n    private Object[] queue; // 存储容器\n    private int head; // 头部指针\n    private int tail; // 尾部指针\n    private int size; // 队列实际存储长度\n    private int maxSize; // 最大容量\n\n    public MyQueue() {\n        // 无参构造函数，设置默认参数\n        this.maxSize = 10;\n        this.head = 0;\n        this.tail = -1;\n        this.size = 0;\n        this.queue = new Object[this.maxSize];\n    }\n\n    public MyQueue(int initSize) {\n        // 有参构造函数，设置参数\n        this.maxSize = initSize;\n        this.head = 0;\n        this.tail = -1;\n        this.size = 0;\n        this.queue = new Object[this.maxSize];\n    }\n\n    /**\n     * 查询队头元素\n     */\n    public E peek() throws Exception {\n        if (size == 0) {\n            throw new Exception(\"队列中暂无数据\");\n        }\n        return (E) this.queue[this.head];\n    }\n\n    /**\n     * 入列\n     */\n    public boolean offer(E e) throws Exception {\n        if (tail >= (maxSize - 1)) {\n            throw new Exception(\"添加失败，队列已满\");\n        }\n        this.queue[++tail] = e;\n        size++;\n        return true;\n    }\n\n    /**\n     * 出列\n     */\n    public E poll() throws Exception {\n        if (size == 0) {\n            throw new Exception(\"删除失败，队列为空\");\n        }\n        size--;\n        return (E) this.queue[head++];\n    }\n\n    /**\n     * 代码测试\n     */\n    public static void main(String[] args) throws Exception {\n        MyQueue queue = new MyQueue();\n        queue.offer(\"Hello\");\n        queue.offer(\"Java\");\n        System.out.println(queue.peek());\n        queue.poll();\n        System.out.println(queue.poll());\n    }\n}\n\n// 运行结果\nHello\nJava\n```\n\n自定义队列 - 链表\n\n![](https://images.gitee.com/uploads/images/2020/1023/212153_7c979d68_7984151.png)\n\n```java\npublic class QueueByLinked {\n\n    /**\n     * 声明链表节点\n     */\n    static class Node<E> {\n        E item; // 当前的值\n        Node<E> next; // 下一个节点\n        Node(E e) {\n            this.item = e;\n        }\n    }\n\n    private Node firstNode; // 队头元素\n    private Node lastNode; // 队尾元素\n    private int size; // 队列实际存储数量\n    private int maxSize; // 队列最大容量\n\n    public QueueByLinked(int maxSize) {\n        if (maxSize <= 0) throw new RuntimeException(\"队列最大容量不能为空\");\n        // 默认初始化函数\n        firstNode = lastNode = new Node(null);\n        this.size = 0;\n        this.maxSize = maxSize;\n    }\n\n    /**\n     * 判断队列是否为空\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * 入列\n     */\n    public void offer(Object e) {\n        // 最大值效验\n        if (maxSize <= size) throw new RuntimeException(\"队列已满\");\n        Node node = new Node(e);\n        lastNode = lastNode.next = node; // 设置最后一个节点和倒数第二个节点的 next\n        size++; // 队列数量 +1\n    }\n\n    /**\n     * 出列\n     */\n    public Node poll() {\n        if (isEmpty()) throw new RuntimeException(\"队列为空\");\n        size--; // 队列数量 -1\n        return firstNode = firstNode.next; // 设置并返回队头元素（第一个节点是 null，当前元素则为 Node.next）\n    }\n    \n    /**\n     * 查询队头元素\n     */\n    public Node peek() {\n        if (isEmpty()) throw new RuntimeException(\"队列为空\");\n        return firstNode.next;  // 返回队头元素（第一个节点是 null，当前元素则为 Node.next）\n    }\n\n    /**\n     * 代码测试\n     */\n    public static void main(String[] args) {\n        QueueByLinked queue = new QueueByLinked(10);\n        queue.offer(\"Hello\");\n        queue.offer(\"JDK\");\n        queue.offer(\"Java\");\n        System.out.println(queue.poll().item);\n        System.out.println(queue.poll().item);\n        System.out.println(queue.poll().item);\n    }\n}\n\n// 执行结果\nHello\nJDK\nJava\n```\n\n使用List实现自定义队列\n\n> 不建议使用\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * 自定义队列（List方式）\n */\npublic class QueueByList<E> {\n\n    private List value; // 队列存储容器\n\n    public QueueByList() {\n        // 初始化\n        value = new ArrayList();\n    }\n\n    /**\n     * 判断队列是否为空\n     */\n    public boolean isEmpty() {\n        return value.size() == 0;\n    }\n\n    /**\n     * 入列\n     */\n    public void offer(Object e) {\n        value.add(e);\n    }\n\n    /**\n     * 出列\n     */\n    public E poll() {\n        if (isEmpty()) throw new RuntimeException(\"队列为空\");\n        E item = (E) value.get(0);\n        value.remove(0);\n        return item;\n    }\n\n    /**\n     * 查询队头元素\n     */\n    public E peek() {\n        if (isEmpty()) throw new RuntimeException(\"队列为空\");\n        return (E) value.get(0);\n    }\n\n    /**\n     * 代码测试\n     */\n    public static void main(String[] args) {\n        QueueByList queue = new QueueByList();\n        queue.offer(\"Hello\");\n        queue.offer(\"JDK\");\n        queue.offer(\"Java\");\n        System.out.println(queue.poll());\n        System.out.println(queue.poll());\n        System.out.println(queue.poll());\n    }\n}\n// 执行结果\nHello\nJDK\nJava\n```\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f54994efac0d43de9c8a93f0b8ef9f5a~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\" style=\"zoom:50%;\" />\n\n### 阻塞队列和非阻塞队列\n\n阻塞队列（Blocking Queue）提供了可阻塞的 `put` 和 `take` 方法，它们与可定时的 `offer` 和 `poll` 是等价的。如果队列满了 `put` 方法会被阻塞等到有空间可用再将元素插入；如果队列是空的，那么 `take` 方法也会阻塞，直到有元素可用。当队列永远不会被充满时，`put` 方法和 `take` 方法就永远不会阻塞。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdec5b9180a446a7b2277cef0944d30d~tplv-k3u1fbpfcp-zoom-1.image)\n\n我们可以从队列的名称中知道此队列是否为阻塞队列，阻塞队列中包含 `BlockingQueue` 关键字，比如以下这些：\n\n- ArrayBlockingQueue\n- LinkedBlockingQueue\n- PriorityBlockingQueue\n- .......\n\n#### 阻塞队列功能演示\n\n接下来我们来演示一下当阻塞队列的容量满了之后会怎样，示例代码如下：\n\n```java\nimport java.util.Date;\nimport java.util.concurrent.ArrayBlockingQueue;\n\npublic class BlockingTest {\n    public static void main(String[] args) throws InterruptedException {\n        // 创建一个长度为 5 的阻塞队列\n        ArrayBlockingQueue q1 = new ArrayBlockingQueue(5);\n        \n        // 新创建一个线程执行入列\n        new Thread(() -> {\n            // 循环 10 次\n            for (int i = 0; i < 10; i++) {\n                try {\n                    q1.put(i);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(new Date() + \" | ArrayBlockingQueue Size:\" + q1.size());\n            }\n            System.out.println(new Date() + \" | For End.\");\n        }).start();\n\n        // 新创建一个线程执行出列\n        new Thread(() -> {\n            for (int i = 0; i < 5; i++) {\n                try {\n                    // 休眠 1S\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                if (!q1.isEmpty()) {\n                    try {\n                        q1.take(); // 出列\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }).start();\n    }\n}\n```\n\n以上代码的执行结果如下：\n\n> Mon Oct 19 20:16:12 CST 2020 | ArrayBlockingQueue Size:1\n>\n> Mon Oct 19 20:16:12 CST 2020 | ArrayBlockingQueue Size:2\n>\n> Mon Oct 19 20:16:12 CST 2020 | ArrayBlockingQueue Size:3\n>\n> Mon Oct 19 20:16:12 CST 2020 | ArrayBlockingQueue Size:4\n>\n> Mon Oct 19 20:16:12 CST 2020 | ArrayBlockingQueue Size:5\n>\n> Mon Oct 19 20:16:13 CST 2020 | ArrayBlockingQueue Size:5\n>\n> Mon Oct 19 20:16:14 CST 2020 | ArrayBlockingQueue Size:5\n>\n> Mon Oct 19 20:16:15 CST 2020 | ArrayBlockingQueue Size:5\n>\n> Mon Oct 19 20:16:16 CST 2020 | ArrayBlockingQueue Size:5\n>\n> Mon Oct 19 20:16:17 CST 2020 | ArrayBlockingQueue Size:5\n>\n> Mon Oct 19 20:16:17 CST 2020 | For End.\n\n从上述结果可以看出，当 `ArrayBlockingQueue` 队列满了之后就会进入阻塞，当过了 1 秒有元素从队列中移除之后，才会将新的元素入列。\n\n#### 非阻塞队列\n\n非阻塞队列也就是普通队列，它的名字中不会包含 `BlockingQueue` 关键字，并且它不会包含 `put` 和 `take` 方法，当队列满之后如果还有新元素入列会直接返回错误，并不会阻塞的等待着添加元素，如下图所示： ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20117a9dd30247e8806d56cd60f17307~tplv-k3u1fbpfcp-zoom-1.image) 非阻塞队列的典型代表是 `ConcurrentLinkedQueue` 和 `PriorityQueue`。\n\n### 有界队列和无界队列\n\n**有界队列**：是指有固定大小的队列，比如设定了固定大小的 `ArrayBlockingQueue`，又或者大小为 0 的 `SynchronousQueue`。 ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d413d77bccd42db8e130cca8b31114d~tplv-k3u1fbpfcp-zoom-1.image)\n\n**无界队列**：指的是没有设置固定大小的队列，但其实如果没有设置固定大小也是有默认值的，只不过默认值是 Integer.MAX_VALUE，当然实际的使用中不会有这么大的容量（超过 Integer.MAX_VALUE），所以从使用者的角度来看相当于 “无界”的。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcc957d5edd54885909031dc2c72bc22~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 按功能分类\n\n接下来就是本文的重点了，我们以功能来划分一下队列，它可以被分为：普通队列、优先队列、双端队列、延迟队列、其他队列等，接下来我们分别来看。\n\n#### 1.普通队列\n\n普通队列（Queue）是指实现了先进先出的基本队列，例如 `ArrayBlockingQueue` 和 `LinkedBlockingQueue`，其中 `ArrayBlockingQueue` 是用数组实现的普通队列，如下图所示：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f5c609371584b6bbc38ad704b98fadd~tplv-k3u1fbpfcp-zoom-1.image) 而 `LinkedBlockingQueue` 是使用链表实现的普通队列，如下图所示：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bd0d697eaf741858afe1f2f358c71d4~tplv-k3u1fbpfcp-zoom-1.image)\n\n##### 常用方法\n\n普通队列中的常用方法有以下这些：\n\n- offer()：添加元素，如果队列已满直接返回 false，队列未满则直接插入并返回 true；\n- poll()：删除并返回队头元素，当队列为空返回 null；\n- add()：添加元素，此方法是对 offer 方法的简单封装，如果队列已满，抛出 IllegalStateException 异常；\n- remove()：直接删除队头元素；\n- put()：添加元素，如果队列已经满，则会阻塞等待插入；\n- take()：删除并返回队头元素，当队列为空，则会阻塞等待；\n- peek()：查询队头元素，但不会进行删除；\n- element()：对 peek 方法进行简单封装，如果队头元素存在则取出并不删除，如果不存在抛出 NoSuchElementException 异常。\n\n注意：**一般情况下 offer() 和 poll() 方法配合使用，put() 和 take() 阻塞方法配合使用，add() 和 remove() 方法会配合使用，程序中常用的是 offer() 和 poll() 方法，因此这两个方法比较友好，不会报错**。\n\n接下来我们以 `LinkedBlockingQueue` 为例，演示一下普通队列的使用：\n\n```java\nimport java.util.concurrent.LinkedBlockingQueue;\n\nstatic class LinkedBlockingQueueTest {\n    public static void main(String[] args) {\n        LinkedBlockingQueue queue = new LinkedBlockingQueue();\n        queue.offer(\"Hello\");\n        queue.offer(\"Java\");\n        queue.offer(\"中文社群\");\n        while (!queue.isEmpty()) {\n            System.out.println(queue.poll());\n        }\n    }\n}\n\n```\n\n以上代码的执行结果如下：\n\n> Hello\n>\n> Java\n>\n> 中文社群\n\n#### 2.双端队列\n\n双端队列（Deque）是指队列的头部和尾部都可以同时入队和出队的数据结构，如下图所示： ![image.png](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>) 接下来我们来演示一下双端队列 `LinkedBlockingDeque` 的使用：\n\n```java\nimport java.util.concurrent.LinkedBlockingDeque;\n\n/**\n  * 双端队列示例\n  */\nstatic class LinkedBlockingDequeTest {\n    public static void main(String[] args) {\n        // 创建一个双端队列\n        LinkedBlockingDeque deque = new LinkedBlockingDeque();\n        deque.offer(\"offer\"); // 插入首个元素\n        deque.offerFirst(\"offerFirst\"); // 队头插入元素\n        deque.offerLast(\"offerLast\"); // 队尾插入元素\n        while (!deque.isEmpty()) {\n            // 从头遍历打印\n            System.out.println(deque.poll());\n        }\n    }\n}\n\n```\n\n以上代码的执行结果如下：\n\n> offerFirst\n>\n> offer\n>\n> offerLast\n\n#### 3.优先队列\n\n优先队列（PriorityQueue）是一种特殊的队列，它并不是先进先出的，而是优先级高的元素先出队。\n\n优先队列是根据二叉堆实现的，二叉堆的数据结构如下图所示： ![image.png](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>) **二叉堆分为两种类型：一种是最大堆一种是最小堆。**以上展示的是最大堆，**在最大堆中，任意一个父节点的值都大于等于它左右子节点的值。**\n\n> 因为优先队列是基于二叉堆实现的，因此它可以将优先级最好的元素先出队。\n\n接下来我们来演示一下优先队列的使用：\n\n```java\nimport java.util.PriorityQueue;\n\npublic class PriorityQueueTest {\n    // 自定义的实体类\n    static class Viper {\n        private int id; // id\n        private String name; // 名称\n        private int level; // 等级\n\n        public Viper(int id, String name, int level) {\n            this.id = id;\n            this.name = name;\n            this.level = level;\n        }\n\n        public int getId() {\n            return id;\n        }\n\n        public void setId(int id) {\n            this.id = id;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public int getLevel() {\n            return level;\n        }\n\n        public void setLevel(int level) {\n            this.level = level;\n        }\n    }\n    public static void main(String[] args) {\n        PriorityQueue queue = new PriorityQueue(10, new Comparator<Viper>() {\n            @Override\n            public int compare(Viper v1, Viper v2) {\n                // 设置优先级规则（倒序，等级越高权限越大）\n                return v2.getLevel() - v1.getLevel();\n            }\n        });\n        // 构建实体类\n        Viper v1 = new Viper(1, \"Java\", 1);\n        Viper v2 = new Viper(2, \"MySQL\", 5);\n        Viper v3 = new Viper(3, \"Redis\", 3);\n        // 入列\n        queue.offer(v1);\n        queue.offer(v2);\n        queue.offer(v3);\n        while (!queue.isEmpty()) {\n            // 遍历名称\n            Viper item = (Viper) queue.poll();\n            System.out.println(\"Name：\" + item.getName() +\n                               \" Level：\" + item.getLevel());\n        }\n    }\n}\n\n```\n\n以上代码的执行结果如下：\n\n> Name：MySQL Level：5\n>\n> Name：Redis Level：3\n>\n> Name：Java Level：1\n\n从上述结果可以看出，**优先队列的出队是不考虑入队顺序的，它始终遵循的是优先级高的元素先出队**。\n\n#### 4.延迟队列\n\n延迟队列（DelayQueue）是基于优先队列 `PriorityQueue` 实现的，它可以看作是一种以时间为度量单位的优先的队列，当入队的元素到达指定的延迟时间之后方可出队。\n\n![image.png](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>)\n\n我们来演示一下延迟队列的使用：\n\n```java\nimport lombok.Getter;\nimport lombok.Setter;\nimport java.text.DateFormat;\nimport java.util.Date;\nimport java.util.concurrent.DelayQueue;\nimport java.util.concurrent.Delayed;\nimport java.util.concurrent.TimeUnit;\n\npublic class CustomDelayQueue {\n    // 延迟消息队列\n    private static DelayQueue delayQueue = new DelayQueue();\n    public static void main(String[] args) throws InterruptedException {\n        producer(); // 调用生产者\n        consumer(); // 调用消费者\n    }\n\n    // 生产者\n    public static void producer() {\n        // 添加消息\n        delayQueue.put(new MyDelay(1000, \"消息1\"));\n        delayQueue.put(new MyDelay(3000, \"消息2\"));\n    }\n\n    // 消费者\n    public static void consumer() throws InterruptedException {\n        System.out.println(\"开始执行时间：\" +\n                DateFormat.getDateTimeInstance().format(new Date()));\n        while (!delayQueue.isEmpty()) {\n            System.out.println(delayQueue.take());\n        }\n        System.out.println(\"结束执行时间：\" +\n                DateFormat.getDateTimeInstance().format(new Date()));\n    }\n\n    static class MyDelay implements Delayed {\n        // 延迟截止时间（单位：毫秒）\n        long delayTime = System.currentTimeMillis();\n        // 借助 lombok 实现\n        @Getter\n        @Setter\n        private String msg;\n\n        /**\n         * 初始化\n         * @param delayTime 设置延迟执行时间\n         * @param msg       执行的消息\n         */\n        public MyDelay(long delayTime, String msg) {\n            this.delayTime = (this.delayTime + delayTime);\n            this.msg = msg;\n        }\n\n        // 获取剩余时间\n        @Override\n        public long getDelay(TimeUnit unit) {\n            return unit.convert(delayTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n        }\n\n        // 队列里元素的排序依据\n        @Override\n        public int compareTo(Delayed o) {\n            if (this.getDelay(TimeUnit.MILLISECONDS) > o.getDelay(TimeUnit.MILLISECONDS)) {\n                return 1;\n            } else if (this.getDelay(TimeUnit.MILLISECONDS) < o.getDelay(TimeUnit.MILLISECONDS)) {\n                return -1;\n            } else {\n                return 0;\n            }\n        }\n        @Override\n        public String toString() {\n            return this.msg;\n        }\n    }\n}\n\n```\n\n以上代码的执行结果如下：\n\n> 开始执行时间：2020-10-20 20:17:28\n>\n> 消息1\n>\n> 消息2\n>\n> 结束执行时间：2020-10-20 20:17:31\n\n从上述结束执行时间和开始执行时间可以看出，消息 1 和消息 2 都正常实现了延迟执行的功能。\n\n#### 5.其他队列\n\n在 Java 的队列中有一个比较特殊的队列 `SynchronousQueue`，它的特别之处在于它内部没有容器，每次进行 `put()` 数据后（添加数据），必须等待另一个线程拿走数据后才可以再次添加数据，它的使用示例如下：\n\n```java\nimport java.util.concurrent.SynchronousQueue;\n\npublic class SynchronousQueueTest {\n\n    public static void main(String[] args) {\n        SynchronousQueue queue = new SynchronousQueue();\n\n        // 入队\n        new Thread(() -> {\n            for (int i = 0; i < 3; i++) {\n                try {\n                    System.out.println(new Date() + \"，元素入队\");\n                    queue.put(\"Data \" + i);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n\n            }\n        }).start();\n\n        // 出队\n        new Thread(() -> {\n            while (true) {\n                try {\n                    Thread.sleep(1000);\n                    System.out.println(new Date() + \"，元素出队：\" + queue.take());\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n}\n\n```\n\n以上代码的执行结果如下：\n\n> Mon Oct 19 21:00:21 CST 2020，元素入队\n>\n> Mon Oct 19 21:00:22 CST 2020，元素出队：Data 0\n>\n> Mon Oct 19 21:00:22 CST 2020，元素入队\n>\n> Mon Oct 19 21:00:23 CST 2020，元素出队：Data 1\n>\n> Mon Oct 19 21:00:23 CST 2020，元素入队\n>\n> Mon Oct 19 21:00:24 CST 2020，元素出队：Data 2\n\n从上述结果可以看出，当有一个元素入队之后，只有等到另一个线程将元素出队之后，新的元素才能再次入队。\n\n### 总结\n\n本文讲了 Java 中的 5 种队列：普通队列、双端队列、优先队列、延迟队列、其他队列。其中普通队列的典型代表为 `ArrayBlockingQueue` 和 `LinkedBlockingQueue`，双端队列的代表为 `LinkedBlockingDeque`，优先队列的代表为 `PriorityQueue`，延迟队列的代表为 `DelayQueue`，最后还讲了内部没有容器的其他队列 `SynchronousQueue`。\n\n> 文末福利：搜索公众号「Java中文社群」发送“面试”，领取最新的面试资料。\n","children":[]},{"name":"java-Collection.md","path":"../guanruihua.github.io/Back-End/Java","data":"# 集合\n\n## 集合与数组\n\n> **数组**\n>\n> - 特点\n>   - 可以存储基本数据类型\n>   - 数组的长度固定\n>   - 不适合在对象数量未知的情况下使用\n\n> **集合**\n>\n> - 特点\n>   - 只能存储对象，对象类型可以不一样\n>   - 长度可变，可在多数情况下使用。\n\n## 集合中接口和类的关系\n\n### **Collection**\n\n> - 集合类的根接口，Java中没有提供这个接口的直接的实现类。\n> - 但是却让其被继承产生了两个接口，就是Set和List。\n>   - Set中不能包含重复的元素。\n>   - List是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式。\n\n### **Map**\n\n> - Java.util包中的另一个接口，它和Collection接口没有关系，是相互独立的，但是都属于集合类的一部分。\n> - Map包含了key-value对。\n> - Map**不能包含重复的key**，但是可以包含相同的value。\n\n### **Iterator**\n\n> - 遍历集合中元素的接口，主要包含以下三种方法：\n>   1.**hasNext()** 是否还有下一个元素。\n>   2.**next()** 返回下一个元素。\n>   3.**remove()**删除当前元素。\n\n### 层次图\n\n图一这个比较简单\n\n![这里写图片描述](http://img.blog.csdn.net/20170905084526091?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGl2ZW9yX0RpZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n图二完整\n\n![这里写图片描述](http://img.blog.csdn.net/20170905084554470?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGl2ZW9yX0RpZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n### list,set,map对比\n\n| 接口       | 子接口      | 是否有序           | 是否允许元素重复                                          |\n| ---------- | ----------- | ------------------ | --------------------------------------------------------- |\n| Collection |             | 否                 |                                                           |\n| List       | ArrayList   | 否                 | 是                                                        |\n|            | LinkedList  | 否                 | 是                                                        |\n|            | Vector      | 否                 | 是                                                        |\n| Set        | AbstractSet | 否                 | 否                                                        |\n|            | HashSet     | 否                 | 否                                                        |\n|            | TreeSet     | 是（用二叉排序树） | 否                                                        |\n| Map        | AbstractMap | 否                 | 使用key-value来映射和存储数据，key必须唯一，value可以重复 |\n|            | HashMap     |                    | 否                                                        |\n|            | TreeMap     | 是（用二叉排序树） | 使用key-value来映射和存储数据，key必须唯一，value可以重复 |\n\n## list（有序、可重复）\n\n> - List里存放的对象是有序的，同时也是可以重复的\n> - List关注的是索引，拥有一系列和索引相关的方法，查询速度快。\n> - 因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有**插入删除数据速度慢**。\n\n### ArrayList\n\n> - ArrayList是基于数组的，在初始化ArrayList时，会构建空数组（Object[] elementData={}）。\n> - ArrayList是一个无序的，它是按照添加的先后顺序排列\n> - 提供了sort方法，如果需要对ArrayList进行排序，只需要调用这个方法，提供Comparator比较器即可\n\n#### add操作\n\n　　1）如果是第一次添加元素，数组的长度被扩容到默认的capacity，也就是10.\n\n　　2) 当发觉同时添加一个或者是多个元素，数组长度不够时，就扩容，这里有两种情况：\n\n　　只添加一个元素，例如：原来数组的capacity为10，size已经为10，不能再添加了。需要扩容，新的capacity=old capacity+old capacity>>1=10+10/2=15.即新的容量为15。\n\n　　当同时添加多个元素时，原来数组的capacity为10，size为10，当同时添加6个元素时。它需要的min capacity为16，而按照capacity=old capacity+old capacity>>1=10+10/2=15。new capacity小于min capacity，则取min capacity。\n\n　　对于添加，如果不指定下标，就直接添加到数组后面，不涉及元素的移动，如果要添加到某个特定的位置，那需要将这个位置开始的元素往后挪一个位置，然后再对这个位置设置。\n\n#### Remove操作\n\n　Remove提供两种，按照下标和value。\n\n　　1）**remove(int index)**：首先需要检查Index是否在合理的范围内。其次再调用System.arraycopy将index之后的元素向前移动。\n\n　　2）**remove(Object o)**：首先遍历数组，获取第一个相同的元素，获取该元素的下标。其次再调用System.arraycopy将index之后的元素向前移动。\n\n#### Get操作\n\n　　这个比较简单，直接对数组进行操作即可。\n\n### LinkedList\n\n　　LinkedList是基于链表的，它是一个双向链表，每个节点维护了一个prev和next指针。同时对于这个链表，维护了first和last指针，first指向第一个元素，last指向最后一个元素。LinkedList是一个无序的链表，按照插入的先后顺序排序，不提供sort方法对内部元素排序。\n\n#### Add元素\n\n　　LinkedList提供了几个添加元素的方法：addFirst、addLast、addAll、add等，时间复杂度为O(1)。\n\n#### Remove元素\n\n　　LinkedList提供了几个移除元素的方法：removeFirst、removeLast、removeFirstOccurrence、remove等，时间复杂度为O(1)。\n\n#### Get元素\n\n　　根据给定的下标index，判断它first节点、last直接距离，如果index<size（数组元素个数)/2,就从first开始。如果大于，就从last开始。这个和我们平常思维不太一样，也许按照我们的习惯，从first开始。这也算是一点小心的优化吧。\n\n### 遍历\n\n在类集中提供了以下四种的常见输出方式：\n\n1）Iterator：迭代输出，是使用最多的输出方式。\n\n2）ListIterator：是Iterator的子接口，专门用于输出List中的内容。\n\n3）foreach输出：JDK1.5之后提供的新功能，可以输出数组或集合。\n\n4）for循环\n\n代码示例如下：\n\n**for的形式：**for（int i=0;i<arr.size();i++）{...}\n\n**foreach的形式：** for（int　i：arr）{...}\n\n**iterator的形式：**\nIterator it = arr.iterator();\nwhile(it.hasNext()){ object o =it.next(); ...}\n\n## Set（无序、不能重复）\n\nSet里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。\n\n### HashSet\n\n　　HashSet是基于HashMap来实现的，操作很简单，更像是对HashMap做了一次“封装”，而且只使用了HashMap的key来实现各种特性，而HashMap的value始终都是PRESENT。\n\n　　HashSet不允许重复（HashMap的key不允许重复，如果出现重复就覆盖），允许null值，非线程安全。\n\n#### 构造方法\n\n**HashSet()**\n　　构造一个新的空 set，其底层 HashMap 实例的默认初始容量是 16，加载因子是 0.75。\n**HashSet(Collection<? extends E> c)**\n　　构造一个包含指定 collection 中的元素的新 set。\n**HashSet(int initialCapacity)**\n　　构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和默认的加载因子（0.75）。\n**HashSet(int initialCapacity, float loadFactor)**\n　　构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和指定的加载因子。\n\n#### 方法\n\n**boolean add(E e) \\**\n　　如果此 set 中尚未包含指定元素，则添加指定元素。\n\\**void clear()\\**\n　　从此 set 中移除所有元素。\n\\** Object clone() \\**\n　　返回此 HashSet 实例的浅表副本：并没有复制这些元素本身。\n\\** boolean contains(Object o) \\**\n　　如果此 set 包含指定元素，则返回 true。\n\\** boolean isEmpty()**\n　　如果此 set 不包含任何元素，则返回 true。\n**Iterator iterator()**\n　　返回对此 set 中元素进行迭代的迭代器。\n**boolean remove(Object o)**\n　　如果指定元素存在于此 set 中，则将其移除。\n**int size()**\n　　返回此 set 中的元素的数量（set 的容量）。\n\n### TreeSet\n\n　　基于 TreeMap 的 NavigableSet 实现。使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator进行排序，具体取决于使用的构造方法。\n\n　　**构造方法和方法比较类似就不说了**\n\n### 遍历（和list相似）\n\n对 set 的遍历\n\n1.迭代遍历：\n\n```\nSet<String> set = new HashSet<String>();  \nIterator<String> it = set.iterator();  \nwhile (it.hasNext()) {  \n  String str = it.next();  \n  System.out.println(str);  \n}  \n```\n\n2.for(foreach)循环遍历：\n\n```\nfor (String str : set) {  \n      System.out.println(str);  \n}  \n```\n\n## Map（键值对、键唯一、值不唯一）\n\n　　Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值。\n\n### HashMap\n\n　　数组方式存储key/value，**线程非安全**，**允许null作为key和value**，key不可以重复，value允许重复，不保证元素迭代顺序是按照插入时的顺序，key的hash值是先计算key的hashcode值，然后再进行计算，每次容量扩容会重新计算所以key的hash值，会消耗资源，要求key必须重写equals和hashcode方法\n\n　　默认初始容量16，加载因子0.75，扩容为旧容量乘2，查找元素快，如果key一样则比较value，如果value不一样，则按照链表结构存储value，就是一个key后面有多个value；\n\n#### 方法\n\n**1、添加：**\n\n　　**V put(K key, V value)** （可以相同的key值，但是添加的value值会覆盖前面的，返回值是前一个，如果没有就返回null）\n\n　　**putAll(Map m)** 从指定映射中将所有映射关系复制到此映射中（可选操作）。\n\n**2、删除**\n\n　　**remove()** 删除关联对象，指定key对象\n\n　　**clear()** 清空集合对象\n\n**3、获取**\n\n　　**value get(key)** 可以用于判断键是否存在的情况。当指定的键不存在的时候，返回的是null。\n\n**４、判断：**\n\n　　**boolean isEmpty()** 长度为0返回true否则false\n\n　　**boolean containsKey(Object key)** 判断集合中是否包含指定的key\n\n　　**boolean containsValue(Object value)** 判断集合中是否包含指定的value\n\n4、长度：\n\n　**Int size（）**\n\n　　map的主要的方法就这几个\n\n### Hashtable\n\n　　Hashtable与HashMap类似，是HashMap的线程安全版，它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢，它继承自Dictionary类，不同的是它不允许记录的键或者值为null，同时效率较低。\n\n### LinkedHashMap\n\nLinkedHashMap保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。\n\n### TreeMap\n\n　　基于红黑二叉树的NavigableMap的实现，线程非安全，不允许null，key不可以重复，value允许重复，存入TreeMap的元素应当实现Comparable接口或者实现Comparator接口，会按照排序后的顺序迭代元素，两个相比较的key不得抛出classCastException。主要用于存入元素的时候对元素进行自动排序，迭代输出的时候就按排序顺序输出\n\n### 遍历\n\n**第一种：KeySet()**\n　　将Map中所有的键存入到set集合中。因为set具备迭代器。所有可以迭代方式取出所有的键，再根据get方法。获取每一个键对应的值。 keySet():迭代后只能通过get()取key 。\n　　取到的结果会乱序，是因为取得数据行主键的时候，使用了HashMap.keySet()方法，而这个方法返回的Set结果，里面的数据是乱序排放的。\n\n```\n Map map = new HashMap();\n map.put(\"key1\",\"lisi1\");\n map.put(\"key2\",\"lisi2\");\n map.put(\"key3\",\"lisi3\");\n map.put(\"key4\",\"lisi4\");  \n //先获取map集合的所有键的set集合，keyset（）\n Iterator it = map.keySet().iterator();\n  //获取迭代器\n while(it.hasNext()){\n  Object key = it.next();\n  System.out.println(map.get(key));\n }\n```\n\n**第二种： values()** 获取所有的值.\nCollection values()**不能获取到key对象**\n\n```\n        Collection<String> vs = map.values();\n        Iterator<String> it = vs.iterator();\n        while (it.hasNext()) {\n            String value = it.next();\n            System.out.println(\" value=\" + value);\n        }\n```\n\n**第三种：entrySet（）**\nSet<Map.Entry<K,V>> entrySet() //返回此映射中包含的映射关系的 Set 视图。（一个关系就是一个键-值对），就是把(key-value)作为一个整体一对一对地存放到Set集合当中的。Map.Entry表示映射关系。entrySet()：迭代后可以e.getKey()，e.getValue()两种方法来取key和value。返回的是Entry接口。\n典型用法如下：\n\n```\n// 返回的Map.Entry对象的Set集合 Map.Entry包含了key和value对象\n        Set<Map.Entry<Integer, String>> es = map.entrySet();\n\n        Iterator<Map.Entry<Integer, String>> it = es.iterator();\n\n        while (it.hasNext()) {\n            \n            // 返回的是封装了key和value对象的Map.Entry对象\n            Map.Entry<Integer, String> en = it.next();\n\n            // 获取Map.Entry对象中封装的key和value对象\n            Integer key = en.getKey();\n            String value = en.getValue();\n\n            System.out.println(\"key=\" + key + \" value=\" + value);\n        }\n```\n\n　　推荐使用第三种方式，即entrySet()方法，效率较高。\n　　对于keySet其实是遍历了2次，一次是转为iterator，一次就是从HashMap中取出key所对于的value。而entryset只是遍历了第一次，它把key和value都放到了entry中，所以快了。两种遍历的遍历时间相差还是很明显的。\n\n## 总结\n\n### Vector和ArrayList\n\n　　1，vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。\n\n　　2，如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%，而arraylist增长率为目前数组长度的50%。如果在集合中使用数据量比较大的数据，用vector有一定的优势。\n\n　　3，如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，如果频繁的访问数据，这个时候使用vector和arraylist都可以。而如果移动一个指定位置会导致后面的元素都发生移动，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据时其它元素不移动。\n\n　　ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要涉及到数组元素移动等内存操作，所以索引数据快，插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快。\n\n### arraylist和linkedlist\n\n　　1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。\n\n　　2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。\n\n　　3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。\n\n### HashMap与TreeMap\n\n　　1、 HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。\n\n　　2、在Map 中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。\n\n　　两个map中的元素一样，但顺序不一样，导致hashCode()不一样。\n\n　　同样做测试：\n　　　　在HashMap中，同样的值的map,顺序不同，equals时，false;\n　　　　而在treeMap中，同样的值的map,顺序不同,equals时，true，说明，treeMap在equals()时是整理了顺序了的。\n\n### HashTable与HashMap\n\n　　1、同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的。\n\n　　2、HashMap允许存在一个为null的key，多个为null的value 。\n\n　　3、hashtable的key和value都不允许为null。\n","children":[]},{"name":"java-expand.md","path":"../guanruihua.github.io/Back-End/Java","data":"# java-expand\n\n## JVM 虚拟内存分布\n\n> 借鉴<https://www.cnblogs.com/syp172654682/p/8082625.html>\n\n<img src=\"https://images.gitee.com/uploads/images/2020/1101/171425_ce5ca706_7984151.png\" style=\"zoom:50%;align:center;\" />\n\n> - **程序计数器**是jvm执行程序的流水线，存放一些跳转指令。\n>\n> - **本地方法栈**是jvm调用操作系统方法所使用的栈。\n>\n> - **虚拟机栈**是jvm执行java代码所使用的栈。\n>\n> - **方法区**存放了一些常量、静态变量、类信息等，可以理解成class文件在内存中的存放位置。\n>\n> - **虚拟机堆**是jvm执行java代码所使用的堆。\n\n### 常量池\n\n> 分为 : **静态常量池** 和 **运行时常量池**\n>\n> 可以通过jvm参数`-XX:PermSize、-XX:MaxPermSize来设置方法区大小`, 从而间接显示常量池的大小\n\n#### 静态常量池\n\n> - `*.class`文件中的常量池\n>   - `*.class`文件中的常量池不仅仅包含字符串(数字) 字面量, 还包含类, 方法的信息, 常用class文件绝大部分空间, 改常量池主要涌入存放两大类常量: `字面量(Literal)`和`符号引用量( Symbolic References )`\n>     - 字面量: 相当于Java语言层面的概念, 入文本字符串, 声明为final的常量值等\n>     - 符号引用量: 属于编译原理方面的概念,包含了如下三种类型的常量:\n>       - 类和接口的全限定名\n>       - 字段名称和描述符\n>       - 方法名称和描述符\n\n#### 运行常量池\n\n> - 这是JVM虚拟机在完成类装载操作后, 将class文件中的常量池载入到内存中, 并保存到方法区中, 我们常说的常量池, 就是指方法去中的运行时常量池\n> - 运行时常量池相对于CLass文件常量池的另外一个重要特征是**具备动态性**，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是**String类的intern()**方法。\n> - String的`intern()`方法会查找在常量池中是否存在一份equal相等的字符串,如果有则返回该字符串的引用,如果没有则添加自己的字符串进入常量池\n\n##### 常量池的好处\n\n> - 避免频繁的创建和销毁对象而影响系统性能, 其实现了对象的共享\n> - 节约内存空间: 常量池中所有相同的字符串长阿林被合并, 只占用一个空间\n> - 节约运行时间: 比较字符串是, == 比 equals() 快, 对于两个引用变量, 只用 == 判断引用是否相等, 也就是判断实际值是否相等\n\n```java\n\n  String s1 = \"hello\";\n  String s2 = \"hello\";\n  String s3 = \"hel\" + \"lo\";\n  String s4 = \"hel\" + new String(\"lo\");\n  String s5 = new String(\"hello\");\n  String s6 = s5.intern();\n  String s7 = \"H\";\n  String s8 = \"ello\";\n  String s9 = s7 + s8;\n  \n  System.out.println( s1 == s2 ); // true\n  /**\n   s1 和  s2 在赋值的时候, 均使用字符串字面量,\n    在编译期间, 这种字面量会直接放入class文件的常量池中, 而实现复用\n    载入运行时常量池后, s1, s2 指向同一个内存地址, 所以相等\n   */\n  System.out.println( s1 == s3 ); // true\n  /*\n   s3 虽然是动态拼接出来的字符串, 但是所有参与拼接的部分都是已知的字面量, \n   在编译期间, 这种拼接会被优化, 编译器直接帮你拼接好\n   \n   只有使用引号包括的文本的方式创建的String对象之间使用\"+\"连接产生新的对象才会被加入字符串池中\n   */\n  System.out.println( s1 == s4 ); // false\n  /*\n   s4有一部分不是已知字面量, 编译器不会优化, 必须等到运行时才可以确定结果, \n   给字符串不变定理, 不确定s4被分配到哪里, 所以地址不相同\n   \n   对于所有包含new方式新建对象(包括null) 的\"+ \" 连接表达式, 他所产生的新对象都不会被加入字符串池中\n   */\n  System.out.println( s1 == s9 ); // false\n  /**\n    s7, s8 作为两个变量, 都是不可以预料的, 都是不可以预料的, \n    在编译期被确认, 所以不做优化, 只能等到运行时, 在堆中创建\n   */\n  System.out.println( s4 == s5 ); // false\n  //  两个都在堆中, 地址不相同\n  System.out.println( s1 == s6 ); // true\n  //  intern() 会尝试将Hello字符串添加到常量池中，并返回其在常量池中的地址，\n  // 因为常量池中已经有了Hello字符串，所以intern方法直接返回地址； 故地址相同\n  \n  \n```\n\n特例1\n\n```java\npublic static final String A = \"ab\"; // 常量A\npublic static final String B = \"cd\"; // 常量B\npublic static void main(String[] args) {\n     String s = A + B;  // 将两个常量用+连接对s进行初始化 \n     String t = \"abcd\";   \n   System.out.println(s == t);//true \n } \n// A 和 B 都是常量, 值是固定的, 因此s的值也是固定的, 他在编译时就已确认, 也就是String s = A + B; 等同于 String s = \"ab\" + \"cd\";\n```\n\n特例2\n\n```java\npublic static final String A; // 常量A\npublic static final String B;    // 常量B\nstatic {   \n     A = \"ab\";   \n     B = \"cd\";   \n }   \n public static void main(String[] args) {   \n    // 将两个常量用+连接对s进行初始化   \n     String s = A + B;   \n     String t = \"abcd\";   \n     System.out.println(s == t);//false\n } \n```\n\n> A 和 B 虽然被定义为常量,  但是它们都没有被马上复制, 在运算上s的值之前, 它们合适被赋值, 以及被赋予什么样的值, 都是变数, 因此A和B在被赋值之前, 性质类型于与变量, 那么s就不能在编译期被确认, 只能在运行时被创建\n\n#### 缓存池\n\n> - new Integer(123) 每次都会新建一个对象；\n> - Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。\n> - integer缓存池大小默认为-128~127\n\n```java\nInteger x = new Integer(123);\nInteger y = new Integer(123);\nSystem.out.println(x == y);    // false\nInteger z = Integer.valueOf(123);\nInteger k = Integer.valueOf(123);\nSystem.out.println(z == k);   // true\n```\n\n## 包装类和基本类型\n\n```java\nint i = 128;\nInteger i2 = 128;\nInteger i3 = new Integer(128);\nSystem.out.println(i == i2); //Integer会自动拆箱为int，所以为true\nSystem.out.println(i == i3); //true，理由同上\n\nInteger i4 = 127;//编译时被翻译成：Integer i4 = Integer.valueOf(127);\nInteger i5 = 127;\n\nSystem.out.println(i4 == i5);\n\nInteger i6 = 128;\nInteger i7 = 128;\nSystem.out.println(i6 == i7);\n\nInteger i8 = new Integer(127);\nSystem.out.println(i5 == i8); //false\n\nInteger i9 = new Integer(128);\nInteger i10 = new Integer(123);\nSystem.out.println(i9 == i10);  //false\n   \nint i11 = 11;\nint i12 = 11;\nSystem.out.println(i11 == i12); // true\n```\n\n> i4 和 i5 为true 的原因:\n>\n> - -128~127之间的数, 会进行缓存,\n> - Interger i4 =127 时, 会将127进行缓存\n> - Interger i5 = 127 时, 会直接在缓存中去, 就不会再new一个对象\n> - 所以i4和i5是true, i6和i7为false\n>\n> 总结:\n>\n> - 两个都是new出来的, 都是false,地址不同\n> - int和Interger(无论new否)比, 都是true, 因为Interger自动猜想为int再去比\n","children":[]},{"name":"java8","path":"../guanruihua.github.io/Back-End/Java","data":"","children":[{"name":"lambda.md","path":"../guanruihua.github.io/Back-End/Java/java8","data":"# Lambda\n\n> - `Lambda` 表达式，也可称为`闭包`，是一个`匿名函数`。\n>\n> - 可以把 Lambda 表达式理解为是`一段可传递的代码`（像数据一样传递）。即 Lambda 允许把`函数`作为一个方法的`实参参数`（函数当作参数传递到方法中）。\n> - `Java8`的其中一个很重要的新特性。\n\n```java\npublic class LambdaDemo {\n    public static void main(String[] args) {\n        List<String> list = Arrays.asList(\"A\", \"B\", \"C\");\n        //x -> System.out.println(x)，就是一个匿名函数,即Lambda表达式，作为实参传给dealList方法\n        dealList(list, x -> System.out.println(x));\n    }\n \n    public static void dealList(List<String> list, Consumer<String> consumer) {\n     // 遍历list中的每一个元素，传给consumer对象的accept函数，进行调用\n        for (String x : list) {\n            consumer.accept(x);\n        }\n    }\n}\n```\n\n> - Lambda 表达式是对某些接口的简单实现，但不是所有接口都可以使用 Lambda 表达式来实现的，Lambda 规定能被 Lambda 表达式实现的接口中，它`只能只有一个需要被实现的方法（函数）`，但`不要求接口中只能只有一个方法。`\n> - 因为Java8中有另外一个新特性，即 `default` 关键字修饰的接口方法有默认实现，这个默认的方法是可以不需要子类实现的，可使用`@FunctionalInterface`注解来强制使接口只能有一个需要被实现的方法。\n\n```java\n// 此注解表明此接口为函数接口，即只能有一个抽象方法\n@FunctionalInterface\npublic interface Human {\n\n    // 抽象方法，需要被实现\n    void eat(String name);\n\n    // default修饰的默认方法，不需要被子类实现\n    default void run() {\n        System.out.println(\"I can run...\");\n    }\n}\n\npublic static void main(String[] args) {\n    Human human = x -> System.out.println(x + \" is eat\");\n    human.eat(\"Mr.nobody\");\n    human.run();\n}\n// 输出结果\nMr.nobody is eat\nI can run...\n```\n\n## 案例一\n\n```java\n// 接口\npublic interface Human {\n // 抽象方法，需要被实现\n    void speak();\n}\n```\n\n### 通过类来实现接口\n\n> 并且实现里面的抽象方法\n\n```java\n// 实现类，并且实现抽象方法\npublic class Man implements Human {\n    @Override\n    public void speak() {\n        System.out.println(\"I am man!\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // 方式一 直接编写实现类\n        Human human = new Man();\n        human.speak();\n    }\n}\n\n```\n\n### 匿名内部类\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 方式一 直接编写实现类\n        Human human = new Man();\n        human.speak();\n\n        // 方式二 匿名内部类\n        Human human1 = new Human() {\n            @Override\n            public void speak() {\n                System.out.println(\"I am woman!\");\n            }\n        };\n        human1.speak();\n    }\n}\n\n```\n\n> 但方式二中，有用的就只有`System.out.println(\"I am woman!\");`这一行，所以有了Lambda表达式，可以这样写，如方式三：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 方式一 直接编写实现类\n        Human human = new Man();\n        human.speak();\n        \n        // 方式二 匿名内部类\n        Human human1 = new Human() {\n            @Override\n            public void speak() {\n                System.out.println(\"I am woman!\");\n            }\n        };\n        human1.speak();\n        \n        // 方式三 Lambda表达式\n        Human human2 = () -> System.out.println(\"I am woman!\");\n        human2.speak();\n    }\n}\n\n```\n\n## 案例二\n\n> 再假如我们要对一个Student类的数组按指定条件进行过滤，如下：\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n    private double score;\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        List<Student> students = Arrays.asList(new Student(\"张三\", 18, 89.5),\n                new Student(\"李四\", 20, 60), new Student(\"王五\", 19, 100), new Student(\"赵六\", 22, 89));\n\n        // 过滤出年龄大于等于20的学生\n        List<Student> stus1 = filterStudentByAge(students);\n        System.out.println(stus1);\n\n        // 过滤出成绩大于80的学生\n        List<Student> stus2 = filterStudentByScore(students);\n        System.out.println(stus2);\n    }\n\n    // 过滤出年龄大于等于20的学生\n    private static List<Student> filterStudentByAge(List<Student> students) {\n        List<Student> stus = new ArrayList<>();\n        for (Student stu : students) {\n            if (stu.getAge() >= 20) {\n                stus.add(stu);\n            }\n        }\n        return stus;\n    }\n\n    // 过滤出成绩大于80的学生\n    private static List<Student> filterStudentByScore(List<Student> students) {\n        List<Student> stus = new ArrayList<>();\n        for (Student stu : students) {\n            if (stu.getScore() > 80) {\n                stus.add(stu);\n            }\n        }\n        return stus;\n    }\n}\n\n```\n\n> 按上面的方式，如果要按另外一个条件过滤呢，又要写一个方法。那可以用策略模式处理，编写一个抽象策略接口，然后编写多个不同策略类实现它。\n\n```java\n// 策略接口\npublic interface MyPredicate<T> {\n    boolean test(T t);\n}\n\n// 过滤出年龄大于等于20的学生\npublic class filterStudentByAge implements MyPredicate<Student> {\n    @Override\n    public boolean test(Student t) {\n        return t.getAge() >= 20;\n    }\n}\n\n// 过滤出成绩大于80的学生\npublic class filterStudentByScore implements MyPredicate<Student> {\n    @Override\n    public boolean test(Student t) {\n        return t.getScore() > 80;\n    }\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        List<Student> students = Arrays.asList(new Student(\"张三\", 18, 89.5),\n                new Student(\"李四\", 20, 60), new Student(\"王五\", 19, 100), new Student(\"赵六\", 22, 89));\n\n        // 过滤出年龄大于等于20的学生\n        List<Student> stus1 = filterStudent(students, new FilterStudentByAge());\n        System.out.println(stus1);\n\n        // 过滤出成绩大于80的学生\n        List<Student> stus2 = filterStudent(students, new FilterStudentByScore());\n        System.out.println(stus2);\n    }\n\n    // 按myPredicate策略过滤出满足条件的学生\n    private static List<Student> filterStudent(List<Student> students,\n            MyPredicate<Student> myPredicate) {\n        List<Student> stus = new ArrayList<>();\n        for (Student stu : students) {\n            if (myPredicate.test(stu)) {\n                stus.add(stu);\n            }\n        }\n        return stus;\n    }\n}\n\n```\n\n> 但是以上方式，每增加一个过滤条件，就要编写一个策略类，太麻烦。所以我们就用匿名内部类方式。\n\n```java\n// 匿名内部类形式 过滤出年龄大于等于18的学生\nList<Student> stus3 = filterStudent(students, new MyPredicate<Student>() {\n    @Override\n    public boolean test(Student t) {\n        return t.getAge() > 18;\n    }\n});\nSystem.out.println(stus3);\n\n```\n\n> 但我们会觉得匿名内部类还是太麻烦，无用代码太多，有用的代码其实就只有`return t.getAge() > 18;`，于是 Lambda 表达式发挥的作用就来了：\n\n```java\n// Lambda形式 过滤出年龄大于等于18的学生\nList<Student> stus4 = filterStudent(students, t -> t.getAge() > 18);\nSystem.out.println(stus4);\n\n```\n\n> 这时还是有人会问，那我们定义的`接口MyPredicate`和`方法filterStudent()`，好像没什么作用呀。然而官方已经想到这一点，它内置了一些通用接口，我们可以使用它。例如断言的接口 `Predicate`，那我们就用如下方式，完全不用写`接口MyPredicate`和`方法filterStudent()`，如下：\n\n```java\n// 按myPredicate策略过滤出满足条件的学生\nprivate static List<Student> filterStudent(List<Student> students,\n        Predicate<Student> predicate) {\n    List<Student> stus = new ArrayList<>();\n    for (Student stu : students) {\n        if (predicate.test(stu)) {\n            stus.add(stu);\n        }\n    }\n    return stus;\n}\n\n```\n\n> 当然，如果你会使用Stream（可以看我另外一篇文章），只需要写下面的代码，如下：\n\n```java\npublic class Main {\n\n    public static void main(String[] args) {\n\n        List<Student> students = Arrays.asList(new Student(\"张三\", 18, 89.5),\n                new Student(\"李四\", 20, 60), new Student(\"王五\", 19, 100), new Student(\"赵六\", 22, 89));\n\n        // 过滤出年龄大于等于20的学生\n        students.stream().filter(t -> t.getAge() >= 20).forEach(System.out::println);\n        \n        System.out.println(\"-------------------------------------\");\n\n        // 过滤出成绩大于80的学生\n        students.stream().filter(t -> t.getScore() > 80).forEach(System.out::println);\n    }\n}\n\n```\n\n## Lambda 语法\n\n> 语法：() -> {} ()：Lambda的形参列表，也就是接口里面那个抽象方法的形参列表。 ->：Lambda的操作符，可以理解为参数和Lambda体的分隔符。 {}：实现了接口中的抽象方法的方法体。\n\n> 我们还是以一个简单的例子，由浅到深学习 Lambda 语法。按照语法，我们可以写出如下 Lambda 表达式，`(String name, int age)` 是参数列表，`->` 是分隔符，`{}` 中的代码是方法体。\n\n```java\n// 函数接口\n@FunctionalInterface\npublic interface Human {\n    // 抽象方法，需要被实现\n    String speak(String name, int age);\n}\n\npublic class LambdaDemo {\n    public static void main(String[] args) {\n        Human human = (String name, int age) -> {\n            System.out.println(\"My name is \" + name + \" ,I am \" + age + \" years old.\");\n            return name;\n        };\n        human.speak(\"Mr.nobody\", 18);\n    }\n}\n\n```\n\n> 当然，`()` 括号内的`参数类型还能省略`（推荐）。\n\n```java\npublic class LambdaDemo {\n    public static void main(String[] args) {\n        Human human = (name, age) -> {\n            System.out.println(\"My name is \" + name + \" ,I am \" + age + \" years old.\");\n            return name;\n        };\n        human.speak(\"Mr.nobody\", 18);\n    }\n}\n\n```\n\n> 如果是`只有一个参数，() 也能省略`。\n\n```java\n@FunctionalInterface\npublic interface Human {\n    // 抽象方法，需要被实现\n    String speak(String name);\n}\n\npublic class LambdaDemo {\n    public static void main(String[] args) {\n        Human human = name -> {\n            System.out.println(\"My name is \" + name + \".\");\n            return name;\n        };\n        human.speak(\"Mr.nobody\");\n    }\n}\n\n```\n\n> 如果，方法体 `{}` 中，只有一行语句，{} 也能省略（推荐）。\n\n```java\n@FunctionalInterface\npublic interface Human {\n    // 抽象方法，需要被实现\n    void speak(String name, int age);\n}\n\npublic class LambdaDemo {\n    public static void main(String[] args) {\n        Human human = (name, age) -> System.out\n                .println(\"My name is \" + name + \" ,I am \" + age + \" years old.\");\n        human.speak(\"Mr.nobody\", 18);\n    }\n}\n\n```\n\n> 如果`方法体需要返回值`，而且`只有一行语句`，那 `{}` 大括号和 `return` 关键字都可以省略（推荐）。\n\n```java\n@FunctionalInterface\npublic interface Human {\n    // 抽象方法，需要被实现\n    String speak(String name, int age);\n}\n\npublic class LambdaDemo {\n    public static void main(String[] args) {\n        Human human = (name, age) -> \"My name is \" + name + \" ,I am \" + age + \" years old.\";\n        human.speak(\"Mr.nobody\", 18);\n    }\n}\n```\n","children":[]}]},{"name":"VO_DTO_Entity.md","path":"../guanruihua.github.io/Back-End/Java","data":"# VO_DTO_Entity\n\n> 1、entity 里的每一个字段，与数据库相对应，\n>\n> 2、vo 里的每一个字段，是和你前台 html 页面相对应，\n>\n> 3、dto 这是用来转换从 entity 到 vo，或者从 vo 到 entity 的中间的东西 。\n\n举个例子：\n\n你的html页面上有三个字段，name，pass，age\n\n你的数据库表里，有两个字段，name，pass ， 注意没有 age。\n\n而你的 vo 里，就应该有下面三个成员变量 ，因为对应 html 页面上三个字段 。\n\n```java\nprivate string name；\nprivate string pass; \nprivate string age;\n```\n\n这个时候，你的 entity 里，就应该有两个成员变量 ，因为对应数据库表中的 2 个字段 。\n\n```java\nprivate string name；\nprivate string pass;\n```\n\n到了这里，好了，业务经理让你做这样一个业务“年龄大于 20 的才能存入数据库，这个时候，你就要用到 dto 了，\n\n1）你要先从页面上拿到 vo，然后判断 vo 中的 age 是不是大于 20。\n\n2）如果大于 20，就把 vo 中的 name 和 pass 拿出来，放到 dto 中。\n\n3）然后在把 dto 中的 name 和 pass 原封不动的给 entity，然后根据 entity 的值，在传入数据库。\n\n这就是他们三个的区别。\n\nPS： dto 和 entity 里面的字段应该是一样的，dto 只是 entity 到 vo，或者 vo 到 entity 的中间过程，如果没有这个过程，你仍然可以做到增删改查，这是根据具体公司规范来的 。\n","children":[]},{"name":"线程.md","path":"../guanruihua.github.io/Back-End/Java","data":"# 线程\n\n## 多线程\n\n> 一个程序执行多个任务, 通常一个任务称为一个线程\n\n### Thread\n\n```java\npackage com.java.test;\n\npublic class ThreadTest\n{\n    public static void main(String[] args)\n    {\n        TreadTest1 thread1 = new TreadTest1();\n        TreadTest2 thread2 = new TreadTest2();\n\n        thread1.start();\n        thread2.start();\n    }\n\n}\nclass TreadTest1 extends Thread{\n    @Override\n    public void run() {\n        for (int i = 0; i < 1000; ++i)\n        {\n            System.out.println(\"Test1 \" + i);\n        }\n    }\n}\nclass TreadTest2 extends Thread{\n    @Override\n    public void run() {\n        for (int i = 0; i < 1000; ++i)\n        {\n            System.out.println(\"Test2 \" + i);\n        }\n    }\n}\n\n```\n\n### Runnable\n\n```java\npackage com.java.test;\n\npublic class ThreadTest\n{\n    public static void main(String[] args)\n    {\n//         线程的另一种实现方法，也可以使用匿名的内部类\n        Thread threadtest1=new Thread((new ThreadTest1()));\n        threadtest1.start();\n        Thread threadtest2=new Thread((new ThreadTest2()));\n        threadtest2.start();\n    }\n}\n\nclass ThreadTest1 implements Runnable\n{\n\n    @Override\n    public void run()\n    {\n        for (int i = 0; i < 100; ++i)\n        {\n            System.out.println(\"Hello: \" + i);\n        }\n    }\n}\n\nclass ThreadTest2 implements Runnable\n{\n\n    @Override\n    public void run()\n    {\n        for (int i = 0; i < 100; ++i)\n        {\n            System.out.println(\"Welcome: \" + i);\n        }\n    }\n}\n```\n\n## 线程同步\n\n> Thread synchronization\n>\n> 对所有线程对于同一个资源的访问上的时序性\n\n栗子:\n\n> 会出现账号的金额数目发生改变,  本来这程序本来来说应该是不会发生改变的, 但是你运行后会发现数字一直在变大或变小\n\n```java\npublic class Demo1 {\n    public static void main(String[] args) {\n        Bank bank = new Bank();\n        //创建10个线程，不停的将一个账号资金转移到另一个账号上\n        for (int i = 0; i < 100; i++) {\n            new Thread(() -> {\n                while (true) {\n                    int account1 = ((Double) Math.floor(Math.random() * 10)).intValue();\n                    int account2 = ((Double) Math.floor(Math.random() * 10)).intValue();\n                    int num = ((Long) Math.round(Math.random() * 100)).intValue();\n                    bank.transfer(account1, account2, num);\n                    try {\n                        Thread.sleep(((Double) (Math.random() * 10)).intValue());\n                    } catch (Exception e) {\n                    }\n                }\n            }).start();\n        }\n    }\n}\n\nclass Bank {\n    /**\n     * 10个资金账户\n     */\n    public int[] accounts = new int[10];\n\n    public Bank() {\n        Arrays.fill(accounts, 1000);\n    }\n\n    public void transfer(int from, int to, int num) {\n        accounts[from] -= num;\n        accounts[to] += num;\n        //计算和\n        int sum = 0;\n        for (int j = 0; j < 10; j++) {\n            sum += accounts[j];\n        }\n        System.out.println(sum);\n    }\n}\n```\n\n修复方法\n\n> - synchronized 关键字自动提供了一个锁以及相关的条件\n>   - 牺牲时间来解决访问冲突\n>\n> - ReentrantLock\n>\n> - ThreadLocal\n>   - 牺牲存储空间\n>   - 只有在线程内才可以获取到对应的值\n\n```java\n// 方法一 : 在main函数\nsynchronized (bank) {                     \n  bank.transfer(account1, account2, num);\n}\n\n// 方法二 :  \npublic synchronized void transfer(int from, int to, int num) {\n ...\n}\n\n// 方法三 : \n    private ReentrantLock lock = new ReentrantLock();\n    public synchronized void transfer(int from, int to, int num) {\n     lock.lock();// 上锁\n     try {   \n      // 要保护的代码块\n     }finally {\n      lock.unlock(); // 释放锁\n     }\n    }\n```\n","children":[]}]},{"name":"README.md","path":"../guanruihua.github.io/Back-End","data":"# [ruihuag](https://guanruihua.github.io/#/)\r\n\r\n<!-- ![](../__assets__/001.jpg) -->\r\n<!-- ![Metrics](https://metrics.lecoq.io/guanruihua?template=classic&isocalendar=1&languages=1&base=header%2C%20activity%2C%20community%2C%20repositories%2C%20metadata&base.indepth=false&base.hireable=false&base.skip=false&isocalendar=false&isocalendar.duration=half-year&languages=false&languages.limit=8&languages.threshold=0%25&languages.other=false&languages.colors=github&languages.sections=most-used&languages.indepth=false&languages.analysis.timeout=15&languages.categories=markup%2C%20programming&languages.recent.categories=markup%2C%20programming&languages.recent.load=300&languages.recent.days=14&config.timezone=Asia%2FShanghai) -->\r\n","children":[]},{"name":"Spring","path":"../guanruihua.github.io/Back-End","data":"","children":[{"name":"maven.md","path":"../guanruihua.github.io/Back-End/Spring","data":"# maven\n\n> [下载 - Maven – Download Apache Maven](http://maven.apache.org/download.cgi)\n\n## maven目录\n\n#### 1）bin\n\n该目录包含了 mvn 运行的脚本，这些脚本用来配置 Java 命令，准备好 classpath 和相关的 Java 系统属性，然后执行 Java 命令。\n\n其中 mvn 是基于 UNIX 平台的 shell 脚本，mvn.bat 是基于 Windows 平台的 bat 脚本。在命令行输入任何一条 mvn 命令时，实际上就是在调用这些脚本。\n\n该目录还包含了 mvnDebug 和 mvnDebug.bat 两个文件，同样，前者是 UNIX 平台的 shell 脚本，后者是 Windows 平台的 bat 脚本。那么 mvn 和 mvnDebug 有什么区别和关系呢？\n\n打开文件我们就可以看到，两者基本是一样的，只是 mvnDebug 多了一条 MAVEN_DEBUG_OPTS 配置，其作用就是在运行 Maven 时开启 debug，以便调试 Maven 本身。\n\n此外，该目录还包含 m2.conf 文件，这是 classworlds 的配置文件，后面会介绍 classworlds。\n\n#### 2）boot\n\n该目录只包含一个文件，以 maven 3.3.9 为例，该文件为 plexus-classworlds-2.5.2.jar。\n\nplexus-classworlds 是一个类加载器框架，相对于默认的 java 类加载器，它提供了更丰富的语法以方便配置，Maven 使用该框架加载自己的类库。\n\n更多关于 classworlds 的信息请参考 <http://classworlds.codehaus.org/>。对于一般的 Maven 用户来说，不必关心该文件。\n\n#### 3）conf\n\n> 重点 **setting.xml**\n\n该目录包含了一个非常重要的文件 settings.xml。直接修改该文件，就能在机器上全局地定制 Maven 的行为。\n\n一般情况下，我们更偏向于复制该文件至 ～/.m2/ 目录下（～表示用户目录），然后修改该文件，在用户范围定制 Maven 的行为。后面将会多次提到 **settings.xml**，并逐步分析其中的各个元素。\n\n#### 4）lib\n\n该目录包含了所有 Maven 运行时需要的 Java 类库，Maven 本身是分模块开发的，因此用户能看到诸如 maven-core-3.0.jar、maven-model-3.0.jar 之类的文件。\n\n此外，这里还包含一些 Maven 用到的第三方依赖，如 common-cli-1.2.jar、commons-lang-2.6.jar 等。\n\n对于 Maven 2 来说，该目录只包含一个如 maven-2.2.1-uber.jar 的文件，原本各为独立 JAR 文件的 Maven 模块和第三方类库都被拆解后重新合并到了这个 JAR 文件中。可以说，lib 目录就是真正的 Maven。\n\n关于该文件，还有一点值得一提的是，用户可以在这个目录中找到 Maven 内置的超级 POM，这一点教程后面会详细解释。\n\n#### 5）LICENSE.txt\n\n记录了 Maven 使用的软件许可证Apache License Version 2.0。\n\n#### 6）NOTICE.txt\n\n记录了 Maven 包含的第三方软件。\n\n#### 7）README.txt\n\n包含了 Maven 的简要介绍，包括安装需求及如何安装的简要指令等。\n\n## 常用指令\n\n| 指令                     | 描述          |\n| ------------------------ | ------------- |\n| `mvn -v`                 | 查看maven版本 |\n| `mvn archetype:generate` | 创建一个项目  |\n\n## 编译和测试\n\n> 先切换到工程目录下\n\n| 指令          | 描述                                                         |\n| ------------- | ------------------------------------------------------------ |\n| `mvn clean`   | 清楚以前编译安装过的历史结果                                 |\n| `mvn compile` | 编译源代码                                                   |\n| `mvn test`    | 运行测试案例进行测试                                         |\n| `mvn install` | 将当前代码打层jar包, 安装maven的本地管理目录下, 其他maven工程指定坐标可以使用 |\n\n> - `mvn site` : 生成站点信息\n> - `mvn javadoc:javadoc`: 生成APIDoc文档\n\n## 其他指令\n\n> mvn archetype:create //创建 Maven 项目\n> mvn compile //编译源代码\n> mvn test-compile //编译测试代码\n> mvn test //运行应用程序中的单元测试\n> mvn site //生成项目相关信息的网站\n> mvn package //依据项目生成 jar 文件\n> mvn install //在本地 Repository 中安装 jar\n> mvn -Dmaven.test.skip=true //忽略测试文档编译\n> mvn clean //清除目标目录中的生成结果\n> mvn clean compile //将.java类编译为.class文件\n> mvn clean package //进行打包\n> mvn clean test //执行单元测试\n> mvn clean deploy //部署到版本仓库\n> mvn clean install //使其他项目使用这个jar,会安装到maven本地仓库中\n> mvn archetype:generate //创建项目架构\n> mvn dependency:list //查看已解析依赖\n> mvn dependency:tree //看到依赖树\n> mvn dependency:analyze //查看依赖的工具\n> mvn help:system //从中央仓库下载文件至本地仓库\n> mvn help:active-profiles //查看当前激活的profiles\n> mvn help:all-profiles //查看所有profiles\n> mvn help:effective -pom //查看完整的pom信息\n\n## Archetype插件\n\n#### 1）maven-archetype-quickstart\n\nmaven-archetype-quickstart 应该是最常用的 Archetype。在用户输入命令行“mvn archetype:generate”时，如果没有指定使用哪个 Archetype，默认就是使用 quickstart。使用 maven-archetype-quickstart 生成的项目比较简单。\n\n- pom.xml，包含有 JUnit 的依赖声明。\n- src/main/java，主代码目录以及一个名为 App 的 [Java](http://c.biancheng.net/java/) 类。\n- src/main/test，测试代码目录以及一个名为 AppTest 的 JUnit 测试用例类。\n\n如果需要创建一个全新的 Maven 项目，可以使用该 Archetype 生成项目架构，再在该架构的基础上进行对应地修改，比如添加依赖、添加 resources 目录等，从而省去手动创建 pom 以及目录结构的麻烦。\n\n#### 2）maven-archetype-webapp\n\nmaven-archetype-webapp 是一个创建 Maven War 项目的 Archetype。它能创建一个 Web 应用的基本目录结构和必需的 web.xml。使用 maven-archetype-webapp 生成如下内容。\n\n- pom.xml packaging 的值为 war，带有 JUnit 的依赖声明。\n- src/main/webapp 目录。\n- src/main/webapp/index.jsp 文件。\n- src/main/webapp/WEB-INF/web.xml 文件。\n","children":[]},{"name":"question","path":"../guanruihua.github.io/Back-End/Spring","data":"","children":[{"name":"ssm跨域.md","path":"../guanruihua.github.io/Back-End/Spring/question","data":"# ssm跨域\n\n创建一个类实现javax.servlet.Filter接口\n\n```java\npublic class MyCORSFilter implements Filter{  \n  @Override  \n  public void destroy() {}  \n\n  @Override  \n  public void doFilter(ServletRequest req, ServletResponse res,  \n          FilterChain chain) throws IOException, ServletException {  \n          HttpServletResponse response = (HttpServletResponse) res;  \n          response.setHeader(\"Access-Control-Allow-Origin\", \"*\");  \n          response.setHeader(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS, DELETE\");  \n          response.setHeader(\"Access-Control-Max-Age\", \"3600\");  \n          response.setHeader(\"Access-Control-Allow-Headers\", \"x-requested-with\");  \n          chain.doFilter(req, res);  \n  }  \n\n  @Override  \n  public void init(FilterConfig arg0) throws ServletException {}  \n}\n```\n\n修改web.xml文件\n添加Filter的配置\n\n```xml\n<filter>  \n  <filter-name>cors</filter-name>  \n  <filter-class>com.ma.filter.MyCORSFilter</filter-class>  \n</filter>  \n<filter-mapping>  \n  <filter-name>cors</filter-name>  \n  <url-pattern>/*</url-pattern>  \n</filter-mapping>\n```\n","children":[]},{"name":"tomcat.md","path":"../guanruihua.github.io/Back-End/Spring/question","data":"# Tomcat\n\n## **在请求目标中找到无效字符。有效字符在RFC 7230和RFC 3986中定义**\n\n> 环境：tomcat9\n>\n> 在tomcat配置中conf/server.xml\n\n```xml\n<Connector port=\"8080\" protocol=\"HTTP/1.1\"\n    connectionTimeout=\"20000\"\n    redirectPort=\"8443\" \n    // 添加的\n    relaxedPathChars=\"|{}[],%\" relaxedQueryChars=\"|{}[],%\" />\n```\n","children":[]}]},{"name":"Shiro.md","path":"../guanruihua.github.io/Back-End/Spring","data":"# Shiro\n\n## 简介\n\n> - 说明:\n>   - 在Web系统中涉及到权限问题, 例如不同角色的人登录系统, 他操作的功能, 按钮, 菜单是各不相同\n> - 权限校验\n>   - 用户认证 - 用户身份识别, 即登录\n>   - 用户授权 - 访问控制\n>   - 密码加密 - 加密敏感数据房子被偷窥\n>   - 会话管理 - 与用户相关的时间敏感的状态信息\n> - Shiro\n>   - 适用环境: javaSE , JavaEE\n>   - 认证, 授权, 加密, 会话管理, 与Web继承, 缓存等\n> - 官网 <http://shiro.apache.org/>\n","children":[]},{"name":"Spring-Boot-annotations.md","path":"../guanruihua.github.io/Back-End/Spring","data":"# Spring Boot 注解\n\n## 注解(annotations)列表\n\n> **@SpringBootApplication**：\n>\n> - 包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。\n> - 其中@ComponentScan让spring Boot扫描到Configuration类并把它加入到程序上下文。\n\n| 注解                         | 描述                                                         |\n| ---------------------------- | ------------------------------------------------------------ |\n| @Configuration               | 等同于spring的XML配置文件；使用[Java][]代码可以检查类型安全。 |\n| @EnableAutoConfiguration     | 自动配置                                                     |\n| @ComponentScan               | 组件扫描                                                     |\n| @Component                   | 可配合CommandLineRunner使用, 在程序启动后执行一些任务        |\n| @RestController              | 是@Controller 和 @ResponseBody 的合集, 表示这个是控制器, 并且是将函数的返回值,接填入HTTP响应体中, REST风格控制器 |\n| @Autowried                   | 自动导入                                                     |\n| @PathVariable                | 获取参数                                                     |\n| @JsonBackReference           | 解决嵌套外链问题                                             |\n| @RepositoryRestResoucepublic | 配合spring-boot-start-data-rest使用                          |\n\n## 注解(annotations)详解\n\n@SpringBootApplication：\n\n- 申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。\n\n```java\npackage com.example.myproject;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n@SpringBootApplication// same as @Configuration @EnableAutoConfiguration @ComponentScan\npublicclassApplication{\n  public static void main(String[] args) {\n    SpringApplication.run(Application.class, args);\n }\n}\n```\n\n@ResponseBody：\n\n​   表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。示例代码：\n\n```java\n@RequestMapping(“/test”)\n@ResponseBody \npublic String test(){\n return”ok”;\n}\n```\n\n@Controller：\n\n​   用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。示例代码：\n\n```java\n@Controller \n@RequestMapping(“/demoInfo”)\npublic class DemoController{\n  @Autowired\n  private DemoInfoService demoInfoService;\n  @RequestMapping(\"/hello\")\n  public String hello(Map<String,Object> map){   \n    System.out.println(\"DemoController.hello()\");   \n    map.put(\"hello\",\"from TemplateController.helloHtml\");   \n    //会使用hello.html或者hello.ftl模板进行渲染显示.   \n    return\"/hello\";\n  }}\n```\n\n@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。示例代码：\n\n```java\npackage com.kfit.demo.web;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n@RestController \n@RequestMapping(“/demoInfo2”)\npublic class DemoController2{\n   @RequestMapping(\"/test\")\n   public String test(){\n      return\"ok\";\n    }\n}\n```\n\n@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。\n\n@EnableAutoConfiguration：Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何[数据库][Link 1]连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。\n\n@ComponentScan：\n\n表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。\n\n@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。\n\n@Import：用来导入其他配置类。\n\n@ImportResource：用来加载xml配置文件。\n\n@Autowired：自动导入依赖的bean\n\n@Service：一般用于修饰service层的组件\n\n@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。\n\n@Bean：用@Bean标注方法等价于XML中配置的bean。\n\n@Value：注入Spring boot application.properties配置的属性的值。示例代码：\n\n```\n@Value(value = “#{message}”)privateString message;\n```\n\n@Inject：等价于默认的@Autowired，只是没有required属性；\n\n@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。\n\n@Bean:相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。\n\n@AutoWired：自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。\n\n@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：\n\n```\n@Autowired @Qualifier(value = “demoInfoService”)privateDemoInfoService demoInfoService;\n```\n\n@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。\n\n## JPA注解\n\n@Entity：\n\n​ @Table(name=\"\")：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略\n\n@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。\n\n@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。\n\n@Column：如果字段名与列名相同，则可以省略。\n\n@Id：表示该属性为主键。\n\n@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。\n\n@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。\n\n@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式\n\n@JsonIgnore：作用是json序列化时将[Java ][Java 1]bean中的一些属性忽略掉,序列化和反序列化都受影响。\n\n@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。\n\n@OneToOne、@OneToMany、@ManyToOne：对应[hibernate][spring]配置文件中的一对一，一对多，多对一。\n\n## springMVC相关注解\n\n@RequestMapping：\n\n- @RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。\n\n> - 用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：\n>   - params:指定request中必须包含某些参数值是，才让该方法处理。\n>   - headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。\n>   - value:指定请求的实际地址，指定的地址可以是URI Template 模式\n>   - method:指定请求的method类型， GET、POST、PUT、DELETE等\n>   - consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;\n>   - produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回\n\n@RequestParam：用在方法的参数前面。\n\n@RequestParam String a =request.getParameter(“a”)。\n\n@PathVariable: 路径变量。如\n\n```java\n@RequestMapping(“user/get/mac/{macAddress}”)\npublic String getByMacAddress( @PathVariableString macAddress){\n  //do something;\n}\n```\n\n参数与大括号里的名字一样要相同。\n\n## 全局异常处理\n\n@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。\n\n@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。\n","children":[]},{"name":"SpringJDBC.md","path":"../guanruihua.github.io/Back-End/Spring","data":"# Spring JDBC\n\n> 主要包括四个包:\n>\n> - core: 包含JDBC的核心功能, 包括JdbcTemplate等类\n> - dataSource: 访问数据源的实用工具类, 他有多种数据源的实现, 可以在JavaEE容器外部测试jdbc代码\n> - object: 以访问对象方式访问数据库, 他允许执行查询并将返回结果作为业务对象, 可以在数据表的列表业务对象的属性之间映射查询结果\n> - support: 包含core和object包的支持类, 例如: 提供异常转换功能的SQLException类\n\n```java\nimport lombok.Data;\n@Data\npublic class User {\n    private int ID;\n    private String name;\n    private String age;\n}\n```\n\n```java\nimport java.util.List;\npublic interface UserDao {\n    public int update(String sql, Object[] param);\n    public List<User> query(String sql, Object[] param);\n}\n```\n\n```js\n@Repository(\"userDao\")\npublic class UserDaoImpl implements UserDao{\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    public int update(String sql, Object[] param){\n        return jdbcTemplate.update(sql, param);\n    }\n\n    public List<User> query(String sql, Object[] param) {\n        RowMapper<User> rowMapper = new BeanPropertyRowMapper<>(User.class);\n        return jdbcTemplate.query(sql, rowMapper, param);\n    }\n}\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\n    <context:component-scan base-package=\"com.tutorialspoint.dao.jdbcDemo\"/>\n<!--    配置数据源-->\n    <bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n<!--       数据库驱动-->\n        <property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"></property>\n<!--        连接数据库URL-->\n        <property name=\"url\"\n                  value=\"jdbc:mysql://localhost:3306/spring?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true\"/>\n<!--        连接数据库和密码-->\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"\"/>\n    </bean>\n<!--    配置jdbc模版-->\n    <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n<!--        默认必须使用的数据源-->\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n    </bean>\n</beans>\n```\n\n```java\n@Test\npublic void DEMO(){\n  ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"jdbc.xml\");\n  UserDao userDao = (UserDao) applicationContext.getBean(\"userDao\");\n\n  Object[] para = { \"张三\", 21};\n  String sql = \"insert into user values ( null, ?, ?)\";\n  userDao.update(sql, para);\n\n  String sql1 = \"select * from user\";\n  List<User> users = userDao.query(sql1, null);\n  for (User user : users){\n    System.out.println(user);\n  }\n}\n```\n","children":[]},{"name":"Spring相关.md","path":"../guanruihua.github.io/Back-End/Spring","data":"# Spring相关\n\n\n\n> - [Getting Started | Building a RESTful Web Service (spring.io)](https://spring.io/guides/gs/rest-service/)\n> - [Spring | Spring Quickstart Guide](https://spring.io/quickstart)\n> - [Spring 环境配置_w3cschool](https://www.w3cschool.cn/wkspring/f6pk1ic8.html)","children":[]},{"name":"ssm","path":"../guanruihua.github.io/Back-End/Spring","data":"","children":[{"name":"log4j.md","path":"../guanruihua.github.io/Back-End/Spring/ssm","data":"# log4j\n\n> log4j包含三个组件\n>\n> - Logger(记录器) : 日志类别\n> - Appender(输出目的地) : 日志要输出的地方\n> - Layout(日志布局) : 日志以何种形式输出\n\n## java项目配置log4j配置步骤\n\npom.xml\n\n```xml\n<!--添加log4j相关jar包-->\n<dependency>\n    <groupId>log4j</groupId>\n    <artifactId>log4j</artifactId>\n    <version>1.2.16</version>\n</dependency>\n```\n\nresources/log4j.properties\n\n```properties\n#日志配置\nlog4j.rootLogger = DEBUG,stdout,file\n \n#控制台输出\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.Target=System.out\nlog4j.appender.stdout.Threshold=DEBUG\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss}[ %p ]%m%n\n \n#所有文件输出\nlog4j.appender.file = org.apache.log4j.FileAppender\nlog4j.appender.file.File = D:/logs/log.log\nlog4j.appender.file.Encoding=UTF-8\nlog4j.appender.file.name = fileLogDemo\nlog4j.appender.file.Threshold=DEBUG\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss} [%c {Num}] [%l] [ %t:%r ] - [ %p ]  %m%n\nlog4j.appender.file.append = true\n```\n\n测试类\n\n```java\nimport org.apache.log4j.Logger;public class log4jTest {\n    //获取日志记录器Logger，名字为本类类名\n    private static Logger logger = Logger.getLogger(log4jTest.class);\n  \n    public static void main(String[] args) {\n        for(int i=0;i<3;i++){\n            // 记录debug级别的信息\n            logger.debug(\"log4j日志输出：This is debug message.\");\n            // 记录info级别的信息\n            logger.info(\"log4j日志输出：This is info message.\");\n            // 记录error级别的信息\n            logger.error(\"log4j日志输出：This is error message.\");\n        }\n    }\n}\n```\n\n## 配置Logger记录器\n\n```java\nlog4j.rootLogger = [ level ] , appenderName, appenderName, …\n```\n\nlevel表示日志记录的优先级，分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者你定义的级别。\n\nLog4j建议使用四个级别，优先级从高到低分别是ERROR、WARN、INFO、DEBUG。\n\n通过在这里定义的级别，你可以控制到应用程序中相应级别的日志信息的开关。比如在这里定义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来。\n\nappenderName就是指日志输出的目的。你可以灵活地定义日志输出，也可以同时指定多个输出目的地。\n\nLog4j配置文件实现了输出到控制台、文件、回滚文件、发送日志邮件、输出到数据库日志表、自定义标签等全套功能。\n\n## 配置Appender输出目的地\n\n输出目的地类型：\n\n```properties\norg.apache.log4j.ConsoleAppender（控制台），  \norg.apache.log4j.FileAppender（文件），  \norg.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），  \norg.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），  \norg.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）\n```\n\n## 配置layout日志布局\n\n```properties\norg.apache.log4j.HTMLLayout（HTML表格形式）\norg.apache.log4j.SimpleLayout（简单格式的日志，只包括日志信息的级别和指定的信息字符串 ，如:DEBUG - Hello）\norg.apache.log4j.TTCCLayout（日志的格式包括日志产生的时间、线程、类别等等信息）\norg.apache.log4j.PatternLayout（灵活地自定义日志格式）\n```\n","children":[]},{"name":"spring.md","path":"../guanruihua.github.io/Back-End/Spring/ssm","data":"# Spring\n\n## 前言\n\n> - Spring是一个开源框架\n> - Spring 为简化企业级应用开发而生. 使用Spring可以使简单的JavaBean实现以前只有EJB才能实现的功能\n> - Spring 是JavaSE/EE的一站式框架\n\n## 优点\n\n- 方便解耦, 简化开发\n\n  - Spring就是一个大工厂,可以将所有对象创建和依赖关系维护, 交给Spring管理\n\n- AOP变成的支持\n\n  - Spring提供蜜蜡线切面编程, 可以方便的实现对程序进行权限拦截、运行监控等功能\n\n- 声明式事务的支持\n\n  - 只需要通过配置就可以完成对事务的管理, 而无需手动编程\n\n- 方便程序的测试\n\n  - Spring对Junit4支持, 可以通过注解方便的测试Spring程序\n\n- 方便继承各种优秀框架\n\n  - Spring不排斥各种优秀的开源框架,其内部提供对各种优秀的框架(Struts、Hibernate、MyBatis等）的直接支持\n\n- 降低JavaEE API的使用难度\n\n  - Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低\n\n## 模块\n\n  <img src=\"https://images.gitee.com/uploads/images/2020/0711/133424_2ed6aec0_6545143.png\" style=\"zoom:25%;\" />\n\n## Spring IOC的底层原理\n\n## 导入Spring核心开发包到创建工程\n\n> commons-logging-xxx.jar\n>\n> spring-beans-x.x.x.RELEASE.jar\n>\n> spring-context-x.x.x.RELEASE.jar\n>\n> spring-core-x.x.x.RELEASE.jar\n>\n> spring-expression-x.x.x.RELEASE.jar\n\npom.xml\n\n```xml\n<dependency>\n  <groupId>log4j</groupId>\n  <artifactId>log4j</artifactId>\n  <version>1.2.17</version>\n</dependency>\n\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-core</artifactId>\n  <version>4.2.4.RELEASE</version>\n</dependency>\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-context</artifactId>\n  <version>4.2.4.RELEASE</version>\n</dependency>\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-beans</artifactId>\n  <version>4.2.4.RELEASE</version>\n</dependency>\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-expression</artifactId>\n  <version>4.2.4.RELEASE</version>\n</dependency>\n```\n\n## 概念\n\n> Spring IOC\n>\n> - IOC Inverse of Control 反转控制的概念, 就是将原本在程序中手动创建UserService对象的控制权, 交由Spring框架管理\n> - 就是将创建UserService对象控制权反转到Spring框架\n> - DI Dependency Injection **依赖注入**的概念, 就是在创建这个对象的过程中, 将这个对象所依赖的属性注入进去\n\n### Bean 使用注解开发\n\n> id和name的作用区别 : name可以使用特殊字符\n\n使用前 需要添加的配置\n\n添加前\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd\">\n // 配置bean\n  <bean id = \"idName\" class= \"位置\"></bean>\n</beans>\n```\n\n添加后\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd\n                           http://www.springframework.org/schema/context  \n                           http://www.springframework.org/schema/context/spring-context.xsd\">\n    <!-- 开启注释 -->\n    <context:annotation-config/>\n    <!-- 注释的位置 -->\n    <context:component-scan base-package=\"com.tutorialspoint.beans\" />\n\n</beans>\n```\n\n```java\n// 这里的Beans.xml 也可以写成相对路径\nApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\");\nHelloSpring helloSpring = (HelloSpring) context.getBean(\"helloSpring\");\n//通过 获取bean的实例来初始化, 该方法获取bean不需要设置bean的id\n// HelloSpring helloSpring = (HelloSpring) context.getBean(HelloSpring.class); \nhelloSpring.setName(\"Spring add\");\nSystem.out.println(helloSpring);\n```\n\n#### 注释和标签的对比\n\n| bean.xml                      | 注解                             | 描述       |\n| ----------------------------- | -------------------------------- | ---------- |\n| id = \"idName\"                 | @Component(\"idName\")             | bean ID    |\n| lazy-init=\"true\"              | @Lazy                            | 延迟加载   |\n| scope=\"singleton\"             | @Scope(\"singleton\")              |            |\n| init-method=\"functionName\"    | @PostConstruct // 放在function前 | bean创建时 |\n| destroy-method=\"functionName\" | @PreDestroy // 放在function 前   | bean销毁时 |\n\n#### Bean 的初始化和销毁前后调用方法\n\n1. interface\n\n   - `implements InitializingBean, DisposableBean`\n\n   - 然后实现里面的两个方法\n\n2. 注解\n\n   - 在Bean中里面的方法前分别添加`@PostConstruct`和 `@PreDestory`\n\n3. xml\n\n   - 先在bean添加方法\n   - 再在xml中, bean中init-method和destory-method注册\n\n补充\n\nScope 的五种取值\n\n- singleton:　单例模式, 在整个Spring IOC 容器中只会创建一个实例. 默认即为单例模式\n\n- prototype:  原型模式, 每次通过`getBean`方法获取实例, 都会创建一个新的实例\n\n- request:  在同一次`http`请求内, 只会产生一个实例 ( Web 应用 )\n\n- session:  在同一词`http`请求内, 只会产生一个实例 ( Web 应用 )\n\n- global session: 映射到porlet的global范围的session, 如果是普通web项目施使用, 会当做普通的session ( 在基于porlet 的web应用程序 )\n\n```java\n/**\n     * Spring的方式实现\n     */\n    @Test\n    public void demo2(){\n        //创建Spring的公厂\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        //通过工厂获得类\n        UserService userService = (UserService) applicationContext.getBean(\"userService\");\n        userService.sayHello();\n    }\n\n    @Test\n    /**\n     * 读取磁盘系统中的配置文件\n     */\n    public void demo3(){\n        //创建Spring的工厂类\n        //读取c盘的配置文件\n        ApplicationContext applicationContext = new FileSystemXmlApplicationContext(\"c:\\\\applicationContext.xml\");\n        UserService userService = (UserService) applicationContext.getBean(\"userService\");\n        userService.sayHello();\n    }\n\n    @Test\n    /**\n     * 传统方式的工厂类: BeanFactory\n     */\n    public void demo4(){\n        BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(\"applicationContext.xml\"));\n        UserService userService = (UserService) beanFactory.getBean(\"userService\");\n        userService.sayHello();\n    }\n\n    @Test\n    /**\n     * 传统方式的工厂类: BeanFactory\n     */\n    public void demo5(){\n        BeanFactory beanFactory = new XmlBeanFactory(new FileSystemResource(\"C:\\\\applicationContext.xml\"));\n        UserService userService = (UserService) beanFactory.getBean(\"userService\");\n        userService.sayHello();\n    }\n```\n\n## Bean\n\n### 三种实例化Bean的方式\n\n#### 类构造器实例化(默认无参数)\n\napplicationContext.xml\n\n```xml\n<!--第一种: 无参构造器的方式-->\n    <bean id=\"bean1\" class=\"com.ioc.demo2.Bean1\"></bean>\n```\n\njavaclass\n\n```java\n \npublic void demo1(){\n        //创建工厂\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        //通过工厂类获得类的实例\n        Bean1 bean1 = (Bean1) applicationContext.getBean(\"bean1\");\n\n    }\n```\n\n#### 静态工厂方法实例化(简单工厂模式)\n\napplicationContext.xml\n\n```xml\n<!--第二种: 静态工厂的方式-->\n    <bean id=\"bean2\" class=\"com.ioc.demo2.Bean2Factory\" factory-method=\"createBean2\"></bean>\n```\n\njavaclass\n\n```java\n \npublic void demo1(){\n        //创建工厂\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        //通过工厂类获得类的实例\n        Bean1 bean1 = (Bean1) applicationContext.getBean(\"bean1\");\n\n    }\n```\n\nDEMO  \n\nPetFactory.java\n\n```java\npublic class PetFactory {\n    public Ipet getPet( String type){\n        if(\"dog\".equals(type)){\n            return new Dog();\n        } else if( \"parrot\".equals(type)){\n            return  new Parrot();\n        } else {\n            throw new IllegalArgumentException(\"pet type is illegal!\");\n        }\n    }\n}\n```\n\nfactoryBean.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean id=\"petFactory\" class=\"com.tutorialspoint.impl.PetFactory\"></bean>\n    <bean id=\"dog\" factory-bean=\"petFactory\" factory-method=\"getPet\">\n        <constructor-arg value=\"dog\"></constructor-arg>\n    </bean>\n\n    <bean id=\"parrot\" factory-bean=\"petFactory\" factory-method=\"getPet\">\n        <constructor-arg value=\"parrot\"></constructor-arg>\n    </bean>\n</beans>\n```\n\nTest文件\n\n```java\n@Test\npublic void FactoryTest1(){\n  Resource resource = new ClassPathResource(\"factoryBeans.xml\");\n  BeanFactory factory = new DefaultListableBeanFactory();\n  BeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader((BeanDefinitionRegistry) factory);\n  beanDefinitionReader.loadBeanDefinitions(resource);\n\n  Dog dog = (Dog) factory.getBean(\"dog\");\n  Parrot parrot = (Parrot) factory.getBean(\"parrot\");\n\n  dog.move();\n  parrot.move();\n}\n\nlog:\nDog can run!\nParrot can fly!\n```\n\n#### 使用实例工厂方法实例化(工厂方法模式)\n\n```xml\n<!--第三种: 实例工厂的方式-->\n    <bean id=\"bean3Factory\" class=\"com.ioc.demo2.Bean3Factory\"></bean>\n    <bean id=\"bean3\" factory-bean=\"bean3Factory\" factory-method=\"createBean3\"/>\n```\n\njavaclass\n\n```java\n \npublic void demo1(){\n        //创建工厂\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        //通过工厂类获得类的实例\n        Bean1 bean1 = (Bean1) applicationContext.getBean(\"bean1\");\n\n    }\n```\n\nDEMO\n\nPetFactory.java\n\n```java\npublic class PetFactory {\n    public static Ipet getPet( String type){\n        if(\"dog\".equals(type)){\n            return new Dog();\n        } else if( \"parrot\".equals(type)){\n            return  new Parrot();\n        } else {\n            throw new IllegalArgumentException(\"pet type is illegal!\");\n        }\n    }\n}\n```\n\nfactoryBean.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean id=\"dog\" class=\"com.tutorialspoint.impl.StaticPetFactory\" factory-method=\"getPet\">\n        <constructor-arg value=\"dog\"></constructor-arg>\n    </bean>\n\n    <bean id=\"parrot\" class=\"com.tutorialspoint.impl.StaticPetFactory\" factory-method=\"getPet\">\n        <constructor-arg value=\"parrot\"></constructor-arg>\n    </bean>\n</beans>\n```\n\nTest文件\n\n```java\n@Test\npublic void FactoryTest1(){\n  Resource resource = new ClassPathResource(\"factoryBeans.xml\");\n  BeanFactory factory = new DefaultListableBeanFactory();\n  BeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader((BeanDefinitionRegistry) factory);\n  beanDefinitionReader.loadBeanDefinitions(resource);\n\n  Dog dog = (Dog) factory.getBean(\"dog\");\n  Parrot parrot = (Parrot) factory.getBean(\"parrot\");\n\n  dog.move();\n  parrot.move();\n}\n\nlog:\nDog can run!\nParrot can fly!\n```\n\n#### 小结\n\n##### 调用实例工厂方法和调用静态工厂方法创建 Bean 的异同\n\n区别如下：\n\n- 配置实例工厂方法创建 Bean,必须将实例工厂配置成 Bean 实例；而配置静态工厂方法创建 Bean,则无需配置工厂 Bean;\n- 配置实例工厂方法创建 Bean,必须使用 `factory-bvean` 属性确定工厂 Bean; 而配置静态工厂方法创建 Bean,则使用 `class` 属性确定静态工厂类。\n  相同之处如下：\n- 都需要使用 `factory-method` 指定生产 Bean 实例的工厂方法；\n- 工厂方法如果需要参数，都使用 `<constructor-arg.../>` 元素指定参数值；\n- 普通的设值注入，都使用 `<property.../>`元素确定参数值。\n\n### Bean的作用域\n\n<img src=\"https://images.gitee.com/uploads/images/2020/0802/144827_2c930c4b_6545143.png\" style=\"zoom:50%;\" />\n\n### Bean的生命周期\n\n- 第一步:MAN被实例化了..., instantiate bean对象实例化\n- 第二步:设置属性..., populate properties 封装属性\n- 第三步,设置Bean的名称man, 如果Bean实现了BeanNameAware 执行 setBeanName\n- 第四步,了解工厂的信息,如果Bean实现BeanFactoryAware 或者 ApplicationContextAware 设置工厂\n- 第五步,初始化前方法, 如果存在BeanPostProcessor(后处理Bean), 执行postProcessBeforeInitialization\n- 第六步,属性设置后, 如果Bean实现了InitializingBean 执行afterPropertiesSet\n- 第七步:MAN被初始化了.... , 调用`<bean init-mothod=\"init\">`\n- 第八步,初始化后的方法, 如果存在类实现 BeanPostProcessor ( 处理Bean ) , 执行postProcessAfterInitialization\n- 第九步: 执行业务方法, 执行业务处理\n- 第十步: 执行Spring的销毁方法, 如果Bean实现DisposableBean 执行 destory\n- 第十一步: MAN被销毁了....  , 掉用`<bean destroy-method=\"customerDestroy\">`执行销毁方法customerDestroy\n\n> 最重要的是第五步和第八步: 可以增强类的方法\n\n> Spring\n>\n> ```xml\n> <bean id=\"man\" class=\"com.ioc.demo3.Man\" init-method=\"setup\" destroy-method=\"manDestory\">\n> ```\n>\n> - 初始化bean会触发init-method=\"functionName\"\n> - bean销毁时触发destory-method = \"destoryFunctionName\"\n\n补充:\n前面工厂内使用的class\nIpet.java\n\n```java\npublic interface Ipet {\n    public void move();\n}\n```\n\nDog.java\n\n```java\npublic class Dog implements Ipet{\n    @Override\n    public void move() {\n        System.out.println(\"Dog can run!\");\n    }\n}\n```\n\nParrot.java\n\n```java\npublic class Parrot implements Ipet{\n    @Override\n    public void move() {\n        System.out.println(\"Parrot can fly!\");\n    }\n}\n```\n\n## Spring AOP\n\n> - Spring 框架的一个关键组件是**面向切面的编程**(AOP [ Aspect Oriented Programming ]) 框架, 可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。\n>   - 不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。\n>   - AOP技术恰恰相反，它利用一种称为\"横切\"的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为\"Aspect\"，即切面。所谓\"切面\"，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。\n> - 面向方面的编程需要把程序逻辑分解成不同的部分称为所谓的关注点。\n>   - 跨一个应用程序的多个点的功能被称为**横切关注点**，这些横切关注点在概念上独立于应用程序的业务逻辑。有各种各样的常见的很好的方面的例子，如日志记录、审计、声明式事务、安全性和缓存等。\n> - 在 OOP 中，关键单元模块度是类，而在 AOP 中单元模块度是方面。依赖注入帮助你对应用程序对象相互解耦和 AOP 可以帮助你从它们所影响的对象中对横切关注点解耦。AOP 是像编程语言的触发物，如 Perl，.NET，Java 或者其他。\n> - Spring AOP 模块提供拦截器来拦截一个应用程序，例如，当执行一个方法时，你可以在方法执行之前或之后添加额外的功能。\n> - 使用\"横切\"技术，AOP把软件系统分为两个部分：**核心关注点**和**横切关注点**。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。\n> - AOP分为两种类型:\n>   - 静态AOP : 在编译期进行加入, 就是对切面进行的任何修改, 都要进行重新编译程序\n>   - 动态AOP : 在代码执行过程中进行加入,  他的切面代码不是编译进class 文件分钟, SpringAOP就是动态AOP\n\n### AOP术语\n\n| 项                        | 描述                                                         |\n| ------------------------- | ------------------------------------------------------------ |\n| 横切关注点                | 对那些方法进行拦截, 拦截后如何处理, 这些关注点成为横切关注点 |\n| Aspect ( 切面 )           | 类就是对物体特征的抽象， 切面就是对横切关注点的抽象， 一个模块具有一组提供横切需求的 APIs。例如，一个日志模块为了记录日志将被 AOP 方面调用。应用程序可以拥有任意数量的方面，这取决于需求。 |\n| Join point ( 连接点)      | 在你的应用程序中它代表一个点，你可以在插件 AOP 方面。你也能说，它是在实际的应用程序中，其中一个操作将使用 Spring AOP 框架。 |\n| Advice( 通知)             | 这是实际行动之前或之后执行的方法。这是在程序执行期间通过 Spring AOP 框架实际被调用的代码。 |\n| Pointcut( 切入点 )        | 对连接点进行拦截的定义， 这是一组一个或多个连接点，通知应该被执行。你可以使用表达式或模式指定切入点正如我们将在 AOP 的例子中看到的。 |\n| Introduction( )           | 在不修改代码的前提下， 引入可以在运行期， 为类动态地添加一些方法或字段，引用允许你添加新方法或属性到现有的类中。 |\n| Target object( 目标对象 ) | 被一个或者多个方面所通知的对象，这个对象永远是一个被代理对象。也称为被通知对象。 |\n| Weaving( 织入 )           | Weaving 把方面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时，类加载时和运行时完成。 |\n\n### **Spring对AOP的支持**\n\n**Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理**。因此，AOP代理可以直接使用容器中的其它bean实例作为目标，这种关系可由IOC容器的依赖注入提供。Spring创建代理的规则为：\n\n1、**默认使用Java动态代理来创建AOP代理**，这样就可以为任何接口实例创建代理了\n\n2、**当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理**，也可强制使用CGLIB\n\nAOP编程其实是很简单的事情，纵观AOP编程，程序员只需要参与三个部分：\n\n1、定义普通业务组件\n\n2、定义切入点，一个切入点可能横切多个业务组件\n\n3、定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作\n\n所以进行AOP编程的关键就是定义切入点和定义增强处理，一旦定义了合适的切入点和增强处理，AOP框架将自动生成AOP代理，即：**代理对象的方法=增强处理+被代理对象**的方法。\n\n下面给出一个Spring AOP的.xml文件模板，名字叫做aop.xml，之后的内容都在aop.xml上进行扩展：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:aop=\"http://www.springframework.org/schema/aop\"\n    xmlns:tx=\"http://www.springframework.org/schema/tx\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd\n        http://www.springframework.org/schema/aop\n        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd\">\n            \n   <!-- bean definition & AOP specific configuration -->\n  \n</beans>\n```\n\n#### **基于Spring的AOP简单实现**\n\n注意一下，在讲解之前，说明一点：使用Spring AOP，要成功运行起代码，只用Spring提供给开发者的jar包是不够的，请额外上网下载两个jar包：\n\n1、aopalliance.jar\n\n2、aspectjweaver.jar\n\n开始讲解用Spring AOP的XML实现方式，先定义一个接口：\n\n```java\npublic interface HelloWorld\n{\n    void printHelloWorld();\n    void doPrint();\n}\n```\n\n定义两个接口实现类：\n\n```java\npublic class HelloWorldImpl1 implements HelloWorld\n{\n    public void printHelloWorld()\n    {\n        System.out.println(\"Enter HelloWorldImpl1.printHelloWorld()\");\n    }\n    \n    public void doPrint()\n    {\n        System.out.println(\"Enter HelloWorldImpl1.doPrint()\");\n        return ;\n    }\n}\n```\n\n```java\npublic class HelloWorldImpl2 implements HelloWorld\n{\n    public void printHelloWorld()\n    {\n        System.out.println(\"Enter HelloWorldImpl2.printHelloWorld()\");\n    }\n    \n    public void doPrint()\n    {\n        System.out.println(\"Enter HelloWorldImpl2.doPrint()\");\n        return ;\n    }\n}\n```\n\n横切关注点，这里是打印时间：\n\n```java\npublic class TimeHandler\n{\n    public void printTime()\n    {\n        System.out.println(\"CurrentTime = \" + System.currentTimeMillis());\n    }\n}\n```\n\n有这三个类就可以实现一个简单的Spring AOP了，看一下aop.xml的配置：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:aop=\"http://www.springframework.org/schema/aop\"\n    xmlns:tx=\"http://www.springframework.org/schema/tx\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd\n        http://www.springframework.org/schema/aop\n        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd\">\n        \n        <bean id=\"helloWorldImpl1\" class=\"com.xrq.aop.HelloWorldImpl1\" />\n        <bean id=\"helloWorldImpl2\" class=\"com.xrq.aop.HelloWorldImpl2\" />\n        <bean id=\"timeHandler\" class=\"com.xrq.aop.TimeHandler\" />\n        \n        <aop:config>\n            <aop:aspect id=\"time\" ref=\"timeHandler\">\n                <aop:pointcut id=\"addAllMethod\" expression=\"execution(* com.xrq.aop.HelloWorld.*(..))\" />\n                <aop:before method=\"printTime\" pointcut-ref=\"addAllMethod\" />\n                <aop:after method=\"printTime\" pointcut-ref=\"addAllMethod\" />\n            </aop:aspect>\n        </aop:config>\n</beans>\n```\n\n写一个main函数调用一下：\n\n```java\npublic static void main(String[] args)\n{\n    ApplicationContext ctx = \n            new ClassPathXmlApplicationContext(\"aop.xml\");\n        \n    HelloWorld hw1 = (HelloWorld)ctx.getBean(\"helloWorldImpl1\");\n    HelloWorld hw2 = (HelloWorld)ctx.getBean(\"helloWorldImpl2\");\n    hw1.printHelloWorld();\n    System.out.println();\n    hw1.doPrint();\n    \n    System.out.println();\n    hw2.printHelloWorld();\n    System.out.println();\n    hw2.doPrint();\n}\n```\n\n运行结果为：\n\n```shell\nCurrentTime = 1446129611993\nEnter HelloWorldImpl1.printHelloWorld()\nCurrentTime = 1446129611993\n\nCurrentTime = 1446129611994\nEnter HelloWorldImpl1.doPrint()\nCurrentTime = 1446129611994\n\nCurrentTime = 1446129611994\nEnter HelloWorldImpl2.printHelloWorld()\nCurrentTime = 1446129611994\n\nCurrentTime = 1446129611994\nEnter HelloWorldImpl2.doPrint()\nCurrentTime = 1446129611994\n```\n\n看到给HelloWorld接口的两个实现类的所有方法都加上了代理，代理内容就是打印时间\n\n#### ***\\*基于Spring的AOP使用其他细节\\****\n\n1、增加一个横切关注点，打印日志，Java类为：\n\n```java\npublic class LogHandler\n{\n    public void LogBefore()\n    {\n        System.out.println(\"Log before method\");\n    }\n    \n    public void LogAfter()\n    {\n        System.out.println(\"Log after method\");\n    }\n}\n```\n\naop.xml配置为：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:aop=\"http://www.springframework.org/schema/aop\"\n    xmlns:tx=\"http://www.springframework.org/schema/tx\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd\n        http://www.springframework.org/schema/aop\n        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd\">\n        \n        <bean id=\"helloWorldImpl1\" class=\"com.xrq.aop.HelloWorldImpl1\" />\n        <bean id=\"helloWorldImpl2\" class=\"com.xrq.aop.HelloWorldImpl2\" />\n        <bean id=\"timeHandler\" class=\"com.xrq.aop.TimeHandler\" />\n        <bean id=\"logHandler\" class=\"com.xrq.aop.LogHandler\" />\n        \n        <aop:config>\n            <aop:aspect id=\"time\" ref=\"timeHandler\" order=\"1\">\n                <aop:pointcut id=\"addTime\" expression=\"execution(* com.xrq.aop.HelloWorld.*(..))\" />\n                <aop:before method=\"printTime\" pointcut-ref=\"addTime\" />\n                <aop:after method=\"printTime\" pointcut-ref=\"addTime\" />\n            </aop:aspect>\n            <aop:aspect id=\"log\" ref=\"logHandler\" order=\"2\">\n                <aop:pointcut id=\"printLog\" expression=\"execution(* com.xrq.aop.HelloWorld.*(..))\" />\n                <aop:before method=\"LogBefore\" pointcut-ref=\"printLog\" />\n                <aop:after method=\"LogAfter\" pointcut-ref=\"printLog\" />\n            </aop:aspect>\n        </aop:config>\n</beans>\n```\n\n测试类不变，打印结果为：\n\n```shell\nCurrentTime = 1446130273734\nLog before method\nEnter HelloWorldImpl1.printHelloWorld()\nLog after method\nCurrentTime = 1446130273735\n\nCurrentTime = 1446130273736\nLog before method\nEnter HelloWorldImpl1.doPrint()\nLog after method\nCurrentTime = 1446130273736\n\nCurrentTime = 1446130273736\nLog before method\nEnter HelloWorldImpl2.printHelloWorld()\nLog after method\nCurrentTime = 1446130273736\n\nCurrentTime = 1446130273737\nLog before method\nEnter HelloWorldImpl2.doPrint()\nLog after method\nCurrentTime = 1446130273737\n```\n\n要想让logHandler在timeHandler前使用有两个办法：\n\n（1）aspect里面有一个order属性，order属性的数字就是横切关注点的顺序\n\n（2）把logHandler定义在timeHandler前面，Spring默认以aspect的定义顺序作为织入顺序\n\n2、我只想织入接口中的某些方法\n\n修改一下pointcut的expression就好了：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:aop=\"http://www.springframework.org/schema/aop\"\n    xmlns:tx=\"http://www.springframework.org/schema/tx\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd\n        http://www.springframework.org/schema/aop\n        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd\">\n        \n        <bean id=\"helloWorldImpl1\" class=\"com.xrq.aop.HelloWorldImpl1\" />\n        <bean id=\"helloWorldImpl2\" class=\"com.xrq.aop.HelloWorldImpl2\" />\n        <bean id=\"timeHandler\" class=\"com.xrq.aop.TimeHandler\" />\n        <bean id=\"logHandler\" class=\"com.xrq.aop.LogHandler\" />\n        \n        <aop:config>\n            <aop:aspect id=\"time\" ref=\"timeHandler\" order=\"1\">\n                <aop:pointcut id=\"addTime\" expression=\"execution(* com.xrq.aop.HelloWorld.print*(..))\" />\n                <aop:before method=\"printTime\" pointcut-ref=\"addTime\" />\n                <aop:after method=\"printTime\" pointcut-ref=\"addTime\" />\n            </aop:aspect>\n            <aop:aspect id=\"log\" ref=\"logHandler\" order=\"2\">\n                <aop:pointcut id=\"printLog\" expression=\"execution(* com.xrq.aop.HelloWorld.do*(..))\" />\n                <aop:before method=\"LogBefore\" pointcut-ref=\"printLog\" />\n                <aop:after method=\"LogAfter\" pointcut-ref=\"printLog\" />\n            </aop:aspect>\n        </aop:config>\n</beans>\n```\n\n表示timeHandler只会织入HelloWorld接口print开头的方法，logHandler只会织入HelloWorld接口do开头的方法\n\n测试aop其他几个标签\n\nLogHandler.java\n\n```java\npackage com.tutorialspoint.beans.SpringAOP.DynamicAOPPackage;\n\nimport org.aspectj.lang.ProceedingJoinPoint;\n\npublic class LogHandler {\n\n    public void LogBefore() {\n        System.out.println(\"Log before method\");\n    }\n\n    public void LogAfter() {\n        System.out.println(\"Log after method\");\n    }\n\n\n\n// 环绕通知 需要通过ProceedingJoinPoint 类型的参数指定增强执行的时机\n    public void round(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"方法执行前\");\n        // 执行增强的方法\n        joinPoint.proceed();\n        System.out.println(\"方法执行后\");\n    }\n\n    public void returning() {\n        System.out.println(\"after-returning\");\n    }\n\n    public void throwing() {\n        System.out.println(\"after-throwing\");\n    }\n}\n\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd\n        http://www.springframework.org/schema/aop\n        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd\">\n\n    <bean id=\"helloWorldImpl1\" class=\"com.tutorialspoint.beans.SpringAOP.DynamicAOPPackage.HelloWorldImpl1\" />\n    <bean id=\"helloWorldImpl2\" class=\"com.tutorialspoint.beans.SpringAOP.DynamicAOPPackage.HelloWorldImpl2\" />\n    <bean id=\"timeHandler\" class=\"com.tutorialspoint.beans.SpringAOP.DynamicAOPPackage.TimeHandler\" />\n    <bean id=\"logHandler\" class=\"com.tutorialspoint.beans.SpringAOP.DynamicAOPPackage.LogHandler\" />\n\n    <aop:config>\n\n        <aop:aspect id=\"time\" ref=\"timeHandler\" order=\"1\">\n            <aop:pointcut id=\"addAllMethod\"\n                  expression=\"execution(* com.tutorialspoint.beans.SpringAOP.DynamicAOPPackage.Hello.*(..))\"/>\n            <aop:before method=\"printTime\" pointcut-ref=\"addAllMethod\" />\n            <aop:after method=\"printTime\" pointcut-ref=\"addAllMethod\" />\n        </aop:aspect>\n\n        <aop:aspect id=\"log\" ref=\"logHandler\" order=\"2\">\n            <aop:pointcut\n                id=\"pringLog\"\n                expression=\"execution(* com.tutorialspoint.beans.SpringAOP.DynamicAOPPackage.Hello.*(..))\"/>\n            <aop:before method=\"LogBefore\" pointcut-ref=\"pringLog\"/>\n            <aop:after method=\"LogAfter\" pointcut-ref=\"pringLog\" />\n            <aop:around method=\"round\" pointcut-ref=\"pringLog\" />\n            <aop:after-returning method=\"returning\" pointcut-ref=\"pringLog\"/>\n            <aop:after-throwing method=\"throwing\" pointcut-ref=\"pringLog\"/>\n        </aop:aspect>\n\n    </aop:config>\n\n</beans>\n```\n\n执行\n\n```shell\nCurrentTime = 1610941059733\nLog before method\n方法执行前\nEnter HelloWorldImpl1.printHelloWorld() \nafter-returning\n方法执行后\nLog after method\nCurrentTime = 1610941059736\n...\n```\n\n补充:\n\n1. `execution`函数: 在通知中定义切入点, 通过`execution`函数, 可以定义切入点的方法切入\n2. 切入点: 就是增强切入点的方法\n3. 常用的表达式:\n   1. `excution(<访问类型>?<返回类型><方法名>(<参数>) <异常>)`\n   2. `excution(* com.test.bean.Book.wirteBook(..))`:　表示类Book里面的writeBook的方法\n   3. `execution(* com.test.bean.Book.*(..))`: 表示Book下的所有方法\n   4. `execution(* *.*(..))` : 表示所有\n   5. `execution(public *.*(..))`: 所有public的方法\n   6. `execution(* com.test.bean.*(..))`: 匹配指定路径下所有类的方法 ( 不包含子包 )\n   7. `execution(* com.test.bean..*(..))`: 匹配指定路径下所有类的方法（ 包含包，子包的所有类 ）\n   8. `execution(* com.test.bean.Book.*(..))`: 匹配指定类的所有方法\n   9. `execution(* com*(..))`: 匹配特定开头的方法\n4. 配置增强类型\n   1. `aop:before` : 前置通知, 指定增强的方法在切入点之前执行\n   2. `aop:after` : 后置通知, 指定增强方法在切入点之后执行\n   3. `aop:after-returning`: 最终通知, 无论增强方法之后异常都会执行\n   4. `aop:after-throwing` : 异常抛出通知, 指定增强的方法在出现异常时执行\n   5. `aop:around`: 环绕通知, 增强方法在切入点方法之前和之后都执行\n\n3、强制使用CGLIB生成代理\n\n前面说过Spring使用动态代理或是CGLIB生成代理是有规则的，高版本的Spring会自动选择是使用动态代理还是CGLIB生成代理内容，当然我们也可以强制使用CGLIB生成代理，那就是<aop:config>里面有一个\"proxy-target-class\"属性，这个属性值如果被设置为true，那么基于类的代理将起作用，如果proxy-target-class被设置为false或者这个属性被省略，那么基于接口的代理将起作用。\n\n### 注解式开发\n\nXML文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd\n        http://www.springframework.org/schema/aop\n        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\n// 组件扫描\n    <context:component-scan base-package=\"com.tutorialspoint.beans.SpringAOP.AOPAnnontation2\"/>\n// aop自动扫描  \n  <aop:aspectj-autoproxy/>\n\n</beans>\n```\n\n接口\n\n```java\npublic interface ITargetInterface {\n    public void save();\n}\n```\n\n实现类\n\n```java\npackage com.tutorialspoint.beans.SpringAOP.AOPAnnontation2;\n\nimport org.springframework.stereotype.Component;\n\n@Component(\"target\")\npublic class Target implements ITargetInterface{\n    @Override\n    public void save() {\n        System.out.println(\"save running...\");\n    }\n}\n\n```\n\n创建切面类\n\n```java\npackage com.tutorialspoint.beans.SpringAOP.AOPAnnontation2;\n\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.*;\nimport org.springframework.stereotype.Component;\n\n@Component(\"myAspect\")\n@Aspect\npublic class MyAspect {\n\n//    @Before(\"execution(* com.tutorialspoint.beans.SpringAOP.AOPAnnontation2.*.*(..))\")\n//    public void before(){\n//        System.out.println(\"before\");\n//    }\n//\n//    @AfterReturning(\"execution(* com.tutorialspoint.beans.SpringAOP.AOPAnnontation2.*.*(..))\")\n//    public void afterReturning() {\n//        System.out.println(\"afterReturning\");\n//    }\n//\n//    @Around(\"execution(* com.tutorialspoint.beans.SpringAOP.AOPAnnontation2.*.*(..))\")\n//    public Object around(ProceedingJoinPoint pjp) throws Throwable {\n//        System.out.println(\"around before\");\n//        Object proceed = pjp.proceed();\n//        System.out.println(\"around after\");\n//        return proceed;\n//    }\n//\n//    @AfterThrowing(\"execution(* com.tutorialspoint.beans.SpringAOP.AOPAnnontation2.*.*(..))\")\n//    public void afterThrowing() {\n//        System.out.println(\"throwing\");\n//    }\n//\n//    @After(\"execution(* com.tutorialspoint.beans.SpringAOP.AOPAnnontation2.*.*(..))\")\n//    public void after() {\n//        System.out.println(\"returning\");\n//    }\n\n    @Before(\"pointcut()\")\n    public void before(){\n        System.out.println(\"before\");\n    }\n\n    @AfterReturning(\"pointcut()\")\n    public void afterReturning() {\n        System.out.println(\"afterReturning\");\n    }\n\n    @Around(\"pointcut()\")\n    public Object around(ProceedingJoinPoint pjp) throws Throwable {\n        System.out.println(\"around before\");\n        Object proceed = pjp.proceed();\n        System.out.println(\"around after\");\n        return proceed;\n    }\n\n    @AfterThrowing(\"pointcut()\")\n    public void afterThrowing() {\n        System.out.println(\"throwing\");\n    }\n\n    @After(\"pointcut()\")\n    public void after() {\n        System.out.println(\"returning\");\n    }\n\n    @Pointcut(\"execution(* com.tutorialspoint.beans.SpringAOP.AOPAnnontation2.*.*(..))\")\n    public void pointcut(){}\n\n}\n```\n\n> @Pointcut注解定义切点表达式, 然后可以在增强注解中使用\n\n测试类\n\n```java\npackage com.tutorialspoint.beans.SpringAOP.AOPAnnontation2;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"classpath:aop-anno.xml\")\npublic class AnnoTest {\n\n    @Autowired\n    private ITargetInterface iTargetInterface;\n\n    @Test\n    public void test1(){\n        iTargetInterface.save();\n    }\n}\n```\n\n## Spring 基于注解的配置\n\n### @Required\n\n> 注释应用于 bean 属性的 setter 方法，它表明受影响的 bean 属性在配置时必须放在 XML 配置文件中，否则容器就会抛出一个 BeanInitializationException 异常\n\n### @Autowired\n\n> 自动装配\n\n@Autowired 注释应用于构造函数\n\n```java\npublic class MovieRecommender {\n \n    private final CustomerPreferenceDao customerPreferenceDao;\n \n    @Autowired\n    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {\n        this.customerPreferenceDao = customerPreferenceDao;\n    }\n \n    // ...\n}\n```\n\n@Autowired 注释应用于 setter 方法\n\n```java\npublic class SimpleMovieLister {\n \n    private MovieFinder movieFinder;\n \n    @Autowired\n    public void setMovieFinder(MovieFinder movieFinder) {\n        this.movieFinder = movieFinder;\n    }\n \n    // ...\n}\n```\n\n将 @Autowired 注释应用于具有任意名称和多个参数的方法\n\n```java\npublic class MovieRecommender {\n \n    private MovieCatalog movieCatalog;\n \n    private CustomerPreferenceDao customerPreferenceDao;\n \n    @Autowired\n    public void prepare(MovieCatalog movieCatalog,\n            CustomerPreferenceDao customerPreferenceDao) {\n        this.movieCatalog = movieCatalog;\n        this.customerPreferenceDao = customerPreferenceDao;\n    }\n \n    // ...\n}\n```\n\n @Autowired 注释应用于字段，或者将其与构造函数混合，如以下示例所示\n\n```java\npublic class MovieRecommender {\n \n    private final CustomerPreferenceDao customerPreferenceDao;\n \n    @Autowired\n    private MovieCatalog movieCatalog;\n \n    @Autowired\n    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {\n        this.customerPreferenceDao = customerPreferenceDao;\n    }\n \n    // ...\n}\n```\n\n直接应用于字段是我们使用的最多的一种方式，但是使用构造方法注入从代码层面却是更加好的。除此之外，还有以下不太常见的几种方式\n\n将 @Autowired 注释添加到需要该类型数组的字段或方法，则 Spring 会从 ApplicationContext 中搜寻符合指定类型的所有 bean，如以下示例所示：\n\n```java\npublic class MovieRecommender {\n \n    @Autowired\n    private MovieCatalog[] movieCatalogs;\n \n    // ...\n}\n```\n\n数组可以，我们可以马上举一反三，那容器也可以吗，答案是肯定的，下面是 set 以及 map 的例子：\n\n```java\npublic class MovieRecommender {\n \n    private Set<MovieCatalog> movieCatalogs;\n \n    @Autowired\n    public void setMovieCatalogs(Set<MovieCatalog> movieCatalogs) {\n        this.movieCatalogs = movieCatalogs;\n    }\n \n    // ...\n}\npublic class MovieRecommender {\n \n    private Map<String, MovieCatalog> movieCatalogs;\n \n    @Autowired\n    public void setMovieCatalogs(Map<String, MovieCatalog> movieCatalogs) {\n        this.movieCatalogs = movieCatalogs;\n    }\n \n    // ...\n}\n```\n\n以上就是 @Autowired 注释的主要使用方式，经常使用 Spring 的话应该对其中常用的几种不会感到陌生。\n\n### **@Qualifier**\n\n> 可能会有这样一种情况，当你创建多个具有相同类型的 bean 时，并且想要用一个属性只为它们其中的一个进行装配，在这种情况下，你可以使用 **@Qualifier** 注释和 **@Autowired** 注释通过指定哪一个真正的 bean 将会被装配来消除混乱\n\n```java\npublic class Profile {\n    @Autowired\n    @Qualifier(\"student1\")//对应xml中bean id为student1\n    private Student student;\n    public Profile() {\n        System.out.println(\"Inside Profile constructor\");\n    }\n    public void printAge(){\n        System.out.println(\"Age : \" + student.getAge() );\n    }\n    public void printName() {\n        System.out.println(\"Name: \" + student.getname() );\n    }\n}\n```\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:annotation-config></context:annotation-config>\n\n    <bean id=\"student\" class=\"com.tutorialspoint.beans.Annontation.Student\">\n        <property name=\"name\" value=\"grh\"/>\n        <property name=\"age\" value=\"11\"/>\n    </bean>\n    <bean id=\"student1\" class=\"com.tutorialspoint.beans.Annontation.Student\">\n        <property name=\"name\" value=\"grh2\"/>\n        <property name=\"age\" value=\"22\"/>\n    </bean>\n    <bean id=\"profile\" class=\"com.tutorialspoint.beans.Annontation.Profile\">\n    </bean>\n</beans>\n```\n\n```shell\nInside Profile constructor\nName: grh2\nAge : 22\n```\n\n### @PostConstruct 和 @PreDestroy\n\n> 这两个分别对应``init-method` 和 `destroy-method`\n>\n> 即bean的安装和卸载\n\n### @Resource\n\n> 使用一个'name'属性, 該属性以一个bean名称的形式被注入, 遵循by-name中自动连接语句\n\n```java\npackage com.tutorialspoint;\nimport javax.annotation.Resource;\npublic class TextEditor {\n   private SpellChecker spellChecker;\n   @Resource(name= \"spellChecker\")\n   public void setSpellChecker( SpellChecker spellChecker ){\n      this.spellChecker = spellChecker;\n   }\n   public SpellChecker getSpellChecker(){\n      return spellChecker;\n   }\n   public void spellCheck(){\n      spellChecker.checkSpelling();\n   }\n}\n```\n\n### @Configuration 和 @Bean 注解\n\n> **@Configuration** 的注解类表示这个类可以使用 Spring IoC 容器作为 bean 定义的来源。\n>\n> **@Bean** 注解告诉 Spring，一个带有 @Bean 的注解方法将返回一个对象，该对象应该被注册为在 Spring 应用程序上下文中的 bean。\n\n```java\npublic class HelloWorld {\n    private String message;\n    public void setMessage(String message){\n        this.message = message;\n    }\n    public void getMessage() {\n        System.out.println(\"Your message: \" + message);\n    }\n}\n```\n\n```java\npackage com.tutorialspoint.beans.Annontation;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class HelloWorldConfig {\n    @Bean\n    public HelloWorld helloWorld() {\n        return new HelloWorld();\n    }\n}\n\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:annotation-config></context:annotation-config>\n    <context:component-scan base-package=\"com.tutorialspoint.beans.Annontation\"/>\n\n</beans>\n```\n\nTest\n\n```java\nApplicationContext context = new ClassPathXmlApplicationContext(\"Annontation.xml\");\nHelloWorld helloWorld = context.getBean(HelloWorld.class);\nhelloWorld.setMessage(\"Hello World!\");\nhelloWorld.getMessage();\n```\n\n### @import\n\n> 允许从另一个配置类中加载@Bean定义\n\n```java\n@Configuration\npublic class ConfigA {\n   @Bean\n   public A a() {\n      return new A(); \n   }\n}\n```\n\n你可以在另一个 Bean 声明中导入上述 Bean 声明，如下所示：\n\n```java\n@Configuration\n@Import(ConfigA.class)\npublic class ConfigB {\n   @Bean\n   public B b() {\n      return new B(); \n   }\n}\n```\n\n现在，当实例化上下文时，不需要同时指定 ConfigA.class 和 ConfigB.class，只有 ConfigB 类需要提供，如下所示：\n\n```java\npublic static void main(String[] args) {\n   ApplicationContext ctx = \n   new AnnotationConfigApplicationContext(ConfigB.class);\n   // now both beans A and B will be available...\n   A a = ctx.getBean(A.class);\n   B b = ctx.getBean(B.class);\n}\n```\n\n> 注意这里的`ApplicationContext ctx =\n> new AnnotationConfigApplicationContext(ConfigB.class);`\n\n### 生命周期回调@Bean(initMethod = \"\", destroyMethod = \"\")\n\n> @Bean 注解支持指定任意的初始化和销毁的回调方法，就像在 bean 元素中 Spring 的 XML 的初始化方法和销毁方法的属性：\n\n```java\npublic class Foo {\n   public void init() {\n      // initialization logic\n   }\n   public void cleanup() {\n      // destruction logic\n   }\n}\n\n@Configuration\npublic class AppConfig {\n   @Bean(initMethod = \"init\", destroyMethod = \"cleanup\" )\n   public Foo foo() {\n      return new Foo();\n   }\n}\n```\n\n指定 Bean 的范围：\n\n默认范围是单实例，但是你可以重写带有 @Scope 注解的该方法，如下所示：\n\n```java\n@Configuration\npublic class AppConfig {\n   @Bean\n   @Scope(\"prototype\")\n   public Foo foo() {\n      return new Foo();\n   }\n}\n```\n\n### @Primary\n\n> 对于同一个接口, 可能有几种不同的实现类, 而默认只会采取其中一种情况下 @Primary 的作用就出来了\n>\n> 自动装配时当出现多个Bean候选者时, 被注解为@Primary将作为首选者, 否则将会抛出异常\n\n## 事件处理\n\n> - Spring核心是ApplicationContext,负责调用beans的生命周期\n>\n> - Spring的时间处理是单线程的, 所有如果一个时间被发布 , 直至并且除非所有的接收者得到的该消息, 该进程被阻塞并且流程将不会继续\n\n| 事件名                    | Spring 内置事件 & 描述                                       |\n| ------------------------- | ------------------------------------------------------------ |\n| **ContextRefreshedEvent** | ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在 ConfigurableApplicationContext 接口中使用 refresh() 方法来发生。 |\n| **ContextStartedEvent**   | 当使用 ConfigurableApplicationContext 接口中的 start() 方法启动 ApplicationContext 时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。 |\n| **ContextStoppedEvent**   | 当使用 ConfigurableApplicationContext 接口中的 stop() 方法停止 ApplicationContext 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作。 |\n| **ContextClosedEvent**    | 当使用 ConfigurableApplicationContext 接口中的 close() 方法关闭 ApplicationContext 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启。 |\n| **RequestHandledEvent**   | 这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。 |\n\n#### 监听上下文事件\n\n```java\npackage com.tutorialspoint;\npublic class HelloWorld {\n   private String message;\n   public void setMessage(String message){\n      this.message  = message;\n   }\n   public void getMessage(){\n      System.out.println(\"Your Message : \" + message);\n   }\n}\n```\n\n下面是 **CStartEventHandler.java** 文件的内容：\n\n```java\npackage com.tutorialspoint;\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.context.event.ContextStartedEvent;\npublic class CStartEventHandler \n   implements ApplicationListener<ContextStartedEvent>{\n   public void onApplicationEvent(ContextStartedEvent event) {\n      System.out.println(\"ContextStartedEvent Received\");\n   }\n}\n```\n\n下面是 **CStopEventHandler.java** 文件的内容：\n\n```java\npackage com.tutorialspoint;\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.context.event.ContextStoppedEvent;\npublic class CStopEventHandler \n   implements ApplicationListener<ContextStoppedEvent>{\n   public void onApplicationEvent(ContextStoppedEvent event) {\n      System.out.println(\"ContextStoppedEvent Received\");\n   }\n}\n```\n\n下面是 **MainApp.java** 文件的内容：\n\n```java\npackage com.tutorialspoint;\n\nimport org.springframework.context.ConfigurableApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class MainApp {\n   public static void main(String[] args) {\n      ConfigurableApplicationContext context = \n      new ClassPathXmlApplicationContext(\"Beans.xml\");\n\n      // Let us raise a start event.\n      context.start();\n\n      HelloWorld obj = (HelloWorld) context.getBean(\"helloWorld\");\n\n      obj.getMessage();\n\n      // Let us raise a stop event.\n      context.stop();\n   }\n}\n```\n\n下面是配置文件 **Beans.xml** 文件：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\">\n\n   <bean id=\"helloWorld\" class=\"com.tutorialspoint.HelloWorld\">\n      <property name=\"message\" value=\"Hello World!\"/>\n   </bean>\n\n   <bean id=\"cStartEventHandler\" \n         class=\"com.tutorialspoint.CStartEventHandler\"/>\n\n   <bean id=\"cStopEventHandler\" \n         class=\"com.tutorialspoint.CStopEventHandler\"/>\n\n</beans>\n```\n\n一旦你完成了创建源和 bean 的配置文件，我们就可以运行该应用程序。如果你的应用程序一切都正常，将输出以下消息：\n\n```shell\nContextStartedEvent Received\nYour Message : Hello World!\nContextStoppedEvent Received\n```\n\n## 自定义事件\n\n> 编写和发布自定义事件\n\n**CustomEvent.java**\n\n```java\npackage com.tutorialspoint;\nimport org.springframework.context.ApplicationEvent;\npublic class CustomEvent extends ApplicationEvent{ \n   public CustomEvent(Object source) {\n      super(source);\n   }\n   public String toString(){\n      return \"My Custom Event\";\n   }\n}\n```\n\n下面是 **CustomEventPublisher.java** 文件的内容：\n\n```java\npackage com.tutorialspoint;\nimport org.springframework.context.ApplicationEventPublisher;\nimport org.springframework.context.ApplicationEventPublisherAware;\npublic class CustomEventPublisher \n   implements ApplicationEventPublisherAware {\n   private ApplicationEventPublisher publisher;\n   public void setApplicationEventPublisher\n              (ApplicationEventPublisher publisher){\n      this.publisher = publisher;\n   }\n   public void publish() {\n      CustomEvent ce = new CustomEvent(this);\n      publisher.publishEvent(ce);\n   }\n}\n```\n\n下面是 **CustomEventHandler.java** 文件的内容：\n\n```java\npackage com.tutorialspoint;\nimport org.springframework.context.ApplicationListener;\npublic class CustomEventHandler \n   implements ApplicationListener<CustomEvent>{\n   public void onApplicationEvent(CustomEvent event) {\n      System.out.println(event.toString());\n   }\n}\n```\n\n下面是 **MainApp.java** 文件的内容：\n\n```java\npackage com.tutorialspoint;\nimport org.springframework.context.ConfigurableApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\npublic class MainApp {\n   public static void main(String[] args) {\n      ConfigurableApplicationContext context = \n      new ClassPathXmlApplicationContext(\"Beans.xml\");    \n      CustomEventPublisher cvp = \n      (CustomEventPublisher) context.getBean(\"customEventPublisher\");\n      cvp.publish();  \n      cvp.publish();\n   }\n}\n```\n\n下面是配置文件 **Beans.xml**：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\">\n\n   <bean id=\"customEventHandler\" \n      class=\"com.tutorialspoint.CustomEventHandler\"/>\n\n   <bean id=\"customEventPublisher\" \n      class=\"com.tutorialspoint.CustomEventPublisher\"/>\n\n</beans>\n```\n\n一旦你完成了创建源和 bean 的配置文件后，我们就可以运行该应用程序。如果你的应用程序一切都正常，将输出以下信息：\n\n```shell\nMy Custom Event\nMy Custom Event\n```\n","children":[]},{"name":"SpringMVC.md","path":"../guanruihua.github.io/Back-End/Spring/ssm","data":"# SpringMVC\n\n> - [Spring官网](https://spring.io/)\n> - [SpringMVC](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web.html)\n> - Spring体系的轻量级web mvc框架\n> - 核心Controller控制器, 用于处理请求, 产生响应\n> - 基于SpringIOC容器运行, 所有对象被IOC管理\n> - MVC\n>   - M: 模型封装应用数据, 通常他们由pojo组成\n>   - V: 呈现数据模型, 并且通常由它生成客户端的浏览器可以解释的HTML输出\n>   - C: 控制器主要用于处理用户请求, 并且构建合适的模型并将其传递到视图呈现\n\n版本变化\n\n> Spring 5.x最低要求JDK8余J2EE 7(Servlet 3.1 / Tomcat 8.5+)\n>\n> 支持响应式编程\n\n## DispatchServlet\n\n> - Spring Web 的mvc模型是围绕dispatcherServlet设计的, dispatcherServlet用来处理所有http请求和响应\n>\n> - Spring MVC DispatcherServlet 请求的工作流程\n>   - 收到一个http请求后, dispatcherServlet根据HanderMapping 来选择适当的控制器\n>   - 控制器接收请求, 并基于使用的get或post方法来调用service方法, service方法将设置基于业务逻辑的模型数据, 并返回视图名称到dispatcherServlet中\n>   - dispatcherServlet 会用viewResolver获取帮助, 为请求检取定义视图\n>   - 一旦确定思路, dispatcherServlet 将把模型数据传输给视图, 最后呈现在浏览器中\n\n## 入门\n\n### 环境搭建\n\n#### Maven依赖spring-webmvc\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>org.example</groupId>\n    <artifactId>SpringMVC_DEMO1</artifactId>\n    <version>1.0-SNAPSHOT</version>\n<!--    添加阿里云的镜像路径, 方便下载依赖-->\n    <repositories>\n        <repository>\n            <id>aliyun</id>\n            <name>aliyun</name>\n            <url>https://maven.aliyun.com/repository/public</url>\n        </repository>\n    </repositories>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-webmvc</artifactId>\n            <version>5.1.9.RELEASE</version>\n        </dependency>\n    </dependencies>\n</project>\n```\n\n#### web.xml配置DispatcherServlet\n\n#### 配置applicationContext的mvc标记\n\n#### 开发Controller控制器\n\n## 数据绑定\n\n## Restful开发风格\n\n## 拦截器\n","children":[]},{"name":"ssm.md","path":"../guanruihua.github.io/Back-End/Spring/ssm","data":"# SSM\n\n## ssm controller 绑定参数 根据url 读取参数\n\n> -\n> - 通过URL路径传递参数并接收\n\n```java\n@RequestMapping(value=\"/path/{key}/{value}\", method=RequestMethod.POST)\n@ResponseBody\npublic String requestPath(@PathVariable String key, @PathVariable String value) {\n    return \"Get request is successful. Path param : key - \" + key + \"; value - \" + value;\n}\n```\n","children":[]}]}]},{"name":"_sidebar.md","path":"../guanruihua.github.io/Back-End","data":"* C语言\n  * C++\n    * [C++basic](C语言/C++/C++basic.md)\n* [GoLang](GoLang/index.md)\n  * [home](GoLang/index.md)\n* Java\n  * [java-basis](Java/java-basis.md)\n  * [java-Collection](Java/java-Collection.md)\n  * [java-expand](Java/java-expand.md)\n  * java8\n    * [lambda](Java/java8/lambda.md)\n  * [VO_DTO_Entity](Java/VO_DTO_Entity.md)\n  * [线程](Java/线程.md)\n* Spring\n  * [maven](Spring/maven.md)\n  * question\n    * [ssm跨域](Spring/question/ssm跨域.md)\n    * [tomcat](Spring/question/tomcat.md)\n  * [Shiro](Spring/Shiro.md)\n  * [Spring-Boot-annotations](Spring/Spring-Boot-annotations.md)\n  * [SpringJDBC](Spring/SpringJDBC.md)\n  * [Spring相关](Spring/Spring相关.md)\n  * ssm\n    * [log4j](Spring/ssm/log4j.md)\n    * [spring](Spring/ssm/spring.md)\n    * [SpringMVC](Spring/ssm/SpringMVC.md)\n    * [ssm](Spring/ssm/ssm.md)\n","children":[]}]},{"name":"config","path":"../guanruihua.github.io","data":"","children":[{"name":"build","path":"../guanruihua.github.io/config","data":"","children":[{"name":"build-sidebar-lv1.js","path":"../guanruihua.github.io/config/build","data":"const fs = require('fs')\r\nconst { toArray, isDir } = require('./util')\r\n\r\nfunction write(path, index = 0) {\r\n\r\n\tconst indexSpaces = new Array(index).fill('  ').join('')\r\n\tconst dirs = toArray(fs.readdirSync(path, 'utf-8'))\r\n\t\t.map(item => {\r\n\t\t\tconst newPath = path + '/' + item\r\n\t\t\tlet content = item\r\n\t\t\tif (content.indexOf('.md') > -1) {\r\n\r\n\t\t\t\tcontent = `[${content.replace('.md', '')}](${newPath.replace('./', '')})`\r\n\t\t\t}\r\n\t\t\tconst nextContent = isDir(newPath) ? write(newPath, index + 1) : ''\r\n\t\t\treturn `${indexSpaces}* ${content}\\n${nextContent}`\r\n\t\t})\r\n\r\n\treturn dirs.join('')\r\n}\r\n\r\nfs.writeFileSync('./_sidebar.md', write('./', 0))\r\n","children":[]},{"name":"build-sidebar-lv2.js","path":"../guanruihua.github.io/config/build","data":"const fs = require('fs')\r\nconst { toArray, isDir } = require('./util')\r\n\r\nfunction write(path, index = 0, lv = 0) {\r\n\tconst indexSpaces = new Array(index).fill('  ').join('')\r\n\tconst dirs = toArray(fs.readdirSync(path, 'utf-8'))\r\n\t\t.map(item => {\r\n\t\t\tif (index === 0 && lv === 0) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst _path = path + item + '/index.html'\r\n\t\t\t\t\t// fs.copyFile('./config/README.md', path + item + '/README.md', (err) => {\r\n\t\t\t\t\t// \terr && console.log(err)\r\n\t\t\t\t\t// });\r\n\t\t\t\t\tconst __index__html = fs.readFileSync('./config/index.html')\r\n\t\t\t\t\tfs.writeFileSync(_path, __index__html.toString().replace('__ruihuag__website__name__', `__ruihuag__website__${item}__`))\r\n\t\t\t\t\t// fs.copyFile('./config/index.html', _path, (err) => {\r\n\t\t\t\t\t// \terr && console.log(err)\r\n\t\t\t\t\t// })\r\n\r\n\t\t\t\t\tfs.writeFileSync(\r\n\t\t\t\t\t\t`./${item}/_sidebar.md`,\r\n\t\t\t\t\t\twrite(path + item, 0, 1)\r\n\t\t\t\t\t\t\t.replaceAll(`](${item}/`, '](')\r\n\t\t\t\t\t)\r\n\t\t\t\t} catch (error) {\r\n\t\t\t\t\tconsole.error(error)\r\n\t\t\t\t}\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tconst newPath = path + '/' + item\r\n\t\t\tconst isDirStatus = isDir(newPath)\r\n\t\t\tconst _newPath = newPath.replace('./', '')\r\n\t\t\tlet nextContent = ''\r\n\t\t\tconst newDirs = isDirStatus ? toArray(fs.readdirSync(newPath, 'utf-8')) : []\r\n\t\t\tconst nextLvHasIndexMd = newDirs.includes('index.md')\r\n\t\t\tlet content = item\r\n\r\n\t\t\t// 判断下级时候有index.md 文件\r\n\t\t\tif (item.indexOf('index.md') > -1) {\r\n\t\t\t\t// return;\r\n\t\t\t}\r\n\r\n\t\t\tif (nextLvHasIndexMd) {\r\n\t\t\t\tcontent = `[${item}](${_newPath}/index.md)`\r\n\t\t\t} else if (content.indexOf('.md') > -1) {\r\n\t\t\t\tcontent = `[${content.replace('.md', '').replace('index', 'home')}](${_newPath})`\r\n\t\t\t}\r\n\r\n\t\t\tif (isDirStatus) {\r\n\t\t\t\tnextContent = write(newPath, index + 1)\r\n\t\t\t}\r\n\t\t\treturn `${indexSpaces}* ${content}\\n${nextContent}`\r\n\t\t}).filter(Boolean)\r\n\r\n\treturn dirs.join('')\r\n}\r\n\r\nwrite('./', 0)","children":[]},{"name":"build-sidebar-OpenSource.js","path":"../guanruihua.github.io/config/build","data":"const fs = require('fs')\r\nconst { toArray, isDir } = require('./util')\r\n\r\nconst openSourceList = ['abandonjs']\r\n\r\n// 复制 index.html 文件\r\nfunction copyHtml(list = []) {\r\n\tlist.forEach(unit => {\r\n\t\tfs.copyFile('./config/index.html', `./OpenSource/${unit}/index.html`, (err) => {\r\n\t\t\terr && console.log(err)\r\n\t\t})\r\n\t})\r\n}\r\n\r\nfunction readDirStructure(path, index = 0) {\r\n\tconst indexSpaces = new Array(index).fill('  ').join('')\r\n\tconst dirs = toArray(fs.readdirSync(path, 'utf-8'))\r\n\tconst result = dirs.map(unit => {\r\n\t\tlet template = `${indexSpaces}* ${unit}`\r\n\t\tconst newPath = path + '/' + unit\r\n\t\tconst isDirStatus = isDir(newPath)\r\n\t\tif (!isDirStatus) {\r\n\t\t\ttemplate = `${indexSpaces}* [${unit.replace('.md', '')}](${newPath})`\r\n\t\t}\r\n\t\tif (isDirStatus) {\r\n\t\t\ttemplate += '\\n' + readDirStructure(newPath, index + 1)\r\n\t\t}\r\n\r\n\t\treturn template\r\n\t}).join('\\n')\r\n\t// dirs.map()\r\n\t// console.log(dirs)\r\n\treturn result\r\n}\r\n\r\nfunction buildSidebar(path) {\r\n\tfs.writeFileSync(\r\n\t\t`./${path}/_sidebar.md`,\r\n\t\treadDirStructure(path).replaceAll('](' + path + '/', '](')\r\n\t)\r\n}\r\n\r\ncopyHtml(openSourceList)\r\nbuildSidebar('./OpenSource/abandonjs')","children":[]},{"name":"getPackageDocs.js","path":"../guanruihua.github.io/config/build","data":"const fs = require('fs')\r\n\r\nfunction getPackageDocs(){\r\n\tconst packageData = fs.readFileSync('../fakingjs/README.md').toString()\r\n\tfs.copyFileSync('../fakingjs/README.md', './OpenSource/fakingjs/index.md')\r\n\r\n\t// console.log(packageData)\r\n}\r\n\r\ngetPackageDocs()","children":[]},{"name":"update-module.js","path":"../guanruihua.github.io/config/build","data":"const fs = require('fs')\r\nconst { toArray } = require('./util')\r\n\r\nconst modules = toArray(fs.readdirSync('./', 'utf-8'))\r\nfs.writeFileSync(`./config/_modules_.js`, 'const modules =' + JSON.stringify(modules))","children":[]},{"name":"util.js","path":"../guanruihua.github.io/config/build","data":"const fs = require('fs')\r\n\r\nconst ignoreDir = [\r\n\t'_modules_.js',\r\n\t'.git', '.gitignore',\r\n\t'.nojekyll', '.prettierrc',\r\n\t'blog', 'config',\r\n\t'index.html',\r\n\t'home.html',\r\n\t'package.json',\r\n\t'Pending.md','log.md',\r\n\t'push.bat', 'README.md',\r\n\t'temp-note.md', '_sidebar.md',\r\n\t'__assets__', 'bar.md', '.keep', 'blog'\r\n]\r\n\r\nfunction toArray(params, ignore = ignoreDir) {\r\n\tif (Array.isArray(params)) return params.filter(i => {\r\n\t\tif (i.indexOf('.assets') > -1) return false\r\n\t\tif (i.indexOf('.jpg') > -1) return false\r\n\t\treturn !ignore.includes(i)\r\n\t})\r\n\treturn [params].filter(Boolean)\r\n}\r\n\r\n\r\nfunction isDir(url) {\r\n\treturn fs.lstatSync(url).isDirectory();// true || false 判断是不是文件夹\r\n}\r\n\r\nmodule.exports = { toArray, isDir }","children":[]}]},{"name":"css","path":"../guanruihua.github.io/config","data":"","children":[{"name":"content.css","path":"../guanruihua.github.io/config/css","data":".content {\r\n  box-sizing: border-box;\r\n  width: 100%;\r\n  margin-bottom: 2rem;\r\n}\r\n\r\n.content>div {\r\n  margin: 1rem;\r\n  padding-top: 1rem;\r\n  padding-bottom: 4rem;\r\n  border-radius: 1rem;\r\n  position: relative;\r\n\r\n}\r\n\r\n.search-content {\r\n  margin: auto;\r\n  max-width: 95%;\r\n  width: 20rem;\r\n  background: transparent;\r\n  border-top-left-radius: 1rem;\r\n  border-top-right-radius: 1rem;\r\n  padding: .4rem .5rem 0;\r\n  position: absolute;\r\n  left: 0;\r\n  right: 0;\r\n  bottom: 1rem;\r\n  z-index: 99;\r\n}\r\n\r\n.search-content.is-search>.search-options {\r\n  position: absolute;\r\n  left: 0;\r\n  right: 0;\r\n  padding: 0 .5rem .4rem;\r\n  background: rgba(255, 255, 255, 0.2);\r\n\r\n  border-bottom-left-radius: 1rem;\r\n  border-bottom-right-radius: 1rem;\r\n}\r\n\r\n.search-options>div {\r\n  line-height: 3rem;\r\n  border-bottom: 1px solid #fff;\r\n  height: 3rem;\r\n  cursor: pointer;\r\n  font-weight: bold;\r\n  background-color: rgba(255, 255, 255, 0.521);\r\n  justify-content: start;\r\n  align-items: center;\r\n  gap: 10px;\r\n  display: none;\r\n}\r\n\r\n.search-options>div>div.name {\r\n  text-overflow: ellipsis;\r\n  white-space: nowrap;\r\n  width: 75%;\r\n  overflow: hidden;\r\n  text-align: start;\r\n}\r\n\r\n.search-options>div>div.logo {\r\n  margin-left: 20px;\r\n  width: 28px;\r\n  height: 28px;\r\n}\r\n\r\n.search-content.is-search .search-options>div {\r\n  display: flex;\r\n\r\n}\r\n\r\n.search-options>div:hover {\r\n  color: rgba(49, 49, 49, 0.692);\r\n}\r\n\r\n.search-options>div:first-child {\r\n  margin-top: .6rem;\r\n  border-top-left-radius: 1rem;\r\n  border-top-right-radius: 1rem;\r\n}\r\n\r\n.search-options>div:last-child {\r\n  border: none;\r\n  border-bottom-left-radius: 1rem;\r\n  border-bottom-right-radius: 1rem;\r\n}\r\n\r\n.search-content.is-search {\r\n  background: rgba(255, 255, 255, 0.2);\r\n}\r\n\r\n.search {\r\n  border: none;\r\n  outline-style: none;\r\n  border-radius: 1rem;\r\n  width: 100%;\r\n  height: 2.2rem;\r\n  background: rgba(255, 255, 255, 0.4);\r\n  padding: .5rem .75rem;\r\n  font-size: 1rem;\r\n}","children":[]},{"name":"index.css","path":"../guanruihua.github.io/config/css","data":"/* @font-face {\r\n  font-family: 'Smiley Sans';\r\n  src: url('/__assets__/font/Smiley-Sans-v1-0-0/SmileySans-Oblique.otf.woff2');\r\n} */\r\n\r\n* {\r\n  margin: 0;\r\n  padding: 0;\r\n  box-sizing: border-box;\r\n  /* font-family: 'Smiley Sans'; */\r\n}\r\n\r\n*::-webkit-scrollbar {\r\n  width: 1px;\r\n}\r\n\r\n*::-webkit-scrollbar-thumb {\r\n  border-radius: 8px;\r\n  box-shadow: inset 0 0 1px rgba(0, 0, 0, 0.2);\r\n  background: rgba(0, 0, 0, 0.2);\r\n}\r\n\r\n*::-webkit-scrollbar-track {\r\n  box-shadow: inset 0 0 1px rgba(0, 0, 0, 0.2);\r\n  border-radius: 8px;\r\n  background: rgba(0, 0, 0, 0.1);\r\n}\r\n\r\na,\r\ninput {\r\n  display: block;\r\n}\r\n\r\nimg,\r\nsvg {\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n\r\ndiv {\r\n  text-align: center;\r\n}\r\n\r\nbody {\r\n  width: 100vw;\r\n  font-family: fangsong;\r\n  font-weight: bold;\r\n  min-height: 100vh;\r\n  overflow-x: hidden;\r\n  background-color: #0d111f;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n}","children":[]},{"name":"lv2","path":"../guanruihua.github.io/config/css","data":"","children":[{"name":"styles.css","path":"../guanruihua.github.io/config/css/lv2","data":":root {\r\n  --icon-size: 16px;\r\n  --border-radius: 8px;\r\n}\r\n\r\n\r\n\r\nimg {\r\n  border-radius: var(--border-radius);\r\n}\r\n\r\nbutton.docsify-copy-code-button {\r\n  height: 20px;\r\n  display: flex;\r\n  font-size: .5rem;\r\n  padding: 0 .6rem;\r\n  border-top-right-radius: var(--border-radius);\r\n  border-bottom-left-radius: var(--border-radius);\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n\r\nsection.content>aside.toc-nav {\r\n  /* background-color: red; */\r\n  margin-right: 5px;\r\n  width: auto;\r\n  min-width: 150px;\r\n  max-width: 220px;\r\n}\r\n\r\n.toc-nav.nothing {\r\n  display: none;\r\n}\r\n\r\n/* .toc-nav+.markdown-section {\r\n  margin-right: 260px;\r\n} */\r\n\r\n.toc-nav.nothing+.markdown-section {\r\n  margin-right: 0;\r\n}\r\n\r\ndiv.expand-btns {\r\n  position: fixed;\r\n  left: 34px;\r\n  bottom: 6px;\r\n}\r\n\r\n.expand-btns>a>img {\r\n  width: 20px;\r\n  height: 20px;\r\n}\r\n\r\n.expand-btns>a {\r\n  text-decoration: none;\r\n}\r\n\r\n.expand-btns>button {\r\n  border: none;\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n\r\ndiv.pagination-item-title {\r\n  margin-top: 5px;\r\n  font-size: 1.2em;\r\n}\r\n\r\nsection>aside.toc-nav {\r\n  position: fixed;\r\n  top: 70px;\r\n  right: 0;\r\n  margin-right: 20px;\r\n  width: 250px;\r\n  z-index: 999999;\r\n  align-self: flex-start;\r\n  flex: 0 0 auto;\r\n  overflow-y: auto;\r\n  max-height: 95%;\r\n}\r\n\r\n@media screen and (max-width: 1300px) {\r\n\r\n  section>aside.toc-nav {\r\n    display: none;\r\n  }\r\n\r\n  .toc-nav+.markdown-section {\r\n    margin-right: 0;\r\n  }\r\n}\r\n\r\n\r\n\r\nbody,\r\n.sidebar ul li a {\r\n  font-family: fangsong;\r\n  font-weight: bold;\r\n}\r\n\r\n.sidebar-nav li.folder {\r\n  padding-left: 20px;\r\n  position: relative;\r\n}\r\n\r\n.sidebar-nav li.folder::before {\r\n  content: '';\r\n  position: absolute;\r\n  width: var(--icon-size);\r\n  height: var(--icon-size);\r\n  left: -3px;\r\n  top: 5px;\r\n  margin: auto;\r\n  background-image: url(/__assets__/folder.png);\r\n  background-repeat: no-repeat;\r\n  background-size: contain;\r\n}\r\n\r\n.sidebar-nav li.folder.open::before {\r\n  background-image: url(/__assets__/opened_folder.png);\r\n}\r\n\r\n.sidebar-nav li.file {\r\n  padding-left: 20px;\r\n  position: relative;\r\n}\r\n\r\n.folder>ul {\r\n  margin-left: -15px;\r\n}\r\n\r\n.file.open>ul.app-sub-sidebar.open {\r\n  margin-left: -15px;\r\n}\r\n\r\n.sidebar-nav li.file::before {\r\n  content: '';\r\n  position: absolute;\r\n  width: var(--icon-size);\r\n  height: var(--icon-size);\r\n  left: -3px;\r\n  top: 5px;\r\n  margin: auto;\r\n  background-image: url(/__assets__/file.png);\r\n  background-repeat: no-repeat;\r\n  background-size: contain;\r\n}\r\n\r\n.sidebar-nav li.file.open::before {\r\n  background-image: url(/__assets__/file.png);\r\n}\r\n\r\n\r\n\r\nul.app-sub-sidebar li.file,\r\nul.app-sub-sidebar li.file.open::before,\r\nul.app-sub-sidebar li.file::before {\r\n  content: '';\r\n  padding-left: 0;\r\n  background-image: none;\r\n}\r\n\r\n.file>.app-sub-sidebar {\r\n  margin-left: 0;\r\n}\r\n\r\n.file>.app-sub-sidebar>li.file {\r\n  padding-left: 25px;\r\n  counter-increment: num;\r\n}\r\n\r\n.file>.app-sub-sidebar>li.file.open::before,\r\n.file>.app-sub-sidebar>li.file::before {\r\n  content: counter(num);\r\n  top: 1px;\r\n  padding-left: 0px;\r\n  background-image: none;\r\n  left: 6px;\r\n  top: -1px;\r\n}\r\n\r\n.file>.app-sub-sidebar>li.file.open.active::before {\r\n  color: var(--theme-color, #42b983);\r\n}\r\n\r\nul+.folder.open {\r\n  background-color: #eee;\r\n  padding-left: 4px;\r\n  border-top-left-radius: 4px;\r\n  border-bottom-left-radius: 4px;\r\n}\r\n\r\nul.open>li.file.active {\r\n  background-color: rgba(238, 238, 238, 0.74);\r\n  border-top-left-radius: 4px;\r\n  border-bottom-left-radius: 4px;\r\n\r\n}\r\n\r\nbutton.sidebar-toggle {\r\n  background: #eee;\r\n  opacity: 0.7;\r\n  width: 120px;\r\n  border-top-right-radius: 12px;\r\n}\r\n\r\n*::-webkit-scrollbar {\r\n  width: 1px;\r\n}\r\n\r\n*::-webkit-scrollbar-thumb {\r\n  border-radius: 8px;\r\n}\r\n\r\n*::-webkit-scrollbar-track {\r\n  border-radius: 8px;\r\n}\r\n\r\n.markdown-section figure,\r\n.markdown-section p {\r\n  margin: .4rem 0;\r\n}\r\n\r\n.markdown-section code,\r\n.markdown-section pre {\r\n  white-space: pre-wrap;\r\n  /* background-color: #eee; */\r\n  /* background-color: red; */\r\n}\r\n\r\nbutton.sidebar-toggle {\r\n  position: fixed;\r\n  left: 0;\r\n  bottom: 0;\r\n  background: transparent;\r\n}\r\n\r\n.sidebar,\r\ninput[type='search'] {\r\n  background: transparent;\r\n}\r\n\r\n.markdown-section pre {\r\n  padding: 0;\r\n  margin: 0;\r\n  border-radius: 8px;\r\n}\r\n\r\n.markdown-section pre>code {\r\n  padding: 0;\r\n  margin: 0;\r\n}\r\n\r\n.markdown-section>:not(h1):not(h2):not(h3):not(h4):not(h5):not(h6) code {\r\n  padding-left: 8px;\r\n}\r\n\r\n.markdown-section blockquote {\r\n  padding-left: 10px;\r\n}\r\n\r\n.markdown-section pre>code {\r\n  padding: 4px 0;\r\n}\r\n\r\n.sidebar {\r\n  padding: 0;\r\n}\r\n\r\ndiv.search {\r\n  border-bottom: 1px solid rgba(238, 238, 238, 0.185);\r\n}\r\n\r\n.folder {\r\n  cursor: pointer;\r\n}\r\n\r\n.markdown-section {\r\n  overflow-y: auto;\r\n  max-width: 98%;\r\n  background-color: rgba(255, 255, 255, .4);\r\n  padding-top: 0;\r\n}\r\n\r\n.content {\r\n  padding-top: 5px;\r\n  margin-top: 1rem;\r\n}\r\n\r\n\r\n.markdown-section>div:first-child {\r\n  margin-right: 85px;\r\n}\r\n\r\ns body {\r\n  background: transparent;\r\n  /* background-color: rgb(225, 225, 225); */\r\n}","children":[]}]},{"name":"modules-content.css","path":"../guanruihua.github.io/config/css","data":".modules-content-layout {\r\n  display: flex;\r\n  justify-content: center;\r\n  text-align: center;\r\n  width: 100%;\r\n  padding-top: 1rem;\r\n\r\n}\r\n\r\n.modules-content {\r\n  white-space: nowrap;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  display: grid;\r\n  width: 100%;\r\n  grid-template-columns: repeat(auto-fill, 14rem);\r\n  gap: 1rem 1rem;\r\n\r\n}\r\n\r\n.modules-content>div {\r\n  color: #eee;\r\n  background-color: #c9c9c934;\r\n  border-radius: 12px;\r\n  text-align: center;\r\n  position: relative;\r\n  font-variant: 3;\r\n  font-family: fantasy;\r\n  cursor: pointer;\r\n  font-weight: lighter;\r\n}\r\n\r\n:root {\r\n  --item-logo-size: 1.7rem;\r\n}\r\n\r\n.modules-content .logo {\r\n  position: absolute;\r\n  left: 1rem;\r\n  top: .5rem;\r\n  width: var(--item-logo-size);\r\n  height: var(--item-logo-size);\r\n  padding: .5rem;\r\n  border-radius: 6px;\r\n  background-color: #c9c9c94a;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n\r\n.modules-content .msg {\r\n  width: 100%;\r\n  height: 7.5rem;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  color: #eee;\r\n}\r\n\r\n.modules-content .msg .tag {\r\n  margin-top: 5px;\r\n  display: inline-block;\r\n  width: 4.5rem;\r\n}\r\n\r\n.modules-content .content:hover {\r\n  background-color: #c9c9c91f;\r\n}\r\n\r\n.modules-content .content:hover .msg {\r\n  color: #fff;\r\n  font-size: large;\r\n  font-family: fantasy;\r\n}\r\n\r\na {\r\n  text-decoration: none;\r\n}\r\n\r\n.content .logo.unit {\r\n  background: none;\r\n  display: block;\r\n  position: absolute;\r\n  width: auto;\r\n  height: auto;\r\n  box-sizing: border-box;\r\n  padding: 0;\r\n}\r\n\r\n.content .logo.unit a {\r\n  margin-right: .25rem;\r\n  display: inline-block;\r\n  width: var(--item-logo-size);\r\n  height: var(--item-logo-size);\r\n}","children":[]}]},{"name":"README.md","path":"../guanruihua.github.io/config","data":"# [ruihuag](https://guanruihua.github.io/#/)\r\n\r\n![](../__assets__/001.jpg)\r\n<!-- ![Metrics](https://metrics.lecoq.io/guanruihua?template=classic&isocalendar=1&languages=1&base=header%2C%20activity%2C%20community%2C%20repositories%2C%20metadata&base.indepth=false&base.hireable=false&base.skip=false&isocalendar=false&isocalendar.duration=half-year&languages=false&languages.limit=8&languages.threshold=0%25&languages.other=false&languages.colors=github&languages.sections=most-used&languages.indepth=false&languages.analysis.timeout=15&languages.categories=markup%2C%20programming&languages.recent.categories=markup%2C%20programming&languages.recent.load=300&languages.recent.days=14&config.timezone=Asia%2FShanghai) -->\r\n","children":[]},{"name":"script","path":"../guanruihua.github.io/config","data":"","children":[{"name":"lv2","path":"../guanruihua.github.io/config/script","data":"","children":[{"name":"index.js","path":"../guanruihua.github.io/config/script/lv2","data":"window.$docsify = {\r\n\tcount: {\r\n\t\tcountable: true,\r\n\t\tfontsize: '0.9em',\r\n\t\tcolor: 'rgb(90,90,90)',\r\n\t\tlanguage: 'chinese'\r\n\t},\r\n\tsearch: {\r\n\t\tmaxAge: 86400000, // 过期时间，单位毫秒，默认一天\r\n\t\tnoData: '找不到结果',//搜索不到结果时显示\r\n\t\tpaths: 'auto',//自动\r\n\t\tplaceholder: '搜索',//搜索框提示\r\n\t\tdepth: 2,\r\n\t},\r\n\tloadSidebar: true,\r\n\t// loadNavbar: true,\r\n\tsubMaxLevel: 4,\r\n\trepo: 'https://github.com/guanruihua',\r\n\tcopyCode: {\r\n\t\tbuttonText: 'Copy',\r\n\t\terrorText: 'Error',\r\n\t\tsuccessText: 'Copied'\r\n\t},\r\n\tplugins: [\r\n\t\tfunction myPlugin2(hook, vm) {\r\n\t\t\tconsole.log(hook, vm)\r\n\t\t}\r\n\t]\r\n}","children":[]}]},{"name":"modules.js","path":"../guanruihua.github.io/config/script","data":"const modulesDom = document.querySelector('.modules-content')\r\n\r\nconst modules = [\r\n\t\"Front-End\",\r\n\t\"JavaScript\",\r\n\t\"CSS\",\r\n\t\"Back-End\",\r\n\t\"Data\",\r\n\t\"Database\", \"HTML\", \"Knowledge-Reserve\", \"OpenSource\", \"React\", \"Tool\",\r\n\t\"TypeScript\"\r\n]\r\n/**\r\n \r\n![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg) [![npm version](https://img.shields.io/npm/v/fakingjs.svg?style=flat)](https://www.npmjs.com/package/fakingjs)\r\n\r\n */\r\n\r\nconst packages = [\r\n\t{\r\n\t\ttype: 'npm',\r\n\t\tname: 'abandonjs',\r\n\t\tnpm: 'https://www.npmjs.com/abandonjs',\r\n\t\tgit: 'https://github.com/abandonjs/abandonjs',\r\n\t},\r\n\t{ type: 'npm', name: 'unit-testing-js', url: 'https://www.npmjs.com/package/unit-testing-js', },\r\n\t{ type: 'npm', name: 'fakingjs', url: 'https://www.npmjs.com/package/fakingjs', },\r\n\t{\r\n\t\ttype: 'npm', name: 'check-it-type',\r\n\t\turl: 'https://www.npmjs.com/package/fakingjs',\r\n\t\tgit: 'https://github.com/abandonjs/check-it-type',\r\n\t\tdocs: 'https://github.com/abandonjs/check-it-type'\r\n\t},\r\n]\r\n\r\nfunction buildPackage() {\r\n\tpackages.forEach(item => {\r\n\t\tconst { name } = item\r\n\t\tconst {\r\n\t\t\ttype, url, docs,\r\n\t\t\tnpm = `https://www.npmjs.com/package/${name}`,\r\n\t\t\tgit = `https://github.com/guanruihua/${name}`\r\n\t\t} = item\r\n\t\tconst dom = document.createElement('div')\r\n\t\tdom.setAttribute('class', 'content')\r\n\t\tdom.innerHTML = `\r\n\t\t\t\t\t<div class=\"logo unit\">\r\n\t\t\t\t\t\t<a href=\"${npm}\" target=\"_blank\">\r\n\t\t\t\t\t\t\t<svg height=\"32\" width=\"32\" viewBox=\"0 0 700 700\" fill=\"currentColor\" aria-hidden=\"true\" style=\"color: rgb(203, 0, 0);\">\r\n\t\t\t\t\t\t\t\t<polygon fill=\"#cb0000\" points=\"0,700 700,700 700,0 0,0\"></polygon>\r\n\t\t\t\t\t\t\t\t<polygon fill=\"#ffffff\" points=\"150,550 350,550 350,250 450,250 450,550 550,550 550,150 150,150 \"></polygon>\r\n\t\t\t\t\t\t\t</svg>\r\n\t\t\t\t\t\t</a>\r\n\t\t\t\t\t\t<a href=\"${git}\" target=\"_blank\">\r\n\t\t\t\t\t\t\t<img src=\"./__assets__/GitHub-Mark-32px.png\" alt=\"package\" />\r\n\t\t\t\t\t\t</a>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<a class=\"msg\" href=\"${docs || `./OpenSource/${name}/index.html`}\" target=\"_blank\">\r\n\t\t\t\t\t\t<div>\r\n\t\t\t\t\t\t\t<div>${name}</div>\r\n\t\t\t\t\t\t\t<div>\r\n\t\t\t\t\t\t\t\t<img class=\"tag\" src=\"https://img.shields.io/badge/license-MIT-blue.svg\" alt='license'/>\r\n\t\t\t\t\t\t\t\t<img class=\"tag\" src=\"https://img.shields.io/npm/v/${name}.svg?style=flat\" alt='version'/>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</a>`\r\n\t\tmodulesDom.appendChild(dom)\r\n\t})\r\n}\r\nfunction buildModulesDom(dom) {\r\n\r\n\tmodules.forEach(name => {\r\n\t\tconst itemDom = document.createElement('div')\r\n\t\titemDom.setAttribute('class', 'content')\r\n\t\titemDom.setAttribute('title', name)\r\n\r\n\t\titemDom.innerHTML = `\r\n\t\t\t<div class='logo'>${name[0]}</div>\r\n\t\t\t<div class='msg'>${name}</div>`\r\n\r\n\t\titemDom.onclick = () => {\r\n\t\t\twindow.location.href = '/' + name + '/index.html'\r\n\t\t}\r\n\t\tdom.appendChild(itemDom)\r\n\t})\r\n\r\n\tconst tempDom = document.createElement('div')\r\n\ttempDom.setAttribute('class', 'content')\r\n\ttempDom.setAttribute('title', 'Demo')\r\n\r\n\ttempDom.innerHTML = `\r\n\t\t\t<div class='logo'>${'D'}</div>\r\n\t\t\t<div class='msg'>${'Demo'}</div>`\r\n\r\n\ttempDom.onclick = () => {\r\n\t\twindow.location.href = 'https://ruihuag-demo.github.io/'\r\n\t}\r\n\tdom.appendChild(tempDom)\r\n}\r\n\r\nbuildModulesDom(modulesDom)\r\nbuildPackage()","children":[]}]},{"name":"temp.md","path":"../guanruihua.github.io/config","data":"<p align=\"center\">\r\n  <img alt=\"npm\" src=\"https://img.shields.io/npm/v/unit-testing-js\">\r\n  <img alt=\"GitHub Release Date\" src=\"https://img.shields.io/github/release-date/guanruihua/unit-testing-js\">\r\n  <img alt=\"npm peer dependency version\" src=\"https://img.shields.io/npm/dependency-version/element-tiptap/peer/vue?color=vue\">\r\n  <img alt=\"semantic-release\" src=\"https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg\">\r\n  <img alt=\"GitHub\" src=\"https://img.shields.io/github/license/Leecason/element-tiptap\">\r\n</p>\r\n****\r\n[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/facebook/react/blob/main/LICENSE)\r\n[![npm version](https://img.shields.io/npm/v/react.svg?style=flat)](https://www.npmjs.com/package/react)\r\n[![CircleCI Status](https://circleci.com/gh/facebook/react.svg?style=shield&circle-token=:circle-token)](https://circleci.com/gh/facebook/react)\r\n[![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](https://reactjs.org/docs/how-to-contribute.html#your-first-pull-request)\r\n\r\n![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)\r\n[![npm version](https://img.shields.io/npm/v/abandonjs.svg?style=flat)](https://www.npmjs.com/package/abandonjs)\r\n","children":[]}]},{"name":"CSS","path":"../guanruihua.github.io","data":"","children":[{"name":"at-rules","path":"../guanruihua.github.io/CSS","data":"","children":[{"name":"charset.md","path":"../guanruihua.github.io/CSS/at-rules","data":"\n# @charset\n\n> 指定样式表使用的字符集\n>\n> 样式表中第一行, 前面不可有任何字符\n\n```css\n@charset \"UTF-8\";\n@charset \"utf-8\"; /*大小写不敏感*/\n/* 设置css的编码格式为Unicode UTF-8 */\n@charset 'iso-8859-15'; /* 无效的, 使用了错误的引号 */\n@charset 'UTF-8';       /* 无效的, 使用了错误的引号 */\n@charset  \"UTF-8\";      /* 无效的, 多于一个空格 */\n @charset \"UTF-8\";      /* 无效的, 在at-rule之前多了一个空格 */\n@charset UTF-8;         /* Invalid, without ' or \", the charset is not a CSS <string> */\n```\n","children":[]},{"name":"color-profile.md","path":"../guanruihua.github.io/CSS/at-rules","data":"# @color-profile\n\n> 定义并命名了一个颜色配置文件，以后可以在`color()`函数中使用该颜色配置文件来指定颜色。\n\n## src\n\n指定从中检索颜色配置文件信息的URL。\n\n## `redering-intent`渲染意图\n\n> 如果颜色配置文件包含多个渲染意图，则此描述符允许选择一个作为用于定义如何将颜色映射到比此配置文件定义的色域更小的色域的描述符。\n>\n> 如果使用，它必须是以下关键字之一：\n>\n> - 相对比色法(**relative-colorimetric**)\n>\n> 介质相对比色法需要保持目标介质色域内的源颜色相对于相应介质白点不变。目标介质色域之外的源颜色将使用各种不同的方法映射到色域边界上的颜色。\n>\n> - 绝对比色法(**absolute-colorimetric**)\n>\n> ICC绝对比色法要求保持目标介质色域内的源颜色相对于采用的白色（完美反射散流器）保持不变。目标介质色域之外的源颜色将使用各种不同的方法映射到色域边界上的颜色。\n>\n> - 感性的(**perceptual**)\n>\n> 此方法通常是图像的首选方法，尤其是当源和目标之间存在实质性差异时（例如在反射打印上再现的屏幕显示图像）。它采用源图像的颜色，并使用专有方法重新优化目标介质的外观。\n>\n> - 饱和(**saturation**)\n>\n> 创建此选项是为了保持原稿的相对饱和度（色度），并保持纯色。然而，它遇到了互操作性问题，比如感知意图。\n\n```css\n@color-profile --swop5c {\n  src: url('https:/\n    /example.org/SWOP2006_Coated5v2.icc');\n}\n.header {\n  background-color:   color(--swop5c 0% 70% 20% 0%);\n}\n```\n","children":[]},{"name":"counter-style.md","path":"../guanruihua.github.io/CSS/at-rules","data":"# @counter-style\n\n> `@counter-style`是一个 [CSS](https://developer.mozilla.org/en-US/CSS) [at-rule](https://developer.mozilla.org/en-US/CSS/At-rule) ，它让开发者可以自定义counter的样式。 一个 `@counter-style规则` 定义了如何把一个计数器的值转化为字符串表示。\n\n## 语法\n\n```css\n@counter-style <counter-style-name> {\n    system: <counter system>\n    symbols: <counter symbols>\n    additive-symbols: <additive-symbols>\n    negative: <negative symbol>\n    prefix: <prefix>\n    suffix: <suffix>\n    range: <range>\n    pad: <padding>\n    speak-as: <speak-as>\n    fallback: <counter-style-name>\n}\n```\n\n## 描述\n\n> 每个 `@counter-style` 由一个名称标识并具有一组描述符\n>\n> - [system (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/system)\n>\n>   指定一个算法，用于将计数器的整数值转化为字符串表示。\n>\n> - [negative(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/negative)\n>\n>   指定一个符号，当计数器表示的值为负的时候，把这个符号加在值的前面或后面\n>\n> - [prefix (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/prefix)\n>\n>   指定一个符号，加在标记表示符的前面。前缀在最后阶段才会被加上，所以在计数器的最终表示中，它在[negative(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/negative)前。\n>\n> - [suffix (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/suffix)\n>\n>   与[prefix (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/prefix)类似，suffix指定一个符号，加在标记表示符的后面。\n>\n> - [range(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/range)\n>\n>    指定一个counter-style生效的范围，如果计数器的值不再这个范围内，那么自定义的counter-style不会生效，counter-style会后退到[fallback (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/fallback)的style。\n>\n> - [pad(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/pad)\n>\n>   在你想要给标记表示符最小值时使用。比如说，你想要计数器从01开始，经过02，03，04，那么这时可以使用pad了。对于大于pad指定值的表示符，标记会恢复为normal。\n>\n> - [fallback (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/fallback)\n>\n>   定义一个备用的系统，当自定义的系统不能使用或者计数器的值超过了定义的范围时使用。如果备用系统也不能表示计数器的值，那么备用系统的备用系统（如果有的话）将会启用。如果没有指定备用系统，或者备用系统链不能够正确表示一个值，那么最终会降为十进制样式表示。\n>\n> - [symbols (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/symbols)\n>\n>   定义一个符号，用于标记的表示。符号可以包含字符串，图片或自定义的识别码。这个符号怎样构建标记呢？这依赖于system描述符里面所定义的算法。 举个例子，如果system的值是fixed,那么symbols属性指定的固定的N个符号，将被用来表示计数器的前N个值。用完了前N个符号后，列表里剩下的值将使用fallback定义的样式来表示。  下面的@counter-style规则使用图片而不是字符标记。\n>\n>   ```css\n>   @counter-style winners-list { \n>     system: fixed; \n>     symbols: url(gold-medal.svg)  url(silver-medal.svg) url(bronze-medal.svg);  \n>     suffix: \" \"; \n>   }\n>   ```\n>\n>\n>\n> - [additive-symbols (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/additive-symbols)\n>\n>   尽管symbols属性中指定的符号可以被system中定义的大部分算法所使用，但是一些system属性的值，比如additive，依赖于本描述符所描述的加性元组。Each additive tuple consists of a counter symbol and a non negative integer weight. 每个加性元组包含一个可数的符号和一个非负证书的权重。The additive tuples must be specified in the descending order of their weights.\n>\n> - [speak-as(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style/speak-as)\n>\n>   定义如何在语音识别器中读出计数器样式，比如屏幕阅读器。例如基于该描述符的值，标记符号的值可以作为有序列表的数字或者字幕作为无序列表的音频提示读出。\n\n```css\n@counter-style circled-alpha {\n  system: fixed;\n  symbols: Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ;\n  suffix: \" \";\n}\n\n.items {\n   list-style: circled-alpha;\n}\n\n\n```\n\n```\nⒶ One  \nⒷ Two\nⒸ Three\nⒹ Four\nⒺ FIve\n....\n...\nⓎ Twenty Five\nⓏ Twenty Six\n\n27 Twenty Seven\n28 Twenty Eight\n29 Twenty Nine\n30 Thirty\n```\n","children":[]},{"name":"font-face.md","path":"../guanruihua.github.io/CSS/at-rules","data":"# @font-face\n\n> 指定一个用于显示文本的自定义字体；字体能从远程服务器或者用户本地安装的字体加载. 如果提供了local()函数，从用户本地查找指定的字体名称，并且找到了一个匹配项, 本地字体就会被使用. 否则, 字体就会使用url()函数下载的资源。\n>\n> 通过允许作者提供他们自己的字体，@font-face 让设计内容成为了一种可能，同时并不会被所谓的\"网络-安全\"字体所限制(字体如此普遍以至于它们能被广泛的使用). 指定查找和使用本地安装的字体名称可以让字体的自定义化程度超过基本字体，同时在不依赖网络情况下实现此功能。\n>\n> 在同时使用url()和local()功能时，为了用户已经安装的字体副本在需要使用时被使用，如果在用户本地没有找到字体副本就会去使用户下载的副本查找字体。\n>\n> @font-face 规则不仅仅使用在CSS的顶层，还可以用在任何CSS条件组规则中.\n\n```css\n@font-face {\n  font-family: \"Open Sans\";\n  src: url(\"/fonts/OpenSans-Regular-webfont.woff2\") format(\"woff2\"),\n       url(\"/fonts/OpenSans-Regular-webfont.woff\") format(\"woff\");\n}\n```\n\nCopy to Clipboard\n\n## [概述](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face#概述)\n\n这是一个叫做`@font-face` 的[CSS](https://developer.mozilla.org/zh-CN/docs/Web/CSS) [@规则](https://developer.mozilla.org/zh-CN/docs/Web/CSS/At-rule) ，它允许网页开发者为其网页指定在线字体。 通过这种作者自备字体的方式，`@font-face` 可以消除对用户电脑字体的依赖。 `@font-face` 不仅可以放在在CSS的最顶层, 也可以放在 @规则 的 [条件规则组](https://developer.mozilla.org/zh-CN/docs/Web/CSS/At-rule#conditional_group_rules) 中。\n\n## [语法](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face#语法)\n\n```css\n@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ] ||\n  [ size-adjust: <size-adjust>; ] ||\n  [ ascent-override: <ascent-override>; ] ||\n  [ descent-override: <descent-override>; ] ||\n  [ line-gap-override: <line-gap-override>; ]\n}where <family-name> = <string> | <custom-ident>+\n```\n\n### [取值](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face#取值)\n\n- [font-family](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face/font-family)\n\n  所指定的字体名字将会被用于font或font-family属性( i.e. font-family: <family-name>; )\n\n- [src](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face/src)\n\n  远程字体文件位置的URL或者用户计算机上的字体名称， 可以使用local语法通过名称指定用户的本地计算机上的字体( i.e. src: local('Arial'); )。 如果找不到该字体，将会尝试其他来源，直到找到它。\n\n- [font-variant (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-variant)\n\n  A [font-variant](https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant) value.\n\n- [font-stretch (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-stretch)\n\n  A [font-stretch](https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-stretch) value.\n\n- [font-weight (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-weight)\n\n  A [font-weight](https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-weight) value.\n\n- [font-style](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face/font-style)\n\n  对于src所指字体的描述。如果所需字体符合描述，则采用本font-face所定义的字体。\n\n- [unicode-range (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/unicode-range)\n\n  在该@font-face中定义的unicode字体范围\n\n## [示例](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face#示例)\n\n下面的例子简单定义了一个可下载的字体，并应用到了文档的整个body标签上。\n\n[View live sample](https://developer.mozilla.org/@api/deki/files/2935/=webfont-sample.html)\n\n```html\n<html>\n<head>\n  <title>Web Font Sample</title>\n  <style type=\"text/css\" media=\"screen, print\">\n    @font-face {\n      font-family: \"Bitstream Vera Serif Bold\";\n      src: url(\"https://developer.mozilla.org/@api/deki/files/2934/=VeraSeBd.ttf\");\n    }\n\n    body { font-family: \"Bitstream Vera Serif Bold\", serif }\n  </style>\n</head>\n<body>\n  This is Bitstream Vera Serif Bold.\n</body>\n</html>\n```\n\n在接下来的例子中，用到了用户本地字体\"Helvetica Neue Bold\"的备份；如果当前用户(浏览器)未安装该字体(两种可能的字体名都已经试过)，就会用下载的字体\"MgOpenModernaBold.ttf\"来代替：\n\n```css\n@font-face {\n  font-family: MyHelvetica;\n  src: local(\"Helvetica Neue Bold\"),\n  local(\"HelveticaNeue-Bold\"),\n  url(MgOpenModernaBold.ttf);\n  font-weight: bold;\n}\n```\n\nCopy to Clipboard\n\n接下来的例子在英文原文中已被删除。\n\n这个例子新定义了一个字体，正常粗细的字采用字体Times New Roman，粗体字采用Consolas。\n\n```css\n@font-face {\n    font-family: myFirstFont;\n    src: local(\"Times New Roman\");\n    font-weight:normal;\n}\n\n@font-face {\n    font-family: myFirstFont;\n    src: local(Consolas);\n    font-weight:bold;\n}\n```\n\nCopy to Clipboard\n\n## [注意](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face#注意)\n\n- 这里使用的Web fonts 仍然受到同域限制  (字体文件必须和调用它的网页同一域), 但可以使用 [HTTP access controls](https://developer.mozilla.org/en-US/docs/HTTP_access_control) 解除这一限制。\n\n- 因为这里没有为 TrueType(ttf), OpenType(otf) 和 Web Open File Format(WOFF) 字体定义MIME，因此不能为这些字体类型设置特定的MIME（实际上WOFF的MIME将会是application/font-woff，但浏览器对此MIME的识别还不统一，其它字体情况也类似，可暂时使用application/octet-stream）。\n\n- 你不能在一个 CSS 选择器中定义 @font-face 。例如，这样写是无效的：\n\n  ```css\n  .className {\n    @font-face {\n      font-family: MyHelvetica;\n      src: local(\"Helvetica Neue Bold\"), local(\"HelveticaNeue-Bold\"),\n          url(MgOpenModernaBold.ttf);\n      font-weight: bold;\n    }\n  }\n  ```\n","children":[]},{"name":"import.md","path":"../guanruihua.github.io/CSS/at-rules","data":"# @import\n\n## [概述](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@import#概述)\n\n**`@import`**[CSS](https://developer.mozilla.org/en-US/docs/Web/CSS)[@规则](https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule)，用于从其他样式表导入样式规则。这些规则必须先于所有其他类型的规则，[@charset](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@charset) 规则除外; 因为它不是一个[嵌套语句](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Syntax#nested_statements)，@import不能在[条件组的规则](https://developer.mozilla.org/zh-CN/docs/Web/CSS/At-rule#conditional_group_rules)中使用。\n\n因此，用户代理可以避免为不支持的媒体类型检索资源，作者可以指定依赖媒体的@import规则。这些条件导入在URI之后指定逗号分隔的[媒体查询](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries)。在没有任何媒体查询的情况下，导入是无条件的。指定所有的媒体具有相同的效果。\n\n## [语法](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@import#语法)\n\n```css\n@import url;\n@import url list-of-media-queries;\n```\n\n其中:\n\n- *url*\n\n  是一个表示要引入资源位置的 [](https://developer.mozilla.org/zh-CN/docs/Web/CSS/string) 或者 [(en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/url()) 。 这个 URL 可以是绝对路径或者相对路径。 要注意的是这个 URL 不需要指明一个文件； 可以只指明包名，然后合适的文件会被自动选择 (e.g. **chrome://communicator/skin/**). [See here](https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XUL/Tutorial/The_Chrome_URL) 了解更多。\n\n- *list-of-media-queries*\n\n  是一个逗号分隔的 [媒体查询](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries) 条件列表，决定通过URL引入的 CSS 规则 在什么条件下应用。如果浏览器不支持列表中的任何一条媒体查询条件，就不会引入URL指明的CSS文件。\n\n## [正规语法](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@import#正规语法)\n\n```css\n@import [ <string> | <url> ]\n        [ layer | layer(<layer-name>) ]?\n        [ supports( [ <supports-condition> | <declaration> ] ) ]?\n        <media-query-list>? ;\n\nwhere <supports-condition> = not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*<media-query-list> = <media-query>#\n\nwhere <supports-in-parens> = ( <supports-condition> ) | <supports-feature> | <general-enclosed><media-query> = <media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?\n\nwhere <supports-feature> = <supports-decl> | <supports-selector-fn><general-enclosed> = [ <function-token> <any-value> ) ] | ( <ident> (en-US) <any-value> )<media-condition> = <media-not> | <media-and> | <media-or> | <media-in-parens><media-type> = <ident> (en-US)<media-condition-without-or> = <media-not> | <media-and> | <media-in-parens>\n\nwhere <supports-decl> = ( <declaration> )<supports-selector-fn> = selector( <complex-selector> )<media-not> = not <media-in-parens><media-and> = <media-in-parens> [ and <media-in-parens> ]+<media-or> = <media-in-parens> [ or <media-in-parens> ]+<media-in-parens> = ( <media-condition> ) | <media-feature> | <general-enclosed>\n\nwhere <complex-selector> = <compound-selector> [ <combinator>? <compound-selector> ]*<media-feature> = ( [ <mf-plain> | <mf-boolean> | <mf-range> ] )\n\nwhere <compound-selector> = [ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!<combinator> = '>' | '+' | '~' | [ '||' ]<mf-plain> = <mf-name> : <mf-value><mf-boolean> = <mf-name><mf-range> = <mf-name> [ '<' | '>' ]? '='? <mf-value> | <mf-value> [ '<' | '>' ]? '='? <mf-name> | <mf-value> '<' '='? <mf-name> '<' '='? <mf-value> | <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>\n\nwhere <type-selector> = <wq-name> | <ns-prefix>? '*'<subclass-selector> = <id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector><pseudo-element-selector> = ':' <pseudo-class-selector><pseudo-class-selector> = ':' <ident-token> | ':' <function-token> <any-value> ')'<mf-name> = <ident> (en-US)<mf-value> = <number> | <dimension> | <ident> (en-US) | <ratio>\n\nwhere <wq-name> = <ns-prefix>? <ident-token><ns-prefix> = [ <ident-token> | '*' ]?  | <id-selector> = <hash-token><class-selector> = '.' <ident-token><attribute-selector> = '[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'\n\nwhere <attr-matcher> = [ '~' |  |  | '^' | '$' | '*' ]? '='<attr-modifier> = i | s\n```\n\n## [示例](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@import#示例)\n\n```css\n@import url(\"fineprint.css\") print;\n@import url(\"bluish.css\") projection, tv;\n@import 'custom.css';\n@import url(\"chrome://communicator/skin/\");\n@import \"common.css\" screen, projection;\n@import url('landscape.css') screen and (orientation:landscape);\n```\n","children":[]},{"name":"keyframes.md","path":"../guanruihua.github.io/CSS/at-rules","data":"# @keyframes\n\n关键帧 **`@keyframes`** [at-rule](https://developer.mozilla.org/zh-CN/docs/Web/CSS/At-rule) 规则通过在动画序列中定义关键帧（或waypoints）的样式来控制CSS动画序列中的中间步骤。和 [转换 transition](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Transitions) 相比，关键帧 keyframes 可以控制动画序列的中间步骤。\n\n```css\n@keyframes slidein {\n  from {\n    transform: translateX(0%); \n  }\n\n  to {\n    transform: translateX(100%);\n  }\n}\n```\n\nCopy to Clipboard\n\nJavaScript 可以通过 CSS对象模型的 [CSSKeyframesRule (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/CSSKeyframesRule) 接口来访问 `@keyframes`。\n\n要使用关键帧, 先创建一个带名称的 `@keyframes` 规则，以便后续使用 [animation-name](https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-name) 属性将动画同其关键帧声明匹配。每个 `@keyframes` 规则包含多个关键帧，也就是一段样式块语句，每个关键帧有一个百分比值作为名称，代表在动画进行中，在哪个阶段触发这个帧所包含的样式。\n\n可以按任意顺序列出关键帧百分比；它们将按照其应该发生的顺序来处理。\n\n### [让关键帧序列生效](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes#让关键帧序列生效)\n\n如果一个关键帧规则没有指定动画的开始或结束状态（也就是，`0%`/`from` 和`100%`/`to`，浏览器将使用元素的现有样式作为起始/结束状态。这可以用来从初始状态开始元素动画，最终返回初始状态。\n\n如果在关键帧的样式中使用了不能用作动画的属性，那么这些属性会被忽略掉，支持动画的属性仍然是有效的，不受波及。\n\n### [重复定义](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes#重复定义)\n\n如果多个关键帧使用同一个名称，以最后一次定义的为准。 `@keyframes` 不存在层叠样式(cascade)的情况，所以动画在一个时刻（阶段）只会使用一个的关键帧的数据。\n\n如果一个@keyframes 内的关键帧的百分比存在重复的情况，则@keyframes规则中该百分比的所有关键帧都将用于该帧。如果多个关键帧指定了相同的百分比值，则@keyframes规则内是可以使用层叠样式的。\n\n### [属性个数不定](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes#属性个数不定)\n\n如果一个关键帧中没有出现其他关键帧中的属性，那么这个属性将使用插值（不能使用插值的属性除外，这些属性会被忽略掉）。例如：\n\n```css\n@keyframes identifier {\n  0% { top: 0; left: 0; }\n  30% { top: 50px; }\n  68%, 72% { left: 50px; }\n  100% { top: 100px; left: 100%; }\n}\n```\n\nCopy to Clipboard\n\n例子中，[top](https://developer.mozilla.org/zh-CN/docs/Web/CSS/top) 属性分别出现在关键帧 `0%`、`30%` 和 `100%` 的中，而 [left](https://developer.mozilla.org/zh-CN/docs/Web/CSS/left) 属性分别出现在关键帧 `0%`、`68%`、`72%` 和 `100%` 中。\n\n### [同一关键帧中的相同属性被重复定义](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes#同一关键帧中的相同属性被重复定义)\n\n如果某一个关键帧出现了重复的定义，且重复的关键帧中的 CSS 属性值不同，则以最后一次定义的属性为准。例如：\n\n```css\n@keyframes identifier {\n  0% { top: 0; }\n  50% { top: 30px; left: 20px; }\n  50% { top: 10px; }\n  100% { top: 0; }\n}\n```\n\nCopy to Clipboard\n\n上面这个例子中，`50%` 关键帧中分别最后设置的属性 `top: 10px` 和 `left: 20px` 是有效的，但是其他的属性会被忽略。\n\nFirefox 14 开始支持层叠 keyframes。\n\n### [关键帧中的 !important](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes#关键帧中的_!important)\n\n关键帧中出现的 `!important` 将会被忽略。\n\n```css\n@keyframes important1 {\n  from { margin-top: 50px; }\n  50%  { margin-top: 150px !important; } /* 忽略 */\n  to   { margin-top: 100px; }\n}\n\n@keyframes important2 {\n  from { margin-top: 50px;\n         margin-bottom: 100px; }\n  to   { margin-top: 150px !important; /* 忽略 */\n         margin-bottom: 50px; }\n}\n```\n\nCopy to Clipboard\n\n## [语法](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes#语法)\n\n### [取值](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes#取值)\n\n- [custom-ident](https://developer.mozilla.org/zh-CN/docs/Web/CSS/custom-ident)\n\n  帧列表的名称。名称必须符合 CSS 语法中对标识符的定义。\n\n- `from`\n\n  等价于 `0%`。\n\n- `to`\n\n  等价于 `100%`。\n\n- [](https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage)\n\n  动画序列中触发关键帧的时间点，使用百分值来表示。\n\n- 形式化语法\n\n```css\n @keyframes <keyframes-name> {  \n   <keyframe-block-list>\n }\n\n  where \n   <keyframes-name> = <custom-ident> | <string>\n   <keyframe-block-list> = <keyframe-block>+\n\n  where <keyframe-block> = <keyframe-selector># {  \n   <declaration-list> \n  }\n \n where <keyframe-selector> = from | to | <percentage>\n ```\n","children":[]},{"name":"media.md","path":"../guanruihua.github.io/CSS/at-rules","data":"# @media\n\n`@media` [CSS](https://developer.mozilla.org/en/CSS) [@规则](https://developer.mozilla.org/zh-CN/docs/Web/CSS/At-rule) 可用于基于一个或多个 [媒体查询](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries)的结果来应用样式表的一部分。 使用它，您可以指定一个媒体查询和一个CSS块，当且仅当该媒体查询与正在使用其内容的设备匹配时，该CSS块才能应用于该文档。\n\n**注：** 在JavaScript中，可以使用[CSSMediaRule](https://developer.mozilla.org/zh-CN/docs/Web/API/CSSMediaRule)CSS对象模型接口访问使用@media创建的规则。\n\n## [语法](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media#语法)\n\n`@media` 规则可置于您代码的顶层或位于其它任何[@条件规则组](https://developer.mozilla.org/zh-CN/docs/Web/CSS/At-rule#条件规则组)内。\n\n```css\n/* At the top level of your code */\n@media screen and (min-width: 900px) {\n  article {\n    padding: 1rem 3rem;\n  }\n}\n\n/* Nested within another conditional at-rule */\n@supports (display: flex) {\n  @media screen and (min-width: 900px) {\n    article {\n      display: flex;\n    }\n  }\n}\n```\n\n### [正式语法](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media#正式语法)\n\n```css\n@media <media-query-list> {\n  <group-rule-body>\n}\nwhere <media-query-list> = <media-query>#\n\nwhere <media-query> = <media-condition> | [ not | only ]? <media-type> [ and \n<media-condition-without-or> ]?\n\nwhere <media-condition> = <media-not> | <media-and> | <media-or> | <media-in-parens><media-type> = <ident> (en-US)<media-condition-without-or> = <media-not> | <media-and> | <media-in-parens>\n\nwhere <media-not> = not <media-in-parens><media-and> = <media-in-parens> [ and <media-in-parens> ]+<media-or> = <media-in-parens> [ or <media-in-parens> ]+<media-in-parens> = ( <media-condition> ) | <media-feature> | <general-enclosed>\n\nwhere <media-feature> = ( [ <mf-plain> | <mf-boolean> | <mf-range> ] )<general-enclosed> = [ <function-token> <any-value> ) ] | ( <ident> (en-US) <any-value> )\n\nwhere <mf-plain> = <mf-name> : <mf-value><mf-boolean> = <mf-name><mf-range> = <mf-name> [ '<' | '>' ]? '='? <mf-value> | <mf-value> [ '<' | '>' ]? '='? <mf-name> | <mf-value> '<' '='? <mf-name> '<' '='? <mf-value> | <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>\n\nwhere <mf-name> = <ident> (en-US)<mf-value> = <number> | <dimension> | <ident> (en-US) | <ratio>\n```\n\n## [媒体特性](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media#媒体特性)\n\n*媒体特性*（*Media features*）描述了 [user agent](https://developer.mozilla.org/zh-CN/docs/Glossary/User_agent)、输出设备，或是浏览环境的具体特征。媒体特性表达式是完全可选的，它负责测试这些特性或特征是否存在、值为多少。每条媒体特性表达式都必须用括号括起来。\n\n| 名称                                                                                                       | 简介                                                                                                                           | 备注                                                                                             |\n| :--------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------- |\n| [any-hover](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/any-hover)                             | 是否有任何可用的输入机制允许用户（将鼠标等）悬停在元素上？                                                                     | 在 Media Queries Level 4 中被添加。                                                              |\n| [any-pointer](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/any-pointer)                         | 可用的输入机制中是否有任何指针设备，如果有，它的精度如何？                                                                     | 在 Media Queries Level 4 中被添加。                                                              |\n| [aspect-ratio](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/aspect-ratio)                       | 视窗（viewport）的宽高比                                                                                                       |                                                                                                  |\n| [color (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/color)                             | 输出设备每个像素的比特值，常见的有 8、16、32 位。如果设备不支持输出彩色，则该值为 0                                            |                                                                                                  |\n| [color-gamut (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/color-gamut)                 | 用户代理和输出设备大致程度上支持的色域                                                                                         | 在 Media Queries Level 4 中被添加。                                                              |\n| [color-index (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/color-index)                 | 输出设备的颜色查询表（color lookup table）中的条目数量，如果设备不使用颜色查询表，则该值为 0                                   |                                                                                                  |\n| [device-aspect-ratio (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/device-aspect-ratio) | 输出设备的宽高比                                                                                                               | 已在 Media Queries Level 4 中被弃用。                                                            |\n| [device-height](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/device-height)                     | 输出设备渲染表面（如屏幕）的高度                                                                                               | 已在 Media Queries Level 4 中被弃用。                                                            |\n| [device-width (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/device-width)               | 输出设备渲染表面（如屏幕）的宽度                                                                                               | 已在 Media Queries Level 4 中被弃用。                                                            |\n| [display-mode (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/display-mode)               | 应用程序的显示模式，如web app的manifest中的[display](https://developer.mozilla.org/zh-CN/docs/Web/Manifest#display) 成员所指定 | 在 [Web App Manifest spec](http://w3c.github.io/manifest/#the-display-mode-media-feature)被定义. |\n| [forced-colors (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/forced-colors)             | 检测是user agent否限制调色板                                                                                                   | 在 Media Queries Level 5 中被添加。                                                              |\n| [grid (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/grid)                               | 输出设备使用网格屏幕还是点阵屏幕？                                                                                             |                                                                                                  |\n| [height (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/height)                           | 视窗（viewport）的高度                                                                                                         |                                                                                                  |\n| [hover](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/hover)                                     | 主要输入模式是否允许用户在元素上悬停                                                                                           | 在 Media Queries Level 4 中被添加。                                                              |\n| [inverted-colors (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/inverted-colors)         | user agent或者底层操作系统是否反转了颜色                                                                                       | 在 Media Queries Level 5 中被添加。                                                              |\n| `light-level`                                                                                              | 环境光亮度                                                                                                                     | 在 Media Queries Level 5 中被添加。                                                              |\n| [monochrome (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/monochrome)                   | 输出设备单色帧缓冲区中每个像素的位深度。如果设备并非黑白屏幕，则该值为 0                                                       |                                                                                                  |\n| [orientation](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/orientation)                         | 视窗（viewport）的旋转方向                                                                                                     |                                                                                                  |\n| [overflow-block (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/overflow-block)           | 输出设备如何处理沿块轴溢出视窗(viewport)的内容                                                                                 | 在 Media Queries Level 4 中被添加。                                                              |\n| [overflow-inline (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/overflow-inline)         | 沿内联轴溢出视窗(viewport)的内容是否可以滚动？                                                                                 | 在 Media Queries Level 4 中被添加。                                                              |\n| [pointer (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/pointer)                         | 主要输入机制是一个指针设备吗？如果是，它的精度如何？                                                                           | 在 Media Queries Level 4 中被添加。                                                              |\n| [prefers-color-scheme](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/prefers-color-scheme)       | 探测用户倾向于选择亮色还是暗色的配色方案                                                                                       | 在 Media Queries Level 5 中被添加。                                                              |\n| [prefers-contrast (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-contrast)       | 探测用户是否有向系统要求提高或降低相近颜色之间的对比度                                                                         | 在 Media Queries Level 5 中被添加。                                                              |\n| [prefers-reduced-motion](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/prefers-reduced-motion)   | 用户是否希望页面上出现更少的动态效果                                                                                           | 在 Media Queries Level 5 中被添加。                                                              |\n| `prefers-reduced-transparency`                                                                             | 用户是否倾向于选择更低的透明度                                                                                                 | 在 Media Queries Level 5 中被添加。                                                              |\n| [resolution (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/resolution)                   | 输出设备的像素密度（分辨率）                                                                                                   |                                                                                                  |\n| `scan`                                                                                                     | 输出设备的扫描过程（适用于电视等）                                                                                             |                                                                                                  |  | [scripting (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/scripting) | 探测脚本（例如 JavaScript）是否可用 | 在 Media Queries Level 5 中被添加。 |  | [update (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/update-frequency) | 输出设备更新内容的渲染结果的频率 | 在 Media Queries Level 4 中被添加。 |\n| [width](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/width)                                     | 视窗（viewport）的宽度，包括纵向滚动条的宽度                                                                                   |                                                                                                  |\n\n## [示例](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media#示例)\n\n```css\n@media print {\n  body { font-size: 10pt; }\n}\n\n@media screen {\n  body { font-size: 13px; }\n}\n\n@media screen, print {\n  body { line-height: 1.2; }\n}\n\n@media only screen\n  and (min-width: 320px)\n  and (max-width: 480px)\n  and (resolution: 150dpi) {\n    body { line-height: 1.4; }\n}\n```\n\n媒体查询第4级引入了一种新的范围语法，在测试接受范围的任何特性时允许更简洁的媒体查询，如下面的示例所示：\n\n```css\n@media (height > 600px) {\n    body { line-height: 1.4; }\n}\n\n@media (400px <= width <= 700px) {\n    body { line-height: 1.4; }\n}\n```\n\n更多示例，请查看[使用媒体查询](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries#syntax)。\n\n## [可访问性](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media#可访问性)\n\n为了最好地调整网站文本大小，当您需要[](https://developer.mozilla.org/zh-CN/docs/Web/CSS/length) 进行[媒体查询](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries)时，请使用`em`。\n\n`em`和`px`都是有效单位，但如果用户更改浏览器文本大小，`em`的效果会更好。\n\n考虑使用4级媒体查询来改善用户体验。 例如，使用`prefers-reduced-motion`以[检测用户是否已请求系统最小化其使用的动画](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-motion)或动作量。\n","children":[]},{"name":"媒体监听.md","path":"../guanruihua.github.io/CSS/at-rules","data":"# 媒体监听\r\n\r\n```css\r\n@media media-type and (media-feature-rule) {\r\n  /* CSS rules go here */\r\n}\r\n```\r\n\r\n- `media-type`: 媒体类型\r\n- `media-feature-rule`: 媒体表达式\r\n- `CSS rules`: css 规则, 通过媒体查询后生效的css\r\n\r\n## `media-type`: 媒体类型\r\n\r\n- `screen`: 计算机屏幕(默认值, 主要使用)\r\n- `tty`:电传打字机以及使用等宽字符网格的类似媒介\r\n- `tv`:电视类型设备（低分辨率、有限的屏幕翻滚能力）\r\n- `projection`:放映机\r\n- `handheld`:手持设备（小屏幕、有限的带宽）\r\n- `print`:打印预览模式 / 打印页\r\n- `braille`:盲人用点字法反馈设备\r\n- `aural`:语音合成器\r\n- `all`:适合所有设备\r\n\r\n## `media-feature-rule`: 媒体表达式\r\n\r\n- 媒体属性: `width` | `min-width` | `max-width` | `height` | `min-height` | `max-height` ...\r\n\r\n### 颜色（color）\r\n\r\n> - 指定输出设备每个像素单元的比特值。如果设备不支持输出颜色，则该值为0\r\n> - 向所有能显示颜色的设备应用样式表\r\n\r\n```css\r\n@media (color){ }\r\n```\r\n\r\n### 颜色索引（color-index）\r\n\r\n> - 颜色索引指定了输出设备中颜色查询表中的条目数量，如果没有使用颜色查询表，则值等于0\r\n> - 向所有使用至少256个索引颜色的设备应用样式表(下列代码无显示，说明返回值为0)\r\n\r\n```css\r\n@media (min-color-index: 256){\r\n}\r\n```\r\n\r\n### 宽高比（aspect-ratio）\r\n\r\n> - 宽高比描述了输出设备目标显示区域的宽高比。该值包含两个以“/”分隔的正整数。代表了水平像素数（第一个值）与垂直像素数（第二个值）的比例\r\n> - 向可视区域是正方形或者是宽屏的设备应用样式表\r\n\r\n```css\r\n@media (min-aspect-ratio: 1/1) { }\r\n```\r\n\r\n### 设备宽高比（device-aspect-ratio）\r\n\r\n> - 设备宽高比描述了输出设备的宽高比。该值包含两个以“/”分隔的正整数。代表了水平像素数（第一个值）与垂直像素数（第二个值）的比例\r\n> - 向宽高比为16:9的特殊宽屏设备应用样式表\r\n\r\n```css\r\n@media (device-aspect-ratio:16/9) { }\r\n```\r\n\r\n### 设备高度（device-height）\r\n\r\n> - 设备高度描述了输出设备的高度\r\n> - 向显示在最小高度1000px的屏幕上的文档应用样式表\r\n\r\n```css\r\n@media (min-device-height: 1000px) { }\r\n```\r\n\r\n### 设备宽度（device-width）\r\n\r\n> - 设备宽度描述了输出设备的宽度\r\n> - 向显示在最小宽度1000px的屏幕上的文档应用样式表\r\n\r\n```css\r\n@media (min-device-width: 1000px) { }\r\n```\r\n\r\n### 网格（grid）\r\n\r\n> - 网格判断输出设备是网格设备还是位图设备。如果设备是基于网格的（例如电传打字机终端或只能显示一种字形的电话），该值为1，否则为0　　\r\n> - 向非网格设备应用样式表\r\n>\r\n```css\r\n@media (grid:0) { }\r\n```\r\n\r\n### 高度（height）\r\n\r\n> 高度描述了输出设备渲染区域（如可视区域的高度或打印机纸盒的高度）的高度\r\n\r\n- `@media (min-height:800px) { }`: 向高度大于800px的可视区域的设备应用样式表\r\n- `@media (max-height:800px) { }`: 向高度小于800px的可视区域的设备应用样式表\r\n\r\n### 宽度（width）\r\n\r\n> 宽度描述了输出设备渲染区域的宽度\r\n\r\n- `@media (min-width:800px) { }`: 向宽度大于800px的可视区域的设备应用样式表\r\n- `@media (max-width:800px) { }`: 向宽度小于800px的可视区域的设备应用样式表\r\n\r\n### 黑白（monochrome）\r\n\r\n> 黑白指定了一个黑白（灰度）设备每个像素的比特数。如果不是黑白设备，值为0\r\n> 向非黑白设备应用样式表\r\n\r\n`@media (monochrome:0) { }`\r\n\r\n### 方向（orientation）\r\n\r\n> 方向指定了设备处于横屏（宽度大于宽度）模式还是竖屏（高度大于宽度）模式\r\n> 值：`landscape(横屏)` | `portrait(竖屏)`\r\n> 向竖屏设备应用样式表\r\n\r\n`@media (orientation: portrait) { }`\r\n\r\n### 分辨率（resolution）\r\n\r\n> 分辨率指定输出设备的分辨率（像素密度）。分辨率可以用每英寸（dpi）或每厘米（dpcm）的点数来表示\r\n> 向每英寸至少90点的设备应用样式\r\n\r\n`@media (min-resolution: 90dpi) { }`\r\n\r\n### 扫描（scan）\r\n\r\n> 扫描描述了电视输出设备的扫描过程\r\n> 值： `progressive` | `interlace`\r\n\r\n- 媒体查询包含了一个CSS2已有的媒介类型(或称为媒体类型)和CSS3新增的包含一个或多个表达式的媒体属性，这些媒体属性会被解析成真或假\r\n\r\n- 当媒体查询为真时，相关的样式表或样式规则就会按照正常的级联规则被应用。即使媒体查询返回假， <link> 标签上带有媒体查询的样式表仍将被下载（只不过不会被应用）\r\n\r\n- `<link rel=\"stylesheet\" href=\"style.css\" media=\"print\">`\r\n\r\n- media并不是'print'，所以媒体查询为假。但是，style.css文件依然被下载\r\n\r\n## 拓展\r\n\r\n### 媒体查询的逻辑运算\r\n\r\n```css\r\n/* and */\r\n@media screen and (min-width: 400px), screen and (orientation: landscape) { }\r\n\r\n/* not */\r\n@media ont screen and (orientation: landscape) { }\r\n\r\n/* only */\r\n@media only screen and (min-width: 400px), screen and (orientation: landscape) { }\r\n\r\n/* or: 逗号就类似or */\r\n@media screen and (min-width: 400px), screen and (orientation: landscape) { }\r\n```\r\n\r\n## js 触发媒体表达式\r\n\r\n### window.matchMedia\r\n\r\n- `window.matchMedia('(max-width: 600px)')`: 就可达到js使用媒体表达式监听\r\n\r\neg: 创建媒体查询，以监控设备分辨率并在每次更改时检查devicePixelRatio的值\r\n\r\n```js\r\nlet pixelRatioBox = document.querySelector(\".pixel-ratio\");\r\nlet mqString = `(resolution: ${window.devicePixelRatio}dppx)`;\r\n\r\nconst updatePixelRatio = () => {\r\n  let pr = window.devicePixelRatio;\r\n  let prString = (pr * 100).toFixed(0);\r\n  pixelRatioBox.innerText = `${prString}% (${pr.toFixed(2)})`;\r\n}\r\n\r\nupdatePixelRatio();\r\n\r\nmatchMedia(mqString).addListener(updatePixelRatio);\r\n```\r\n\r\n## 补充\r\n\r\n- CSS2 中: 媒体查询值使用与`<style>` 和 `<link>`, 以media属性存在\r\n\r\n| 值                      | 描述                                                                            |\r\n| :---------------------- | :------------------------------------------------------------------------------ |\r\n| `aspect-ratio`          | 定义输出设备中的页面可见区域宽度与高度的比率                                    |\r\n| color                   | 定义输出设备每一组彩色原件的个数。如果不是彩色设备，则值等于 0                  |\r\n| color-index             | 定义在输出设备的彩色查询表中的条目数。如果没有使用彩色查询表，则值等于0         |\r\n| device-aspect-ratio     | 定义输出设备的屏幕可见宽度与高度的比率。                                        |\r\n| device-height           | 定义输出设备的屏幕可见高度。                                                    |\r\n| device-width            | 定义输出设备的屏幕可见宽度。                                                    |\r\n| grid                    | 用来查询输出设备是否使用栅格或点阵。                                            |\r\n| height                  | 定义输出设备中的页面可见区域高度。                                              |\r\n| max-aspect-ratio        | 定义输出设备的屏幕可见宽度与高度的最大比率。                                    |\r\n| max-color               | 定义输出设备每一组彩色原件的最大个数。                                          |\r\n| max-color-index         | 定义在输出设备的彩色查询表中的最大条目数。                                      |\r\n| max-device-aspect-ratio | 定义输出设备的屏幕可见宽度与高度的最大比率。                                    |\r\n| max-device-height       | 定义输出设备的屏幕可见的最大高度。                                              |\r\n| max-device-width        | 定义输出设备的屏幕最大可见宽度。                                                |\r\n| max-height              | 定义输出设备中的页面最大可见区域高度。                                          |\r\n| max-monochrome          | 定义在一个单色框架缓冲区中每像素包含的最大单色原件个数。                        |\r\n| max-resolution          | 定义设备的最大分辨率。                                                          |\r\n| max-width               | 定义输出设备中的页面最大可见区域宽度。                                          |\r\n| min-aspect-ratio        | 定义输出设备中的页面可见区域宽度与高度的最小比率。                              |\r\n| min-color               | 定义输出设备每一组彩色原件的最小个数。                                          |\r\n| min-color-index         | 定义在输出设备的彩色查询表中的最小条目数。                                      |\r\n| min-device-aspect-ratio | 定义输出设备的屏幕可见宽度与高度的最小比率。                                    |\r\n| min-device-width        | 定义输出设备的屏幕最小可见宽度。                                                |\r\n| min-device-height       | 定义输出设备的屏幕的最小可见高度。                                              |\r\n| min-height              | 定义输出设备中的页面最小可见区域高度。                                          |\r\n| min-monochrome          | 定义在一个单色框架缓冲区中每像素包含的最小单色原件个数                          |\r\n| min-resolution          | 定义设备的最小分辨率。min-width定义输出设备中的页面最小可见区域宽度。           |\r\n| monochrome              | 定义在一个单色框架缓冲区中每像素包含的单色原件个数。如果不是单色设备，则值等于0 |\r\n| orientation             | 定义输出设备中的页面可见区域高度是否大于或等于宽度。                            |\r\n| resolution              | 定义设备的分辨率。如：96dpi, 300dpi, 118dpcm                                    |\r\n| scan                    | 定义电视类设备的扫描工序。                                                      |\r\n| width                   | 定义输出设备中的页面可见区域宽度。                                              |\r\n","children":[]}]},{"name":"attribute","path":"../guanruihua.github.io/CSS","data":"","children":[{"name":"animation.md","path":"../guanruihua.github.io/CSS/attribute","data":"# animation\n\n> 名称：关键帧动画，帧动画  \n> `animation: 属性名 时长 过度方式 延迟 次数 方向 填充模式 是否暂停;`  \n> `animation: name duration timing-function delay iteration-count direction fill-mode;`\n\n| 属性   | 描述 |\n| -- | -- |\n| animation-name            | 指定 @keyframes 动画的`名称`。|\n| animation-duration        | 指定动画完成一个`周期`所需要时间，单位秒（s）或毫秒（ms），默认是 |\n| animation-timing-function | 指定动画`计时函数`，即动画的速度曲线，默认是 \"ease\"。|\n| animation-delay           | 指定动画`延迟时间`，即动画何时开始，默认是 0。|\n| animation-iteration-count | 指定动画`播放的次数`，默认是 1。|\n| animation-direction       | 指定动画`播放的方向`。默认是 normal。|\n| animation-fill-mode       | 指定动画`填充模式`。默认是 none。|\n| animation-play-state      | 指定动画`播放状态`，正在运行或暂停。默认是 running。|\n\n## animation-name\n\n> 通过`@keyframs`来定义关键帧动画\n\n```css\n/* 使用 */\nanimation： [name] 2s ;\n\n/* 等价于 */\nanimation-name: [name];\nanimation-duration: 2s;\n\n/* 定义 */\n@keyframes [name] {\n ....\n}\n```\n\n### @keyframes\n\n> 主要两种写法\n\n#### 百分率\n\n```css\n@keyframes [name] {\n 0%{\n    transform: rotate(0deg);\n  }\n  100%{\n    transform: rotate(360deg);\n  }\n \n\n@keyframes [name]{\n  0%, 66%{\n    transform: translate(0,0);\n  }\n  33%,100%{\n    transform: translate(200px,0);\n  }\n}\n```\n\n#### from & to\n\n```css\n@keyframes [name] {\n  from{\n    transform: rotate(0deg);\n  }\n  to{\n    transform: rotate(360deg);\n  }\n}\n```\n\n## animation-duration\n\n> 动画运行时间\n\n## animation-timing-function\n\n> 计时函数  \n> 常见值： `linear`,`ease`,`ease-in`,`ease-out`,`ease-in-out` （都是`cubicbezier(n,n,n,n)`的特例）\n\n## animation-delay\n\n## animation-iteration-count\n\n> 动画播放次数  \n> `infinite`: 无限播放\n\n## animation-direction\n\n> 指定动画按照指定顺序播放  \n> `normal`:默认值；  \n> `reverse`: 动画反向播放；  \n> `alternate`: 正向和反向交叉进行；  \n> `alternate-reverse`: 表反向和正向交叉进行；\n\n## animation-fill-mode\n\n> 填充模式\n> none: 默认值；  \n> forwards: 动画完成后保持最后一帧(停在最后一帧)  \n> backwards: 有动画颜值时，动画开始前，元素状态保持第一帧的状态  \n> both: 前两者均有；\n\n## animation-play-state\n\n> 表示动画播放状态  \n> `running`: 播放\n> `paused`: 暂停\n","children":[]},{"name":"background.md","path":"../guanruihua.github.io/CSS/attribute","data":"# background\n\n## basic\n\n> `background`: 是简写属性, 可以在一次声明中定义或多个属性, 除去特定的属性, 其他属性可以按照任意位置放置\n\n```css\nbackground ： [background-color] | [background-image] | [background-position][/background-size] | [background-repeat] | [background-attachment] | [background-clip] | [background-origin],...\n```\n\nCSS3 `background`支持多重背景，主要是靠`origin`、`clip`和`size`组成新的`background`多次叠加\n\n### 注意\n\n- `background` 属性被指定多个背景层时，使用逗号分隔每个背景层。每个属性用空格隔开\n- 如果有`size`的值必须紧跟着`position`，用 / 隔开\n- `background-color`只能设置一个值 且被包含在最后一层\n- `border-box/padding-box/content-box` 如果出现一次则同时设置`origin`和`clip`，如果出现两次 第一个指定`origin`，第二个指定`clip`\n- 多重背景，其他属性只有一个表示所有的背景共用一个属性的属性值\n\n### background-color\n\n> - `background-color`会设置元素的背景色，属性的值为颜色值或者关键字“transparent”二者选其一。\n> - `background-color`的优先级比`background-image`低，如果同时存在`background-color`和`background-image`时，image会显示在color上面\n\n```css\n/* Keyword values */\nbackground-color: red;\n\n/* Hexadecimal value */\nbackground-color: #bbff00;\n\n/* RGB value */\nbackground-color: rgb(255, 255, 128);\n\n/* HSLA value */\nbackground-color: hsla(50, 33%, 25%, 0.75);\n\n/* Special keyword values */\nbackground-color: currentColor; /* 纯白色*/\nbackground-color: transparent;\n\n/* Global values */\nbackground-color: inherit;\nbackground-color: initial;\nbackground-color: unset;\n```\n\n### background-image\n\n> background-image属性用于为一个元素设置一个或多个背景图像, 过关背景图像用`,`隔开\n>\n> `background-image:url('...') || linerat-gradient(渐变)|| none[无背景图]`\n\n```css\n/* html */\n<div class=\"border-image-color\"></div>\n/* css */\n.border-image-color {\n  width: 500px;\n  height: 400px;\n  border: 20px dashed yellowgreen;\n  background-image: url(https://user-gold-cdn.xitu.io/2020/3/19/170f20b3c106f518?w=642&h=339&f=png&s=107259);\n  background-repeat: no-repeat;\n  background-origin: border-box;\n  background-color: lightSkyBlue;\n  background-position: -60px -20px;\n}\n\n```\n\n> `background-image`的绘制方向在Z轴上堆叠方式，先指定的图像会在后指定图像上面\n>\n> `background-image`绘制在`border`之下，`background-color`之上\n>\n> `background-image`的绘制、显示位置与`background-position`、`background-clip`、`background-origin`相关\n\n![实例](https://user-gold-cdn.xitu.io/2020/3/20/170f597acad1d3a8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n### background-origin\n\n  `background-origin`规定了背景图片`background-image`属性的原点位置的背景相对区域，为`background-position`设置初始位置。但是当`background-attachment`为`fixed`时，此属性将被忽略，不起作用。\n\n#### 属性值： 默认值/padding-box\n\n- border-box 背景图片的摆放以border区域为参考\n- padding-box 背景图片的摆放以padding区域为参考\n- content-box 背景图片的摆放以content区域为参考\n\n### background-position\n\n  `background-position`为每个背景图片设置初始位置，`background-position`的原点是`background-origin`定义的位置，相对偏移量都是以原点为基准。\n\n#### 属性值：默认值/left top\n\n三种取值类型可以混合使用\n\n- 关键字\n  - `center`用来居中背景图片\n  - `left`、`right`指定图片放置于X轴的左右边缘\n  - `top`、`bottom`指定图片放置于Y轴的上下边缘\n- length 数值+ 'px'，指定相对于X,Y坐标的位置\n- percentage  百比分，指定相对于X,Y坐标的位置\n\n#### 值个数\n\n- 关键字取单个值，另外一个位置默认为 center\n- length、percentage取一个值 当前值同时指定X轴与Y轴的坐标\n- length、percentage取两个值，第一个值定义X轴的方向、第二值定义Y轴的方向\n- 四个值 position: bottom 10px right 20px;  关键字定义位置，length/percentage定义距离\n\n#### 扩展\n\n`background-position`属性已经得到扩展，它允许我们指定背景图片距离任意角的偏移量，只要我们在偏移量(`length`/`percentage`)前面指定关键字(`top`,`bottom`,`left`,`right`)\n\n#### percentage语法\n\n  百分比值的偏移指定图片的相对位置和容器相对位置重合。值0%表示图片的(左上)边界与容器(左上)边界重合，值100%代表图片的右边界（或下边界）和容器的右边界（或下边界）重合。值50%则代表图片的中点和容器的中点重合。\n\npercentage公式：\n  `(container width - image width) * (position x%) = (x offset value)`\n  `(container height - image height) * (position y%) = (y offset value)`  \n\n![img](https://user-gold-cdn.xitu.io/2020/3/20/170f5c2c5723acd3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n```css\n/* html */\n<div class=\"border-image-color\"></div>\n/* css */\n/*\n    图片宽度： 642px\n    容器宽度: 742px\n    容器宽度：，容器box-sizing与背景background-origin同步作用\n    若想X方向上移动20px：20px / (742px - 642px) = 20%\n    X方向上移动20%，实际移动像素值： (742px - 642px) * 20% = 20px\n    \n    其中若background-origin为padding-box\n    实际容器宽度应为包裹图片时原点origin控制的部分\n    容器宽度则需要减去边框40px，实际为702px，再在X轴移动20%时实际移动的像素：\n    (702px - 642px) * 20% = 12px\n*/\n.border-image-color {\n  box-sizing: border-box;\n  width: 742px;\n  height: 400px;\n  border: 20px dashed yellowgreen;\n  background-image: url(https://user-gold-cdn.xitu.io/2020/3/19/170f20b3c106f518?w=642&h=339&f=png&s=107259);\n  background-repeat: no-repeat;\n  background-origin: border-box;\n  background-color: lightSkyBlue;\n  background-position: 20% 0px;\n}\n```\n\n### background-size\n\n  `background-size`设置背景图片的大小。图片可以保有原有的尺寸，或者拉伸到新的尺寸，或者保持其原有比例的同时缩放到元素的可用空间尺寸\n\n#### 属性值：默认值/auto auto\n\n- 关键字\n  - auto 以背景图片的比例缩放背景图片。\n  - cover 缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。和 contain 值相反，cover值尽可能大的缩放背景图像并保持图像的宽高比例(图像不会被压扁)\n  - contain (背景区容纳背景图片)缩放背景图片以完全装入背景区，可能背景区部分空白。contain尽可能的缩放背景并保持图像的宽高比例(图像不会被压缩)\n\n![img](https://user-gold-cdn.xitu.io/2020/3/20/170f5f4c42de2970?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n- length 指定背景图的宽高，不能为负值\n- percentage 指定背景图片相对背景区(同`position`的容器宽高)的百分比。背景区由`background-origin`设置\n\n### background-repeat\n\n  `background-repeat`属性定义背景图像的重复方式。背景图像可以沿着水平轴，垂直轴，两个轴重复，或者根本不重复。\n\n| 属性      | 定义                                                         |\n| :-------- | :----------------------------------------------------------- |\n| repeat    | 图像会按需**重复来覆盖整个背景图片所在的区域**. 最后一个图像会被裁剪, 如果它的大小不合适的话. repeat-x、repeat-y指定单方向重复 |\n| space     | 图像会尽可能得重复, 但是不会裁剪. 第一个和最后一个图像会被固定在元素(element)的相应的边上, 同时空白会均匀地分布在图像之间. background-position属性会被忽视, 除非只有一个图像能被无裁剪地显示. 只在一种情况下裁剪会发生, 那就是图像太大了以至于没有足够的空间来完整显示一个图像. |\n| round     | 随着允许的空间在尺寸上的增长, 被重复的图像将会伸展(没有空隙), 直到有足够的空间来添加一个图像. 当下一个图像被添加后, 所有的当前的图像会被压缩来腾出空间. 例如, 一个图像原始大小是260px, 重复三次之后, 可能会被伸展到300px, 直到另一个图像被加进来. 这样他们就可能被压缩到225px. |\n| no-repeat | 图像不会被重复(因为背景图像所在的区域将可能没有完全被覆盖). 那个没有被重复的背景图像的位置是由background-position属性来决定. |\n\n| <img src=\"https://user-gold-cdn.xitu.io/2020/3/20/170f60a5313a224c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"round\" style=\"zoom: 33%;\" /> | <img src=\"https://user-gold-cdn.xitu.io/2020/3/20/170f609015dc74b3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"space\" style=\"zoom: 33%;\" /> |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n|                                                              |                                                              |\n\n### background-attachment\n\n  `background-attachment`属性决定背景图像的位置是在视口内固定，还是随着包含它的区块滚动。\n\n#### 属性值\n\n- fixed 表示背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动\n- local 表示背景相对于元素的内容固定。如果一个元素拥有滚动机制，背景将会随着元素的内容滚动， 并且背景的绘制区域和定位区域是相对于可滚动的区域而不是包含他们的边框。\n- scroll 示背景相对于元素本身固定，而不是随着它的内容滚动（对元素边框是有效的）。\n\n### background-clip\n\n  `background-clip`设置元素的背景（背景图片或颜色）是否延伸到边框下面\n\n#### 取值：默认值/border-box\n\n- border-box 背景延伸至边框外沿（但是在边框下层）\n- padding-box 背景延伸至内边距（padding）外沿。不会绘制到边框处\n- content-box 背景被裁剪至内容区（content box）外沿\n- text 背景被裁剪成文字的前景色,属性值为text时 属性应设置为 `-webkit-background-clip`, 字体的颜色使用背景色 即`color: transparent`/`-webkit-text-fill-color: transparent`;\n\n```css\n/* html */\n<div class=\"border-image-color\">\n  text\n</div>\n/* css */\n.border-image-color {\n  box-sizing: border-box;\n  width: 642px;\n  height: 400px;\n  font-size: 100px;\n  line-height: 300px;\n  text-align: center;\n  border: 20px dashed yellowgreen;\n  background-image: url(https://user-gold-cdn.xitu.io/2020/3/19/170f20b3c106f518?w=642&h=339&f=png&s=107259);\n  background-repeat: no-repeat;\n  background-origin: border-box;\n  -webkit-background-clip: text;\n  color: transparent;\n}\n```\n\n![clip:text](https://user-gold-cdn.xitu.io/2020/3/20/170f616e1f91ffb1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n### 多重背景使用实例\n\n> 工作场景： 官网主页底部为铺满不同的图片，图片之上再进行 基本的图片文字排版\n\n> 使用多重背景处理可以避免冗余空的html元素格外铺图片，避免伪元素和伪类去进行多余的position定位\n\n![多图片为底](https://user-gold-cdn.xitu.io/2020/3/20/170f6d6502c3d6c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n```css\n/* html */\n<div class=\"border-image-color\">\n  <div class=\"section\">\n    我是排版一\n  </div>\n  <div class=\"section\">\n    我是排版二\n  </div>\n</div>\n\n/* css */\n.border-image-color {\n  display: flex;\n  flex-direction: column;\n  box-sizing: border-box;\n  width: 600px;\n  height: 580px;\n  border: 1px solid yellowgreen;\n  text-align: center;\n  background: url(https://user-gold-cdn.xitu.io/2020/3/20/170f5f4c42de2970?w=672&h=299&f=png&s=146779) 0px 0px,\n              url(https://user-gold-cdn.xitu.io/2020/3/19/170f20b3c106f518?w=642&h=339&f=png&s=107259) 0px 250px;\n  background-size: contain 250px;\n  background-repeat: no-repeat;\n}\n.section {\n  width: 400px;\n  height: 200px;\n  line-height: 200px;\n  margin: 30px auto;\n  text-align: center;\n  background-color: rgba(0,0,0, .8);\n  color: #fff;\n}\n```\n\n## CSS backgroundImage 7个好用的技巧\n\n### 背景图完美适配视口\n\n```css\nbody {\n  background-image: url('https://images.unsplash.com/photo-1573480813647-552e9b7b5394?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2253&q=80');\n  background-repeat: no-repeat;\n  background-position: center;\n  background-attachment: fixed;\n  background-size: cover;\n  -webkit-background-size: cover;\n  -moz-background-size: cover;\n  -o-background-size: cover;\n}\n```\n\n![clipboard.png](https://segmentfault.com/img/bVbHhuO)\n\n### 在CSS中使用多个背景图片\n\n```css\nbody {\n  background-image: url(https://image.flaticon.com/icons/svg/748/748122.svg), url(https://images.unsplash.com/photo-1478719059408-592965723cbc?ixlib=rb-1.2.1&auto=format&fit=crop&w=2212&q=80);\n  background-position: center, top;\n  background-repeat: repeat, no-repeat;\n  background-size: contain, cover;\n}\n```\n\n![clipboard.png](https://segmentfault.com/img/bVbG9V2)\n\n### 创建一个三角形的背景图像\n\n另一个很酷的背景特效就是三角形背景，当我们想展示某些完全不同的选择（例如白天和黑夜或冬天和夏天）时，这种特效就更加棒。\n\n思路是这样的，首先创建两个`div`，然后将两个背景都添加到其中，然后，第二个`div`使用`clip-path`属性画出三角形。\n\n![clipboard.png](https://segmentfault.com/img/bVbHhsp)\n\n```html\n<body>\n  <div class=\"day\"></div>\n  <div class=\"night\"></div>\n</body>\n```\n\n```css\nbody {\n  margin: 0;\n  padding: 0;\n}\n\ndiv {\n  position: absolute;\n  height: 100vh;\n  width: 100vw;\n}\n\n.day {\n  background-image: url(\"https://images.unsplash.com/photo-1477959858617-67f85cf4f1df?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2613&q=80\");\n  background-size: cover;\n  background-repeat: no-repeat;\n}\n\n.night {\n  background-image: url(\"https://images.unsplash.com/photo-1493540447904-49763eecf55f?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2250&q=80\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  clip-path: polygon(100vw 0, 0% 0vh, 100vw 100vh);\n}\n```\n\n> `clip-path`: 使用裁剪方式穿啊金元素的可显示区域, 区域内的部分显示, 区域外隐藏\n>\n> `clip-path: polygon(100vw 0, 0% 0vh, 100vw 100vh);`\n>\n> - polygon是多边形里面是指定的端点\n>\n> <https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path>\n\n### 背景图像上添加叠加渐变\n\n有时我们想在背景上添加一些文字，但有的图片太亮，导致字看不清楚，所以这里我们就需要让背景图叠加一些暗乐来突出文字效果。\n\n例如，可以通过添加粉红橙色渐变或红色至透明渐变来增强日落图像，这些情况下使用叠加的渐变就很容易做到。\n\n![clipboard.png](https://segmentfault.com/img/bVbHhtM)\n\n**css**\n\n```css\nbody {\n  background-image: \n    linear-gradient(4deg, rgba(38,8,31,0.75) 30%, rgba(213,49,127,0.3) 45%, rgba(232,120,12,0.3) 100%),\n    url(\"https://images.unsplash.com/photo-1503803548695-c2a7b4a5b875?ixlib=rb-1.2.1&auto=format&fit=crop&w=2250&q=80\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: center\n}\n```\n\n### 创建一个颜色动态变化的背景\n\n如果你很多颜色，你想确认哪种颜色更适合背景图片的颜色，刚动态更改背景颜色的技巧就很有用。\n\n```css\n@keyframes background-overlay-animation {\n  0%   {\n      background-image: \n        linear-gradient(4deg, rgba(255,78,36,0.3) 50%, rgba(255,78,36,0.3) 100%), url(\"https://images.unsplash.com/photo-1559310589-2673bfe16970?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2250&q=80\");\n  }\n  25%  {\n      background-image: \n         linear-gradient(4deg, rgba(213,49,127,0.3) 50%, rgba(213,49,127,0.3) 100%), url(\"https://images.unsplash.com/photo-1559310589-2673bfe16970?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2250&q=80\");\n  }\n  50%  {\n    background-image: \n       linear-gradient(4deg, rgba(36,182,255,0.3) 50%, rgba(36,182,255,1) 100%),\n     url(\"https://images.unsplash.com/photo-1559310589-2673bfe16970?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2250&q=80\");\n  }\n  100% {\n    background-image: \n        linear-gradient(4deg, rgba(0,255,254,0.3) 50%, rgba(0,255,254,0.3) 100%),\n        url(\"https://images.unsplash.com/photo-1559310589-2673bfe16970?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2250&q=80\");\n  }\n}\n\n@-webkit-keyframes background-overlay-animation {\n  0%   {\n      background-image: \n        linear-gradient(4deg, rgba(255,78,36,0.3) 50%, rgba(255,78,36,0.3) 100%)\n        url(\"https://images.unsplash.com/photo-1559310589-2673bfe16970?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2250&q=80\");\n  }\n  25%  {\n      background-image: \n         linear-gradient(4deg, rgba(213,49,127,0.3) 50%, rgba(213,49,127,0.3) 100%),\n        url(\"https://images.unsplash.com/photo-1559310589-2673bfe16970?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2250&q=80\");\n  }\n  50%  {\n    background-image: \n       linear-gradient(4deg, rgba(36,182,255,0.3) 50%, rgba(36,182,255,1) 100%),\n     url(\"https://images.unsplash.com/photo-1559310589-2673bfe16970?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2250&q=80\");\n  }\n  100% {\n    background-image: \n        linear-gradient(4deg, rgba(0,255,254,0.3) 50%, rgba(0,255,254,0.3) 100%),\n  \n```\n\n![图片描述](https://segmentfault.com/img/bVbHhtY)\n\n### 制作网格背景图像\n\n![clipboard.png](https://segmentfault.com/img/bVbHhum)\n\n```html\n<body>\n<div class=\"container\">\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n</div>\n</body>\n```\n\n```scss\nbody {\n margin: 0;\n  padding: 0;\n}\n\n.container {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    background: black;\n    display: grid;\n    grid-template-columns: 25fr 30fr 40fr 15fr;\n    grid-template-rows: 20fr 45fr 5fr 30fr;\n    grid-gap: 20px;\n    .item_img {\n      background-image: url('https://images.unsplash.com/photo-1499856871958-5b9627545d1a?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2207&q=80');\n    background-repeat: no-repeat;\n    background-position: center;\n    background-attachment: fixed;\n    background-size: cover;\n  }\n}\n```\n\n> `fr`: 是一个自适应单位, 用于在一系列长度值中分配剩余空间，如果多个已指定了多个部分，则剩下的空间根据各自的数字按比例分配。\n\n### 将背景图像设置为文本颜色\n\n使用`background-image`与` background-clip `，可以实现背景图像对文字的优美效果。 在某些情况下，它可能非常有用，尤其是当我们想创建一个较大的文本标题而又不如普通颜色那么枯燥的情况。\n\n![图片描述](https://segmentfault.com/img/bVbHhuz)\n\n```html\n<body>\n  <h1>Hello world!</h1>\n</body>\n```\n\n```scss\nbody {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: column;\n  width: 100%;\n  text-align: center;\n  min-height: 100vh;\n  font-size: 120px;\n  font-family:Arial, Helvetica, sans-serif;\n}\n\nh1 {\n   background-image: url(\"https://images.unsplash.com/photo-1462275646964-a0e3386b89fa?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2600&q=80\");\n  background-clip: text;\n  -webkit-background-clip: text;\n  color: transparent;\n}\n```\n","children":[]},{"name":"contain.md","path":"../guanruihua.github.io/CSS/attribute","data":"# contain\n\n`contain` 属性允许我们指定特定的 DOM 元素和它的子元素，让它们能够独立于整个 DOM 树结构之外。目的是能够让浏览器有能力只对部分元素进行重绘、重排，而不必每次都针对整个页面。\n\n> The contain property allows an author to indicate that an element and its contents are, as much as possible, independent of the rest of the document tree. This allows the browser to recalculate layout, style, paint, size, or any combination of them for a limited area of the DOM and not the entire page.\n\n## `contain` 语法\n\n看看它的语法：\n\n```CSS\n{\n  /* No layout containment. */\n  contain: none;\n  /* Turn on size containment for an element. */\n  contain: size;\n  /* Turn on layout containment for an element. */\n  contain: layout;\n  /* Turn on style containment for an element. */\n  contain: style;\n  /* Turn on paint containment for an element. */\n  contain: paint;\n\n  /* Turn on containment for layout, paint, and size. */\n  contain: strict;\n  /* Turn on containment for layout, and paint. */\n  contain: content;\n}\n\n```\n\n除去 `none`，取值还有 6 个，我们一个一个来看看。\n\n## contain: size\n\ncontain: size: 设定了 `contain: size` 的元素的渲染不会受到其子元素内容的影响。\n\n> The value turns on size containment for the element. This ensures that the containing box can be laid out without needing to examine its descendants.\n\n我开始看到这个定义也是一头雾水，光看定义很难明白到底是什么意思。还需实践一番：\n\n假设我们有如下简单结构：\n\n```HTML\n<div class=\"container\">\n   \n</div>\n\n.container {\n    width: 300px;\n    padding: 10px;\n    border: 1px solid red;\n}\n\np {\n    border: 1px solid #333;\n    margin: 5px;\n    font-size: 14px;\n}\n\n```\n\n并且，借助 jQuery 实现每次点击容器添加一个 `<p>Coco</p>` 结构：\n\n```javascript\n$('.container').on('click', e => {\n    $('.container').append('<p>Coco</p>')\n})\n\n```\n\n那么会得到如下结果：\n\n![containsize](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad0040e236d245649f52d199cd25ff6b~tplv-k3u1fbpfcp-watermark.awebp)\n\n可以看到，容器 `.container` 的高度是会随着元素的增加而增加的，这是正常的现象。\n\n此刻，我们给容器 `.container` 添加一个 `contain: size`，也就会出现上述说的：**设定了 `contain: size` 的元素的渲染不会受到其子元素内容的影响**。\n\n```CSS\n.container {\n    width: 300px;\n    padding: 10px;\n    border: 1px solid red;\n+   contain: size\n}\n\n```\n\n再看看会发生什么：\n\n![containsize2](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41c8e8578776435591bcc23a096e355b~tplv-k3u1fbpfcp-watermark.awebp)\n\n正常而言，父元素的高度会因为子元素的增多而被撑高，而现在，子元素的变化不再影响父元素的样式布局，这就是 `contain: size` 的作用。\n\n## contain: style\n\n接下来再说说 `contain: style`、`contain: layout` 、`contain: paint`。先看看 contain: style。\n\n截止至本文书写的过程中，`contain: style` 暂时被移除了。\n\n> [CSS Containment Module Level 1](https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FTR%2Fcss-contain-1%2F): Drop the at-risk “style containment” feature from this specification, move it Level 2。\n\n嗯，官方说辞是因为存在某些风险，暂时被移除，可能在规范的第二版会重新定义吧，那这个属性也暂且放一放。\n\n## contain: paint\n\ncontain: paint：设定了 `contain: paint` 的元素即是设定了布局限制，也就是说告知 User Agent，此元素的子元素不会在此元素的边界之外被展示，因此，如果元素不在屏幕上或以其他方式设定为不可见，则还可以保证其后代不可见不被渲染。\n\n> This value turns on paint containment for the element. This ensures that the descendants of the containing box don’t display outside its bounds, so if an element is off-screen or otherwise not visible, its descendants are also guaranteed to be not visible.\n\n这个稍微好理解一点，先来看第一个特性：\n\n### 设定了 `contain: paint` 的元素的子元素不会在此元素的边界之外被展示\n\n- 设定了 `contain: paint` 的元素的子元素不会在此元素的边界之外被展示\n\n这个特点有点类似与 `overflow: hidden`，也就是明确告知用户代理，子元素的内容不会超出元素的边界，所以超出部分无需渲染。\n\n简单示例，假设元素结构如下：\n\n```HTML\n<div class=\"container\">\n    <p>Coco</p>\n</div>\n\n.container {\n    contain: paint;\n    border: 1px solid red;\n}\n\np{\n    left: -100px;\n}\n\n```\n\n我们来看看，设定了 `contain: paint` 与没设定时会发生什么：\n\n![containsize3](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1edabb7b354493cb0ed38a5c03b9db6~tplv-k3u1fbpfcp-watermark.awebp)\n\n[CodePen Demo -- contain: paint Demo](https://link.juejin.cn?target=https%3A%2F%2Fcodepen.io%2FChokcoco%2Fpen%2FKKwmgmN)\n\n### 设定了 `contain: paint` 的元素在屏幕之外时不会渲染绘制\n\n通过使用 `contain: paint`， 如果元素处于屏幕外，那么用户代理就会忽略渲染这些元素，从而能更快的渲染其它内容。\n\n## contain: layout\n\ncontain: layout：设定了 `contain: layout` 的元素即是设定了布局限制，也就是说告知 User Agent，此元素内部的样式变化不会引起元素外部的样式变化，反之亦然。\n\n> This value turns on layout containment for the element. This ensures that the containing box is totally opaque for layout purposes; nothing outside can affect its internal layout, and vice versa.\n\n启用 `contain: layout` 可以潜在地将每一帧需要渲染的元素数量减少到少数，而不是重新渲染整个文档，从而为浏览器节省了大量不必要的工作，并显着提高了性能。\n\n使用 `contain：layout`，开发人员可以指定对该元素任何后代的任何更改都不会影响任何外部元素的布局，反之亦然。\n\n因此，浏览器仅计算内部元素的位置（如果对其进行了修改），而其余DOM保持不变。因此，这意味着帧渲染管道中的布局过程将加快。\n\n### 存在的问题\n\n描述很美好，但是在实际 Demo 测试的过程中（截止至2021/04/27，Chrome 90.0.4430.85），仅仅单独使用 `contain：layout` 并没有验证得到上述那么美好的结果。\n\n**设定了 `contain: layout` 的指定元素，改元素的任何后代的任何更改还是会影响任何外部元素的布局**，点击红框会增加一条 `<p>Coco<p>` 元素插入到 `container` 中：\n\n简单的代码如下：\n\n```HTML\n<div class=\"container\">\n    <p>Coco</p>\n    ...\n</div>\n<div class=\"g-test\"></div>\n\nhtml,\nbody {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: column;\n    gap: 10px;\n}\n\n.container {\n    width: 150px;\n    padding: 10px;\n    contain: layout;\n    border: 1px solid red;\n}\n\n.g-test {\n    width: 150px;\n    height: 150px;\n    border: 1px solid green;\n}\n\n```\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02c6ecc821d845e593faa7c8f83e1550~tplv-k3u1fbpfcp-watermark.awebp)\n\n[CodePen Demo -- contain: layout Demo](https://link.juejin.cn?target=https%3A%2F%2Fcodepen.io%2FChokcoco%2Fpen%2FrNjRELL)\n\n目前看来，`contain: layout` 的实际作用不那么明显，更多的关于它的用法，你可以再看看这篇文章：[CSS-tricks - contain](https://link.juejin.cn?target=https%3A%2F%2Fcss-tricks.com%2Falmanac%2Fproperties%2Fc%2Fcontain%2F)\n\n## contain: strict | contain: content\n\n这两个属性稍微有点特殊，效果是上述介绍的几个属性的聚合效果：\n\n- `contain: strict`：同时开启 layout、style、paint 以及 size 的功能，它相当于 `contain: size layout paint`\n- `contain: content`：同时开启 layout、style 以及 paint 的功能，它相当于 `contain: layout paint`\n\n所以，这里也提一下，contain 属性是可以同时定义几个的。\n\n## Can i Use -- CSS Contain\n\n截止至 2021-04-27，Can i Use  上的 CSS Contain 兼容性，已经可以开始使用起来：\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c34ec138a05b4cc6916aad01600ed651~tplv-k3u1fbpfcp-watermark.awebp)\n\n## 参考文献\n\n- [CSS Containment Module Level 1](https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FTR%2Fcss-contain-1%2F)\n- [CSS containment](https://link.juejin.cn?target=https%3A%2F%2Fjustmarkup.com%2Farticles%2F2016-04-05-css-containment%2F)\n- [CSS Containment in Chrome 52](https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Fupdates%2F2016%2F06%2Fcss-containment)\n","children":[]},{"name":"content-visibility.md","path":"../guanruihua.github.io/CSS/attribute","data":"# content-visibility\r\n\r\n属性值\r\n\r\n> `content-visibility`是CSS新增的属性，\r\n> 主要用来提高页面渲染性能，它可以控制一个元素是否渲染其内容，并且允许浏览器跳过这些元素的布局与渲染。\r\n\r\n- visible：默认值，没有效果。元素的内容被正常布局和呈现\r\n- hidden：元素跳过它的内容。跳过的内容不能被用户代理功能访问，例如在页面中查找、标签顺序导航等，也不能被选择或聚焦。这类似于给内容设置`display: none`\r\n- auto：该元素打开布局包含、样式包含和绘制包含。如果该元素与用户不相关，它也会跳过其内容。与 hidden 不同，跳过的内容必须仍可正常用于用户代理功能，例如在页面中查找、tab 顺序导航等，并且必须正常可聚焦和可选择, 只有在可视区域才会被渲染\r\n\r\n## `content-visibility: hidden`手动管理可见性\r\n\r\n与display: none区别：\r\n\r\n- `content-visibility: hidden` 只是隐藏了子元素，自身不会被隐藏\r\n- `content-visibility: hidden` 隐藏内容的渲染状态会被缓存，所以当它被移除或者设为可见时，浏览器不会重新渲染，而是会应用缓存，所以对于需要频繁切换显示隐藏的元素，这个属性能够极大地提高渲染性能\r\n\r\n## `content-visibility: auto`\r\n\r\n> 只有在可视区域才会被渲染\r\n\r\n### 问题\r\n\r\n> 渲染元素前, 当前元素的高度为0, 滚动时候就会出现混乱\r\n> 结合`contain-intrinsic-size` 来解决\r\n\r\n## `contain-intrinsic-size`\r\n\r\n> 指定元素的自然大小, 确保没有被渲染元素占据控件, 同事也保留延迟渲染的好处\r\n\r\n是以下css的简写\r\n\r\n- `contain-intrinsic-width`\r\n- `contain-intrinsic-height`\r\n\r\n```css\r\n/* Keyword values */\r\ncontain-intrinsic-width: none;\r\n\r\n/* <length> values */\r\ncontain-intrinsic-size: 1000px;\r\ncontain-intrinsic-size: 10rem;\r\n\r\n/* width | height */\r\ncontain-intrinsic-size: 1000px 1.5em;\r\n\r\n/* auto <length> */\r\ncontain-intrinsic-size: auto 300px;\r\n\r\n/* auto width | auto height */\r\ncontain-intrinsic-size: auto 300px auto 4rem;\r\n```\r\n\r\n## 实现\r\n\r\n```css\r\n.card_item {\r\n  content-visibility: auto;\r\n  contain-intrinsic-size: 200px;\r\n}\r\n```\r\n\r\n## 兼容性\r\n\r\n> `content-visibility`\r\n\r\n![](./__assets__/content-visibility-2022-11-23-14-11-44.png)\r\n\r\n> `contain-intrinsic-size`\r\n\r\n![](./__assets__/content-visibility-2022-11-23-14-27-26.png)\r\n","children":[]},{"name":"css-动画.md","path":"../guanruihua.github.io/CSS/attribute","data":"# css动画\n\n> CSS动画(transform, transition, animation)\n\n## 浏览器渲染原理\n\n[![0DhCRO.md.png](https://s1.ax1x.com/2020/10/09/0DhCRO.md.png)](https://imgchr.com/i/0DhCRO)\n\n### 浏览器渲染过程\n\n1. 根据html标记构建DOM树\n2. 根据CSS构建css树(CSSDOM)\n3. 将两棵树合并成一棵渲染树(render tree)\n4. layout布局(文档流, 盒模型, 大小等)\n5. paint绘制(边框颜色, 背景颜色等)\n6. compose合成(根据层叠关系展示画面)\n\n### 更新样式的三种方式\n\n#### JS / CSS > 样式 > 布局 > 绘制 > 合成\n\n![img](https://user-gold-cdn.xitu.io/2020/5/4/171dde4a96e82fe1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n- 根据浏览器的渲染原理，若是开发者**更新了样式**（即元素的几何属性，类似于宽高，位置等）\n- 则浏览器会检查所有属性然后重新绘制，最后再合成。\n\n#### JS / CSS > 样式 > 绘制 > 合成\n\n![img](https://user-gold-cdn.xitu.io/2020/5/4/171dde4fe149e0a2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n- 如果开发者只是更新了`paint only`的属性（例如背景，文字颜色等）\n- 由于不影响页面布局，则浏览器直接执行绘制。\n\n#### JS / CSS > 样式 > 合成\n\n![img](https://user-gold-cdn.xitu.io/2020/5/4/171dde5405781ebe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n- 在开发者只是更改**一个既不更改布局也不需要绘制的属性时**，\n- 浏览器将只执行合成，例如动画和`transform`。\n","children":[]},{"name":"font-variant-numeric.md","path":"../guanruihua.github.io/CSS/attribute","data":"# `font-variant-numeric`\r\n\r\n## 值\r\n\r\n```css\r\nfont-variant-numeric: normal;\r\nfont-variant-numeric: ordinal;\r\nfont-variant-numeric: slashed-zero;\r\nfont-variant-numeric: lining-nums;         /* <numeric-figure-values> */\r\nfont-variant-numeric: oldstyle-nums;       /* <numeric-figure-values> */\r\nfont-variant-numeric: proportional-nums;   /* <numeric-spacing-values> */\r\nfont-variant-numeric: tabular-nums;        /* <numeric-spacing-values> */\r\nfont-variant-numeric: diagonal-fractions;  /* <numeric-fraction-values> */\r\nfont-variant-numeric: stacked-fractions;   /* <numeric-fraction-values> */\r\nfont-variant-numeric: oldstyle-nums stacked-fractions;\r\n\r\n/* Global values */\r\nfont-variant-numeric: inherit;\r\nfont-variant-numeric: initial;\r\nfont-variant-numeric: unset;\r\n```\r\n\r\n- normal\r\n下列特性均不启用。\r\n\r\n- `ordinal`\r\n启用序数形式显示。对序号标记强制启用特殊字形，如英文中的 $1^{st}$，$2^{nd}$，$3^{rd}$，$4^{th}$ ，意大利文中的 $1^a$。等同于 OpenType 特性 ordn。\r\n- `slashed-zero`\r\n启用区分零显示。强制使用带有斜杠的 0；常用于区分 O 和 0。等同于 OpenType 特性 zero。\r\n- `<numeric-figure-values>`\r\n下列值用于控制数字样式，可用值如下：\r\n  - lining-nums 启用内衬数字显示。使数字全部对齐到基线。等同于 OpenType 特性 lnum。\r\n  - oldstyle-nums 启用旧式数字显示。部分数字如 3、4、7、9 会有下沉。等同于 OpenType 特性 onum。\r\n- `<numeric-spacing-values>`\r\n下列值用于控制数字宽度，可用值如下：\r\n- `proportional-nums` 启用比例数字显示。使数字变成基于字形本身形状下的特定宽度表现。等同于 OpenType 特性 `pnum`\r\n- `tabular-nums` 启用表格数字显示。使数字等宽，易于像表格那样对齐。等同于 `OpenType` 特性 `tnum`\r\n- `<numeric-fraction-values>`\r\n下列值用于控制分数字形，可用值如下：\r\n  - `diagonal-fractions` 启用斜角分数显示。使分子和分母变成像下标字，并用变长的斜线分隔。等同于 `OpenType` 特性 frac。\r\n  - `stacked-fractions` 启用标准分数显示。使分子在上，分母在下，并用水平线分隔。等同于 `OpenType` 特性 afrc。\r\n\r\n## 兼容性\r\n\r\n![](./__assets__/font-variant-numeric-2022-07-14-15-43-50.png)\r\n","children":[]},{"name":"gap.md","path":"../guanruihua.github.io/CSS/attribute","data":"# [`gap`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/gap)\r\n\r\n> 属性是用来设置网格行与列之间的间隙（gutters），该属性是 row-gap 和 column-gap 的简写形式。\r\n\r\n![](./__assets__/gap-2022-11-04-10-34-12.png)\r\n","children":[]},{"name":"isolation.md","path":"../guanruihua.github.io/CSS/attribute","data":"# `isolation`\r\n\r\n- 决定一个元素是否要创建一个新的层叠上下文\r\n\r\n```html\r\n<section>\r\n  <h1>\r\n    <span>Elaborate title</span>\r\n  </h1>\r\n</section>\r\n\r\n<article>\r\n  This is a <span class=\"tooltip-parent\"><u>tooltip</u>\r\n    <span class=\"tooltip\">\r\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit. In ac vulputate augue, sed consequat velit. Praesent rhoncus viverra ullamcorper.\r\n    </span>\r\n\r\n  </span> that is in a hovered state for your convinience.\r\n\r\n  <p> Lorem ipsum dolor sit amet, consectetur adipiscing elit. In ac vulputate augue, sed consequat velit. Praesent rhoncus viverra ullamcorper.\r\n  </p>\r\n  \r\n  <p>\r\n    In eu erat commodo enim varius feugiat ac vitae arcu. Aenean id varius justo. Curabitur eget mollis nibh. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Vestibulum eu sapien sed lorem imperdiet auctor sit amet in felis. Donec non sem vel turpis laoreet pretium vitae sit amet odio. In sit amet fermentum arcu. Ut fringilla risus ac venenatis euismod. Donec non eleifend purus. Suspendisse a aliquet tellus. Maecenas bibendum commodo augue et porta.\r\n  </p>\r\n</article>\r\n```\r\n\r\n```css\r\n*,\r\n*::before {\r\n  box-content: content-box;\r\n}\r\n\r\nh1 {\r\n  isolation: isolate;\r\n  font-size: 64px;\r\n  text-transform: uppercase;\r\n  margin: 0;\r\n  position: relative;\r\n  display: inline-block;\r\n  margin-bottom: 0.5em;\r\n}\r\n\r\nh1 span {\r\n  position: relative;\r\n  z-index: 999999;\r\n  padding: 0 0.25em;\r\n}\r\n\r\nh1::before {\r\n  content: \"\";\r\n  width: 100%;\r\n  height: 20px;\r\n  background-color: goldenrod;\r\n  opacity: 0.6;\r\n  z-index: 1;\r\n  position: absolute;\r\n  top: 60%;\r\n  left: 0;\r\n  transform: skew(-45deg, 0);\r\n  transform-origin: 50% 50%;\r\n}\r\n\r\nbody {\r\n  padding: 3rem 2rem;\r\n  width: 768px;\r\n  margin: 0 auto;\r\n  line-height: 1.5;\r\n  color: #111111;\r\n}\r\n\r\nu {\r\n  color: darkgoldenrod;\r\n  font-weight: 600;\r\n}\r\n\r\n.tooltip-parent {\r\n  \r\n  position: relative;\r\n  display: inline-block;\r\n}\r\n\r\n.tooltip {\r\n  isolation: isolate;\r\n  width: 300px;\r\n  z-index: 1;\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  transform: translate3d(0, calc(-100% - 16px), 0);\r\n  background-color: #ffffff;\r\n  padding: 0.5rem;\r\n  border: 2px solid darkgoldenrod;\r\n  border-radius: 4px;\r\n}\r\n\r\n.tooltip::before {\r\n  content: \"\";\r\n  width: 0; \r\n  height: 0; \r\n  border-left: 12px solid transparent;\r\n  border-right: 12px solid transparent;\r\n  border-top :12px solid darkgoldenrod;\r\n  position: absolute;\r\n  top: 100%;\r\n  margin-top: 1px;\r\n  left:12px;\r\n  z-index: -1;\r\n}\r\n\r\n```\r\n\r\n<section>\r\n  <h1>\r\n    <span>Elaborate title</span>\r\n  </h1>\r\n</section>\r\n\r\n<article>\r\n  This is a <span class=\"tooltip-parent\"><u>tooltip</u>\r\n    <span class=\"tooltip\">\r\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit. In ac vulputate augue, sed consequat velit. Praesent rhoncus viverra ullamcorper.\r\n    </span>\r\n\r\n  </span> that is in a hovered state for your convinience.\r\n\r\n  <p> Lorem ipsum dolor sit amet, consectetur adipiscing elit. In ac vulputate augue, sed consequat velit. Praesent rhoncus viverra ullamcorper.\r\n  </p>\r\n  \r\n  <p>\r\n    In eu erat commodo enim varius feugiat ac vitae arcu. Aenean id varius justo. Curabitur eget mollis nibh. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Vestibulum eu sapien sed lorem imperdiet auctor sit amet in felis. Donec non sem vel turpis laoreet pretium vitae sit amet odio. In sit amet fermentum arcu. Ut fringilla risus ac venenatis euismod. Donec non eleifend purus. Suspendisse a aliquet tellus. Maecenas bibendum commodo augue et porta.\r\n  </p>\r\n</article>\r\n\r\n<style>\r\n*,\r\n*::before {\r\n  box-content: content-box;\r\n}\r\n\r\nh1 {\r\n  isolation: isolate;\r\n  font-size: 64px;\r\n  text-transform: uppercase;\r\n  margin: 0;\r\n  position: relative;\r\n  display: inline-block;\r\n  margin-bottom: 0.5em;\r\n}\r\n\r\nh1 span {\r\n  position: relative;\r\n  z-index: 999999;\r\n  padding: 0 0.25em;\r\n}\r\n\r\nh1::before {\r\n  content: \"\";\r\n  width: 100%;\r\n  height: 20px;\r\n  background-color: goldenrod;\r\n  opacity: 0.6;\r\n  z-index: 1;\r\n  position: absolute;\r\n  top: 60%;\r\n  left: 0;\r\n  transform: skew(-45deg, 0);\r\n  transform-origin: 50% 50%;\r\n}\r\n\r\nbody {\r\n  padding: 3rem 2rem;\r\n  width: 768px;\r\n  margin: 0 auto;\r\n  line-height: 1.5;\r\n  color: #111111;\r\n}\r\n\r\nu {\r\n  color: darkgoldenrod;\r\n  font-weight: 600;\r\n}\r\n\r\n.tooltip-parent {\r\n  \r\n  position: relative;\r\n  display: inline-block;\r\n}\r\n\r\n.tooltip {\r\n  isolation: isolate;\r\n  width: 300px;\r\n  z-index: 1;\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  transform: translate3d(0, calc(-100% - 16px), 0);\r\n  background-color: #ffffff;\r\n  padding: 0.5rem;\r\n  border: 2px solid darkgoldenrod;\r\n  border-radius: 4px;\r\n}\r\n\r\n.tooltip::before {\r\n  content: \"\";\r\n  width: 0;\r\n  height: 0;\r\n  border-left: 12px solid transparent;\r\n  border-right: 12px solid transparent;\r\n  border-top :12px solid darkgoldenrod;\r\n  position: absolute;\r\n  top: 100%;\r\n  margin-top: 1px;\r\n  left:12px;\r\n  z-index: -1;\r\n}\r\n</style>\r\n\r\n## 兼容性\r\n\r\n![](./__assets__/isolation-2022-07-14-14-59-35.png)\r\n","children":[]},{"name":"mix-blend-mode.md","path":"../guanruihua.github.io/CSS/attribute","data":"# [mix-blend-mode](https://developer.mozilla.org/zh-CN/docs/Web/CSS/mix-blend-mode)\r\n\r\n> 属性描述了元素的内容应该与元素的直系父元素的内容和元素的背景如何混合\r\n\r\n![](./__assets__/mix-blend-mode-2022-11-04-10-43-52.png)\r\n","children":[]},{"name":"overflow.md","path":"../guanruihua.github.io/CSS/attribute","data":"# overflow\r\n\r\n## overflow:clip\r\n\r\n> 视觉上和`overflow: hidden`一样\r\n> 设置 overflow: hidden 就会创建 BFC，自然没法只限制一个方向；而 clip 不会创建 BFC，这是本质原因。同时，BFC 还会带来的一些小区别这里也会有体现，比如 float 是否能限制在元素内，relative 定位的基准啥的\r\n","children":[]},{"name":"pointer-events.md","path":"../guanruihua.github.io/CSS/attribute","data":"# pointer-events\r\n\r\n> 指定在什么情况下 (如果有) 某个特定的图形元素可以成为鼠标事件的 target\r\n\r\n```css\r\n/* Keyword values */\r\npointer-events: auto;\r\npointer-events: none;\r\npointer-events: visiblePainted; /* SVG only */\r\npointer-events: visibleFill;    /* SVG only */\r\npointer-events: visibleStroke;  /* SVG only */\r\npointer-events: visible;        /* SVG only */\r\npointer-events: painted;        /* SVG only */\r\npointer-events: fill;           /* SVG only */\r\npointer-events: stroke;         /* SVG only */\r\npointer-events: all;            /* SVG only */\r\n\r\n/* Global values */\r\npointer-events: inherit;\r\npointer-events: initial;\r\npointer-events: unset;\r\n```\r\n\r\n## auto\r\n\r\n> 与`pointer-events`属性未指定时的表现效果相同，对于SVG内容，该值与`visiblePainted`效果相同\r\n\r\n## none\r\n\r\n> **元素永远不会成为鼠标事件的`target`**。但是，当其后代元素的`pointer-events`属性指定其他值时，鼠标事件可以指向后代元素，在这种情况下，鼠标事件将在捕获或冒泡阶段触发父元素的事件侦听器。\r\n\r\n## visiblePainted\r\n\r\n> 只适用于SVG。元素只有在以下情况才会成为鼠标事件的目标：\r\n>\r\n> - `visibility`属性值为`visible`，且鼠标指针在元素内部，且fill属性指定了none之外的值\r\n> - `visibility`属性值为`visible`，鼠标指针在元素边界上，且stroke属性指定了none之外的值\r\n\r\n## visibleFill\r\n\r\n> 只适用于SVG。只有在元素`visibility`属性值为`visible`，且鼠标指针在元素内部时,元素才会成为鼠标事件的目标，`fill`属性的值不影响事件处理。\r\n\r\n## visibleStroke\r\n\r\n> 只适用于SVG。只有在元素`visibility`属性值为`visible`，且鼠标指针在元素边界时,元素才会成为鼠标事件的目标，stroke属性的值不影响事件处理。\r\n\r\n## visible\r\n\r\n> 只适用于SVG。只有在元素`visibility`属性值为`visible`，且鼠标指针在元素内部或边界时,元素才会成为鼠标事件的目标，fill和stroke属性的值不影响事件处理。\r\n\r\n## 　painted\r\n\r\n> 只适用于SVG。元素只有在以下情况才会成为鼠标事件的目标：\r\n> 鼠标指针在元素内部，且`fill`属性指定了none之外的值\r\n> 鼠标指针在元素边界上，且`stroke`属性指定了none之外的值\r\n> `visibility`属性的值不影响事件处理。\r\n\r\n## fill\r\n\r\n> 只适用于SVG。只有鼠标指针在元素内部时,元素才会成为鼠标事件的目标，`fill`和`visibilit`属性的值不影响事件处理。\r\n\r\n## stroke\r\n\r\n> 只适用于SVG。只有鼠标指针在元素边界上时,元素才会成为鼠标事件的目标，`stroke`和`visibility`属性的值不影响事件处理。\r\n\r\n## all\r\n\r\n> 只适用于SVG。只有鼠标指针在元素内部或边界时,元素才会成为鼠标事件的目标，`fill`、`stroke`和`visibility`属性的值不影响事件处理。\r\n","children":[]},{"name":"scroll-behavior.md","path":"../guanruihua.github.io/CSS/attribute","data":"# scroll-behavior\n\n> - auto\n>   - 滚动框立即滚动。\n>\n> - smooth\n>   - 滚动框通过一个用户代理预定义的时长、使用预定义的时间函数，来实现平稳的滚动，用户代理应遵循其平台的约定，如果有的话。\n\n\n\n```css\n/* Keyword values */\nscroll-behavior: auto;\nscroll-behavior: smooth;\n\n/* Global values */\nscroll-behavior: inherit;\nscroll-behavior: initial;\nscroll-behavior: unset;\n```\n\n![](scroll-behavior.assets/GIF 2021-6-7 15-30-05-1623051086791.gif)\n\n## 栗子\n\n```html\n<style>\n\ta {\n\t\tdisplay: inline-block;\n\t\twidth: 50px;\n\t\ttext-decoration: none;\n\t}\n\n\tnav,\n\tscroll-container {\n\t\tdisplay: block;\n\t\tmargin: 0 auto;\n\t\ttext-align: center;\n\t}\n\n\tnav {\n\t\twidth: 339px;\n\t\tpadding: 5px;\n\t\tborder: 1px solid black;\n\t}\n\n\tscroll-container {\n\t\tdisplay: block;\n\t\twidth: 350px;\n\t\theight: 200px;\n\t\toverflow-y: scroll;\n\t\tscroll-behavior: smooth;\n\t}\n\n\tscroll-page {\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t\tjustify-content: center;\n\t\theight: 100%;\n\t\tfont-size: 5em;\n\t}\n</style>\n\n<body>\n\t<nav>\n\t\t<a href=\"#page-1\">1</a>\n\t\t<a href=\"#page-2\">2</a>\n\t\t<a href=\"#page-3\">3</a>\n\t</nav>\n\t<scroll-container>\n\t\t<scroll-page id=\"page-1\">1</scroll-page>\n\t\t<scroll-page id=\"page-2\">2</scroll-page>\n\t\t<scroll-page id=\"page-3\">3</scroll-page>\n\t</scroll-container>\n</body>\n```\n\n\n\n\n\n## 兼容性\n\n![image-20210607153219790](scroll-behavior.assets/image-20210607153219790-1623051142758.png)","children":[]},{"name":"scroll-padding-top.md","path":"../guanruihua.github.io/CSS/attribute","data":"# `scroll-padding-top`\r\n\r\n- 用来定义滚动窗口的最佳查看区域对于顶部的偏移量\r\n\r\n```html\r\n<header>\r\n  <div>\r\n  <h1>Some website</h1>\r\n  <nav>\r\n  <ul>\r\n    <li>\r\n      <a href=\"#section-first\">Section 1</a>\r\n    </li>\r\n        <li>\r\n      <a href=\"#section-second\">Section 2</a>\r\n    </li>\r\n            <li>\r\n      <a href=\"#section-third\">Section 3</a>\r\n    </li>\r\n            <li>\r\n      <a href=\"#section-fourth\">Section 4</a>\r\n    </li>\r\n  </ul>\r\n  </nav>\r\n  </div>\r\n</header>\r\n\r\n<main>\r\n  <section id=\"section-first\">\r\n    <h2>Lorem ipsum title 1</h2>\r\n    <article>\r\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse ullamcorper, massa eu rhoncus porttitor, enim dui scelerisque augue, sed eleifend quam dolor rhoncus dolor. Nunc sit amet ornare mi, eu vestibulum lectus. Mauris ac ultricies felis. Praesent ut orci vestibulum, tincidunt purus in, malesuada elit. Phasellus tempor dolor at accumsan suscipit. Maecenas efficitur hendrerit enim id pellentesque. Nunc placerat nibh sit amet malesuada vestibulum. Ut scelerisque sit amet velit in mattis. Mauris erat augue, eleifend nec posuere nec, vehicula vitae nibh. In hac habitasse platea dictumst.\r\n    </article>\r\n    \r\n  </section>\r\n    <section id=\"section-second\">\r\n    <h2>Lorem ipsum title 2</h2>\r\n    <article>\r\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse ullamcorper, massa eu rhoncus porttitor, enim dui scelerisque augue, sed eleifend quam dolor rhoncus dolor. Nunc sit amet ornare mi, eu vestibulum lectus. Mauris ac ultricies felis. Praesent ut orci vestibulum, tincidunt purus in, malesuada elit. Phasellus tempor dolor at accumsan suscipit. Maecenas efficitur hendrerit enim id pellentesque. Nunc placerat nibh sit amet malesuada vestibulum. Ut scelerisque sit amet velit in mattis. Mauris erat augue, eleifend nec posuere nec, vehicula vitae nibh. In hac habitasse platea dictumst.\r\n    </article>\r\n    \r\n  </section>\r\n    <section id=\"section-third\">\r\n    <h2>Lorem ipsum title 3</h2>\r\n    <article>\r\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse ullamcorper, massa eu rhoncus porttitor, enim dui scelerisque augue, sed eleifend quam dolor rhoncus dolor. Nunc sit amet ornare mi, eu vestibulum lectus. Mauris ac ultricies felis. Praesent ut orci vestibulum, tincidunt purus in, malesuada elit. Phasellus tempor dolor at accumsan suscipit. Maecenas efficitur hendrerit enim id pellentesque. Nunc placerat nibh sit amet malesuada vestibulum. Ut scelerisque sit amet velit in mattis. Mauris erat augue, eleifend nec posuere nec, vehicula vitae nibh. In hac habitasse platea dictumst.\r\n    </article>\r\n    \r\n  </section>\r\n    <section id=\"section-fourth\">\r\n    <h2>Lorem ipsum title 4</h2>\r\n    <article>\r\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse ullamcorper, massa eu rhoncus porttitor, enim dui scelerisque augue, sed eleifend quam dolor rhoncus dolor. Nunc sit amet ornare mi, eu vestibulum lectus. Mauris ac ultricies felis. Praesent ut orci vestibulum, tincidunt purus in, malesuada elit. Phasellus tempor dolor at accumsan suscipit. Maecenas efficitur hendrerit enim id pellentesque. Nunc placerat nibh sit amet malesuada vestibulum. Ut scelerisque sit amet velit in mattis. Mauris erat augue, eleifend nec posuere nec, vehicula vitae nibh. In hac habitasse platea dictumst.\r\n    </article>\r\n    \r\n  </section>\r\n</main>\r\n\r\n<footer>\r\n  Footer\r\n</footer>\r\n```\r\n\r\n```css\r\n* {\r\n  box-sizing: border-box;\r\n}\r\n\r\nhtml {\r\n  scroll-padding-top: 6rem;\r\n  scroll-behavior: smooth;\r\n}\r\n\r\nnav ul {\r\n  list-style: none;\r\n  display: flex;\r\n  gap: 1em;\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n\r\nheader {\r\n  position: fixed;\r\n  top: 0;\r\n  left: 0;\r\n  right: 0;\r\n  background-color: #eeeeee;\r\n}\r\n\r\nheader > div {\r\n  display: flex;\r\n  padding: 0 2rem;\r\n  justify-content: space-between;\r\n  align-items: baseline;\r\n  max-width: 768px;\r\n  margin: 0 auto;\r\n}\r\n\r\nmain {\r\n  width: 768px;\r\n  margin: 0 auto;\r\n  padding-top: 6rem;\r\n}\r\n\r\nsection {\r\n  min-height: 50vh;\r\n  background-color: #f9f9f9;\r\n  padding: 1rem 2rem;\r\n  margin-bottom: 1.5rem;\r\n}\r\n\r\nfooter {\r\n  min-height: 40vh;\r\n  text-align: center;\r\n}\r\n```\r\n\r\n<style>\r\n * {\r\n  box-sizing: border-box;\r\n}\r\n\r\nhtml {\r\n  scroll-padding-top: 6rem;\r\n  scroll-behavior: smooth;\r\n}\r\n\r\nnav ul {\r\n  list-style: none;\r\n  display: flex;\r\n  gap: 1em;\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n\r\nheader {\r\n  position: fixed;\r\n  top: 0;\r\n  left: 0;\r\n  right: 0;\r\n  background-color: #eeeeee;\r\n}\r\n\r\nheader > div {\r\n  display: flex;\r\n  padding: 0 2rem;\r\n  justify-content: space-between;\r\n  align-items: baseline;\r\n  max-width: 768px;\r\n  margin: 0 auto;\r\n}\r\n\r\nmain {\r\n  width: 768px;\r\n  margin: 0 auto;\r\n  padding-top: 6rem;\r\n}\r\n\r\nsection {\r\n  min-height: 50vh;\r\n  background-color: #f9f9f9;\r\n  padding: 1rem 2rem;\r\n  margin-bottom: 1.5rem;\r\n}\r\n\r\nfooter {\r\n  min-height: 40vh;\r\n  text-align: center;\r\n}\r\n</style>\r\n\r\n## 兼容性\r\n\r\n![](./__assets__/scroll-padding-top-2022-07-14-15-38-52.png)\r\n","children":[]},{"name":"shap-outside.md","path":"../guanruihua.github.io/CSS/attribute","data":"# shape-outside\r\n\r\n> 定义了一个可以是非矩形的形状，相邻的内联内容应围绕该形状进行包装\r\n<https://developer.mozilla.org/zh-CN/docs/Web/CSS/shape-outside>\r\n","children":[]},{"name":"transform.md","path":"../guanruihua.github.io/CSS/attribute","data":"# transform\n\n> `transform: translate(位移)|scale(缩放)| rotete(旋转)| skew(倾斜)`\n> 不支持inline元素, 使用时候需要变成block  \n> deg单位为角度单位\n\n## translate\n\n> 位移\n\n```css\ntranslate(x,y);\ntranslateX(x);\ntranslateY(y);\ntranslateZ(z);/*需要在父容器上加上perspective元素 */\ntranslate3d(x,y,z);/*需要在父容器上加上perspective元素 */\n```\n\n<style>\n :root{\n  --w: 20px;\n  --h: 20px;\n  --bg: #20810f;\n    --box-c: #ff85c0;\n }\n table{ width:100%; }\n  .td-container{width:100px; height:50px;background:#fff;}\n .tf{\n  width: var(--w);\n  height: var(--h);\n  background: var(--bg);\n  display:flex;\n  justify-content:center;\n  align-items:center;\n }\n</style>\n\n<style>\n .tfx{ transform: translateX(var(--X)); }\n  .tfy{ transform: translateY(var(--Y)); }\n  .tfxy{ transform: translate(var(--X),var(--Y)); }\n  .tfz{ transform: perspective(30px) translateZ(var(--Z)); }\n .tf3d{ transform: perspective(30px) translate3d(var(--X), var(--Y), var(--Z)); }\n</style>\n<table border=\"1\">\n <tr>\n  <td>translate</td>\n  <td>示例</td>\n </tr>\n <tr>\n  <td>translateX(x);</td> <td>\n    <div class=\"td-container\">\n      <div class=\"tf tfx\" style=\"--X:30px;\"></div>\n    </td>\n </tr>\n  <tr>\n  <td>translateY(y);</td> <td>\n    <div class=\"td-container\">\n      <div class=\"tf tfy\" style=\"--Y:10px;\"></div>\n    </td>\n </tr>\n  <tr>\n  <td>translate(x,y);</td> <td>\n    <div class=\"td-container\">\n      <div class=\"tf tfxy\" style=\"--Y:10px;--X:10px;\"></div>\n    </td>\n </tr>\n <tr>\n  <td>translateZ(z);<br/>需要和perspective配合使用(将观察者相对于z=0处的平面进行定位)<br/>里面的参数就相当于向前移动了多少像素</td> <td>\n    <div class=\"td-container\">\n      <div class=\"tf tfz\" style=\"--Z:10px;\"></div>\n    </td>\n </tr>\n  <tr>\n  <td>translate3d(z);<br/>需要和perspective配合使用(将观察者相对于z=0处的平面进行定位)<br/>里面的参数就相当于向前移动了多少像素</br>z轴大小要小于该参数</td> <td>\n    <div class=\"td-container\">\n      <div class=\"tf tf3d\" style=\"--Z:10px;--X:10px;--Y:10px;\"></div>\n    </td>\n </tr>\n</table>\n\n## scale\n\n> 注意参数都是数字  \n> 放大\n\n```css\nscaleX(x);\nscaleY(y);\nscaleZ(z);\nscale(x, y);\nscale3d();/* 待补充 */\nscale(整数放大倍数);\n```\n\n<style>\n .scx{ transform: scaleX(var(--X))}\n .scy{ transform: scaleY(var(--Y))}\n .scz{ transform: scaleX(var(--Z))}\n .sc{ transform: scale(var(--X),var(--Y))}\n .scn{ transform: scale(var(--Num))}\n .sc3d{ transform: scale3d(var(--X),var(--Y),var(--Z))}\n</style>\n<table border=\"1\">\n <tr>\n  <td>scale</td>\n  <td>示例</td>\n </tr>\n <tr>\n  <td>scaleX(x);</td> <td>\n    <div class=\"td-container\">\n      <div class=\"tf scx\" style=\"--X:1.5;\">1.5</div>\n    </td>\n </tr>\n  <tr>\n  <td>scaleY(y);</td> <td>\n    <div class=\"td-container\">\n      <div class=\"tf scy\" style=\"--Y:1.5;\">1.5</div>\n    </td>\n </tr>\n  <tr>\n  <td>scale(x,y);</td> <td>\n    <div class=\"td-container\">\n      <div class=\"tf sc\" style=\"--Y:1.5;--X:1.5;\">(1.5,1.5)</div>\n    </td>\n </tr>\n <tr>\n  <td>scaleZ(z);<td>\n    <div class=\"td-container\">\n      <div class=\"tf scz\" style=\"--Z:1.5;\">1.5</div>\n    </td>\n </tr>\n  <tr>\n  <td>scale3d(z);</td> <td>\n    <div class=\"td-container\">\n      <div class=\"tf sc3d\" style=\"--Z:2;--X:3;--Y:2;\">(2,3,2)</div>\n    </td>\n </tr>\n  </tr>\n  <tr>\n  <td>scale(Num);(整体放大)</td> <td>\n    <div class=\"td-container\">\n      <div class=\"tf scn\" style=\"--Num:2\">2</div>\n    </td>\n </tr>\n</table>\n\n## rotate\n\n> 旋转\n\n```css\nrotate([<angle>|<zero>])/* 顺时针旋转 */\nrotateZ([<angle>|<zero>])/* 绕Z轴旋转 */\nrotateX([<angle>|<zero>])/* 绕X轴旋转 */\nrotateY([<angle>|<zero>])/* 绕Y轴旋转 */\nrotate3d([number],[number],[number],[<angle>|<zero>])\n```\n\n<style>\n .rt{ transform: rotate(var(--angle))}\n .rtx{ transform:rotateX(var(--angle))}\n .rty{ transform: rotateY(var(--angle))}\n .rtz{ transform: rotateZ(var(--angle))}\n .rt3d{ transform: rotate3d(var(--X),var(--Y),var(--Z),var(--angle))}\n</style>\n<table border=\"1\">\n <tr>\n  <td>rotate</td>\n  <td>示例</td>\n </tr>\n <tr>\n  <td>rotateX(45deg);</td> <td>\n    <div class=\"td-container\">\n      <div class=\"tf rtx\" style=\"--angle:45deg;\"></div>\n    </td>\n </tr>\n  <tr>\n  <td>rotateY(45deg);</td> <td>\n    <div class=\"td-container\">\n      <div class=\"tf rty\" style=\"--angle:45deg\"></div>\n    </td>\n </tr>\n  <tr>\n  <td>rotate(45deg);</td> <td>\n    <div class=\"td-container\">\n      <div class=\"tf rt\" style=\"--angle:45deg\"></div>\n    </td>\n </tr>\n <tr>\n  <td>rotateZ(z);<td>\n    <div class=\"td-container\">\n      <div class=\"tf rtz\" style=\"--angle:-33deg\"></div>\n    </td>\n </tr>\n  <tr>\n  <td>rotate3d(1,2,3,45deg);</td> <td>\n    <div class=\"td-container\">\n      <div class=\"tf rt3d\" style=\"--Z:2;--X:3;--Y:2;--angle:45deg;\"></div>\n    </td>\n</table>\n\n## skew\n\n> 歪斜\n\n```css\nskewX([<angle>|<zero>])\nskewY([<angle>|<zero>])\nskew(([<angle>|<zero>],[<angle>|<zero>]? )\n```\n\n<style>\n .skew{ transform: skew(15deg,15deg)}\n .skewx{ transform: skewX(var(--angle))}\n .skewy{ transform: skewY(var(--angle))}\n</style>\n<table border=\"1\">\n <tr>\n  <td>skew</td>\n  <td>示例</td>\n </tr>\n <tr>\n  <td>skewX(45deg);</td> <td>\n    <div class=\"td-container\">\n      <div class=\"tf skewx\" style=\"--angle:45deg;\"></div>\n    </td>\n </tr>\n  <tr>\n  <td>skewY(45deg);</td> <td>\n    <div class=\"td-container\">\n      <div class=\"tf skewy\" style=\"--angle:45deg\"></div>\n    </td>\n </tr>\n  <tr>\n  <td>skew(15deg, 15dep);</td> <td>\n    <div class=\"td-container\">\n      <div class=\"tf skew\"></div>\n    </td>\n </tr>\n <tr>\n</table>\n\n## matrix\n\n> 矩阵变换\n\n```css\nmatrix()\nmatrix(a, b, c, d, tx, ty) \n=> matrix3d(a, b, 0, 0, c, d, 0, 0, 0, 0, 1, 0, tx, ty, 0, 1) \n=> matrix( scaleX(), skewY(), skewX(), scaleY(), translateX(), translateY() )\n\n\nmatrix3d()\nmatrix3d(a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4)\n```\n\n<style>\n .matr3d{ transform: matrix3d(1,0,0,0, 0,1,0,0, 0,0,1,0,-5,-10,0,1.1)}\n .matr{ transform: matrix(1,2,-1,1,40,20)}\n</style>\n<table border=\"1\">\n <tr>\n  <td>skew</td>\n  <td>示例</td>k\n </tr>\n <tr>\n  <td>matrix3d(1,0,0,0, 0,1,0,0, 0,0,1,0,-5,-10,0,1.1);</td> <td>\n    <div class=\"td-container\">\n      <div class=\"tf matr3d\"></div>\n    </td>\n </tr>\n  <tr>\n  <td>matrix(1, 2, -1, 1, 40, 20);</td> <td>\n    <div class=\"td-container\">\n      <div class=\"tf matr\"></div>\n    </td>\n </tr>\n</table>\n\n## 视距 `prtspective`\n>\n> - perspective([length])  : 就是相当于定义人物（或观察者）＂离显示器中该元素的距离＂\n> - <b style=\"color:red;\"> 在3D空间中改变元素的形态时, 基本上都要赋予元素一定H的视域。</b>\n> - 视域为元素赋予前后深度，而这深度可以根据需要设定。\n\n​\n\n## 移动原点`transform-origin`\n>\n> - 修改元素动画的变形原点\n> - 旋转中心默认中心\n> - 其他变换中心是是不太确定的\n> - 都可以通过该属性进行修改\n\n```css\ntransform-origin: 50%,50%;\n```\n\n## 变换方式 `tansform-style`\n\n> 在一个三维空间中改变元素的形态，使用translate3d()，或许希望在3D空间中呈现元素。  \n> 一般这不是默认行为。默认情况下，不管怎么变形，得到的结果都是扁平的。但是可以使用transform-style修改。\n\n| `transform-style` |                  |\n| ----------------- | ---------------- |\n| 取值              | `flat            |\n| 初始值            | `flat`           |\n| 适用于            | 任何可变形的元素 |\n| 计算值            | 指定的值         |\n| 继承性            | 否               |\n| 动画性            | 否               |\n\n### 原来\n\n```html\n<style>\n.mbd{ border:1px solid red; }\n.outer{\n display:flex;\n width:150px;\n height:125px;\n justify-content:center;\n align-items:center;\n}\n.inner { \n width:50px;\n transform: perspective(750px) translateZ(60px) rotateX(60deg); \n }\n</style>\n\n<div class=\"outer mbd\">\n    <div class=\"inner mbd\">inner</div>\n</div>\n```\n\n<style>\n.mbd{ border:1px solid red; }\n.outer{\n display:flex;\n width:150px;\n height:125px;\n justify-content:center;\n align-items:center;\n}\n.inner {\n width:50px;\n transform: perspective(750px) translateZ(60px) rotateX(60deg);\n }\n</style>\n\n<div class=\"outer mbd\">\n    <div class=\"inner mbd\">inner</div>\n</div>\n\n### 后\n\n```html\n<div style=\"\n  display:flex;\n  width:150px;\n  height:125px;\n  justify-content:center;\n  align-items:center;\n  transform: perspective(750px) translateY(60px) rotateX(-20deg); \n  transform-style: perserve-3d;\n  overflow: visible;\n  filter: none;\n  clip: auto;\n  clip-path: none;\n  mask-image: none;\n  mask-border-source: none;\n  mix-blend-mode: normal;\n  border:1px solid red;\">\n    <div style=\" \n   width:50px;\n   border:1px solid red;\n   transform: perspective(750px) translateZ(60px) rotateX(60deg); \n   \">inner</div>\n</div>\n```\n\n<div style=\"\n  display:flex;\n  width:150px;\n  height:125px;\n  justify-content:center;\n  align-items:center;\n  transform: perspective(750px) translateY(60px) rotateX(-20deg);\n  transform-style: perserve-3d;\n  overflow: visible;\n  filter: none;\n  clip: auto;\n  clip-path: none;\n  mask-image: none;\n  mask-border-source: none;\n  mix-blend-mode: normal;\n  border:1px solid red;\">\n    <div style=\"\n   width:50px;\n   border:1px solid red;\n   transform: perspective(750px) translateZ(60px) rotateX(60deg);\n   \">inner</div>\n</div>\n\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n\n## 处理背面 `backface-visibility`\n\n> 在3D变形中，backface-visibility属性可以看到元素的背面。\n> 一个元素的backface-visibility属性设置为visible，另一个设置为hidden。\n\n<style>\n.card {\n  position: relative;\n  perspective: 800px;\n  transform-style: preserve-3d;\n  width:200px;\n  height:280px;\n  transition: all .6s;\n  border: 1px solid #000;\n  border-radius: 4px;\n}\n\n.card:hover {\n  transform: rotateY(180deg);\n}\nimg {\n  position: absolute;\n  width:100%;\n  height: 100%;\n  transition: all .5s;\n  backface-visibility: hidden;\n}\n/*由于我们将两个图像都藏在了背面，所以另一面没有任何东西。 所以接下来需要再把.front-face翻转180度*/\n.back-face {\n  transform: rotateY(180deg);\n}\n</style>\n\n<div class=\"card\">\n    <img class=\"front-face\" src=\"https://api.pixivweb.com/anime18r.php?return=img\">\n    <img class=\"back-face\" src=\"https://api.pixivweb.com/bw.php?return=img\">\n</div>\n","children":[]},{"name":"transition.md","path":"../guanruihua.github.io/CSS/attribute","data":"# transition\n\n> vscode可以支持动图  \n> transition-property、transition-duration、transition-timing-function,transition-delay\n> `transition-duration`: 为必填项\n简写\n\n```css\ntransition: all 5s linear .2s; // 以空格隔开属性\ntransition: all 5s linear .2s, height 3s ease-in-out; // 可以以逗号隔开多个过渡。\n```\n\n<div>\n <style>\n .test1{\n  width: 300px;\n  height: 100px;\n  background: green;\n  transition: all 2s linear .2s;\n }\n .test1:hover{\n  width: 250px;\n  height: 50px;\n  background: #ff85c0;\n }\n </style>\n <div class=\"test1\"></div>\n</div>\n\n## transition-property\n\n> 可以选择对某一个属性进行添加特效\n\n```css\ntransition-property: all; // 默认为all，所有可被动画的属性都表现出过渡动画。\ntransition-property: none; // 没有动画效果\ntransition-property: width, height; //也可以取其他属性的值\n```\n\n### all\n\n<div>\n <style>\n .test2{\n  width: 300px;\n  height: 100px;\n  background: green;\n  transition: all 2s linear .2s;\n }\n .test2:hover{\n  width: 250px;\n  height: 50px;\n  background: #ff85c0;\n }\n </style>\n <div class=\"test2\"></div>\n</div>\n\n### none\n\n<div>\n <style>\n .test3{\n  width: 300px;\n  height: 100px;\n  background: green;\n  transition: none 2s linear .2s;\n }\n .test3:hover{\n  width: 250px;\n  height: 50px;\n  background: #ff85c0;\n }\n </style>\n <div class=\"test3\"></div>\n</div>\n\n### 自选\n\n> 这里选的是 `width`\n\n<div>\n <style>\n .test4{\n  width: 300px;\n  height: 100px;\n  background: green;\n  transition: width 2s linear .2s;\n }\n .test4:hover{\n  width: 250px;\n  height: 50px;\n  background: #ff85c0;\n }\n </style>\n <div class=\"test4\"></div>\n</div>\n\n## transition-duration\n\n> 动画时间\n\n```css\ntransition-duration: 1s;\ntransition-duration: 1ms;\ntransition-duration: 1s, 10s, 10ms; // 对应多个动画的属性\n```\n\n### 1s\n\n<div>\n <style>\n .test5{\n  width: 300px;\n  height: 100px;\n  background: green;\n  transition: all 1s linear .2s;\n }\n .test5:hover{\n  width: 250px;\n  height: 50px;\n  background: #ff85c0;\n }\n </style>\n <div class=\"test5\"></div>\n</div>\n\n### 1ms\n\n<div>\n <style>\n .test7{\n  width: 300px;\n  height: 100px;\n  background: green;\n  transition: all 1ms linear .2s;\n }\n .test7:hover{\n  width: 250px;\n  heigth: 50px;\n  background: #ff85c0;\n }\n </style>\n <div class=\"test7\"></div>\n</div>\n\n### 1s, 3s, 10ms\n\n<div>\n <style>\n .test6{\n  width: 300px;\n  height: 100px;\n  background: green;\n  margin-left:0;\n  /*transition: all 1ms linear .2s;*/\n  transition-property:width,margin-left,background;\n  transition-duration: 1s, 3s, 10ms;\n  transition-timing-function: linear;\n  transition-delay: .2s;\n }\n .test6:hover{\n  width: 250px;\n  heigth: 50px;\n  margin-left: 10px;\n  background: #ff85c0;\n }\n </style>\n <div class=\"test6\"></div>\n</div>\n\n## transition-timing-function\n\n> 过渡动画\n\n<div>\n<style>\n :root{\n  --w-before: 100px;\n  --w-after: 50px;\n  --h-before: 100px;\n  --h-after: 50px;\n  --bg-before: #20810f;\n  --bg-after: #ff85c0;\n }\n table{ width:100%; }\n .t-center{ text-align:center;}\n .ttf{\n  width: var(--w-before);\n  height: var(--h-before);\n  background: var(--bg-before);\n  /*transition: all 2s linear .2s;*/\n  transition-property:width,height,background;\n  transition-duration: 1s, 3s, 10ms;\n  transition-timing-function: var(--ttf);\n  transition-delay: .2s;\n  display:flex;\n  justify-content:center;\n  align-items:center;\n }\n .ttf:hover{\n  width: var(--w-after);\n  height: var(--h-after);\n  background: var(--bg-after);\n }\n</style>\n<table border=\"1\">\n <tr>\n  <td>transition-timing-function</td>\n  <td class=\"t-center\">示例</td>\n  <td class=\"t-center\">描述</td>\n </tr>\n <tr>\n  <td>ease</td>  \n  <td><div class=\"ttf\" style=\"--ttf:ease;\">ease</div></td>\n  <td>默认值，慢速开始，中间变快，慢速结束；相当于 cubic-bezier(0.25, 0.1, 0.25, 1)</td>\n </tr>\n <tr>\n  <td>linear</td>\n  <td><div class=\"ttf\" style=\"--ttf:linear;\">linear</div></td>\n  <td>匀速运动；相当于 cubic-bezier(0, 0, 1, 1)</td>\n </tr>\n <tr>\n  <td>ease-in</td>\n  <td><div class=\"ttf\" style=\"--ttf:ease-in;\">ease-in</div></td>\n  <td>慢速开始；相当于 cubic-bezier(0.42, 0, 1, 1)</td>\n </tr>\n <tr>\n  <td>ease-out</td>\n  <td><div class=\"ttf\" style=\"--ttf:ease-out;\">ease-out</div></td>\n  <td>慢速结束；相当于 cubic-bezier(0, 0, 0.58, 1)</td>\n </tr>\n <tr>\n  <td>ease-in-out</td>\n  <td><div class=\"ttf\" style=\"--ttf:ease-in-out;\">ease-in-out</div></td>\n  <td>慢速开始，慢速结束；相当于 cubic-bezier(0.42, 0, 0.58, 1)</td>\n </tr>\n <tr>\n  <td>step-start</td>\n  <td><div class=\"ttf\" style=\"--ttf:step-start;\">step-start</div></td>\n  <td></td>\n </tr>\n <tr>\n  <td>step-end</td>\n  <td><div class=\"ttf\" style=\"--ttf:step-end;\">step-end</div></td>\n  <td></td>\n </tr>\n <tr>\n  <td>steps(4, end)</td>\n  <td><div class=\"ttf\" style=\"--ttf:step(4,end);\">step(4,end)</div></td>\n  <td></td>\n </tr>\n</table>\n</div>\n\n## transition-delay\n\n> 延迟时间\n\n```css\ntransition-delay: 1s;\n```\n\n<div>\n <style>\n .test41{\n  width: 300px;\n  height: 100px;\n  background: green;\n  transition: all 2s linear 1s;\n }\n .test41:hover{\n  width: 250px;\n  height: 50px;\n  background: #ff85c0;\n }\n </style>\n <div class=\"test41\"></div>\n</div>\n\n## 过渡状态切换\n\n```css\n.app {\n  width: 300px;\n transition: all 3s linear .2s;\n}\n\n.app:hover {\n  width: 100;\n  transition: all 1s linear .2s;\n}\n```\n","children":[]},{"name":"user-select.md","path":"../guanruihua.github.io/CSS/attribute","data":"# [`user-select`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/user-select)\r\n\r\n> 控制用户能否选中文本。除了文本框内，它对被载入为 chrome 的内容没有影响。\r\n\r\n![](./__assets__/user-select-2022-11-04-10-37-52.png)\r\n","children":[]},{"name":"毛玻璃.md","path":"../guanruihua.github.io/CSS/attribute","data":"# 毛玻璃\n\n> `backdrop-filter`:  元素后面影响\n>\n> `filter`: 元素本身影响\n\n\n\n```css\nbackdrop-filter:blur(10px)\n        blur: 模糊\n        brightness: 亮度\n        contrast: 对比度\n        drop-shadow: 投影\n        grayscale: 灰度\n        hue-rotate: 色调变化\n        invert: 反像\n        opacity: 透明度\n        saturate: 饱和度\n        sepia: 褐色\n```\n\n","children":[]},{"name":"颜色","path":"../guanruihua.github.io/CSS/attribute","data":"","children":[{"name":"currentColor.md","path":"../guanruihua.github.io/CSS/attribute/颜色","data":"# `currentColor`\r\n\r\n- `currentColor`经常被叫做『第一个CSS变量』\r\n- `currentColor`的值等于当前元素的`color`属性值，看上去有些像继承。它可以被应用于任何可以接收color值的属性中，比如`border-color`, `background`, `box-shadow`等。\r\n- 当在同一个CSS选择器中，需要将同一个颜色值应用到多个接收color值的CSS属性上（例如`border-color`，`background`, `box-shadow`）时，`currentColor`就派上用场了。\r\n\r\n```html\r\n<aside class=\"success\">\r\n  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam auctor tellus ac tempus sollicitudin. Mauris quam eros, viverra eget pulvinar at, scelerisque non velit.\r\n</aside>\r\n\r\n<aside class=\"warning\">\r\nVestibulum dapibus, libero non venenatis suscipit, elit libero scelerisque odio, nec laoreet ipsum sem sed nibh. Nulla facilisi.  \r\n</aside>\r\n\r\n<aside class=\"error\">\r\nVivamus rhoncus dignissim diam, id dictum lorem tincidunt sit amet. Cras et eros urna. Proin pulvinar enim a congue porttitor.\r\n</aside>\r\n```\r\n\r\n```css\r\n<style>\r\n aside {\r\n  border-left: 5px solid currentColor;\r\n  box-shadow: 5px 5px 10px currentColor;\r\n  margin-bottom: 20px;\r\n}\r\n.success {\r\n  color: darkgreen;\r\n}\r\n.warning {\r\n  color: darkgoldenrod;\r\n}\r\n.error {\r\n  color: darkred;\r\n}\r\n```\r\n\r\n<aside class=\"success\">\r\n  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam auctor tellus ac tempus sollicitudin. Mauris quam eros, viverra eget pulvinar at, scelerisque non velit.\r\n</aside>\r\n\r\n<aside class=\"warning\">\r\nVestibulum dapibus, libero non venenatis suscipit, elit libero scelerisque odio, nec laoreet ipsum sem sed nibh. Nulla facilisi.  \r\n</aside>\r\n\r\n<aside class=\"error\">\r\nVivamus rhoncus dignissim diam, id dictum lorem tincidunt sit amet. Cras et eros urna. Proin pulvinar enim a congue porttitor.\r\n</aside>\r\n\r\n<style>\r\n aside {\r\n  border-left: 5px solid currentColor;\r\n  box-shadow: 5px 5px 10px currentColor;\r\n margin-bottom: 20px;\r\n}\r\n.success {\r\n  color: darkgreen;\r\n}\r\n.warning {\r\n  color: darkgoldenrod;\r\n}\r\n.error {\r\n  color: darkred;\r\n}\r\n\r\n</style>\r\n\r\n## 兼容性\r\n\r\n![](./__assets__/currentColor-2022-07-14-14-43-21.png)\r\n","children":[]},{"name":"radial-gradient.md","path":"../guanruihua.github.io/CSS/attribute/颜色","data":"# radial-gradient\n\n> 渐变色\n\n```css\nackground-image: radial-gradient(shape size at position, start-color, ..., last-color);\n```\n\n| 值                             | 描述                                                         |\n| :----------------------------- | :----------------------------------------------------------- |\n| *shape*                        | 确定圆的类型:<br/>ellipse (默认): 指定椭圆形的径向渐变。<br/>circle ：指定圆形的径向渐变 |\n| *size*                         | 定义渐变的大小，可能值：<br/>farthest-corner (默认) : 指定径向渐变的半径长度为从圆心到离圆心最远的角<br/>closest-side ：指定径向渐变的半径长度为从圆心到离圆心最近的边<br/>closest-corner ： 指定径向渐变的半径长度为从圆心到离圆心最近的角<br/>farthest-side ：指定径向渐变的半径长度为从圆心到离圆心最远的边 |\n| *position*                     | 定义渐变的位置。可能值：<br/>**center**（默认）：设置中间为径向渐变圆心的纵坐标值。<br/>**top**：设置顶部为径向渐变圆心的纵坐标值。<br/>**bottom**：设置底部为径向渐变圆心的纵坐标值。 |\n| *start-color, ..., last-color* | 用于指定渐变的起止颜色。                                     |\n","children":[]}]}]},{"name":"basis","path":"../guanruihua.github.io/CSS","data":"","children":[{"name":"1px.md","path":"../guanruihua.github.io/CSS/basis","data":"# 1px\n\n```shell\n\n设备像素：设备的物理像素，其尺寸大小是绝对的\n\n逻辑像素：CSS 的像素单位，其尺寸大小是相对的，也称为独立像素\n\n分辨率：屏长的设备像素 × 屏宽的设备像素\n\ndpi（dots per inch）：像素密度，表示水平或垂直方向每英寸长度的像素数目\n\nppi（pixels per inch）：像素密度，表示沿对角线每英寸长度的像素数目\n\n（dpi 和 ppi 其实不就是一回事吗，呵呵）\n\n缩放因子（Scale Factor）：逻辑像素相对于设备像素的放大比例，可通过 window.devicePixelRatio 获得，但二者并不完全等同\n\n关系一：\n\n　　设备尺寸 × 像素密度 = 分辨率（设备像素）\n\n　　举例：\n\n　　iphone6s 对角线长度为5.5 inches，像素密度401 ppi，分辨率 1920 * 1080，计算可得对角线的设备像素为2205.5。\n\n　　5.5 * 401 = 2205.5\n\n关系二：\n\n　　逻辑像素 = 设备像素 × 缩放因子\n\n　　举例：\n\n　　iphone6逻辑像素为375 *667，分辨率为750* 1334，缩放因子为2\n\n　　1个逻辑像素 = 设备宽度的1/375\n\n　　1个设备像素 = 设备宽度的1/750\n\n　　1/375 = 1/750 * 2\n```\n","children":[]},{"name":"W3C和IE盒模型.md","path":"../guanruihua.github.io/CSS/basis","data":"# W3C盒模型和IE盒模型\n\n> E的盒模型问题只会出现在IE5.5及其更早的版本中，因为在IE6及更新的版本在标准兼容模式下使用的是W3C的盒模型标准，但事实上不仅IE5.5，连IE6的使用率也很少了，这里对他们进行讨论只是为了更深刻的理解盒模型。\n\n![img](W3C和IE盒模型.assets/20150629102231720)\n\n## 例子\n\n```html\n<!-- 没有声明 -->\n<html>\n<head lang=\"ch\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <style>\n        .box{\n            float:left;\n            width: 100px;\n            height: 100px;\n            background-color: #ff9000;\n        }\n        .container{\n            width: 200px;\n            padding: 10px;\n            background-color: #f00;\n            overflow: hidden;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"box\"></div>\n        <div class=\"box\"></div>\n    </div>\n<script>\n</script>\n</body>\n</html>\n```\n\n无论IE还是其他都会显示\n\n![img](W3C和IE盒模型.assets/20150629102836021)\n\n但是给container添加padding\n\n```css\n.container{\n    width: 200px;\n    background-color: #f00;\n    overflow: hidden;\n    padding: 10px;\n}\n```\n\n则其在非IE下的样式为：\n\n\n\n![W3C](W3C和IE盒模型.assets/20150629103146025)\n\n但在IE下为：\n\n![IE](W3C和IE盒模型.assets/20150629103238709)","children":[]},{"name":"单位.md","path":"../guanruihua.github.io/CSS/basis","data":"# 单位\n\n> - CSS像素、物理像素、逻辑像素、设备像素比、PPI、Viewport\n> - 浏览器内的一切长度都是以css箱数为单位, css像素的单位是px\n> - css 规范中: 长度主要有绝对(absolute)单位 和 相对( relative)单位\n\n## PX\n\n> - 相对长度单位，相对与电脑显示屏的分辨率而言。\n>\n> - 特点：IE无法调整px单位的字体大小\n>\n> - 不是一个确定的值,  不同的设备, 图像基本采样单元是不同的, 显示器上的物理像素等于显示器的点距，而打印机的物理像素等于打印机的墨点。而衡量点距大小和打印机墨点大小的单位分别称为`ppi`和`dpi`：\n>\n>    ppi( dots per inch )：像素密度,  表示沿对角线每英寸长度的像素数目\n>\n>    dpi( pixels per inch ) ：像素密度,  表示水平或垂直方向每英寸长度的像素数目\n>\n>    关于打印机的点距我们不去关心，只要知道 当用于描述显示器设备时ppi与dpi是同一个概念 。\n\n## EM\n\n> - 相对长度单位，相对于对象内的字体文字的尺寸，如果行内文本没有认为设置文字尺寸，则相对于浏览器的字体默认尺寸。\n>\n> - 一般相对于root em元素的长度, 一般是父元素\n\n特点：\n\n```js\n1. em的值不会固定\n2. em会继承父级元素的字体大小\n\n浏览器的字体尺寸默认的大小是16px，没进行过调整的浏览器的符合 16px = 1em这个规则，所以 12px = 0.75em，10px = 0.625em，\n为了简化font-size的计算方式，在body选择器里添加font-size = 62.5%，由此以来，在使用em单位的时候，10px = 1em;\n```\n\n## REM（root em）\n\n> css3新增加的相对长度单位，直接相对于根元素`<html>`，可以忽略层级关系。\n\n## vh/vw\n\n> - CSS3新增样式，部分浏览器（IE8）不支持。\n> - vh、vw：相对于视窗（Viewport）的高度和宽度\n> - 1vh 等于1/100的视窗高度，1vw 等于1/100的视窗宽度。\n> - 视窗:是指浏览器内部的可视区域大小，即`window.innerWidth/window.innerHeight`大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。\n\n## vmin/vmax\n\n> - CSS3新增样式，部分浏览器（IE8）不支持。\n> - vmin：取视窗高度和宽度的最小值作为基准。\n> - vmax：取视窗高度和宽度的最大值作为基准。\n> - 浏览器视窗大小为 window.innerWidth=1000px，window.innerHeight=800px，那么，1vmin=800px/100=8px; 1vmax=1000px/100=10px。\n>\n> 使用场景：做移动页面开发时，如果使用 vw、wh 设置字体大小（比如 5vw），在竖屏和横屏状态下显示的字体大小是不一样的。由于 vmin 和 vmax 是当前较小的 vw 和 vh 和当前较大的 vw 和 vh。这里就可以用到 vmin 和 vmax。使得文字大小在横竖屏下保持一致\n\n## %\n\n> - 相对于父元素的长度高度\n>\n> - 注意1：position:fixed时，无论当前元素放在哪里，将相对于窗口宽度\n>\n> - 注意2：position:absolute时，将相对于其相对的元素宽度（递归父元素直到第一个设置了position的元素）\n\n## 获取页面,屏幕的大小参数\n\n> JavaScript获取获取屏幕、浏览器窗口 ，浏览器，网页高度、宽度的大小\n> 网页可见区域宽：document.body.clientWidth\n> 网页可见区域高：document.body.clientHeight\n> 网页可见区域宽：document.body.offsetWidth (包括边线的宽)\n> 网页可见区域高：document.body.offsetHeight (包括边线的宽)\n> 网页正文全文宽：document.body.scrollWidth\n> 网页正文全文高：document.body.scrollHeight\n> 网页被卷去的高：document.body.scrollTop\n> 网页被卷去的左：document.body.scrollLeft\n> 网页正文部分上：window.screenTop\n> 网页正文部分左：window.screenLeft\n> 屏幕分辨率的高：window.screen.height\n> 屏幕分辨率的宽：window.screen.width\n> 屏幕可用工作区高度：window.screen.availHeight\n> 屏幕可用工作区宽度：window.screen.availWidth\n>\n> HTML精确定位:scrollLeft,scrollWidth,clientWidth,offsetWidth\n> scrollHeight: 获取对象的滚动高度。\n> scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离\n> scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离\n> scrollWidth:获取对象的滚动宽度\n> offsetHeight:获取对象相对于版面或由父坐标 offsetParent 属性指定的父坐标的高度\n> offsetLeft:获取对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置\n> offsetTop:获取对象相对于版面或由 offsetTop 属性指定的父坐标的计算顶端位置\n> event.clientX 相对文档的水平座标\n> event.clientY 相对文档的垂直座标\n> event.offsetX 相对容器的水平坐标\n> event.offsetY 相对容器的垂直坐标\n> document.documentElement.scrollTop 垂直方向滚动的值\n> event.clientX+document.documentElement.scrollTop 相对文档的水平座标+垂直方向滚动的量\n>\n> IE，FireFox 差异如下：\n>\n> IE6.0、FF1.06+：\n>\n> clientWidth = width + padding\n>\n> clientHeight = height + padding\n>\n> offsetWidth = width + padding + border\n>\n> offsetHeight = height + padding + border\n>\n> IE5.0/5.5：\n> clientWidth = width - border\n>\n> clientHeight = height - border\n>\n> offsetWidth = width\n>\n> offsetHeight = height\n>\n> (需要提一下：CSS中的margin属性，与clientWidth、offsetWidth、clientHeight、offsetHeight均无关)\n>\n> 网页可见区域宽： document.body.clientWidth\n> 网页可见区域高： document.body.clientHeight\n> 网页可见区域宽： document.body.offsetWidth (包括边线的宽)\n> 网页可见区域高： document.body.offsetHeight (包括边线的高)\n> 网页正文全文宽： document.body.scrollWidth\n> 网页正文全文高： document.body.scrollHeight\n> 网页被卷去的高： document.body.scrollTop\n> 网页被卷去的左： document.body.scrollLeft\n> 网页正文部分上： window.screenTop\n> 网页正文部分左： window.screenLeft\n> 屏幕分辨率的高： window.screen.height\n> 屏幕分辨率的宽： window.screen.width\n> 屏幕可用工作区高度： window.screen.availHeight\n> 屏幕可用工作区宽度： window.screen.availWidth\n>\n> div.style.top：相对于div所在的元件的顶部距离\n","children":[]}]},{"name":"css-basis.md","path":"../guanruihua.github.io/CSS","data":"# CSS-basis\n\n## 内核前缀\n\n> 主流浏览器内核私有属性css前缀：\n>\n> mozilla内核 (firefox,flock等)       -moz\n> webkit内核(safari,chrome等)         -webkit\n> opera内核(opera浏览器)              -o\n> trident内核(ie浏览器)               -ms\n\n## 选择器\n\n| 属性       | 选择器                  |\n| ---------- | ----------------------- |\n| html元素   | 直接html标签, h1 span p |\n| id         | #                       |\n| class      | .                       |\n| type       | [type=\"属性\"]           |\n| !important | 最高级选择器            |\n\n### `[attr](属性)`\n\n用法:\n\n1. `[attr](有该属性)`\n2. [attr =xxx] (属性值 是xxx)\n3. `[attr^=xxx](属性是xxx开头)`\n4. `[attr$=xxx](属性是xxx结尾)`\n5. `[attr*=xxx](属性包含xxx)`\n\n### 权重计算\n\n| 选择器                    | 权重  |\n| ------------------------- | ----- |\n| !important                | >1000 |\n| 内联(style='color: #fff') | 1000  |\n| id                        | 100   |\n| class                     | 10    |\n| 伪类                      | 10    |\n| 元素                      | 1     |\n| *                         | 0     |\n| 继承                      | 无    |\n\n### 选择器的使用\n\n> 内部样式和外部样式   采用就近原则\n\n| 选择器         | 书写                                                         |\n| -------------- | ------------------------------------------------------------ |\n| 后代选择器     | `h1 span`                                                    |\n| 子代选择器     | `h1>span`                                                    |\n| 伪类选择器     | `:hover  :link :visted  :active`                             |\n| 相邻兄弟选择器 | `span+span`                                                  |\n| 通用兄弟选择器 | `p~span`( 不一定要紧跟着, 但是必须要有一个共同的父元素 )<br>`p`元素之后的所有`span`元素 |\n| 通用选择器     | *                                                            |\n| 群组选择器     | span, p, h1                                                  |\n| 结构伪类选择器 | :first-child      : nth-child(n)    : last-child             |\n| 伪元素选择器   | :after    :before                                            |\n\n## background\n\nbackground-color : #fff000 | rgb(255,255,255) | red | agba(255.255.255.0.9)\n\nbackground-image : url('paper.gif')\n\nbackground-repeat : no-repreat(没有平铺) | repeat-x(水平平铺) | repeat-y(垂直平铺)\n\nbackground-attachment :\n\n| 值      | 说明                                            |\n| ------- | ----------------------------------------------- |\n| scroll  | 背景图片随页面的其余部分滚动。这是默认          |\n| fixed   | 背景图像是固定的                                |\n| inherit | 指定background-attachment的设置应该从父元素继承 |\n| local   | 背景图片随滚动元素滚动                          |\n\nbackground-posittion : center\n\n| 单一关键字 | 等价的关键字                   |\n| :--------- | :----------------------------- |\n| center     | center center                  |\n| top        | top center 或 center top       |\n| bottom     | bottom center 或 center bottom |\n| right      | right center 或 center right   |\n| left       | left center 或 center left     |\n\n## CSS Text(文本)\n\n### 文本颜色\n\n> color : blue | #00ff00 | rgb(255,0,0)\n\n### 对齐方式\n\n> text-align : center | left | right | justify [ 每一行被展开为宽度相等，左，右外边距是对齐（如杂志和报纸）]\n\n### 文字方向\n\n> text-direction : ltr [左到右] | rtl [右到左] | inherit[从父元素继承direction属性值]\n\n### 字符间距\n\n> letter-spacing : normal(默认) |  length(数字,可以为负) | inherit(从父元素继承)\n\n### 行高\n\n> line-height : normal(默认) | number(行间距=当前字体尺寸*number) | lenght |  % | inherit\n\n### 文本的首行元素 缩进\n\n> text-indent : length(默认值: 0) | %(为父元素的百分比缩进) | inherit\n\n### 文字阴影\n\n> text-shadow : none(默认值)\n>\n> 语法: `text-shadow: *h-shadow v-shadow blur color*;`\n>\n> | 值         | 描述                                                         |\n> | :--------- | :----------------------------------------------------------- |\n> | *h-shadow* | 必需。水平阴影的位置。允许负值。                             |\n> | *v-shadow* | 必需。垂直阴影的位置。允许负值。                             |\n> | *blur*     | 可选。模糊的距离。                                           |\n> | *color*    | 可选。阴影的颜色。参阅 [CSS 颜色值](https://www.w3cschool.cn/cssref/css-colors-legal.html)。 |\n\n### 元素中的字母\n\n> text-transform :  \n>\n> ​  none:    默认\n>\n> ​  capitalize:  文本中每个单词以大写字母开头\n>\n> ​  uppercase:  定义仅有大写字母\n>\n> ​  lowercase: 定义无大写字母,仅有小写字母\n>\n> ​  inherit:   规定从父元素继承text-transform属性\n\n### 设置或返回文本是否被重写\n\n> `unicode-bidi: normal|embed|bidi-override|initial|inherit;`\n>\n> | 值            | 描述                                                         | 测试                                                     |\n> | :------------ | :----------------------------------------------------------- | :------------------------------------------------------- |\n> | normal        | 默认。不使用附加的嵌入层面。                                 | [测试 »](https://www.w3cschool.cn/css/css-css_quiz.html) |\n> | embed         | 创建一个附加的嵌入层面。                                     | [测试 »](https://www.w3cschool.cn/css/css-css_quiz.html) |\n> | bidi-override | 创建一个附加的嵌入层面。重新排序取决于 direction 属性。      | [测试 »](https://www.w3cschool.cn/css/css-css_quiz.html) |\n> | initial       | 设置该属性为它的默认值。请参阅 [*initial*](https://www.w3cschool.cn/cssref/css-initial.html)。 | [测试 »](https://www.w3cschool.cn/css/css-css_quiz.html) |\n> | inherit       | 从父元素继承该属性。请参阅 [*inherit*](https://www.w3cschool.cn/cssref/css-inherit.html)。 |                                                          |\n\n### 元素垂直对齐\n\n> vertical-align:\n>\n> | 值          | 描述                                                         |\n> | ----------- | ------------------------------------------------------------ |\n> | baseline    | 默认。元素放置在父元素的基线上。                             |\n> | sub         | 垂直对齐文本的下标。                                         |\n> | super       | 垂直对齐文本的上标                                           |\n> | top         | 把元素的顶端与行中最高元素的顶端对齐                         |\n> | text-top    | 把元素的顶端与父元素字体的顶端对齐                           |\n> | middle      | 把此元素放置在父元素的中部。                                 |\n> | bottom      | 把元素的顶端与行中最低的元素的顶端对齐。                     |\n> | text-bottom | 把元素的底端与父元素字体的底端对齐。                         |\n> | length      |                                                              |\n> | %           | 使用 \"line-height\" 属性的百分比值来排列此元素。允许使用负值。 |\n> | inherit     | 规定应该从父元素继承 vertical-align 属性的值。               |\n\n### 元素中空白的处理方式\n\n> white-space:\n>\n> | 值       | 描述                                                         |\n> | :------- | :----------------------------------------------------------- |\n> | normal   | 默认。空白会被浏览器忽略。                                   |\n> | pre      | 空白会被浏览器保留。其行为方式类似 HTML 中的 <pre> 标签。    |\n> | nowrap   | 文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止。 |\n> | pre-wrap | 保留空白符序列，但是正常地进行换行。                         |\n> | pre-line | 合并空白符序列，但是保留换行符。                             |\n> | inherit  | 规定应该从父元素继承 white-space 属性的值。                  |\n\n### 字间距\n\n> word-spacing:\n>\n> | 值       | 描述                                         |\n> | :------- | :------------------------------------------- |\n> | normal   | 默认。定义单词间的标准空间。                 |\n> | *length* | 定义单词间的固定空间。                       |\n> | inherit  | 规定应该从父元素继承 word-spacing 属性的值。 |\n\n## Fonts(字体)\n\n> CSS字体属性定义字体，加粗，大小，文字样式\n\n![](./__assets__/css-basis-2022-11-22-09-25-43.png)\n\n| 值             | 描述                                                         | 值&描述                                                      |\n| :------------- | :----------------------------------------------------------- | ------------------------------------------------------------ |\n| *font-style*   | 规定字体样式。                                               | normal\\|italic(斜体)\\|bolique(倾斜)\\|inherit                 |\n| *font-variant* | 规定字体异体。                                               | normal\\|small-caps(显示小心大写字母的字体)\\|inherit          |\n| *font-weight*  | 规定字体粗细                                                 | normal\\|bold(粗体)\\|bolder(更粗的字符)\\|lighter(更细的字符)\\|100(数字)\\|inherit |\n| *font-size*    | 字体尺寸和行高                                               | xx-small \\| x-small \\| small \\| medium(默认) \\| large \\| x-large \\| xx-large\\| smaller(比父元素更小的尺寸) \\| larger(比父元素更大的尺寸) \\| length(固定值) \\| %(为父元素的一个百分值) \\| inherit \\| |\n| *line-height*  | 行高                                                         |                                                              |\n| *font-family*  | 规定字体系列。参阅：[font-family](https://www.w3cschool.cn/cssref/pr-font-font-family.html) 中可能的值。 |                                                              |\n| caption        | 定义被标题控件（比如按钮、下拉列表等）使用的字体。           |                                                              |\n| icon           | 定义被图标标记使用的字体。                                   |                                                              |\n| menu           | 定义被下拉列表使用的字体。                                   |                                                              |\n| message-box    | 定义被对话框使用的字体。                                     |                                                              |\n| small-caption  | caption 字体的小型版本。                                     |                                                              |\n| status-bar     | **定义被窗口状态栏使用的字体**                               |                                                              |\n","children":[]},{"name":"css-demo.md","path":"../guanruihua.github.io/CSS","data":"# css-demo\n\n## datalist,progress,audio,video\n\n未完成\n\n## 水平垂直居中\n\n#### absolute + 负margin\n\n这种方式比较好理解，兼容性也很好，缺点是需要知道子元素的宽高\n\n```html\n<div class=\"out\">\n  <div class=\"inner\">12345</div>\n</div>\n\n<style type=\"text/css\">\n  .out{\n    position: relative;\n    width: 300px;\n    height: 300px;\n    background: red;\n  }\n\n  .inner{\n    position: absolute;\n    width: 100px;\n    height: 100px;\n    background: yellow;\n    left: 50%;\n    top: 50%;\n    margin-left: -50px;\n    margin-top: -50px;\n  }\n</style>\n```\n\n#### absolute + auto margin\n\n这种方法兼容性也很好，缺点是需要知道子元素的宽高\n\n```html\n<style type=\"text/css\">\n  .out{\n    position: relative;\n    width: 300px;\n    height: 300px;\n    background: red;\n  }\n\n  .inner{\n    position: absolute;\n    width: 100px;\n    height: 100px;\n    background: yellow;\n    left: 0;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    margin: auto;\n  }\n</style>\n```\n\n#### absolute + calc\n\n这种方法的兼容性依赖于 calc，且也需要知道宽高\n\n```html\n<style type=\"text/css\">\n  .out{\n    position: relative;\n    width: 300px;\n    height: 300px;\n    background: red;\n  }\n\n  .inner{\n    position: absolute;\n    width: 100px;\n    height: 100px;\n    background: yellow;\n    left: calc(50% - 50px);\n    top: calc(50% - 50px);\n  }\n</style>\n```\n\n#### absolute + transform\n\n兼容性依赖 translate，不需要知道子元素宽高\n\n```html\n<style type=\"text/css\">\n  .out{\n    position: relative;\n    width: 300px;\n    height: 300px;\n    background: red;\n  }\n\n  .inner{\n    position: absolute;\n    background: yellow;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);\n  }\n</style>\n```\n\n#### table\n\ncss新增的table属性，可以让我们把普通元素，变为table元素的显示效果，通过这个特性也可以实现水平垂直居中。\n这种方法兼容性也不错。\n\n```html\n<style type=\"text/css\">\n  .out{\n    display: table-cell;\n    width: 300px;\n    height: 300px;\n    text-align: center;\n    vertical-align: middle;\n    background: red;\n  }\n\n  .inner{\n    display: inline-block;\n    background: yellow;\n    width: 100px;\n    height: 100px;\n  }\n</style>\n```\n\n#### flex\n\nflex 实现起来比较简单，三行代码即可搞定。可通过父元素指定子元素的对齐方式，也可通过 子元素自己指定自己的对齐方式来实现。第二种方式见 grid 布局。\n\n```html\n<style type=\"text/css\">\n  .out{\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 300px;\n    height: 300px;\n    background: red;\n  }\n\n  .inner{\n    background: yellow;\n    width: 100px;\n    height: 100px;\n  }\n</style>\n```\n\n#### grid\n\ngrid 布局也很强大，大体上属性跟 flex 差不多。\n\n```html\n//方法一：父元素指定子元素的对齐方式\n<style type=\"text/css\">\n  .out{\n    display: grid;\n    align-content: center;\n    justify-content: center;\n    width: 300px;\n    height: 300px;\n    background: red;\n  }\n\n  .inner{\n    background: yellow;\n    width: 100px;\n    height: 100px;\n  }\n</style>\n\n//方法二：子元素自己指定自己的对齐方式\n<style type=\"text/css\">\n  .out{\n    display: grid;\n    width: 300px;\n    height: 300px;\n    background: red;\n  }\n\n  .inner{\n    background: yellow;\n    width: 100px;\n    height: 100px;\n    align-self: center;\n    justify-self: center;\n  }\n</style>\n```\n\n## 多行文本实现移除显示省略号\n\n单行\n\n```css\noverflow:hidden;\ntext-overflow: ellipsis;\nwhite-space: nowrap;\n```\n\nwebkit浏览器或移动端的页面\n\n多行\n\n```css\noverflow : hidden;\ntext-overflow: ellipsis;//显示省略号\ndisplay: -webkit-box;//设置对象为弹性盒子模型显示\n-webkit-line-clamp: 2;//限制一个块元素显示的文本的行数\n-webkit-box-orient: vertical;//必须结合的属性,设置或检索伸缩和对象\n```\n\n跨浏览器兼容的方案\n\n```css\np {\n    position:relative;\n    line-height:1.4em;\n    /* 3 times the line-height to show 3 lines */\n    height:4.2em;\n    overflow:hidden;\n}\np::after {\n    content:\"...\";\n    font-weight:bold;\n    position:absolute;\n    bottom:0;\n    right:0;\n    padding:0 20px 1px 45px;\n    background:url(/newimg88/2014/09/ellipsis_bg.png) repeat-y;\n}\n```\n\n## 更改有序列表的样式\n\n有序列表\n\n```html\n<ol>\n  <li>第一行</li>\n  <li>第二行</li> \n  <li>第三行</li> \n  <li>第四行</li> \n</ol>\n     \n```\n\n效果：\n\n```\n1.第一行\n2.第二行\n3.第三行\n4.第四行\n```\n\n新的需求效果\n\n```css\n1、第一行\n2、第二行\n3、第三行\n4、第四行\n//使用:before伪类\n//样式：\nol{\n  counter-reset: num;\n}\nol li:after{\n  content: counter(num)\"、\";\n  counter-increment: num;\n}\n// 结构\n<ol>\n  <li>第一行</li>\n  <li>第二行</li>\n  <li>第三行</li>\n  <li>第四行</li>\n</ol>\n```\n\n## 修改谷歌没浏览器滚动条的样式\n\n```css\n/*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/\n::-webkit-scrollbar {\n  width: 8px;\n  background-color: #fff;\n  z-index: 11;\n}\n\n/*定义滚动条轨道 内阴影+圆角*/\n::-webkit-scrollbar-track {\n  -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);\n  border-radius: 10px;\n  background-color: #ededed;\n}\n\n/*定义滑块 内阴影+圆角*/\n::-webkit-scrollbar-thumb {\n  border-radius: 10px;\n  background-color: #46cdff;\n  background-image: -webkit-linear-gradient(\n    45deg,\n    rgba(255, 255, 255, 0.2) 25%,\n    transparent 25%,\n    transparent 50%,\n    rgba(255, 255, 255, 0.2) 50%,\n    rgba(255, 255, 255, 0.2) 75%,\n    transparent 75%,\n    transparent\n  );\n}\n\n/*定义最上方和最下方的按钮*/\n::-webkit-scrollbar-button {\n  background-color: #000;\n  border: 1px solid yellow;\n  display: none;\n}\n```\n\n## 元素隐藏\n\n```\ndisplay: none; 设置为隐藏, 且不会渲染, 不会占据空间\nvisibility: hidden; 设置为隐藏, 但是还是会占用空间\nrgba() 或opacity 改变其透明度为1 , 也同样可以达到元素隐藏的效果\n```\n\n## CSS属性默认值\n\n```\nborder-top-width:默认值medium,定义中等的上边框。\noutline-width:默认值medium,规定中等的轮廓。\npadding-top, margin-top默认值都是0;\n```\n\n## max-device-width 与 max-width 区别\n\n**max-width 指的是显示区域的宽度，比如浏览器的显示区域宽度**\n\n（max-width is the width of the target display area, e.g. the browser）\n\n**max-device-width 指的是设备整个渲染（显示）区域的宽度，比如设备的实际屏幕大小，也就是设备分辨率**\n\n## FF2.0\n\n> 父元素不能支持自适应子元素的高度\n\n**Mozilla Firefox 2**是**Firefox**的版本的问题,\n\n## 置换元素,不可替换元素\n\na) 置换元素：浏览器根据元素的标签和属性，来决定元素的具体显示内容。\n例如：浏览器会根据<img>标签的src属性的 值来读取图片信息并显示出来，而如果查看(x)html代码，则看不到图片的实际内容；<input>标签的type属性来决定是显示输入 框，还是单选按钮等。 (x)html中 的<img>、<input>、<textarea>、<select>、<object> 都是置换元素。这些元素往往没有实际的内容，即是一个空元素。\n\n置换元素在其显示中生成了框，这也就是有的内联元素能够设置宽高的原因。\n\nb) 不可替换元素：(x)html 的大多数元素是不可替换元素，即其内容直接表现给用户端（如浏览器）。\n\n例如： <label>label中的内容</label> 标签<label>是一个非置换元素，文字label中的内容”将全被显示。\n\n## 默认支持跨域的标签\n\n> image, iframe,img,\n\n## fieldset>legend\n\n```html\n<fieldset>\n  <legend>类型名</legend>\n  内容显示\n</fieldset>\n```\n\n## 预备格式化标签\n\n```html\n<pre>定义预格式文本，保持文本原有的格式\n<meta> 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。\n<meta> 标签位于文档的头部，不包含任何内容。\n<meta> 标签的属性定义了与文档相关联的名称/值对。\n\n<mark> 标签定义带有记号的文本。请在需要突出显示文本时使用 <m> 标签。\neg:<mark>milk</mark>   \n       milk \n\n<small>标签呈现小号字体效果。\n```\n\n## 修改radio和checkbox的样式\n\n- 无法通过 css 样式来直接修改原生的 radio 和 checkbox\n\n- 通过 label 和 radio 或checkbox 的绑定关系, 让label 当做 checkbox 来显示\n\n  ```pug\n  // pug\n  \n  input( type='checkbox',id='mycheck')\n  label(for='mycheck')\n  \n  input(type='radio',id='myradio')\n  label(for='myradio')\n  ```\n\n```css\n  // css\n  input[type='radio'], input[type='checkbox'] {\n    display: none !important;\n  }\n  input[type='checkbox']+label {\n    background-color: #fff;\n    border-radius: 5px;\n    border: 1px solid #d3d3d3;\n    width: 20px;\n    height: 20px;\n    display: inline-block;\n    text-align: center;\n    vertical-align: middle;\n    line-height: 20px;\n  }\n  // 通过checked状态 , 再通过兄弟组件 替换checkbox 的label\n  input[type='checkbox']:checked+label {\n    background-color: #c0c0c0;\n  }\n  input[type='radio']:checked+label {\n    background-color: #c0c0c0;\n  }\n  // 通过after 和 context 来替换 radio中点  \n  #myCheck:checked+label:after {\n    content: \"\\2714\";  // √ \n    display: block;\n    width: 20px;\n    height: 20px;\n  }\n```\n\n## div三角形\n\n```css\n*{margin: 0; padding: 0}\n.content{\n width:0;\n height:0;\n margin: 0 auto;\n border-width:20px;\n border-style:solid;\n border-color:transparent transparent pink transparent;\n}\n\n.content2{\n width: 0;\n  height:0;\n  margin:0 auto;\n  border:50px solid transparent;\n  border-top: 50px solid pink;\n \n}\n```\n","children":[]},{"name":"css-expand.md","path":"../guanruihua.github.io/CSS","data":"# css-expand\n\n## div禁用, 不可点击\n\n> `pointer-events: none;`\n\n## 滚动贴边 & 无视事件\n\n> 1. 滚动贴合 ：父元素scroll-snap-type，子元素scroll-snap-align。\n>\n> 2. 无视事件：pointer-events: none 。\n\n## 修改滚动条样式\n\ndemo\n\n```css\n/*滚动条的宽度*/\n\n    ::-webkit-scrollbar {\n        width:9px;\n        height:9px;\n    }\n\n/*外层轨道。可以用display:none让其不显示，也可以添加背景图片，颜色改变显示效果*/\n\n    ::-webkit-scrollbar-track {\n        width: 6px;\n        background-color:#0d1b20;\n        -webkit-border-radius: 2em;\n        -moz-border-radius: 2em;\n        border-radius:2em;\n    }\n\n/*滚动条的设置*/\n\n    ::-webkit-scrollbar-thumb {\n        background-color:#606d71;\n        background-clip:padding-box;\n        min-height:28px;\n        -webkit-border-radius: 2em;\n        -moz-border-radius: 2em;\n        border-radius:2em;\n    }\n/*滚动条移上去的背景*/\n\n    ::-webkit-scrollbar-thumb:hover {\n         background-color:#fff;\n    }\n\n```\n\n```css\n::-webkit-scrollbar 滚动条整体部分，其中的属性有width,height,background,border（就和一个块级元素一样）等。\n::-webkit-scrollbar-button 滚动条两端的按钮。可以用display:none让其不显示，也可以添加背景图片，颜色改变显示效果。\n::-webkit-scrollbar-track 外层轨道。可以用display:none让其不显示，也可以添加背景图片，颜色改变显示效果。\n::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分（除去）。\n::-webkit-scrollbar-thumb 滚动条里面可以拖动的那部分\n::-webkit-scrollbar-corner 边角\n::-webkit-resizer 定义右下角拖动块的样式\n```\n\n## 清除浮动\n\n> - 1  非父元素设置高度         但这种情况 有些时候不能精确的计算出父元所需要的高度\n> - 2  父元素也浮动           这又会影响父类元素的同级元素了\n> - 3  父元素写 overflow:hidden    如果父元素需要 溢出显示的话  就不行了\n> - 4  在父元素的后面加空的div元素   设置样式clear:both\n\n## css盒模型\n\n```css\n//设置标准模型\nbox-sizing: content-box;//默认\n//设置IE模型\nbox-sizing: border-box;\n```\n\n| 标准模型                                                     | IE模型                                                       |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| <img src=\"https://images.gitee.com/uploads/images/2020/0918/224618_5ce6d3cf_7984151.png\" style=\"zoom:50%;\" /> | <img src=\"https://images.gitee.com/uploads/images/2020/0918/224630_77d492a3_7984151.png\" style=\"zoom:50%;\" /> |\n\n### js设置和模型的宽高\n\n```js\n//只能获取内联样式设置的宽高\ndom.style.width/height\n\n//获取渲染后即时运行的宽高，值是准确的。但只支持 IE\ndom.currentStyle.width/height\n\n//获取渲染后即时运行的宽高，值是准确的。兼容性更好\nwindow.getComputedStyle(dom).width/height;\n\n//获取渲染后即时运行的宽高，值是准确的。兼容性也很好，一般用来获取元素的绝对位置，getBoundingClientRect()会得到4个值：left, top, width, height\ndom.getBoundingClientRect().width/height;\n```\n\n## BFC\n\n什么是 BFC？Block Formatting Context（块级格式化上下文）。\n在解释什么是BFC之前，我们需要先知道Box、Formatting Context的概念。\n\n#### Box：css布局的基本单位\n\nBox 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子：\n\n- block-level box: display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；\n- inline-level box: display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；\n- run-in box: css3 中才有， 这儿先不讲了。\n\n#### Formatting Context\n\nFormatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 **Block fomatting context** (简称BFC)和 **Inline formatting context** (简称IFC)。\n\n#### BFC的布局规则\n\n- 内部的Box会在垂直方向，一个接一个地放置。\n- Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。\n- 每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。\n- BFC的区域不会与float box重叠。\n- BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。\n- 计算BFC的高度时，浮动元素也参与计算。\n\n#### 如何创建BFC\n\n1. float 的值不是none。\n2. position 的值不是static或者relative。\n3. overflow 的值不是visible。\n4. display 的值是inline-block、table-cell、flex、table-caption或者inline-flex。\n\n#### BFC的作用\n\n1. 利用BFC避免margin重叠\n2. 自适应两栏布局\n3. 清除浮动\n","children":[]},{"name":"css3.md","path":"../guanruihua.github.io/CSS","data":"# CSS3\n\n## 边框\n\n### border-radius:圆角\n\n```css\n\ndiv{\n  border:2px solid;\n  border-radius:25px;//添加圆角\n  -moz-border-radius:25px; /* Old Firefox */\n}\n```\n\n### box-shadow:边框阴影\n\n```css\ndiv{\n box-shadow: 10px 10px 5px #888888;\n}\n```\n\n### border-image:边框图片\n\n> 语法`box-shadow: h-shadow v-shadow blur spread color inset;`\n\n| 值         | 描述                                     |\n| :--------- | :--------------------------------------- |\n| *h-shadow* | 必需。水平阴影的位置。允许负值。         |\n| *v-shadow* | 必需。垂直阴影的位置。允许负值。         |\n| *blur*     | 可选。模糊距离。                         |\n| *spread*   | 可选。阴影的尺寸。                       |\n| *color*    | 可选。阴影的颜色。请参阅 CSS 颜色值。    |\n| inset      | 可选。将外部阴影 (outset) 改为内部阴影。 |\n\n```css\ndiv{\n  border-image:url(border.png) 30 30 round;\n  -moz-border-image:url(border.png) 30 30 round; /* 老的 Firefox */\n  -webkit-border-image:url(border.png) 30 30 round; /* Safari 和 Chrome */\n -o-border-image:url(border.png) 30 30 round; /* Opera */\n}\n```\n\n## 背景\n\n### background-size\n\n> 用于控制背景图片的尺寸的大小\n>\n> `background-size` :    宽   高\n>\n> `background-size: cover;` :\n>\n> ​  作用 :  将背景图片按照比例缩放到最小尺寸, 使其可以完整覆盖背景区域\n>\n> ​  主要作用于 : 背景图片 <  容器小\n>\n> `background: contian;` :\n>\n> ​  作用: 将背景图片按比例将图片缩放到最大尺寸, 使其高宽都在背景区域总\n>\n> ​  主要作用于 : 背景图片 > 容器 ( 背景图片可能会发生扭曲 )\n\n```css\ndiv{\n  background:url(bg_flower.gif);\n  -moz-background-size:63px 100px; /* 老版本的 Firefox */\n  background-size:63px 100px;\n  background-repeat:no-repeat;\n}\n```\n\n### background-origin:规定背景图片的定位区域\n\n> 背景图片可以放置于 content-box、padding-box 或 border-box 区域。\n\n![](https://images.gitee.com/uploads/images/2020/0521/204114_f4fa818f_6545143.png)\n\n```css\ndiv{\nbackground:url(bg_flower.gif);\nbackground-repeat:no-repeat;\nbackground-size:100% 100%;\n-webkit-background-origin:content-box; /* Safari */\nbackground-origin:content-box;\n}\n```\n\n![](https://images.gitee.com/uploads/images/2020/0521/204314_74d8bc39_6545143.png)\n\n```css\n//多重背景图片\nbody{ \nbackground-image:url(bg_flower.gif),url(bg_flower_2.gif);\n}\n```\n\n### background-clip:规定背景的绘制区域\n\n```css\nbackground-clip: border-box|padding-box|content-box;\n```\n\n## 文字效果\n\n### text-shadow:文本阴影\n\n> 水平阴影 垂直阴影 模糊距离 阴影颜色\n\n```css\nh1{\ntext-shadow: 5px 5px 5px #FF0000;\n}\n```\n\n![](https://images.gitee.com/uploads/images/2020/0521/205537_5885dc8a_6545143.png)\n\n### word-wrap:允许单词换行\n\n> ```css\n> word-wrap: normal|break-word;\n> ```\n\n### text-overflow:规定当文本溢出包含元素时发生的事情\n\n```css\ntext-overflow: clip|ellipsis|string;\n```\n\n> clip:修剪文本\n>\n> ellipsis:显示省略符号来替代被修剪的文本\n>\n> string: 使用给定的字符串来代表修剪的文本\n\n![](https://images.gitee.com/uploads/images/2020/0521/210327_4f5ac834_6545143.png)\n\n## 字体\n\n### @font-face\n\n> 可以使用自己喜欢的任意字体\n\n```css\n@font-face{\n font-family: myFirstFont;\n src: url('Sansation_Light.ttf'),\n     url('Sansation_Light.eot'); /* IE9+ */\n  font-weight:bold;//可选\n}\n\ndiv{\nfont-family:myFirstFont;\n}\n```\n\n| 描述符        | 值                                                           | 描述                                                         |\n| :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| font-family   | *name*                                                       | 必需。规定字体的名称。                                       |\n| src           | *URL*                                                        | 必需。定义字体文件的 URL。                                   |\n| font-stretch  | normal \\|  condensed \\| ultra-condensed\\|extra-condensed \\| semi-condensed   expanded \\| semi-expanded \\| extra-expanded \\| ultra-expanded | 可选。定义如何拉伸字体。默认是 \"normal\"。                    |\n| font-style    | ormal     italic    oblique                                  | 可选。定义字体的样式。默认是 \"normal\"。                      |\n| font-weight   | normal   bold   100...                                       | 可选。定义字体的粗细。默认是 \"normal\"。                      |\n| unicode-range | *unicode-range*                                              | 可选。定义字体支持的 UNICODE 字符范围。默认是 \"U+0-10FFFF\"。 |\n\n## 2D转换\n\n> 能对元素进行移动、缩放、转动、拉长或拉伸\n\n### rotate():顺时针旋转\n\n```css\ndiv{\ntransform: rotate(30deg);\n-ms-transform: rotate(30deg);  /* IE 9 */\n-webkit-transform: rotate(30deg); /* Safari and Chrome */\n-o-transform: rotate(30deg);  /* Opera */\n-moz-transform: rotate(30deg);  /* Firefox */\n}\n```\n\n> deg:单位 度\n\n### translate(x,y):移动\n\n> | translateX(*n*) | 定义 2D 转换，沿着 X 轴移动元素。 |\n> | --------------- | --------------------------------- |\n> | translateY(*n*) | 定义 2D 转换，沿着 Y 轴移动元素。 |\n\n```css\ndiv{\ntransform: translate(50px,100px);\n-ms-transform: translate(50px,100px);  /* IE 9 */\n-webkit-transform: translate(50px,100px); /* Safari and Chrome */\n-o-transform: translate(50px,100px);  /* Opera */\n-moz-transform: translate(50px,100px);  /* Firefox */\n}\n```\n\n### scale(x,y):放大\n\n> 宽放大x倍,    高扩大y倍\n>\n> | scaleX(*n*) | 定义 2D 缩放转换，改变元素的宽度。 |\n> | ----------- | ---------------------------------- |\n> | scaleY(*n*) | 定义 2D 缩放转换，改变元素的高度。 |\n\n```css\ndiv{\ntransform: scale(2,4);\n-ms-transform: scale(2,4); /* IE 9 */\n-webkit-transform: scale(2,4); /* Safari 和 Chrome */\n-o-transform: scale(2,4); /* Opera */\n-moz-transform: scale(2,4); /* Firefox */\n}\n```\n\n### skew():翻转\n\n> 值 skew(30deg,20deg) 围绕 X 轴把元素翻转 30 度，围绕 Y 轴翻转 20 度\n>\n> | skewX(*angle*) | 定义 2D 倾斜转换，沿着 X 轴。 |\n> | -------------- | ----------------------------- |\n> | skewY(*angle*) | 定义 2D 倾斜转换，沿着 Y 轴。 |\n\n```css\ndiv{\ntransform: skew(30deg,20deg);\n-ms-transform: skew(30deg,20deg); /* IE 9 */\n-webkit-transform: skew(30deg,20deg); /* Safari and Chrome */\n-o-transform: skew(30deg,20deg); /* Opera */\n-moz-transform: skew(30deg,20deg); /* Firefox */\n}\n```\n\n### matrix():把所有 2D 转换方法组合在一起\n\n```css\ntransform: matrix(a,b,c,d,e,f);\n```\n\n![](https://images.gitee.com/uploads/images/2020/0521/232156_7bf18ee4_6545143.png)\n\n> ​    x  =>  `ax+cy+e`\n>\n> ​ y  => `bx+dy+f`\n\n```css\ndiv{\ntransform:matrix(0.866,0.5,-0.5,0.866,0,0);\n-ms-transform:matrix(0.866,0.5,-0.5,0.866,0,0);  /* IE 9 */\n-moz-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Firefox */\n-webkit-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Safari and Chrome */\n-o-transform:matrix(0.866,0.5,-0.5,0.866,0,0);  /* Opera */\n}\n```\n\n## 3D转换\n\n### rotateX():绕X翻转\n\n```css\ndiv{\n  transform: rotateX(120deg);\n  -webkit-transform: rotateX(120deg); /* Safari 和 Chrome */\n  -moz-transform: rotateX(120deg); /* Firefox */\n}\n```\n\n### rotateY():绕Y旋转\n\n```css\ndiv{\n  transform: rotateY(130deg);\n  -webkit-transform: rotateY(130deg); /* Safari 和 Chrome */\n  -moz-transform: rotateY(130deg); /* Firefox */\n}\n```\n\n| 函数                                                         | 描述                                      |\n| :----------------------------------------------------------- | :---------------------------------------- |\n| matrix3d(*n*,*n*,*n*,*n*,*n*,*n*, *n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*) | 定义 3D 转换，使用 16 个值的 4x4 矩阵。   |\n| translate3d(*x*,*y*,*z*)                                     | 定义 3D 转化。                            |\n| translateX(*x*)                                              | 定义 3D 转化，仅使用用于 X 轴的值。       |\n| translateY(*y*)                                              | 定义 3D 转化，仅使用用于 Y 轴的值。       |\n| translateZ(*z*)                                              | 定义 3D 转化，仅使用用于 Z 轴的值。       |\n| scale3d(*x*,*y*,*z*)                                         | 定义 3D 缩放转换。                        |\n| scaleX(*x*)                                                  | 定义 3D 缩放转换，通过给定一个 X 轴的值。 |\n| scaleY(*y*)                                                  | 定义 3D 缩放转换，通过给定一个 Y 轴的值。 |\n| scaleZ(*z*)                                                  | 定义 3D 缩放转换，通过给定一个 Z 轴的值。 |\n| rotate3d(*x*,*y*,*z*,*angle*)                                | 定义 3D 旋转。                            |\n| rotateX(*angle*)                                             | 定义沿 X 轴的 3D 旋转。                   |\n| rotateY(*angle*)                                             | 定义沿 Y 轴的 3D 旋转。                   |\n| rotateZ(*angle*)                                             | 定义沿 Z 轴的 3D 旋转。                   |\n| perspective(*n*)                                             | 定义 3D 转换元素的透视视图。              |\n\n## 过渡\n\n### transition\n\n```css\ndiv{\n  transition: width 2s, height 2s, transform 2s;\n  -moz-transition: width 2s, height 2s, -moz-transform 2s;\n  -webkit-transition: width 2s, height 2s, -webkit-transform 2s;\n  -o-transition: width 2s, height 2s,-o-transform 2s;\n}\n\ndiv:hover{\n  width:200px;\n  height:200px;\n  transform:rotate(180deg);\n  -moz-transform:rotate(180deg); /* Firefox 4 */\n  -webkit-transform:rotate(180deg); /* Safari and Chrome */\n  -o-transform:rotate(180deg); /* Opera */\n}\n//实现鼠标移至元素div上,div会变成div:hover{},过渡时间为2s\n```\n\n| 属性                                                         | 描述                                         |\n| :----------------------------------------------------------- | :------------------------------------------- |\n| [transition](https://www.w3school.com.cn/cssref/pr_transition.asp) | 简写属性，用于在一个属性中设置四个过渡属性。 |\n| [transition-property](https://www.w3school.com.cn/cssref/pr_transition-property.asp) | 规定应用过渡的 CSS 属性的名称。              |\n| [transition-duration](https://www.w3school.com.cn/cssref/pr_transition-duration.asp) | 定义过渡效果花费的时间。默认是 0。           |\n| [transition-timing-function](https://www.w3school.com.cn/cssref/pr_transition-timing-function.asp) | 规定过渡效果的时间曲线。默认是 \"ease\"。      |\n| [transition-delay](https://www.w3school.com.cn/cssref/pr_transition-delay.asp) | 规定过渡效果何时开始。默认是 0。             |\n\n## 动画\n\n### @keyframes\n\n> 规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。\n\n#### 改变背景颜色\n\n```css\n@keyframes myfirst\n{\nfrom {background: red;}\nto {background: yellow;}\n}\n\n@-moz-keyframes myfirst /* Firefox */\n{\nfrom {background: red;}\nto {background: yellow;}\n}\n\n@-webkit-keyframes myfirst /* Safari 和 Chrome */\n{\nfrom {background: red;}\nto {background: yellow;}\n}\n\n@-o-keyframes myfirst /* Opera */\n{\nfrom {background: red;}\nto {background: yellow;}\n}\n\ndiv{\n  animation: myfirst 5s;\n  -moz-animation: myfirst 5s; /* Firefox */\n  -webkit-animation: myfirst 5s; /* Safari 和 Chrome */\n  -o-animation: myfirst 5s; /* Opera */\n}\n//把 \"myfirst\" 动画捆绑到 div 元素，时长：5 秒：\n```\n\n#### 多次改变背景颜色\n\n> 当动画为 25% 及 50% 时改变背景色，然后当动画 100% 完成时再次改变：\n\n```css\n@keyframes myfirst\n{\n0%   {background: red;}\n25%  {background: yellow;}\n50%  {background: blue;}\n100% {background: green;}\n}\n\n@-moz-keyframes myfirst /* Firefox */\n{\n0%   {background: red;}\n25%  {background: yellow;}\n50%  {background: blue;}\n100% {background: green;}\n}\n\n@-webkit-keyframes myfirst /* Safari 和 Chrome */\n{\n0%   {background: red;}\n25%  {background: yellow;}\n50%  {background: blue;}\n100% {background: green;}\n}\n\n@-o-keyframes myfirst /* Opera */\n{\n0%   {background: red;}\n25%  {background: yellow;}\n50%  {background: blue;}\n100% {background: green;}\n}\n\n```\n\n#### 改变背景颜色和位置\n\n```css\n@keyframes myfirst\n{\n0%   {background: red; left:0px; top:0px;}\n25%  {background: yellow; left:200px; top:0px;}\n50%  {background: blue; left:200px; top:200px;}\n75%  {background: green; left:0px; top:200px;}\n100% {background: red; left:0px; top:0px;}\n}\n\n@-moz-keyframes myfirst /* Firefox */\n{\n0%   {background: red; left:0px; top:0px;}\n25%  {background: yellow; left:200px; top:0px;}\n50%  {background: blue; left:200px; top:200px;}\n75%  {background: green; left:0px; top:200px;}\n100% {background: red; left:0px; top:0px;}\n}\n\n@-webkit-keyframes myfirst /* Safari 和 Chrome */\n{\n0%   {background: red; left:0px; top:0px;}\n25%  {background: yellow; left:200px; top:0px;}\n50%  {background: blue; left:200px; top:200px;}\n75%  {background: green; left:0px; top:200px;}\n100% {background: red; left:0px; top:0px;}\n}\n\n@-o-keyframes myfirst /* Opera */\n{\n0%   {background: red; left:0px; top:0px;}\n25%  {background: yellow; left:200px; top:0px;}\n50%  {background: blue; left:200px; top:200px;}\n75%  {background: green; left:0px; top:200px;}\n100% {background: red; left:0px; top:0px;}\n}\n```\n\n| 属性                                                         | 描述                                                     |\n| :----------------------------------------------------------- | :------------------------------------------------------- |\n| [@keyframes](https://www.w3school.com.cn/cssref/pr_keyframes.asp) | 规定动画。                                               |\n| [animation](https://www.w3school.com.cn/cssref/pr_animation.asp) | 所有动画属性的简写属性，除了 animation-play-state 属性。 |\n| [animation-name](https://www.w3school.com.cn/cssref/pr_animation-name.asp) | 规定 @keyframes 动画的名称。                             |\n| [animation-duration](https://www.w3school.com.cn/cssref/pr_animation-duration.asp) | 规定动画完成一个周期所花费的秒或毫秒。默认是 0。         |\n| [animation-timing-function](https://www.w3school.com.cn/cssref/pr_animation-timing-function.asp) | 规定动画的速度曲线。默认是 \"ease\"。                      |\n| [animation-delay](https://www.w3school.com.cn/cssref/pr_animation-delay.asp) | 规定动画何时开始。默认是 0。                             |\n| [animation-iteration-count](https://www.w3school.com.cn/cssref/pr_animation-iteration-count.asp) | 规定动画被播放的次数。默认是 1。                         |\n| [animation-direction](https://www.w3school.com.cn/cssref/pr_animation-direction.asp) | 规定动画是否在下一周期逆向地播放。默认是 \"normal\"。      |\n| [animation-play-state](https://www.w3school.com.cn/cssref/pr_animation-play-state.asp) | 规定动画是否正在运行或暂停。默认是 \"running\"。           |\n| [animation-fill-mode](https://www.w3school.com.cn/cssref/pr_animation-fill-mode.asp) | 规定对象动画时间之外的状态。                             |\n\n## 多列\n\n#### column-count:规定元素分隔成多列\n\n```css\n//分隔成三列\ndiv{\n-moz-column-count:3;  /* Firefox */\n-webkit-column-count:3; /* Safari 和 Chrome */\ncolumn-count:3;\n}\n```\n\n#### column-gap:列间隔\n\n```css\ndiv{\n-moz-column-gap:40px;  /* Firefox */\n-webkit-column-gap:40px; /* Safari 和 Chrome */\ncolumn-gap:40px;\n}\n```\n\n#### column-rule:列规则\n\n```css\ndiv{\n-moz-column-rule:3px outset #ff0000; /* Firefox */\n-webkit-column-rule:3px outset #ff0000; /* Safari and Chrome */\ncolumn-rule:3px outset #ff0000;\n}\n```\n\n| [column-count](https://www.w3school.com.cn/cssref/pr_column-count.asp) | 规定元素应该被分隔的列数。                         |\n| ------------------------------------------------------------ | -------------------------------------------------- |\n| [column-fill](https://www.w3school.com.cn/cssref/pr_column-fill.asp) | 规定如何填充列。                                   |\n| [column-gap](https://www.w3school.com.cn/cssref/pr_column-gap.asp) | 规定列之间的间隔。                                 |\n| [column-rule](https://www.w3school.com.cn/cssref/pr_column-rule.asp) | 设置所有 column-rule-* 属性的简写属性。            |\n| [column-rule-color](https://www.w3school.com.cn/cssref/pr_column-rule-color.asp) | 规定列之间规则的颜色。                             |\n| [column-rule-style](https://www.w3school.com.cn/cssref/pr_column-rule-style.asp) | 规定列之间规则的样式。                             |\n| [column-rule-width](https://www.w3school.com.cn/cssref/pr_column-rule-width.asp) | 规定列之间规则的宽度。                             |\n| [column-span](https://www.w3school.com.cn/cssref/pr_column-span.asp) | 规定元素应该横跨的列数。                           |\n| [column-width](https://www.w3school.com.cn/cssref/pr_column-width.asp) | 规定列的宽度。                                     |\n| [columns](https://www.w3school.com.cn/cssref/pr_columns.asp) | 规定设置 column-width 和 column-count 的简写属性。 |\n\n## 用户界面\n\n### resize\n\n```css\ndiv{\nresize:both;\noverflow:auto;\n}\n//可有用户调整大小\n```\n\n### box-sizing\n\n> 允许您以确切的方式定义适应某个区域的具体内容\n\n```css\ndiv{\nbox-sizing:border-box;\n-moz-box-sizing:border-box; /* Firefox */\n-webkit-box-sizing:border-box; /* Safari */\nwidth:50%;\nfloat:left;\n}\n```\n\n### outline-offset\n\n> 对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓\n\n> 规定边框边缘之外 15 像素处的轮廓：\n\n```css\ndiv{\nborder:2px solid black;\noutline:2px solid red;\noutline-offset:15px;\n}\n```\n\n| [appearance](https://www.w3school.com.cn/cssref/pr_appearance.asp) | 允许您将元素设置为标准用户界面元素的外观           |\n| ------------------------------------------------------------ | -------------------------------------------------- |\n| [box-sizing](https://www.w3school.com.cn/cssref/pr_box-sizing.asp) | 允许您以确切的方式定义适应某个区域的具体内容。     |\n| [icon](https://www.w3school.com.cn/cssref/pr_icon.asp)       | 为创作者提供使用图标化等价物来设置元素样式的能力。 |\n| [nav-down](https://www.w3school.com.cn/cssref/pr_nav-down.asp) | 规定在使用 arrow-down 导航键时向何处导航。         |\n| [nav-index](https://www.w3school.com.cn/cssref/pr_nav-index.asp) | 设置元素的 tab 键控制次序。                        |\n| [nav-left](https://www.w3school.com.cn/cssref/pr_nav-left.asp) | 规定在使用 arrow-left 导航键时向何处导航。         |\n| [nav-right](https://www.w3school.com.cn/cssref/pr_nav-right.asp) | 规定在使用 arrow-right 导航键时向何处导航。        |\n| [nav-up](https://www.w3school.com.cn/cssref/pr_nav-up.asp)   | 规定在使用 arrow-up 导航键时向何处导航。           |\n| [outline-offset](https://www.w3school.com.cn/cssref/pr_outline-offset.asp) | 对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。   |\n| [resize](https://www.w3school.com.cn/cssref/pr_resize.asp)   | 规定是否可由用户对元素的尺寸进行调整。             |\n\n## 伪类&伪元素\n\n### :hover&:focus显示浮层\n\n```html\n<a href=\"javascript:;\">图片链接</a>\n<img src=\"xxx\" alt=\"\" />\n<style> \n  img{\n    visiblity: hidden;\n    position: absolute;\n    transition: visiblity .2s;\n  }\n  a:hover + img, img:hover{\n    visibility: visible;\n  }\n  \n  //非PC端,用这个\n  a:focus + img,\n  img:focus{\n    visibility: visible;\n    transition: none;\n  }\n</style>\n```\n\n### :not()判断显示元素\n\n```css\n.list:not([class=\"show\"]) { display: none; }\n```\n\n### ::after & ::before & content\n\n> - content 属性常常用于在元素::before和::after伪元素中插入内容\n> - ::after     在指定元素后加入content\n> - ::before  在指定元素前加入content\n\n#### content\n\n> - 值\n>   - none : 不会产生伪类元素\n>   - normal : `:before` 和 `:after`伪类元素会被视为none\n>   - `<string>`: 文本内容\n>   - `<uri> url()` :  uri会指定一个外部资源 (比如图片) , 不能正常显示就会被忽略, 或显示一些占位符(无图片标志)\n>   - `<counter>`\n>     - counter(计数器名 [, style])\n>     - counters(计数器名称 [, string] [,style])\n>   - attr(X) : 将元素的X属性以字符串的形式返回, 该元素没有该属性就会返回空字符串\n>   - open-quote | close-quote : 这些值会被quotes中定义的字符串替换\n>   - no-open-quote | no-close-quote : 不会产生任何内容, 但是会改变(增加或降低) 引号的层级\n\n##### content counter\n\n> 1. counter属性对多个项目进行连续编号, 计数器课任意命名\n> 2. counter-increment属性设置counter属性值所指定的计数器名\n> 3. 使用content 追加内容 coutent : '第' counter(计数器名称) '个'\n> 4. 指定彪悍种类: content: counter(计数器名, 种类[\"upper-alpha\"])\n> 5. 编号嵌套需要在大标题中使用counter-reset进行编号重置\n\n###### 插入编号\n\n```html\n<style>\n    h4::before{\n      content: counter(num)'.';\n      color: #f00;\n    }\n    h4{\n      counter-increment: num;\n    }\n</style>\n<body>\n    <h4>标题一</h4>\n    <h4>标题二</h4>\n    <h4>标题三</h4>\n    <h4>标题四</h4>\n    <h4>标题五</h4>\n</body>\n```\n\n###### 指定编号种类\n\n```html\n<style>\n    h4::before{\n      content: counter(num,upper-alpha)'.';\n      color: #f00;\n    }\n    h4{\n      counter-increment: num;\n    }\n</style>\n<body>\n    <h4>标题一</h4>\n    <h4>标题二</h4>\n    <h4>标题三</h4>\n    <h4>标题四</h4>\n    <h4>标题五</h4>\n</body>\n```\n\n###### 编号嵌套\n\n```html\n<style>\n    h1::before{\n      content: counter(num)'.';\n    }\n    h1{\n      counter-increment: num;\n      counter-reset: littenum; /* 重置小标题编号 */\n    }\n    h4::before{\n      content: counter(littenum)'.';\n    }\n    h4{\n      counter-increment: littenum;\n      margin-left: 40px;\n    }\n</style>\n<body>\n <h1>标题</h1>\n    <h4>小标题</h4>\n    <h4>小标题</h4>\n    <h4>小标题</h4>\n    <h1>标题</h1>\n    <h4>小标题</h4>\n    <h4>小标题</h4>\n    <h4>小标题</h4>\n    <h1>标题</h1>\n    <h4>小标题</h4>\n    <h4>小标题</h4>\n    <h4>小标题</h4>\n</body>\n```\n\n### :lang\n","children":[]},{"name":"gradient","path":"../guanruihua.github.io/CSS","data":"","children":[{"name":"linear-gradient.md","path":"../guanruihua.github.io/CSS/gradient","data":"# [linear-gradient](https://developer.mozilla.org/zh-CN/docs/Web/CSS/gradient/linear-gradient)\r\n\r\n> 用于创建一个表示两种或多种颜色线性渐变的图片。其结果属于`<gradient>`数据类型，是一种特别的`<image>`数据类型\r\n\r\n## 线性渐变\r\n\r\n> 线性渐变由一个轴 (梯度线) 定义，其上的每个点具有两种或多种的颜色，且轴上的每个点都具有独立的颜色。为了构建出平滑的渐变，`linear-gradient()` 函数构建一系列垂直于渐变线的着色线，每一条着色线的颜色则取决于与之垂直相交的渐变线上的色点\r\n\r\n![](./__assets__/linear-gradient-2022-12-14-15-16-06.png)\r\n\r\n- 渐变线由包含渐变图形的容器的中心点和一个角度来定义的。渐变线上的颜色值是由不同的点来定义，包括起始点，终点，以及两者之间的可选的中间点（中间点可以有多个）\r\n\r\n- 起始点是渐变线上代表起始颜色值的点。起始点由渐变线和过容器顶点的垂直线之间的交叉点来定义。（垂直线跟渐变线在同一象限内）\r\n\r\n- 同样的，终点是渐变线上代表最终颜色值的点。终点也是由渐变线和从最近的顶点发出的垂直线之间的交叉点定义的，然而从起始点的对称点来定义终点是更容易理解的一种方式，因为终点是起点关于容器的中心点的反射点\r\n\r\n- 关于起点和终点的稍微有些复杂的定义导致了一个有趣的性质，有时候被叫做不可思议的顶点效应：起点附近的点具有跟起点相同的颜色值，终点附近的点具有跟终点相同的颜色值\r\n\r\n- 不仅仅只有起点和终点的颜色值可以指定。通过提供额外的颜色中间点，Web 开发者可以构建在起始颜色值和终点颜色值之间的自定义更强的过渡效果，另外还可以提供多种颜色值的渐变线\r\n\r\n- 当颜色中间点的位置被隐式定义，它被放置在位于它之前的点和位于它之后的点之间的中间位置处。利用`<length>`或者`<percentage>`数据类型可以显示定义一个位置\r\n\r\n```css\r\nlinear-gradient(red, orange, yellow, green, blue);\r\nlinear-gradient(red 0%, orange 25%, yellow 50%, green 75%, blue 100%);\r\n```\r\n\r\n<div style=\"width:100px; height: 100px; background: linear-gradient(red, orange, yellow, green, blue);\" ></div>\r\n\r\n<div style=\"width:100px; height: 100px; background: linear-gradient(red 0%, orange 25%, yellow 50%, green 75%, blue 100%);\" ></div>\r\n","children":[]}]},{"name":"layout","path":"../guanruihua.github.io/CSS","data":"","children":[{"name":"css-layout.md","path":"../guanruihua.github.io/CSS/layout","data":"# css-layout\n\n## 静态布局\n\n- 制作的网页上的**元素尺寸一律以px为单位**。\n\n- 布局特点： 页面上的布局是按最初写代码时候的布局方式进行布局的，常规的pc网站是进行设置了宽度值进行布局的，不会随着pc端的屏幕的大小而变化。\n\n- 缺点： 不会随着pc端的屏幕大小而变化。\n\n## 三栏布局\n\n> 左右固定, 中间自适应\n\n```html\n<section class=\"layout float\">\n  <style type=\"text/css\" media=\"screen\">\n    .layout.float .wrapper>div{\n      min-height: 100px;\n    }\n    .layout.float .left{\n      float: left;\n      width: 300px;\n      background: red;\n    }\n    .layout.float .center{\n      background: yellow;\n    }\n    .layout.float .right{\n      float: right;\n      width: 300px;\n      background: blue;\n    }\n\n  </style>\n  <article class=\"wrapper\">\n    <div class=\"left\"></div>\n    <div class=\"right\"></div>\n    <div class=\"center\">\n      <h1>float布局</h1>\n      1.我是float布局的中间部分\n      2.我是float布局的中间部分\n    </div>\n  </article>\n</section>\n\n\n<section class=\"layout absolute\">\n  <style type=\"text/css\" media=\"screen\">\n    .layout.absolute .wrapper{\n      width: 100%;\n      margin-top: 20px;\n    }\n    .layout.absolute .wrapper>div{\n      min-height: 100px;\n    }\n    .layout.absolute .left{\n      position: absolute;\n      left: 0;\n      width: 300px;\n      background: red;\n    }\n    .layout.absolute .center{\n      position: absolute;\n      left: 300px;\n      right: 300px;\n      background: yellow;\n    }\n    .layout.absolute .right{\n      position: absolute;\n      right: 0;\n      width: 300px;\n      background: blue;\n    }\n  </style>\n  <article class=\"wrapper\">\n    <div class=\"left\"></div>\n    <div class=\"center\">\n      <h1>absolute布局</h1>\n      1.我是absolute布局的中间部分\n      2.我是absolute布局的中间部分\n    </div>\n    <div class=\"right\"></div>\n  </article>\n</section>\n\n\n<section class=\"layout flex\">\n  <style type=\"text/css\" media=\"screen\">\n    .layout.flex .wrapper{\n      width: 100%;\n      min-height: 100px;\n      display: flex;\n      margin-top: 140px;\n    }\n    .layout.flex .left{\n      width: 300px;\n      background: red;\n    }\n    .layout.flex .center{\n      flex: 1;\n      background: yellow;\n    }\n    .layout.flex .right{\n      width: 300px;\n      background: blue;\n    }\n  </style>\n  <article class=\"wrapper\">\n    <div class=\"left\"></div>\n    <div class=\"center\">\n      <h1>flex布局</h1>\n      1.我是flex布局的中间部分\n      2.我是flex布局的中间部分\n    </div>\n    <div class=\"right\"></div>\n  </article>\n</section>\n\n\n<section class=\"layout table\">\n  <style type=\"text/css\" media=\"screen\">\n    .layout.table .wrapper{\n      display: table;\n      width: 100%;\n      min-height: 100px;\n      margin-top: 20px;\n    }\n    .layout.table .left{\n      display: table-cell;\n      width: 300px;\n      background: red;\n    }\n    .layout.table .center{\n      display: table-cell;\n      background: yellow;\n    }\n    .layout.table .right{\n      display: table-cell;\n      width: 300px;\n      background: blue;\n    }\n\n  </style>\n  <article class=\"wrapper\">\n    <div class=\"left\"></div>\n    <div class=\"center\">\n      <h1>table布局</h1>\n      1.我是table布局的中间部分\n      2.我是table布局的中间部分\n    </div>\n    <div class=\"right\"></div>\n  </article>\n</section>\n\n\n<section class=\"layout grid\">\n  <style type=\"text/css\" media=\"screen\">\n    .layout.grid .wrapper{\n      display: grid;\n      grid-template-columns: 300px auto 300px;\n      grid-template-rows: 100px;\n      width: 100%;\n      margin-top: 20px;\n    }\n    .layout.grid .left{\n      background: red;\n    }\n    .layout.grid .center{\n      background: yellow;\n    }\n    .layout.grid .right{\n      background: blue;\n    }\n\n  </style>\n  <article class=\"wrapper\">\n    <div class=\"left\"></div>\n    <div class=\"center\">\n      <h1>grid布局</h1>\n      1.我是grid布局的中间部分\n      2.我是grid布局的中间部分\n    </div>\n    <div class=\"right\"></div>\n  </article>\n</section>\n\n```\n\n## 浮动布局\n\n浮动布局进行调用浮动属性改变页面中元素的位置，浮动布局应该是目前各大网站用的最多的一种布局方式了，但是也特别复杂。浮动元素是脱离文档流的，但不脱离文本流。浮动元素有左浮动（float : left）和右浮动（float : right）两种\n\n```css\n.lian{\n width: 90%;\n padding-left: 5%;\n}\n.lian img{\n float: right;\n margin-top: -180px;\n}\n.phone ul li{\n list-style: none;\n    margin-top: 50px;\n    margin-left: 70px;\n    color: #808080;\n}\n.phone ul li img{\n position: absolute;\n margin-left: -80px;\n float: left;\n margin-top: -5px;\n}\n.view{\n margin-top: 50px;\n margin-left: -5px;\n float: left;\n}\n.view input{\n width: 120px;\n height: 40px;\n border-radius: 6px;\n border: 1px solid #3CB371;\n background-color: #3CB371;\n font-size: 16px;\n color: white;\n}\n```\n\n- 优点： 兼容性比较好\n- 缺点： 浮动带来的影响比较多，页面宽度不够的时候会影响布局。\n\n## 响应式布局\n\n> 响应式设计与自适应设计的区别：\n>\n> - 响应式开发一套界面，通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容；\n> - 自适应需要开发多套界面，通过检测视口分辨率，来判断当前访问的设备是pc端、平板、手机，从而请求服务层，返回不同的页面。\n\n### **1. 媒体查询**\n\n> - CSS3媒体查询可以让我们针对不同的媒体类型定义不同的样式，当重置浏览器窗口大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。\n> - 移动端优先首先使用的是min-width，PC端优先使用的max-width\n\n#### PC优先\n\n```css\n/* pc width > 1024px */\n    body {\n        background-color: yellow;\n    }\n/* ipad pro */\n@media screen and (max-width: 1024px) {\n    body {\n        background-color: #FF00FF;\n    }\n}\n/* ipad */\n@media screen and (max-width: 768px) {\n    body {\n        background-color: green;\n    }\n}\n/* iphone6 7 8 plus */\n@media screen and (max-width: 414px) {\n    body {\n        background-color: blue;\n    }\n}\n/* iphoneX */\n@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) {\n    body {\n        background-color: #0FF000;\n    }\n}\n/* iphone6 7 8 */\n@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) {\n    body {\n        background-color: #0FF000;\n    }\n}\n/* iphone5 */\n@media screen and (max-width: 320px) {\n    body {\n        background-color: #0FF000;\n    }\n}\n\n```\n\n#### 移动端优先\n\n```css\n/* iphone6 7 8 */\nbody {\n    background-color: yellow;\n}\n/* iphone 5 */\n@media screen and (max-width: 320px) {\n    body {\n      background-color: red;\n    }\n}\n/* iphoneX */\n@media screen and (min-width: 375px) and (-webkit-device-pixel-ratio: 3) {\n    body {\n      background-color: #0FF000;\n    }\n}\n/* iphone6 7 8 plus */\n@media screen and (min-width: 414px) {\n    body {\n      background-color: blue;\n    }\n}\n/* ipad */\n@media screen and (min-width: 768px) {\n    body {\n      background-color: green;\n    }\n}\n/* ipad pro */\n@media screen and (min-width: 1024px) {\n    body {\n      background-color: #FF00FF;\n    }\n}\n/* pc */\n@media screen and (min-width: 1100px) {\n    body {\n      background-color: black;\n    }\n}\n\n```\n\n### **2.百分比布局**\n\n> - 计算复杂, 难以还原设计稿\n\n```css\n/* pc width > 1100px */\nhtml, body { margin: 0;padding: 0;width: 100%;height: 100%;}\naside {\n    width: 10%;\n    height: 100%;\n    background-color: red;\n    float: left;\n}\nmain {\n    height: 100%;\n    background-color: blue;\n    overflow: hidden;\n}\n/* ipad pro */\n@media screen and (max-width: 1024px) {\n    aside {\n      width: 8%;\n      background-color: yellow;\n    }\n}\n/* ipad */\n@media screen and (max-width: 768px) {\n    aside {\n      float: none;\n      width: 100%;\n      height: 10%;\n      background-color: green;\n    }\n    main {\n      height: calc(100vh - 10%);\n      background-color: red;\n    }\n}\n/* iphone6 7 8 plus */\n@media screen and (max-width: 414px) {\n    aside {\n      float: none;\n      width: 100%;\n      height: 5%;\n      background-color: yellow;\n    }\n    main {\n      height: calc(100vh - 5%);\n      background-color: red;\n    }\n}\n/* iphoneX */\n@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) {\n    aside {\n      float: none;\n      width: 100%;\n      height: 10%;\n      background-color: blue;\n    }\n    main {\n      height: calc(100vh - 10%);\n      background-color: red;\n    }\n}\n/* iphone6 7 8 */\n@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) {\n    aside {\n      float: none;\n      width: 100%;\n      height: 3%;\n      background-color: black;\n    }\n    main {\n      height: calc(100vh - 3%);\n      background-color: red;\n    }\n}\n/* iphone5 */\n@media screen and (max-width: 320px) {\n    aside {\n      float: none;\n      width: 100%;\n      height: 7%;\n      background-color: green;\n    }\n    main {\n      height: calc(100vh - 7%);\n      background-color: red;\n    }\n}\n\n```\n\n### **3.rem布局**\n\n> - REM是CSS3新增的单位，并且移动端的支持度很高，Android2.x+,ios5+都支持。\n> - rem单位都是相对于根元素html的font-size来决定大小的,根元素的font-size相当于提供了一个基准，当页面的size发生变化时，只需要改变font-size的值，那么以rem为固定单位的元素的大小也会发生响应的变化。 因此，如果通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可（而em是相对于父元素的）。\n\nrem响应式的布局思想：\n\n一般不要给元素设置具体的宽度，但是对于一些小图标可以设定具体宽度值\n\n高度值可以设置固定值，设计稿有多大，我们就严格有多大\n\n所有设置的固定值都用rem做单位（首先在HTML总设置一个基准值：px和rem的对应比例，然后在效果图上获取px值，布局的时候转化为rem值)\n\njs获取真实屏幕的宽度，让其除以设计稿的宽度，算出比例，把之前的基准值按照比例进行重新的设定，这样项目就可以在移动端自适应了\n\nrem布局的缺点：\n\n在响应式布局中，必须通过js来动态控制根元素font-size的大小，也就是说css样式和js代码有一定的耦合性，且必须将改变font-size的代码放在css样式之前\n\n```css\n/*将视图容器分为10份，font-size用十分之一的宽度来表示，最后在header标签中执行这段代码，就可以动态定义font-size的大小，从而1rem在不同的视觉容器中表示不同的大小，用rem固定单位可以实现不同容器内布局的自适应。*/\nfunction refreshRem() {\n    var docEl = doc.documentElement;\n    var width = docEl.getBoundingClientRect().width;\n    var rem = width / 10;\n    docEl.style.fontSize = rem + 'px';\n    flexible.rem = win.rem = rem;\n}\nwin.addEventListener('resize', refreshRem);\n\n```\n\nrem布局适配多屏幕适配的最佳方式\n\n```css\n/* pc width > 1100px */\nhtml{ font-size: 100%;}\nbody {\n    background-color: yellow;\n    font-size: 1.5rem;\n}\n/* ipad pro */\n@media screen and (max-width: 1024px) {\n    body {\n      background-color: #FF00FF;\n      font-size: 1.4rem;\n    }\n}\n/* ipad */\n@media screen and (max-width: 768px) {\n    body {\n      background-color: green;\n      font-size: 1.3rem;\n    }\n}\n/* iphone6 7 8 plus */\n@media screen and (max-width: 414px) {\n    body {\n      background-color: blue;\n      font-size: 1.25rem;\n    }\n}\n/* iphoneX */\n@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) {\n    body {\n      background-color: #0FF000;\n      font-size: 1.125rem;\n    }\n}\n/* iphone6 7 8 */\n@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) {\n    body {\n      background-color: #0FF000;\n      font-size: 1rem;\n    }\n}\n/* iphone5 */\n@media screen and (max-width: 320px) {\n    body {\n      background-color: #0FF000;\n      font-size: 0.75rem;\n    }\n}\n```\n\n### **4.视口单位**\n\n> - css3中引入了一个新的单位vw/vh，与视图窗口有关\n\n| 单位 | 含义                                                      |\n| ---- | --------------------------------------------------------- |\n| vw   | 相对于视窗的宽度，1vw 等于视口宽度的1%，即视窗宽度是100vw |\n| vh   | 相对于视窗的高度，1vh 等于视口高度的1%，即视窗高度是100vh |\n| vmin | vw和vh中的较小值                                          |\n| vmax | vw和vh中的较大值                                          |\n\n用视口单位度量，视口宽度为100vw，高度为100vh（左侧为竖屏情况，右侧为横屏情况）。\n\n例如，在桌面端浏览器视口尺寸为650px，那么 1vw = 650 * 1% = 6.5px（这是理论推算的出，如果浏览器不支持0.5px，那么实际渲染结果可能是7px）。\n\n使用视口单位来实现响应式有两种做法：\n\n1. 仅使用vw作为CSS单位\n\n2. 搭配vw和rem\n","children":[]},{"name":"display.md","path":"../guanruihua.github.io/CSS/layout","data":"# display\r\n\r\n| 值                   | 作用                                                                         |\r\n| :------------------- | :--------------------------------------------------------------------------- |\r\n| `none`               | 使用后元素将不会显示                                                         |\r\n| `grid`               | 定义一个容器属性为网格布局                                                   |\r\n| `flex`               | 定义一个弹性布局                                                             |\r\n| `block`              | 使用后元素将变为块级元素显示，元素前后带有换行符                             |\r\n| `inline`             | display默认值。使用后原色变为行内元素显示，前后无换行符                      |\r\n| `list-item`          | 使用后元素作为列表显示run-in使用后元素会根据上下文作为块级元素或行内元素显示 |\r\n| `table`              | 使用后将作为块级表格来显示（类似`<table>`），前后带有换行符                  |\r\n| `inline-table`       | 使用后元素将作为内联表格显示（类似`<table>`），前后没有换行符                |\r\n| `table-row-group`    | 元素将作为一个或多个行的分组来显示（类似`<tbody>`）                          |\r\n| `table-header-group` | 元素将作为一个或多个行的分组来表示（类似`<thead>`）                          |\r\n| `table-footer-group` | 元素将作为一个或多个行分组显示（类似`<tfoot>`）                              |\r\n| `table-row`          | 元素将作为一个表格行显示（类似`<tr>`）                                       |\r\n| `table-column-group` | 元素将作为一个或多个列的分组显示（类似`<colgroup>`）                         |\r\n| `table-column`       | 元素将作为一个单元格列显示（类似`<col>`）                                    |\r\n| `table-cell`         | 元素将作为一个表格单元格显示（类似`<td>`和`<th>`）                           |\r\n| `table-caption`      | 元素将作为一个表格标题显示（类似`<caption>`）                                |\r\n| `inherit`            | 规定应该从父元素集成display属性的值                                          |\r\n\r\n```css\r\n/* pre composed values */\r\ndisplay: block;\r\ndisplay: inline;\r\ndisplay: inline-block;\r\ndisplay: flex;\r\ndisplay: inline-flex;\r\ndisplay: grid;\r\ndisplay: inline-grid;\r\ndisplay: flow-root;\r\n\r\n/* box generation */\r\ndisplay: none;\r\ndisplay: contents;\r\n\r\n/* two-value syntax */\r\ndisplay: block flow;\r\ndisplay: inline flow;\r\ndisplay: inline flow-root;\r\ndisplay: block flex;\r\ndisplay: inline flex;\r\ndisplay: block grid;\r\ndisplay: inline grid;\r\ndisplay: block flow-root;\r\n\r\n/* other values */\r\ndisplay: table;\r\ndisplay: table-row; /* all table elements have an equivalent CSS display value */\r\ndisplay: list-item;\r\n\r\n/* Global values */\r\ndisplay: inherit;\r\ndisplay: initial;\r\ndisplay: revert;\r\ndisplay: revert-layer;\r\ndisplay: unset;\r\n\r\n```\r\n","children":[]},{"name":"flex.md","path":"../guanruihua.github.io/CSS/layout","data":"# flex\n\n## 弹性布局\n\n> - 弹性布局可以简便、完整、响应的实现各种页面上的布局。\n>\n> - 与静态不同的是，使用em或rem单位（lem=16px，1rem=10px）进行相对布局，相对使用百分比更加方便、灵活，相应同时支持浏览器的字体大小调整和缩放的等正常显示。\n>\n> - 优点：\n>\n>   1. 适应性强，在做多种不同的屏幕分辨率不同的界面是非常使用。\n>   2. 随意按照宽度、比例划分元素的宽高。\n>   3. 可以轻松的改变元素的显示顺序。\n>   4. 网页布局实现快捷，维护起来更加容易。\n>\n> - 如果做移动端时，如果客户对细微的之处的要求不高，使用弹性布局进行制作是最好的选择，一份css+一份js调节font-size搞定。\n>\n> - 缺点： 浏览器兼容性较差，只能<u>兼容到IE9及以上</u>。\n>\n> - 使用:\n>\n>   ```css\n>   .box{\n>    display: flex; \n>     display: inline-flex; // 行内块\n>     // Webkit 内核的浏览器\n>     display: -webkit-flex; /* Safari */\n>    display: flex;\n>   }\n>   ```\n>\n> - 设为 Flex 布局以后，子元素的`float`、`clear`和`vertical-align`属性将失效。\n\n![](./__assets__/flex-2022-03-29-13-53-02.png)\n\n## 概念\n\n> 容器默认存在两根轴：\n>\n> - 水平的主轴（main axis）和垂直的交叉轴（cross axis）。\n>\n> - 主轴的开始位置（与边框的交叉点）叫做`main start`，结束位置叫做`main end`；\n>\n> - 交叉轴的开始位置叫做`cross start`，结束位置叫做`cross end`。\n>\n> 项目默认沿主轴排列。单个项目占据的主轴空间叫做`main size`，占据的交叉轴空间叫做`cross size`。\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png)\n\n## 容器的属性\n\n> - `flex-direction :  row | row-reverse | column | column-reverse;`  => 决定主轴的方向(项目的排列方式)\n> - `flex-wrap : nowrap | wrap | wrap-reverse;` => 如果一条轴线排不下，如何换行\n> - `flex-flow :  <flex-direction> || <flex-wrap>;` => 是前flex-direction和flex-warp的简写方式\n> - `justify-content : flex-start | flex-end | center | space-between | space-around;` => 项目在主轴上的对齐方式\n> - `align-items : flex-start | flex-end | center | baseline | stretch;` => 项目在交叉轴上如何对齐\n> - `align-content : flex-start | flex-end | center | space-between | space-around | stretch;` => 定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用\n\n### flex-direction\n\n`flex-direction`属性决定主轴的方向（即项目的排列方向）。\n\n> ```css\n> .box {\n>  flex-direction: row | row-reverse | column | column-reverse;\n> }\n> ```\n>\n![](/__assets__/img/2022-01-25-14-30-04.png)\n\n它可能有4个值。\n\n> - `row`（默认值）：主轴为水平方向，起点在左端。\n> - `row-reverse`：主轴为水平方向，起点在右端。\n> - `column`：主轴为垂直方向，起点在上沿。\n> - `column-reverse`：主轴为垂直方向，起点在下沿。\n\n### flex-wrap\n\n默认情况下，项目都排在一条线（又称\"轴线\"）上。`flex-wrap`属性定义，如果一条轴线排不下，如何换行。\n\n> ```css\n> .box{\n>  flex-wrap: nowrap | wrap | wrap-reverse;\n> }\n> ```\n\n它可能取三个值。\n\n（1）`nowrap`（默认）：不换行。\n\n![](/__assets__/img/2022-01-25-14-33-06.png)\n\n（2）`wrap`：换行，第一行在上方。\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg)\n\n（3）`wrap-reverse`：换行，第一行在下方。\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg)\n\n### flex-flow\n\n`flex-flow`属性是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap`。\n\n> ```css\n> .box {\n>   flex-flow: <flex-direction> || <flex-wrap>;\n> }\n> ```\n\n### justify-content\n\n`justify-content`属性定义了项目在主轴上的对齐方式。\n\n> ```css\n> .box {\n>  justify-content: flex-start | flex-end | center | space-between | space-around;\n> }\n> ```\n\n<img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png\" alt=\"img\" style=\"zoom:80%;\" />\n\n它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。\n\n> - `flex-start`（默认值）：左对齐\n> - `flex-end`：右对齐\n> - `center`： 居中\n> - `space-between`：两端对齐，项目之间的间隔都相等。\n> - `space-around`：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n### align-items\n\n`align-items`属性定义项目在交叉轴上如何对齐。\n\n> ```css\n> .box {\n>  align-items: flex-start | flex-end | center | baseline | stretch;\n> }\n> ```\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png)\n\n它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。\n\n> - `flex-start`：交叉轴的起点对齐。\n> - `flex-end`：交叉轴的终点对齐。\n> - `center`：交叉轴的中点对齐。\n> - `baseline`: 项目的第一行文字的基线对齐。\n> - `stretch`（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n### align-content\n\n`align-content`属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n> ```css\n> .box {\n>  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n> }\n> ```\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png)\n\n该属性可能取6个值。\n\n> - `flex-start`：与交叉轴的起点对齐。\n> - `flex-end`：与交叉轴的终点对齐。\n> - `center`：与交叉轴的中点对齐。\n> - `space-between`：与交叉轴两端对齐，轴线之间的间隔平均分布。\n> - `space-around`：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n> - `stretch`（默认值）：轴线占满整个交叉轴。\n\n## 项目的属性\n\n> - `order : <integer>`  => 项目的排列顺序。数值越小，排列越靠前，默认为0\n> - `flex-grow: <number>` => 项目的放大比例，默认为`0`，即如果存在剩余空间，也不放大\n> - `flex-shrink: <number>`=>  定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n> - `flex-basis: <length> | auto; /* default auto */` => 定义了在分配多余空间之前，项目占据的主轴空间（main size）\n> - `flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]`=> 默认值为`0 1 auto`\n> - `align-self : auto | flex-start | flex-end | center | baseline | stretch;` => 允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。\n\n### order\n\n> 定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n\n```css\n.item {\n order: <integer>;\n}\n```\n\n<img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png\" alt=\"img\" style=\"zoom:80%;\" />\n\n### flex-grow\n\n> 定义项目的放大比例，默认为`0`，即如果存在剩余空间，也不放大。\n\n```css\n.item {\n flex-grow: <number>; /* default 0 */\n}\n```\n\n<img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png\" alt=\"img\" style=\"zoom:80%;\" />\n\n### flex-shrink\n\n> 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n\n```css\n.item {\n flex-shrink: <number>; /* default 1 */\n}\n```\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg)\n\n- 如果所有项目的`flex-shrink`属性都为1，当空间不足时，都将等比例缩小。\n\n- 如果一个项目的`flex-shrink`属性为0，其他项目都为1，则空间不足时，前者不缩小。\n\n- 负值对该属性无效。\n\n### flex-basis\n\n> 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，即项目的本来大小。\n\n```css\n.item {\n flex-basis: <length> | auto; /* default auto */\n}\n```\n\n它可以设为跟`width`或`height`属性一样的值（比如350px），则项目将占据固定空间。\n\n### flex\n\n> 属性是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为`0 1 auto`。后两个属性可选。\n\n```css\n.item {\n flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n}\n```\n\n> 该属性有两个快捷值：`auto` (`1 1 auto`) 和 none (`0 0 auto`)。\n>\n> 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值\n> `flex: 2 200px` => 先给当前项留200px, 再根据前面属性进行均分\n\n### align-self\n\n> 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n\n```css\n.item {\n align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n<img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png\" alt=\"img\" style=\"zoom:80%;\" />\n\n属性可能取6个值，除了auto，其他都与align-items属性完全一致。\n","children":[]},{"name":"grid.md","path":"../guanruihua.github.io/CSS/layout","data":"# grid布局\n\n## 网格布局\n\n```css\ndisplay: grid | inline-grid; //行列布局\n\ngrid-template-columns: 200px 200px 200px; | repeat(3, 200px) | repeat(auto-fill, 200px)[表示列宽200px, 只要能容纳得下就可以放置] | 200px 2fr 1fr [后面两项分别占有剩下的2/3,1/3] | 1fr 1fr minmax(300px, 2fr)[第三列:300px<=x<=2fr]\ngrid-template-rows: 200px 200px 200px; | repeat(3, 200px) | 和上个类似\n\n//行列间隔\ngrid-row-gap:10px;\ngrid-column-gap:20px;\ngrid-gap:10px 20px;[等同于上两行]\nrow-gap: 10px;\ncolumn-gap: 20px;\n\n//定义区域\ngrid-template-areas:\n\". header  header\"[.表示空单元格]\n\"sidebar content content\";[这里定义的六个区域]\n //子元素\n.header{\n  grid-area: header;\n}\n\n//控制自动布局\ngrid-auto-flow: row | column | row dense | column dense;[dense:自动填补空白;row: 表示先行后列]\n\n//控制单元格位置\njustify-items:start | end | center | stretch[拉伸];[水平方向]\nalign-items:start | end | center | stretch;[垂直方向]\nplace-items:[jusity-item] [align-items];//同时设置水平和垂直方向\n\n//这个是对于单个单元格\njustify-self:start | end | center | stretch[拉伸];[水平方向]\nalign-self:start | end | center | stretch;[垂直方向]\nplace-self:[jusity-item] [align-items];//同时设置水平和垂直方向\n\n//控制内容区域在容器的位置\njustify-content: start | end | center | stretch | \n   space-around[每个项目两侧距离相等,项目间间隔比到容器间隙大一倍] | \n   space-between[项目间隔相等,与容器边框没有间隙] | \n   space-evenly[项目与项目的间隙相等, 项目间与容器边框间间隙相等];\nalign-content: start | end | center | stretch | space-around | space-between | space-evenly;  \nplace-content: [justify-content] [align-content]\n\n//定义隐式网格属性[当超出grid-template-xxx的定义就会触发]\ngrid-auto-columns: 50px;\ngrid-auto-rows: 50px;\n\n//网格项目所在的四个边框\ngrid-column-start 属性：左边框所在的垂直网格线\ngrid-column-end 属性：右边框所在的垂直网格线\ngrid-row-start 属性：上边框所在的水平网格线\ngrid-row-end 属性：下边框所在的水平网格线\n\n//  合并单元格(可以使用 grid-template-areas 来定义重复的名字可以达到效果)\n// 'span 3': 合并往下三个单元格; auto: 表示再原有位置进行合并, 也可以指定其他行\ngrid-row: auto / span 3;\n// 'span 2': 合并往右边2个单元格; auto: 表示再原有位置进行合并, 也可以指定其他列\ngrid-column: auto / span 2;\n\n```\n\n## display 属性\n\n> - `display：grid`  \n>\n> - `display：inline-grid`\n\n## grid-template-columns / rows\n\n> - `grid-template-columns` 属性设置每列宽\n>\n> - `grid-template-rows` 属性设置每行高\n\n**固定的列宽和行高**\n\n```css\n.wrapper {\n  display: grid;\n  /*  声明了三列，宽度分别为 200px 100px 200px */\n  grid-template-columns: 200px 100px 200px;\n  grid-gap: 5px;\n  /*  声明了两行，行高分别为 50px 50px  */\n  grid-template-rows: 50px 50px;\n}\n```\n\n> **repeat() 函数**：可以简化重复的值。\n>\n> - 第一个参数是重复的次数\n> - 第二个参数是所要重复的值\n\n```scss\n.wrapper-1 {\n  display: grid;\n  grid-template-columns: 200px 100px 200px;\n  grid-gap: 5px;\n  /*  2行，而且行高都为 50px  */\n  grid-template-rows: repeat(2, 50px);\n}\n```\n\n> **auto-fill 关键字**：表示自动填充，让一行（或者一列）中尽可能的容纳更多的单元格。`grid-template-columns: repeat(auto-fill, 200px)` 表示列宽是 200 px，但列的数量是不固定的，只要浏览器能够容纳得下，就可以放置元素\n\n```css\n.wrapper-2 {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, 200px);\n  grid-gap: 5px;\n  grid-auto-rows: 50px;\n}\n```\n\n> **fr 关键字**：`Grid` 布局还引入了一个另外的长度单位来帮助我们创建灵活的网格轨道。`fr` 单位代表网格容器中可用空间的一等份。`grid-template-columns: 200px 1fr 2fr` 表示第一个列宽设置为 200px，后面剩余的宽度分为两部分，宽度分别为剩余宽度的 1/3 和 2/3。\n\n```css\n.wrapper-3 {\n  display: grid;\n  grid-template-columns: 200px 1fr 2fr;\n  grid-gap: 5px;\n  grid-auto-rows: 50px;\n}\n```\n\n**minmax() 函数**：我们有时候想给网格元素一个最小和最大的尺寸，`minmax()` 函数产生一个长度范围，表示长度就在这个范围之中都可以应用到网格项目中。它接受两个参数，分别为最小值和最大值。`grid-template-columns: 1fr 1fr minmax(300px, 2fr)` 的意思是，第三个列宽最少也是要 300px，但是最大不能大于第一第二列宽的两倍。代码以及效果如下：\n\n```css\n.wrapper-4 {\n  display: grid;\n  grid-template-columns: 1fr 1fr minmax(300px, 2fr);\n  grid-gap: 5px;\n  grid-auto-rows: 50px;\n}\n```\n\n**auto 关键字**：由浏览器决定长度。通过 `auto` 关键字，我们可以轻易实现三列或者两列布局。`grid-template-columns: 100px auto 100px` 表示第一第三列为 100px，中间由浏览器决定长度，代码以及效果如下：\n\n```css\n.wrapper-5 {\n  display: grid;\n  grid-template-columns: 100px auto 100px;\n  grid-gap: 5px;\n  grid-auto-rows: 50px;\n}\n```\n\n## gap(间隙)\n\n> `grid-row-gap` 属性、`grid-column-gap` 属性分别设置行间距和列间距。\n>\n> `grid-gap` 属性是两者的简写形式。(已经弃用)\n> `column-gap` 和 `row-gay` 替代\n\n```css\n.wrapper {\n  display: grid;\n  grid-template-columns: 200px 100px 100px;\n  grid-gap: 10px 20px;\n  grid-auto-rows: 50px;\n}\n```\n\n```\n.wrapper-1 {\n  display: grid;\n  grid-template-columns: 200px 100px 100px;\n  grid-auto-rows: 50px;\n  grid-row-gap: 10px;\n  grid-column-gap: 20px;\n}\n```\n\n## grid-template-areas/grid-area\n\n> `grid-template-areas` 属性用于定义区域，一个区域由一个或者多个单元格组成\n>\n> `grid-area` : 指定放在哪个区域\n\n```css\n.wrapper {\n  display: grid;\n  grid-gap: 10px;\n  grid-template-columns: 120px  120px  120px;\n  grid-template-areas:\n    \". header  header\"\n    \"sidebar content content\";\n  background-color: #fff;\n  color: #444;\n}\n```\n\n> 上面代码表示划分出 6 个单元格，其中值得注意的是 `.` 符号代表空的单元格，也就是没有用到该单元格。\n\n```css\n.sidebar {\n  grid-area: sidebar;\n}\n\n.content {\n  grid-area: content;\n}\n\n.header {\n  grid-area: header;\n}\n```\n\n以上代码表示将类 `.sidebar` `.content` `.header`所在的元素放在上面 `grid-template-areas` 中定义的 `sidebar` `content` `header` 区域中\n\n## grid-auto-flow\n\n> `grid-auto-flow` 属性控制着自动布局算法怎样运作，精确指定在网格中被自动布局的元素怎样排列。默认的放置顺序是\"先行后列\"，即先填满第一行，再开始放入第二行，即下图英文数字的顺序 `one`,`two`,`three`...。这个顺序由 `grid-auto-flow` 属性决定，默认值是 `row`。\n\n### row\n\n```css\n.wrapper {\n  display: grid;\n  grid-template-columns: 100px 200px 100px;\n  grid-auto-flow: row;\n  grid-gap: 5px;\n  grid-auto-rows: 50px;\n}\n```\n\n### dense\n\n> `grid-auto-flow: row dense` => dense 会用后面的项目填充前面的空位\n\n```css\n.wrapper-2 {\n  display: grid;\n  grid-template-columns: 100px 200px 100px;\n  grid-auto-flow: row dense;\n  grid-gap: 5px;\n  grid-auto-rows: 50px;\n}\n```\n\n### column\n\n可以设置 `grid-auto-flow: column`，表示先列后行，代码以及效果如下图所示：\n\n```css\n.wrapper-1 {\n  display: grid;\n  grid-auto-columns: 100px;\n  grid-auto-flow: column;\n  grid-gap: 5px;\n  grid-template-rows:  50px 50px;\n}\n```\n\n## 项目对齐(item)\n\n> - `justify-items` : 设置单元格内容的水平位置（左中右）\n>\n> - `align-items`  : 设置单元格的垂直位置（上中下）\n> - `place-items : [align-items]  | [justify-items]`  \n\n```css\n.container {\n  justify-items: start | end | center | stretch;\n  align-items: start | end | center | stretch;\n}\n```\n\n```css\n.wrapper, .wrapper-1, .wrapper-2, .wrapper-3 {\n  display: grid;\n  grid-template-columns: 100px 200px 100px;\n  grid-gap: 5px;\n  grid-auto-rows: 50px;\n  justify-items: start;\n}\n.wrapper-1 {\n  justify-items: end;\n}\n.wrapper-2 {\n  justify-items: center;\n}\n.wrapper-3 {\n  justify-items: stretch;\n}\n```\n\n### start\n\n- start：对齐单元格的起始边缘\n\n### end\n\n> 对齐单元格的结束边缘\n\n### center\n\n> center：单元格内部居中\n\n### stretch\n\n> 拉伸，占满单元格的整个宽度（默认值）\n\n## justify-content ,align-content ,place-content\n\n> `justify-content` 属性是整个内容区域在容器里面的水平位置（左中右）\n>\n> `align-content` 属性是整个内容区域的垂直位置（上中下）。它们都有如下的属性值。\n\n```css\n.container {\n  justify-content: start | end | center | stretch | space-around | space-between | space-evenly;\n  align-content: start | end | center | stretch | space-around | space-between | space-evenly; \n  place-content:  [align-content] [justify-content];\n}\n```\n\n```css\n.wrapper, .wrapper-1, .wrapper-2, .wrapper-3, .wrapper-4, .wrapper-5, .wrapper-6 {\n  display: grid;\n  grid-template-columns: 100px 200px 100px;\n  grid-gap: 5px;\n  grid-auto-rows: 50px;\n  justify-content: start;\n}\n.wrapper-1 {\n  justify-content: end;\n}\n.wrapper-2 {\n  justify-content: center;\n}\n```\n\n- space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍\n- space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔\n- space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔\n- stretch - 项目大小没有指定时，拉伸占据整个网格容器\n\n```css\n.wrapper-3 {\n  justify-content: space-around;\n}\n.wrapper-4 {\n  justify-content: space-between;\n}\n.wrapper-5 {\n  justify-content: space-evenly;\n}\n.wrapper-6 {\n  justify-content: stretch;\n}\n```\n\n## grid-auto-columns, grid-auto-rows\n\n> - 显式网格 : 包含了你在 `grid-template-columns` 和 `grid-template-rows` 属性中定义的行和列。\n>\n> - 如果你在网格定义之外又放了一些东西，或者因为内容的数量而需要的更多网格轨道的时候，**网格将会在隐式网格中创建行和列**\n> - 不指定这隐式网格属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高\n\n```css\n.wrapper {\n  display: grid;\n  grid-template-columns: 200px 100px;\n/*  只设置了两行，但实际的数量会超出两行，超出的行高会以 grid-auto-rows 算 */\n  grid-template-rows: 100px 100px;\n  grid-gap: 10px 20px;\n  grid-auto-rows: 50px;\n}\n```\n\n`grid-template-columns` 属性和 `grid-template-rows` 属性只是指定了两行两列，但实际有九个元素，就会产生隐式网格。通过 `grid-auto-rows` 可以指定隐式网格的行高为 50px\n\n## 项目属性介绍\n\n### grid-column-start /end 、grid-row-start / end\n\n> 可以指定网格项目所在的四个边框，分别定位在哪根网格线，从而指定项目的位置\n>\n> - grid-column-start 属性：左边框所在的垂直网格线\n> - grid-column-end 属性：右边框所在的垂直网格线\n> - grid-row-start 属性：上边框所在的水平网格线\n> - grid-row-end 属性：下边框所在的水平网格线\n\n```css\n.wrapper {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-gap: 20px;\n  grid-auto-rows: minmax(100px, auto);\n}\n.one {\n  grid-column-start: 1;\n  grid-column-end: 2;\n  background: #19CAAD;\n}\n.two { \n  grid-column-start: 2;\n  grid-column-end: 4;\n  grid-row-start: 1;\n  grid-row-end: 2;\n  /*   如果有重叠，就使用 z-index */\n  z-index: 1;\n  background: #8CC7B5;\n}\n.three {\n  grid-column-start: 3;\n  grid-column-end: 4;\n  grid-row-start: 1;\n  grid-row-end: 4;\n  background: #D1BA74;\n}\n.four {\n  grid-column-start: 1;\n  grid-column-end: 2;\n  grid-row-start: 2;\n  grid-row-end: 5;\n  background: #BEE7E9;\n}\n.five {\n  grid-column-start: 2;\n  grid-column-end: 2;\n  grid-row-start: 2;\n  grid-row-end: 5;\n  background: #E6CEAC;\n}\n.six {\n  grid-column: 3;\n  grid-row: 4;\n  background: #ECAD9E;\n}\n```\n\n上面代码中，类 `.two` 所在的网格项目，垂直网格线是从 2 到 4，水平网格线是从 1 到 2。其中它跟 `.three` （垂直网格线是从3 到 4，水平网格线是从 1 到 4） 是有冲突的。可以设置 `z-index` 去决定它们的层级关系\n\n### justify / align / place -self\n\n> - `justify-self` 属性设置单元格内容的水平位置（左中右），跟 `justify-items` 属性的用法完全一致，但只作用于单个项目\n>\n> - `align-self` 属性设置单元格内容的垂直位置（上中下），跟``align-items`属性的用法完全一致，也是只作用于单个项目\n\n```css\n.item {\n  justify-self: start | end | center | stretch;\n  align-self: start | end | center | stretch;\n}\n\n.item {\n  justify-self: start;\n}\n.item-1 {\n  justify-self: end;\n}\n.item-2 {\n  justify-self: center;\n}\n.item-3 {\n  justify-self: stretch;\n}\n```\n\n- start：对齐单元格的起始边缘\n\n- end：对齐单元格的结束边缘\n\n- center：单元格内部居中\n\n- stretch：拉伸，占满单元格的整个宽度（默认值）\n\n## Grid 布局兼容性\n\n最后，聊聊 `Grid` 布局兼容性问题，在 [caniuse](https://caniuse.com/#search=grid) 中，我们可以看到的结果如下，总体兼容性还不错，但在 IE 10 以下不支持。个人建议在公司的内部系统运用起来是没有问题的，但 TOC 的话，可能目前还是不太合适\n\n|                   属性                   |            描述            |\n| :--------------------------------------: | :------------------------: |\n|                 display                  | grid      \\|   inline-grid |\n| grid-template-columns/grid-template-rows |       设置列宽/行高        |\n","children":[]},{"name":"position","path":"../guanruihua.github.io/CSS/layout","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/CSS/layout/position","data":"# position\r\n\r\n> 定位布局时利用position属性控制页面元素设置一些不规则布局。\r\n> 定位元素的各个属性：\r\n\r\n1. static 静态定位： HTML元素的默认值，即没有定位，元素出现在正常的流中。\r\n\r\n```css\r\ndiv.static {\r\n    position: static;\r\n    border: 3px solid #73AD21;\r\n}\r\n```\r\n\r\n2. fixed 固定定位： 元素的位置相对于浏览器窗口是固定位置。即使窗口是滚动的它也不会移动。Fixed定位使元素的位置与文档流无关，因此不占据空间。Fixed定位的元素和其他元素重叠。\r\n\r\n```css\r\np.pos_fixed{\r\n    position:fixed;\r\n    top:30px;\r\n    right:5px;\r\n}\r\n```\r\n\r\n3. relative 相对定位： 相对定位元素的定位是以自身为参照物。对象不可层叠、不脱离文档流，移动相对定位元素，但它原本所占的空间不会改变。通过 top,bottom,left,right 定位。\r\n\r\n```css\r\nh2.pos_top\r\n{\r\n    position:relative;\r\n    top:-50px;\r\n}\r\n```\r\n\r\n4. absolute 绝对定位 absolute 定位使元素的位置与文档流无关，因此不占据空间。元素和其他元素重叠。通过 top,bottom,left,right 定位。选取其最近一个最有定位设置的父级对象进行绝对定位，如果对象的父级没有设置定位属性，absolute元素将以body坐标原点进行定位。\r\n\r\n```css\r\nh2{\r\n    position:absolute;\r\n    left:100px;\r\n    top:150px;\r\n}\r\n```\r\n\r\n5. sticky 粘性定位 基于用户的滚动位置来定位。粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。\r\n\r\n```css\r\ndiv.sticky {\r\n    position: -webkit-sticky; /* Safari */\r\n    position: sticky;\r\n    top: 0;\r\n    background-color: green;\r\n    border: 2px solid #4CAF50;\r\n}\r\n```\r\n\r\n6. z-index 因为页面中元素的定位与文档流无关，所以定位的元素可以覆盖在文档流上面。所以z-index属性指定了一个元素的堆叠顺序（哪个元素应该放在前面/后面）。z-index的值必须取正整数，数值越大显示的优先级就越高。 如果两个定位元素重叠，而且还没有指定z - index，name最后定位在HTML代码中的元素将被显示在最前面。\r\n","children":[]},{"name":"问题","path":"../guanruihua.github.io/CSS/layout/position","data":"","children":[{"name":"fixed失效.md","path":"../guanruihua.github.io/CSS/layout/position/问题","data":"# [`fixed失效`]()\r\n\r\n> <https://drafts.fxtf.org/filter-effects/#FilterProperty>\r\n\r\n## 与 filter 使用\r\n\r\n> 当在 body 中使用了 filter 滤镜属性的时候，会导致 fixed 元素定位发生错误，即不再相对 viewport 进行定位，而是相对整个网页（ body 元素）进行定位\r\n\r\n```html\r\n<html>\r\n  <head>\r\n    <title>css filter issue</title>\r\n    <style>\r\n      body {\r\n        height: 600px;\r\n        background: red;\r\n        filter: grayscale(1);\r\n      }\r\n      .fixed {\r\n        color: yellow;\r\n        position: fixed;\r\n        top: 0;\r\n        right: 0;\r\n      }\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <div class=\"fixed\">fixed item</div>\r\n  </body>\r\n</html>\r\n```\r\n\r\n![](./__assets__/fixed-error.gif)\r\n\r\n### 解决方案\r\n\r\n> 产生这个问题的原因就是：当 filter 不为 none 的时候，如果该元素或者其子元素具有 absolute 或 fixed 属性，那么它会为其创建一个新的包含块/容器，会造成该 absolute 或 fixed 元素的定位发生变化（就是改变了 absolute 或 fixed 元素的定位<父>元素，变成新创建的元素）。\r\n\r\n> 以上面的例子说明，当在 body 标签中使用了 filter 属性后， filter 就会生成一个新的包含块，其位置大小和 body 一样，然后 fixed 元素就会根据这个包含块进行定位，所以我们会看到 fixed 元素失去原有的特性；\r\n\r\n> 但是，如果 filter 作用在根元素（即 html 标签）时，它是不会为 absolute 或 fixed 子元素创建新的包含块的\r\n> 所以解决方案也就很简单了，只需要将 filter 属性放在 html 标签上就好了\r\n\r\n```css\r\nhtml {\r\n  filter: grayscale(1);\r\n}\r\n```\r\n\r\n> `position: fixed`\r\n>\r\n> 当一个元素包含 fixed 属性时，屏幕视口（ viewport ）会为其创建一个包含块（ containing block ），其大小就是 viewport 的大小，然后该 fixed 元素基于该包含块进行定位。所以通常我们会说 fixed 元素是相对 viewport 来定位的。\r\n>\r\n> 此外， fixed 属性会创建新的层叠上下文。当元素祖先的 transform , perspective 或 filter 属性非 none 时，容器由视口改为该祖先。\r\n","children":[]}]}]},{"name":"table.md","path":"../guanruihua.github.io/CSS/layout","data":"# table\n\n> - 基于`display:table`的布局\n> - 类似于原生的`<table>`标签的使用\n\n## 原生的table标签的说明\n\n> - 就是使用通过使用CSS Table 来说来实现相关属性的。\n> - table：指定对象作为块元素级的表格。类同于html标签<table>（CSS2）\n> - inline-table：指定对象作为内联元素级的表格。类同于html标签<table>（CSS2）\n> - table-caption：指定对象作为表格标题。类同于html标签<caption>（CSS2）\n> - table-cell：指定对象作为表格单元格。类同于html标签<td>（CSS2）\n> - table-row：指定对象作为表格行。类同于html标签<tr>（CSS2）\n> - table-row-group：指定对象作为表格行组。类同于html标签<tbody>（CSS2）\n> - table-column：指定对象作为表格列。类同于html标签<col>（CSS2）\n> - table-column-group：指定对象作为表格列组显示。类同于html标签<colgroup>（CSS2）\n> - table-header-group：指定对象作为表格标题组。类同于html标签<thead>（CSS2）\n> - table-footer-group：指定对象作为表格脚注组。类同于html标签<tfoot>（CSS2）\n\n```css\ntable    { display: table }\ntr       { display: table-row }\nthead    { display: table-header-group }\ntbody    { display: table-row-group }\ntfoot    { display: table-footer-group }\ncol      { display: table-column }\ncolgroup { display: table-column-group }\ntd, th   { display: table-cell }\ncaption  { display: table-caption }\n```\n\n### 使用CSS表格\n\n> - CSS表格能够解决所有那些我们在使用绝对定位和浮动定位进行多列布局时所遇到的问题。例如，“display:table;”的CSS声明能够让一个HTML元素和它的子节点像table元素一样。\n> - 使用基于表格的CSS布局，使我们能够轻松定义一个单元格的边界、背景等样式，而不会产生因为使用了table那样的制表标签所导致的语义化问题。\n> - 在深入了解这种方法之前，让我们先来写份HTML文档实例：\n\n```html\n<div id=\"wrapper\">\n    <div id=\"main\">\n        <div id=\"nav\">navigation column content…</div>\n        <div id=\"extras\">news headlines column content…</div>\n        <div id=\"content\">main article content…</div>\n    </div>\n</div>\n```\n\n> 这份HTML源代码满足了内容呈现方面的要求。先是导航栏，然后是附加栏，最后是内容栏。我们同样需要将以下CSS样式应用上去：\n\n```css\n#main {\n    display: table;\n    border-collapse: collapse;\n}\n#nav {\n    display: table-cell;\n    width: 180px;\n    background-color: #e7dbcd;\n}\n#extras {\n    display: table-cell;\n    width: 180px;\n    padding-left: 10px;\n    border-right: 1px dotted #d7ad7b;\n}\n#content {\n    display: table-cell;\n    width: 380px;\n    padding-left: 10px;\n}\n```\n\n>　这种基于表格的新CSS布局方式能够正确的在IE8、Firefox、Safari和Opera（译者注：包括FF2/FF3/Google都通过了测试）中显示出来。我们轻松实现了三栏等高布局，而无需使用伪造背景图片之类的技巧，更不用担心定位和清除浮动的问题！\n\n### 它是怎样实现的？\n\n- 你可以给HTML元素指定与表格相关的display属性值，使得它们像表格元素那样渲染。以下是这些可用的display属性值：\n\n- table 使该元素按table样式渲染\n- table-row 使该元素按tr样式渲染\n- table-cell 使该元素按td样式渲染\n- table-row-group 使该元素按tbody样式渲染\n- table-header-group 使该元素按thead样式渲染\n- table-footer-group 使该元素按tfoot样式渲染\n- table-caption 使该元素按caption样式渲染\n- table-column 使该元素按col样式渲染\n- table-column-group 使该元素按colgroup样式渲染\n\n### 难道用table布局不是错的吗？\n\n> - 可能你会对我们上面给出的布局实例有点不爽——毕竟，正如我自己也是一名WEB标准化的拥护者，我们不都一直坚持不应该使用table来进行布局吗？\n> - table元素在HTML当中是一个包含语义的标签：它描述什么是数据。因此，你只能用它来标记那些需要制表的数据，例如一张财务信息表。如果数据能够以电子表格的形式保存在你的电脑中，那它在HTML文档中很可能需要用到table标签进行标记。从另一方面来看，display的table属性值只是声明了某些元素在浏览器中的样式——它不包含语义。如果使用table元素来进行布局，它将会告诉客户端：这些数据是制表的。使用一些display属性被设置为table和table-cell之类的div标签，除了告诉客户端以某种特定的样式来渲染它们以外，不会告诉客户端任何语义，只要客户端能够支持这些属性值。\n> - 当然，我们同样还要注意，当我们真的需要制表数据的时候不要使用一大堆被声明为display:table;的div元素。\n> - 我们上面的那个例子是一个简单的单行三列布局，无需费尽心思，我们就能够使用这种技术轻松实现复杂的栅格布局。\n\n### 匿名表格元素\n\n　　CSS表格除了包含table布局的普通规则之外，同时还有着CSS table布局的超强特性：缺少的表格元素会被浏览器以匿名方式创建。CSS2.1规范中写道：\n\n> CSS2.1表格模型中的元素，可能不会全部包含在除HTML之外的文档语言中。这时，那些“丢失”的元素会被模拟出来，从而使得表格模型能够正常工作。所有的表格元素将会自动在自身周围生成所需的匿名table对象，使其符合table/inline-table、table-row、table-cell的三层嵌套关系。\n\n　　这段话的意思是，如果我们为元素使用“display:table-cell;”属性，而不将其父容器设置为“display:table-row;”属性，浏览器会默认创建出一个表格行，就好像文档中真的存在一个被声明的表格行一样。\n\n### 创建匿名表格元素的规则\n\n> - 这些匿名的盒对象不是用魔术变出来的，它们也不会自动往你的HTML源码中添加新的标签。为了完全发挥出匿名表格元素的优势，你最好能够对创建它们的规则有所了解。如果布局中调用了匿名元素，浏览器将会根据需要创建一个匿名的盒对象并将它的CSS display属性设置为table、table-row或table-cell中的一个。\n> - 如果某个元素已经被设置为“display:table-cell;”，而它的父节点（包含它的容器）没有被设置为“display:table-row;”属性，那么浏览器将会创建一个被设置为“display:table-row;”的匿名盒对象来嵌套它。并且与之相邻的属性为“display: table-cell;”的兄弟节点也都会被这个匿名盒对象所包含，直到碰到一个没有被设置为“display: table-cell;”的元素而结束这一行。以下是相关的代码样例：\n\n```html\n<div class=”cell”>CELL A</div>\n<div class=”cell”>CELL B</div>\n<div class=”cell”>CELL C</div>\n<div>Not a cell</div>\n```\n\n> 3个`cell`的div元素被设置为`display: table-cell;`：会像一个单行三个单元格一样并排排列这。最后一个div元素则不会被包含在这一表格行当中，因为它没有被设置成`display:table-cell;`\n>\n> 如果某个元素被设置为“display:table-row;”，而它的父节点没有被设置为“display:table;”（或者“display:table-row-group;”），浏览器将会创建一个被设置为“display:table;”的匿名盒对象来嵌套它，与之相邻的属性为“display: table-row;”的兄弟节点也都会被包含其中。\n>\n> 如果某个元素被设置为“display:table-row;”，但它的内部却缺少“display:table-cell;”的元素，那么一个匿名的table-cell将会被创建，用来包含该table-row中的所有元素。请看以下代码：\n\n```html\n<div class=”row”>ROW A</div>\n<div class=”row”>ROW B</div>\n<div>Not a row</div>\n```\n\n> 上面两排类名为“row”的div元素被设置了“display:table-row;”属性，它们将会像单列表格中的两行一样依次排列。最后一个div元素则不会包含在这个匿名的table中。\n>\n> 以此类推，如果某个元素的display属性值被设置为与表格相关的值，如table-row-group、table-header-group、 table-footer-group、table-column、table-column-group以及table-caption，但同时又没有一个被设置为“display:table;”的父元素，那么一个匿名的盒对象将会被创建用来包含该元素和它的某些兄弟节点。\n\n### 其他有用的表格属性\n\n> 当使用CSS表格时，因为这些元素遵从table布局的普通规则，所以你还可以给它们应用其它表格相关的CSS属性。下面是一些派得上用场的属性：\n>\n> - table-layout 将table-layout属性设置为fixed可以让浏览器按照固定算法来渲染单元格的宽度。这在固定宽度布局中非常有用，例如我们最上面的那段布局代码。\n>\n> - border-collapse 和普通的HTML表格一样，你可以使用border-collapse属性来定义你的table布局元素之间使用何种形式的边框，是共用边框（赋值为collapse）还是使用各自独立的边框（赋值为separate）。\n>\n> - border-spacing 如果你声明了“border-collapse:separate;”，那么你就可以使用border-spacing属性来定义相邻两个单元格边框间的距离。\n\n### 制作完美的栅格\n\n> 制作等高栅格对于传统CSS布局技术来说已经成为一个难题，然而使用合适的CSS表格则很容易实现。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n    <title>等高栅格</title>\n<style>  \n.grid {\n    display: table;/*表格布局*/\n    border-spacing: 4px;/*单元格间距4px*/\n}\n.row {\n    display: table-row;/*表格th布局*/\n}\n.image {\n    display: table-cell;/*表格td布局*/\n    width: 240px;\n    background-color: #000;\n    border: 8px solid #000;\n    vertical-align: middle;\n    text-align: center;\n}\n.image p {\n    color: #fff;\n    font-size: 85%;\n    text-align: left;\n    padding-top: 8px;\n}\n</style>\n<body>\n<div class='grid'>\n    <div class='row'>\n        <div class='image'><img src='images/11.png' alt='A Lily' />\n        <p>A lily in the gardens of The Vyne Country House</p></div>\n        <div class='image'><img src='images/11.png' alt='A Fuchsia plant' />\n        <p>Fuchsia plant in my garden</p></div>\n    </div>\n    <div class='row'>\n        <div class='image'><img src='images/11.png' alt='A crazy looking Allium flower' />\n        <p>A crazy looking flower</p></div>\n        <div class='image'><img src='images/11.png' alt='A Robin sitting on a fence' />\n        <p>This robin has been visiting our garden over the summer.He is very friendly and doesn’t seem to be too worried about sharing the garden with us.</p></div>\n    </div>\n</div>\n</body>\n</html>\n```\n\n效果图：![img](C:\\RUIHUA\\Project\\blog-code\\source\\_posts\\front-end\\前端基础\\css\\layout\\table\\1158910-20171016230813099-1688210396.png)\n\n> 当然，这个我采用的是vertical-align:middle;你如果采用top对齐，那么图片就是完全一致对齐啦。\n\n## 区别\n\n> HTML Table和CSS Table之间的真正区别是：适当地调整CSS属性\n> CSS的Table能做到许多HTML Table 不能做的事情，可以从Table中择优选择属性使用。\n","children":[]}]},{"name":"README.md","path":"../guanruihua.github.io/CSS","data":"# [ruihuag](https://guanruihua.github.io/#/)\r\n\r\n<!-- ![](../__assets__/001.jpg) -->\r\n<!-- ![Metrics](https://metrics.lecoq.io/guanruihua?template=classic&isocalendar=1&languages=1&base=header%2C%20activity%2C%20community%2C%20repositories%2C%20metadata&base.indepth=false&base.hireable=false&base.skip=false&isocalendar=false&isocalendar.duration=half-year&languages=false&languages.limit=8&languages.threshold=0%25&languages.other=false&languages.colors=github&languages.sections=most-used&languages.indepth=false&languages.analysis.timeout=15&languages.categories=markup%2C%20programming&languages.recent.categories=markup%2C%20programming&languages.recent.load=300&languages.recent.days=14&config.timezone=Asia%2FShanghai) -->\r\n","children":[]},{"name":"templates&slots.md","path":"../guanruihua.github.io/CSS","data":"# template & slots\n\n> `<template>` 和 `<slot>` 元素创建一个可以用来灵活填充 Web组件的 shadow DOM 的模板。\n\n```html\n<link rel=\"stylesheet\" href=\"../../config/css/test-body.css\">\n<script src=\"../../config/js/addWindowSize.js\" defer></script>\n\n<style>\n dl {\n  margin-left: 6px;\n }\n\n dt {\n  font-weight: bold;\n  color: #217ac0;\n  font-size: 110%\n }\n\n dt {\n  font-family: Consolas, \"Liberation Mono\", Courier\n }\n\n dd {\n  margin-left: 16px\n }\n</style>\n\n\n<template id=\"element-details-template\">\n <style>\n  details {\n   font-family: \"Open Sans Light\", Helvetica, Arial\n  }\n\n  .name {\n   font-weight: bold;\n   color: #217ac0;\n   font-size: 120%\n  }\n\n  h4 {\n   margin: 10px 0 -8px 0;\n  }\n\n  h4 span {\n   background: #217ac0;\n   padding: 2px 6px 2px 6px\n  }\n\n  h4 span {\n   border: 1px solid #cee9f9;\n   border-radius: 4px\n  }\n\n  h4 span {\n   color: white\n  }\n\n  .attributes {\n   margin-left: 22px;\n   font-size: 90%\n  }\n\n  .attributes h4 {\n   margin-bottom: 10px;\n  }\n\n  .attributes p {\n   margin-left: 16px;\n   font-style: italic\n  }\n </style>\n <details>\n  <summary>\n   <span>\n    <code class=\"name\">&lt;<slot name=\"element-name\">NEED NAME</slot>&gt;</code>\n    <i class=\"desc\">\n     <slot name=\"description\">NEED DESCRIPTION</slot>\n    </i>\n   </span>\n  </summary>\n  <div class=\"attributes\">\n   <h4><span>Attributes</span></h4>\n   <slot name=\"attributes\">\n    <p>None</p>\n   </slot>\n  </div>\n </details>\n <hr>\n</template>\n\n<script>\n customElements.define('element-details',\n  class extends HTMLElement {\n   constructor() {\n    super();\n    var template = document\n     .getElementById('element-details-template')\n     .content;\n    const shadowRoot = this.attachShadow({ mode: 'open' })\n     .appendChild(template.cloneNode(true));\n   }\n  })\n</script>\n\n<element-details>\n <span slot=\"element-name\">slot</span>\n <span slot=\"description\">A placeholder inside a web\n  component that users can fill with their own markup,\n  with the effect of composing different DOM trees\n  together.</span>\n <dl slot=\"attributes\">\n  <dt>name</dt>\n  <dd>The name of the slot.</dd>\n </dl>\n</element-details>\n\n<element-details>\n <span slot=\"element-name\">template</span>\n <span slot=\"description\">A mechanism for holding client-\n  side content that is not to be rendered when a page is\n  loaded but may subsequently be instantiated during\n  runtime using JavaScript.</span>\n</element-details>\n```\n\n![](/__assets__/img/2022-01-10-17-09-40.png)\n","children":[]},{"name":"type","path":"../guanruihua.github.io/CSS","data":"","children":[{"name":"基础.md","path":"../guanruihua.github.io/CSS/type","data":"# type\n\n## `<alpha-value>`\n\n> 颜色的alpha值\n> 数字 / 百分比\n\n## `<number>`\n\n> 数字`<integer>`\n\n## `<percentage>`\n\n> - 百分比值\n> - 许多 CSS 属性 可以取百分比值，经常用以根据父对象来确定大小。百分比值由一个`<number>`具体数值后跟着%符号构成.\n> - 就像其它在css里的单位一样，在%和数值之间是不允许有空格的。\n\n## `<string>`\n\n> 字符串\n\n## `<length*>`\n\n### `<length>`\n\n> 距离尺寸 / 长度\n\n### `<length-percentage>`\n\n> 距离尺寸 百分值\n\n## `<angle*>`\n\n### `<angle>`\n\n> 角的大小\n> 位为度（degrees）、 百分度（gradians）、弧度（radians）或圈数（turns）\n\n#### 度 deg\n\n> 一个完整的圆是 360deg。例：0deg，90deg，14.23deg\n\n#### 百分度 grad\n\n> 一个完整的圆是 400grad。例：0grad，100grad，38.8grad\n\n#### 弧度 rad\n\n> 一个完整的圆是 2π 弧度，约等于 6.2832rad。1rad 是 180/π 度。例：0rad，1.0708rad，6.2832rad\n\n#### 圈数 turn\n\n一个完整的圆是 1turn。例：0turn，0.25turn，1.2turn\n\n- 直角：90deg = 100grad = 0.25turn ≈ 1.5708rad\n- 平角：180deg = 200grad = 0.5turn ≈ 3.1416rad\n- 直角（逆时针）：-90deg = -100grad = -0.25turn ≈ -1.5708rad\n- 零角：0 = 0deg = 0grad = 0turn = 0rad\n\n### `<angle-percentage>`\n\n> 可以是角度, 也可以是百分值\n> 使用: `calc()`\n\n## `<color>`\n\n> 颜色\n>\n> - 定义\n>   - 关键字 颜色单词(`blue`)\n>   - 十六进制:\n>     - #ffffff(简写#fff)\n>     - #00ff3388(简写#0f38)\n>   - RGB: rgb() / rgba()\n>   - HSL: hsl() / hsla()\n> 补充: rgba比rgb多一个参数, 多一个透明值\n\n## `<time*>`\n\n> `<time>` : 时间(单位`s`或`ms`)\n> `<time-percentage>` : 时间 / 百分比\n\n- 有效时间\n\n```txt\n12s         正整数\n-456ms      负整数\n4.3ms       非整数\n14mS        单位大小写不敏感，虽然不推荐大写\n+0s         0以及前置 + 号和单位\n-0ms        0以及前置 - 号和单位\n```\n\n- 无效时间\n\n```txt\n0           尽管<length>中允许0，其在<time>中无效。\n12.0        此为<number>而非<time>。其缺乏单位。\n7 ms        数字与单位间不允许有空格。\n```\n\n## `<custom-ident>`\n\n> 用户自定义字符串标识符\n>\n> 组成(区分大小写)\n>\n> - 字母 (A - Z,  a - z),\n> - 十进制数 (0 - 9),\n> - 连字符 (-),\n> - 下划线 (_),\n> - 转义字符 ( \\),\n> - Unicode 编码（格式：转义字符（\\）后跟1到6位十六进制数）\n\n- 有效标识符\n\n```txt\nnono79            字母数字混合\nground-level      字母-字母\n-test             连字符后跟字母\n_internal         下划线后跟字母\n\\22 toto          Unicode编码后跟字母\nbili\\.bob         转义的句号\n```\n\n- 无效标识符\n\n```txt\n34rem             第一个字符不能是数字\n-12rad            第一个字符连字符后不能跟数字\nbili.bob          只有字母数字、连字符-、下划线_不需要转义\n--toto            第一个字符不能为连字符后跟连字符\n'bilibob'         不能用单引号包起来，这是一个字符串类型\n\"bilibob\"         不能用双引号包起来，这是一个字符串类型\n```\n\n## dimension\n\n> 带有单位的数据\n","children":[]},{"name":"复杂.md","path":"../guanruihua.github.io/CSS/type","data":"# type\n\n## `<translation-value>`\n\n> 转换函数参数`translate*()`\n\n## `<basic-shape>`\n\n> 基础图形的CSS数据类型\n\n### inset\n\n`clip-path: inset(22% 12% 15px 35px);`\n\n![](/__assets__/img/2022-01-18-18-12-25.png)\n\n### circle\n\n`clip-path: circle(6rem at 12rem 8rem);`\n\n![](/__assets__/img/2022-01-18-18-13-06.png)\n\n### ellipse\n\n`clip-path: ellipse(115px 55px at 50% 40%);`\n\n![](/__assets__/img/2022-01-18-18-14-12.png)\n\n### polygon\n\n`clip-path: polygon(50% 2.4%, 34.5% 33.8%, 0% 38.8%, 25% 63.1%, 19.1% 97.6%, 50% 81.3%, 80.9% 97.6%, 75% 63.1%, 100% 38.8%, 65.5% 33.8%);`\n![](/__assets__/img/2022-01-18-18-15-02.png)\n\n### path\n\n`clip-path: path('M 50,245 A 160,160 0,0,1 360,120 z')`\n![](/__assets__/img/2022-01-18-18-15-34.png)\n\n## `<filter-function>`\n\n> 改变输入图像外观的图形效果。它可以用于filter 和 backdrop-filter 属性\n> 过滤函数\n>\n> - `brightness()` : 让图像更明亮或更暗淡\n> - `contrast()` : 增加或减少图像的对比度\n> - `drop-shadow()` : 在图像后方应用投影\n> - `grayscale()` : 将图像转为灰度图\n> - `hue-rotate()` : 改变图像的整体色调\n> - `invert()` : 反转图像颜色\n> - `opacity()` : 改变图像透明度\n> - `saturate()` : 超饱和或去饱和输入的图像\n> - `sepia()` : 将图像转为棕褐色\n\n## `<blend-mode>`\n\n> 用于描述元素重合, 颜色呈现\n> 用于`background-blend-mode`,`mix-blend-mode`属性\n> ie 不支持\n\n### normal\n\n> 最终颜色: 顶层色\n\n![](/__assets__/img/2022-01-18-17-27-55.png)\n\n### multiply\n\n> 最终颜色: 顶层颜色与底层颜色相乘\n\n![](/__assets__/img/2022-01-18-17-37-23.png)\n\n### screen\n\n> 最终颜色: 顶层颜色和底层颜色,反转后相乘,再反转相加之和\n\n![](/__assets__/img/2022-01-18-17-41-00.png)\n\n### overlay\n\n> - 如果底层颜色比顶层颜色深，则最终颜色是 multiply 的结果\n> - 如果底层颜色比顶层颜色浅，则最终颜色是 screen 的结果\n> - 此混合模式相当于顶层与底层互换后的 hard-light\n\n![](/__assets__/img/2022-01-18-17-42-05.png)\n\n### darken\n\n> 显示黑色\n\n![](/__assets__/img/2022-01-18-17-59-23.png)\n\n### lighten\n\n> 显示最亮值组成的颜色\n\n![](/__assets__/img/2022-01-18-18-00-31.png)\n\n### color-dodge\n\n> 显示: 底部颜色除以顶部颜色的反色\n\n![](/__assets__/img/2022-01-18-18-05-14.png)\n\n### color-burn\n\n> 反转底部颜色, 将反转后的值除以顶层颜色, 再反转除以后的值\n\n![](/__assets__/img/2022-01-18-18-06-02.png)\n\n### hard-light\n\n> 如果顶层颜色比底层颜色深，则最终颜色是 multiply 的结果，如果顶层颜色比底层颜色浅，则最终颜色是 screen 的结果。\n> 此混合模式相当于顶层与底层互换后的 overlay。\n> 其效果类似于在背景层上（用前景层）打出一片刺眼的聚光灯\n\n![](/__assets__/img/2022-01-18-18-08-45.png)\n\n### soft-light\n\n> 最终颜色类似于 hard-light 的结果，但更加柔和一些。\n> 此混合模式的表现类似 hard-light。\n> 其效果类似于在背景层上（用前景层）打出一片发散的聚光灯。\n\n![](/__assets__/img/2022-01-18-18-09-39.png)\n\n[其他](https://developer.mozilla.org/zh-CN/docs/Web/CSS/blend-mode)\n\n## display*\n\n### `<display-box>`\n\n> 一个元素到底是否产生显示盒\n> 值: `none`, `contents`\n\n### `<display-legacy>`\n\n> 指定`display`的属性\n> 值: `block`, `inline`\n>\n> - inline-block\n>   - 元素会产生一个块元素盒子，并且像内联盒子一样（表现得更像一个被替换的元素），可以融入到周围内容中。\n>   - 等同于 inline flow-root\n>\n> - inline-table\n>   - 在HTML中， inline-table 没有直接对应关系。它表现为一个HTML `<table>` 元素， 但是又表现为一个不同于块级盒子的内联盒子。表盒子内部是一个块级上下文。\n>   - 等同于 inline table\n> - inline-flex\n>   - 元素表现为一个内联元素，并对内容采用弹性盒子模型进行布局。\n>   - 等同于 inline flex\n>\n> - inline-grid\n>   - 元素表现为一个内联元素，并对内容采用网格模型进行布局。\n>   - 等同于 inline grid\n\n### `<display-inside>`\n\n> 元素内部类型\n> `flow`:该元素使用流布局（块和内联布局）来布局其内容\n> `flow-root`: 该元素生成一个块元素框，用于建立一个新的块格式设置上下文，定义格式化根的位置。\n> `table`: 这些元素的行为类似于 HTML`<table>`elements。 它定义了一个块级框。\n> `flex`: 该元素的行为类似于块元素，并根据flexbox 模型布置其内容。\n> `grid`: 该元素的行为类似于块元素，并根据网格模型对其内容进行布局。\n> `ruby`: 该元素的行为类似于内联元素，并根据 ruby 格式模型对其内容进行布局。它的行为类似于相应的 HTML `<ruby>`elements。\n\n### `<display-internal>`\n\n> 布局模型\n> `table-row-group`:  这些元素的行为类似于`<tbody>`HTML元素。\n> `table-header-group`:  这些元素的行为类似于`<thead>`HTML元素。\n> `table-footer-group`:  这些元素的行为类似于`<tfoot>`HTML元素。\n> `table-row`:  这些元素的行为类似于`<tr>`HTML元素。\n> `table-cell`:  这些元素的行为类似于`<td>`HTML元素。\n> `table-column-group`:  这些元素的行为类似于`<colgroup>`HTML元素。\n> `table-column`:  这些元素的行为类似于`<col>`HTML元素。\n> `table-caption`:  这些元素的行为类似于`<caption>`HTML元素。\n> `ruby-base`:  这些元素的行为类似于`<rb>`HTML元素。\n> `ruby-text`:  这些元素的行为类似于`<rt>`HTML元素。\n> `ruby-base-container`:  这些元素的行为类似于`<rbc>`匿名框生成的HTML元素。\n> `ruby-text-container`:  这些元素的行为类似于`<rtc>`HTML元素。\n\n### `<display-outside>`\n\n> - 可用值\n> - block : 这个值会生成一个块级元素盒子，同时在该元素之前和之后打断（换行）,会将该元素变成块级元素。\n> - inline : 这个值会生成一个行内元素盒子，该元素之前和之后不会打断（换行）, 如果空间充足，该元素后的元素将会在同一行显示。简单来说就是，这个值会将该元素变成行内元素。\n\n### `<display-listitem>`\n\n> 该关键字使元素生成一个伪元素，其中包含由其列表样式属性（例如项目符号点）指定的内容以及为其自己的内容指定的类型的主要框\n","children":[]},{"name":"特殊.md","path":"../guanruihua.github.io/CSS/type","data":"# type\n\n## `<ratio>`\n\n> 媒体查询中的宽高比\n\n`@media screen和(min-aspect-ratio：16/9){...}`\n\n## `<translation-value>`\n\n> 用于某些转换函数的参数中，包括translate（）、 translateX（）、 translateY（）和translate3d（）。\n\n## `<position>`\n\n> 2D空间中的坐标\n\n```css\n[ \n [ left | center | right | top | bottom | <percentage> | <length> ] |\n [ left | center | right | <percentage> | <length> ] [ top | center | bottom | <percentage> | <length> ] |\n [ center | [ left | right ] [ <percentage> | <length> ]? ] &&\n [ center | [ top | bottom ] [ <percentage> | <length> ]? ]\n]\n```\n\n## `<image>`\n\n> 2D图形\n>\n> - CSS可以处理以下情形中的不同类型图像：\n>   - 具有固有尺寸（大小）的图像，即图像具有自己的原始尺寸（大小），比如一个jpeg格式的图像有他自己的固有尺寸（大小）；\n>   - 图像具有多个固定尺寸，可在一个文件中存在多个不同版本的尺寸，比如有些.ico格式的图像。在这种情况下，图像表现出来的固有尺寸将是这些尺寸较大的一个，也就是最接近外层包含它的容器纵横比的那个图像；\n>   - 没有固定大小但有固定纵横比的图像，像一些矢量图形，比如SVG格式的图像；\n>   - 没有固定大小也没有固定宽高比的图像，比如CSS渐变（图像）；\n>\n\n## `<gradient>`\n\n> image 子类型, 表两种及以上的颜色过渡变化\n\n### 线性渐变\n\n> 颜色值沿着一条隐式的直线逐渐过渡。由`linear-gradient()`产生。\n\n```css\n.linear-gradient {\n  background: linear-gradient(to right,\n      red, orange, yellow, green, blue, indigo, violet);\n}\n```\n\n![](/__assets__/img/2022-01-18-17-07-40.png)\n\n### 径向渐变\n\n> 颜色值由一个中心点（原点）向外扩散并逐渐过渡到其他颜色值。由`radial-gradient()`函数产生。\n\n```css\n.radial-gradient {\n  background: radial-gradient(red, yellow, rgb(30, 144, 255));\n}\n```\n\n![](/__assets__/img/2022-01-18-17-08-48.png)\n\n### 重复渐变\n\n> 重复多次渐变图案直到足够填满指定元素\n> 由 `repeating-linear-gradient()`和`repeating-radial-gradient()`函数产生\n\n```css\n.linear-repeat {\n  background: repeating-linear-gradient(to top left, lightpink, lightpink 5px, white 5px, white 10px);\n}\n\n.radial-repeat {\n  background: repeating-radial-gradient(powderblue, powderblue 8px, white 8px, white 16px);\n}\n```\n\n![](/__assets__/img/2022-01-18-17-10-04.png)\n\n## `<resolution>`\n\n> 分辨率：用于描述媒体查询中的分辨率的<resolution> CSS数据类型表示输出设备的像素密度。\n>\n> - 在屏幕上，单位与CSS英寸，厘米或像素有关，而与物理值无关\n> - 单位\n>   - dpi: 表示每英寸的点数。屏幕通常每英寸包含72或96个点，但打印文档的dpi通常要大得多。\n>   - dpcm: 每厘米上的点数\n>   - dppx: 表示每个px的点数。 由于CSS px的固定比率为1:96，因此1dppx相当于96dpi\n>   - x: dppx 的别名\n","children":[]}]},{"name":"word-break&word-wrap&white-space.md","path":"../guanruihua.github.io/CSS","data":"# word-break & word-wrap & white-space\n\n## white-space\n\n> 控制空白字符的显示, 控制是否换行\n>\n> `normal | nowrap | pre | pre-wrap | pre-line`\n\n```html\n<style>\n div#box {\n  border: 1px solid #000;\n  width: 100px;\n    white-space: normal;\n }\n</style>\n<div id=\"box\">\n  Hi&nbsp;&nbsp;,\n  This is a incomprehensibilities long word.\n  <br>\n  你好&nbsp;&nbsp;，\n  这 是一个不可思议的长单词\n</div>\n```\n\n| `normal`   | ![](/__assets__/image-20211209102306919-16390165906611.png) | 默认                                           |\n| ---------- | ------------------------------------------------------------ | ---------------------------------------------- |\n| `nowrap`   | ![](./__assets__/image-20211209102458666.png) | 只有`<br>`才可以换行, <br>空格和换行符失效     |\n| `pre`      | ![](./__assets__/image-20211209102536365.png) | 空格和换行符全都被保留了下来<br>自动换行还是没 |\n| `pre-wrap` | ![](./__assets__/image-20211209102933032.png) | 保留空格和换行符, 可自动换行                   |\n| `pre-line` | ![](./__assets__/image-20211209103105521.png) | 空格被合并, 换行符发挥作用                     |\n\n## word-break\n\n> 控制单词如何被拆分换行\n>\n> `normal | break-all | keep-all`\n\n```html\n<style>\n div#box {\n  border: 1px solid #000;\n  width: 100px;\n  word-break: normal;\n }\n</style>\n\n<body>\n <div id=\"box\">\n  Hi&nbsp;&nbsp;,\n  This is a incomprehensibilities long word.\n  <br>\n  你好&nbsp;&nbsp;，\n  这 是一个不可思议的长单词\n </div>\n</body>\n```\n\n| `normal`    | ![](__assets__/image-20211209104047949-16390176505692.png) | 默认                                                   |\n| ----------- | ------------------------------------------------------------ | ------------------------------------------------------ |\n| `break-all` | ![](__assets__/image-20211209104132983.png) | 所有单词碰到边界一律拆分换行                           |\n| `keep-all`  | ![](__assets__/image-20211209104246886.png) | __所有“单词”一律不拆分换行__, <br>只有空格可以触发换行 |\n\n## word-wrap ( overflow-wrap )\n\n> 控制单词如何换行\n>\n> `normal | break-word`\n\n### break-word\n\n![image-20211209104919825](__assets__/image-20211209104919825.png)\n","children":[]},{"name":"_sidebar.md","path":"../guanruihua.github.io/CSS","data":"* at-rules\n  * [charset](at-rules/charset.md)\n  * [color-profile](at-rules/color-profile.md)\n  * [counter-style](at-rules/counter-style.md)\n  * [font-face](at-rules/font-face.md)\n  * [import](at-rules/import.md)\n  * [keyframes](at-rules/keyframes.md)\n  * [media](at-rules/media.md)\n  * [媒体监听](at-rules/媒体监听.md)\n* attribute\n  * [animation](attribute/animation.md)\n  * [background](attribute/background.md)\n  * [contain](attribute/contain.md)\n  * [content-visibility](attribute/content-visibility.md)\n  * [css-动画](attribute/css-动画.md)\n  * [font-variant-numeric](attribute/font-variant-numeric.md)\n  * [gap](attribute/gap.md)\n  * [isolation](attribute/isolation.md)\n  * [mix-blend-mode](attribute/mix-blend-mode.md)\n  * [overflow](attribute/overflow.md)\n  * [pointer-events](attribute/pointer-events.md)\n  * [scroll-behavior](attribute/scroll-behavior.md)\n  * [scroll-padding-top](attribute/scroll-padding-top.md)\n  * [shap-outside](attribute/shap-outside.md)\n  * [transform](attribute/transform.md)\n  * [transition](attribute/transition.md)\n  * [user-select](attribute/user-select.md)\n  * [毛玻璃](attribute/毛玻璃.md)\n  * 颜色\n    * [currentColor](attribute/颜色/currentColor.md)\n    * [radial-gradient](attribute/颜色/radial-gradient.md)\n* basis\n  * [1px](basis/1px.md)\n  * [W3C和IE盒模型](basis/W3C和IE盒模型.md)\n  * [单位](basis/单位.md)\n* [css-basis](css-basis.md)\n* [css-demo](css-demo.md)\n* [css-expand](css-expand.md)\n* [css3](css3.md)\n* gradient\n  * [linear-gradient](gradient/linear-gradient.md)\n* layout\n  * [css-layout](layout/css-layout.md)\n  * [display](layout/display.md)\n  * [flex](layout/flex.md)\n  * [grid](layout/grid.md)\n  * [position](layout/position/index.md)\n    * [home](layout/position/index.md)\n    * 问题\n      * [fixed失效](layout/position/问题/fixed失效.md)\n  * [table](layout/table.md)\n* [templates&slots](templates&slots.md)\n* type\n  * [基础](type/基础.md)\n  * [复杂](type/复杂.md)\n  * [特殊](type/特殊.md)\n* [word-break&word-wrap&white-space](word-break&word-wrap&white-space.md)\n* 伪元素\n  * [empty](伪元素/empty.md)\n  * [focus-within](伪元素/focus-within.md)\n  * [invalid](伪元素/invalid.md)\n* [伪类(元素)](伪类(元素).md)\n* 标签\n  * [input](标签/input.md)\n* 预编译语言\n  * [css-sass-scss-stylus](预编译语言/css-sass-scss-stylus.md)\n  * less\n    * [@plugin At-Rules](预编译语言/less/@plugin At-Rules.md)\n    * [CSSGuards](预编译语言/less/CSSGuards.md)\n    * [extend](预编译语言/less/extend.md)\n    * [function](预编译语言/less/function/index.md)\n      * [home](预编译语言/less/function/index.md)\n      * [ListFunction](预编译语言/less/function/ListFunction.md)\n      * [MathFunction](预编译语言/less/function/MathFunction.md)\n      * [MiscFunction](预编译语言/less/function/MiscFunction.md)\n      * [TypeFunction](预编译语言/less/function/TypeFunction.md)\n    * [less](预编译语言/less/less.md)\n    * [Merge](预编译语言/less/Merge.md)\n    * [mixins](预编译语言/less/mixins.md)\n    * [variables](预编译语言/less/variables.md)\n  * [sass](预编译语言/sass.md)\n* [黑白灰主题](黑白灰主题.md)\n","children":[]},{"name":"伪元素","path":"../guanruihua.github.io/CSS","data":"","children":[{"name":"empty.md","path":"../guanruihua.github.io/CSS/伪元素","data":"# [`:empty`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:empty)\r\n\r\n> 代表没有子元素的元素。子元素只可以是元素节点或文本（包括空格）。注释或处理指令都不会产生影响\r\n\r\n```css\r\n.container:empty::after {\r\n    content: \"暂无数据\";\r\n}\r\n```\r\n\r\n![](./__assets__/empty-2022-11-04-10-27-56.png)\r\n","children":[]},{"name":"focus-within.md","path":"../guanruihua.github.io/CSS/伪元素","data":"# [`focus-within`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus-within)\r\n\r\n> 表示一个元素获得焦点，或该元素的后代元素获得焦点。换句话说，元素自身或者它的某个后代匹配 :focus 伪类\r\n\r\n![](./__assets__/focus-within-2022-11-04-10-41-36.png)\r\n","children":[]},{"name":"invalid.md","path":"../guanruihua.github.io/CSS/伪元素","data":"# [`invalid`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:invalid)\r\n\r\n> 表示任意内容未通过验证的 `<input>` 或其他 `<form>` 元素\r\n\r\n![](./__assets__/invalid-2022-11-04-10-39-54.png)\r\n","children":[]}]},{"name":"伪类(元素).md","path":"../guanruihua.github.io/CSS","data":"# 伪类(元素)\n\n> Resudo-classes & Pseudo-elements\n\n## 相关补充\n\n```css\n/* CSS3 语法 */\nelement::before { 样式 }\n\n/* （单冒号）CSS2 过时语法 (仅用来支持 IE8) */\nelement:before  { 样式 }\n```\n\n## before & after\n>\n> - `before`:\n> - `after`\n\n```html\n<q>一些引用</q>, 他说, <q>比没有好。</q>.\n```\n\n```css\nq::before {\n  content: \"«\";\n  color: blue;\n}\nq::after {\n  content: \"»\";\n  color: red;\n}\n```\n\n![](/__assets__/img/2022-01-10-16-06-07.png)\n\n## selection\n\n> 修改选中文本的样式\n\n```html\nThis text has special styles when you highlight it.\n<p>Also try selecting text in this paragraph.</p>\n```\n\n```css\n::-moz-selection {\n  color: gold;\n  background-color: red;\n}\n\np::-moz-selection {\n  color: white;\n  background-color: blue;\n}\n/* 选中的文本是红色背景，金黄色的字体 */\n::selection {\n  color: gold;\n  background-color: red;\n}\n\n/*选中的是蓝色背景，白色的字体的段落*/\np::selection {\n  color: white;\n  background-color: blue;\n}\n```\n\n![](/__assets__/img/2022-01-10-16-09-16.png)\n\n## nth*\n\n> `nth-child(an+b) & nth-of-type(an+b) & nth-last-child(an+b) & nth-last-of-type(an+b)`\n>\n> CSS 伪类首先找到所有当前元素的兄弟元素，然后按照位置先后顺序从1开始排序，选择的结果为CSS伪类:nth-child括号中表达式（an+b）匹配到的元素集合（n=0，1，2，3...）。示例：\n>\n> - 0n+3 或简单的 3 匹配第三个元素。\n> - 1n+0 或简单的 n 匹配每个元素。（兼容性提醒：在 Android 浏览器 4.3 以下的版本 n 和 1n 的匹配方式不一致。1n 和 1n+0 是一致的，可根据喜好任选其一来使用。）\n> - 2n+0 或简单的 2n 匹配位置为 2、4、6、8...的元素（n=0时，2n+0=0，第0个元素不存在，因为是从1开始排序)。你可以使用关键字 even 来替换此表达式。\n> - 2n+1 匹配位置为 1、3、5、7...的元素。你可以使用关键字 odd 来替换此表达式。\n> - 3n+4 匹配位置为 4、7、10、13...的元素。\n> a 和 b 都必须为整数，并且元素的第一个子元素的下标为 1。换言之就是，该伪类匹配所有下标在集合 { an + b; n = 0, 1, 2, ...} 中的子元素。另外需要特别注意的是，an 必须写在 b 的前面，不能写成 b+an 的形式。\n>\n> `nth-of-type`: 忽略掉不符合选择器要求的元素\n> `nth-last-child(an+b)`: 从后往前匹配\n> `nth-last-of-type(an+b)`:  忽略掉不符合选择器要求的元素,从后往前匹配\n\n```html\n<h3><code>span:nth-child(2n+1)</code>, WITHOUT an\n   <code>&lt;em&gt;</code> among the child elements.</h3>\n<p>Children 1, 3, 5, and 7 are selected.</p>\n<div class=\"first\">\n  <span>Span 1!</span>\n  <span>Span 2</span>\n  <span>Span 3!</span>\n  <span>Span 4</span>\n  <span>Span 5!</span>\n  <span>Span 6</span>\n  <span>Span 7!</span>\n</div>\n\n<br>\n\n<h3><code>span:nth-child(2n+1)</code>, WITH an\n   <code>&lt;em&gt;</code> among the child elements.</h3>\n<p>Children 1, 5, and 7 are selected.<br>\n   3 is used in the counting because it is a child, but it isn't\n   selected because it isn't a <code>&lt;span&gt;</code>.</p>\n<div class=\"second\">\n  <span>Span!</span>\n  <span>Span</span>\n  <em>This is an `em`.</em>\n  <span>Span</span>\n  <span>Span!</span>\n  <span>Span</span>\n  <span>Span!</span>\n  <span>Span</span>\n</div>\n\n<br>\n\n<h3><code>span:nth-of-type(2n+1)</code>, WITH an\n   <code>&lt;em&gt;</code> among the child elements.</h3>\n<p>Children 1, 4, 6, and 8 are selected.<br>\n   3 isn't used in the counting or selected because it is an <code>&lt;em&gt;</code>,\n   not a <code>&lt;span&gt;</code>, and <code>nth-of-type</code> only selects\n   children of that type. The <code>&lt;em&gt;</code> is completely skipped\n   over and ignored.</p>\n<div class=\"third\">\n  <span>Span!</span>\n  <span>Span</span>\n  <em>This is an `em`.</em>\n  <span>Span!</span>\n  <span>Span</span>\n  <span>Span!</span>\n  <span>Span</span>\n  <span>Span!</span>\n</div>\n\n```\n\n```css\nhtml {\n  font-family: sans-serif;\n}\n\nspan,\ndiv em {\n  padding: 5px;\n  border: 1px solid green;\n  display: inline-block;\n  margin-bottom: 3px;\n}\n\n.first span:nth-child(2n+1),\n.second span:nth-child(2n+1),\n.third span:nth-of-type(2n+1) {\n  background-color: lime;\n}\n```\n\n![](/__assets__/img/2022-01-10-16-17-19.png)\n\n## only*\n\n### only-child\n\n> - `only-child` *匹配没有任何兄弟元素的元素.*\n> - 等效的选择器还可以写成 `:first-child:last-child`或者`:nth-child(1):nth-last-child(1)`,当然,前者的权重会低一点.\n> - `only-of-type` 代表了任意一个元素，这个元素没有其他相同类型的兄弟元素。\n\n```html\n<main>\n  <div>\n    <i>I am a lonely only child.</i>\n  </div>\n\n  <div>\n    <i>I have siblings.</i><br>\n    <b>So do I!</b><br>\n    <span>I also have siblings, <span>but this is an only child.</span></span>\n  </div>\n</main>\n```\n\n```css\nmain :only-child {\n  color: red;\n}\n\n```\n\n![](/__assets__/img/2022-01-10-16-30-43.png)\n\n### only-of-type\n\n```html\n<main>\n  <div>I am `div` #1.</div>\n  <p>I am the only `p` among my siblings.</p>\n  <div>I am `div` #2.</div>\n  <div>I am `div` #3.\n    <i>I am the only `i` child.</i>\n    <em>I am `em` #1.</em>\n    <em>I am `em` #2.</em>\n  </div>\n</main>\n```\n\n```css\nmain :only-of-type {\n  color: red;\n}\n```\n\n![](/__assets__/img/2022-01-10-16-32-17.png)\n\n## first*\n\n### first-child\n\n> 一组兄弟元素中的第一个元素\n> 不能改变所有的css属性. 你只能改变 margins、 orphans、 widows、文档什么时候换页。别的所有css样式都会被忽略。\n\n```html\n<div>\n  <p>This text is selected!</p>\n  <p>This text isn't selected.</p>\n</div>\n\n<div>\n  <h2>This text isn't selected: it's not a `p`.</h2>\n  <p>This text isn't selected.</p>\n</div>\n```\n\n```css\np:first-child {\n  color: lime;\n  background-color: black;\n  padding: 5px;\n}\n```\n\n![](/__assets__/img/2022-01-11-09-37-18.png)\n\n### first-of-type\n\n> 一组兄弟元素中其类型的第一个元素\n\n```html\n<h2>Heading</h2>\n<p>Paragraph 1</p>\n<p>Paragraph 1</p>\n```\n\n```css\np:first-of-type {\n  color: red;\n  font-style: italic;\n}\n```\n\n![](/__assets__/img/2022-01-11-09-40-08.png)\n\n### first-letter\n\n> - 伪元素\n> - 选中某 block-level element（块级元素）第一行的第一个字母，并且文字所处的行之前没有其他内容（如图片和内联的表格）\n> 只在display属性值为`block, inline-block, table-cell, list-item` 或者 `table-caption`的元素上才起作用\n> 只有一小部分CSS可以在包含使用了::first-letter 伪元素选择器的CSS规则集声明块内运用:\n>\n> - 所有的字体属性 : ``font, font-style, font-feature-settings, font-kerning, font-language-override, font-stretch, font-synthesis, font-variant, font-variant-alternates, font-variant-caps, font-variant-east-asian , font-variant-ligatures, font-variant-numeric, font-variant-position, font-weight, font-size, font-size-adjust, line-height 以及 font-family.``\n> - 所有的背景属性 : ``background-color, background-image, background-clip, background-origin, background-position, background-repeat, background-size, background-attachment以及 background-blend-mode.``\n> - 所有的外边距属性: ``margin, margin-top, margin-right, margin-bottom, margin-left.``\n> - 所有的内边距属性: ``padding, padding-top, padding-right, padding-bottom, padding-left.``\n> - 所有的边框属性: 比如一些简短的边框属性 ``border, border-style, border-color, border-width, border-radius, border-image``, 还剩下许多冗长的边框属性等等.\n> - ``color`` 属性.\n> - ``text-decoration, text-shadow, text-transform, letter-spacing, word-spacing (使用恰当的话), line-height, text-decoration-color, text-decoration-line, text-decoration-style, box-shadow, float, vertical-align`` 注意此刻必须没有浮动) 等属性.\n\n```html\n<div class=\"fl\">ruihuig</div>\n<div class=\"fl\">Ruihuig</div>\n```\n\n```css\n.fl::first-letter{\n color: red;\n}\n```\n\n### first-line\n\n> - 伪元素\n> - 块级元素 的第一行应用样式。第一行的长度取决于很多因素，包括元素宽度，文档宽度和文本的文字大小。\n> - 和其他所有的 伪元素一样，::first-line 不能匹配任何真实存在的html元素。\n> - ::first-line 伪元素只能在块容器中,所以,::first-line伪元素只能在一个display值为block, inline-block, table-cell 或者 table-caption中有用.。在其他的类型中，::first-line 是不起作用的.\n> - 允许属性\n>   - 所有和字体有关的属性：`font, font-kerning, font-style, font-variant, font-variant-numeric, font-variant-position, font-variant-east-asian (en-US), font-variant-caps, font-variant-alternates, font-variant-ligatures, font-synthesis, font-feature-settings, font-language-override, font-weight, font-size, font-size-adjust, font-stretch, and font-family`\n color\n>   - 所有和背景有关的属性： `background-color, background-clip, background-image, background-origin, background-position, background-repeat, background-size,  background-attachment, and background-blend-mode\n word-spacing, letter-spacing, text-decoration, text-transform, and line-height\n text-shadow, text-decoration, text-decoration-color, text-decoration-line, text-decoration-style, and vertical-align.`\n\n```html\n<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit,\nsed do eiusmod tempor incididunt ut labore.</p>\n```\n\n```css\np::first-line { text-transform: uppercase }\n```\n\n![](/__assets__/img/2022-01-18-15-03-49.png)\n\n## last*\n\n### last-child\n\n> 代表父元素的最后一个子元素\n\n```html\n<ul>\n  <li>此元素背景色不是lime</li>\n  <li>我的也不是lime。</li>\n  <li>我的才是lime！ :)</li>\n</ul>\n```\n\n```css\nli:last-child {\n  background-color: lime;\n}\n```\n\n![](/__assets__/img/2022-01-18-11-34-13.png)\n\n### last-of-type\n\n> 表示了在（它父元素的）子元素列表中，最后一个给定类型的元素。当代码类似Parent tagName:last-of-type的作用区域包含父元素的所有子元素中的最后一个选定元素，也包括子元素的最后一个子元素并以此类推。\n\n```html\n<p>\n  <em>我没有颜色 :(</em><br>\n  <strong>我没有颜色 :(</strong><br>\n  <em>我有颜色 :D</em><br>\n  <strong>我也没有颜色 :(</strong><br>\n</p>\n\n<p>\n  <em>我没有颜色 :(</em><br>\n  <span><em>我有颜色!</em></span><br>\n  <strong>我没有颜色 :(</strong><br>\n  <em>我有颜色 :D</em><br>\n  <span>\n    <em>我在子元素里，但没有颜色!</em><br>\n    <span style=\"text-decoration:line-through;\"> 我没有颜色 </span><br>\n    <em>我却有颜色！</em><br>\n  </span><br>\n  <strong>我也没有颜色 :(</strong>\n</p>\n```\n\n```css\np em:last-of-type {\n  color: lime;\n}\n\n```\n\n![](/__assets__/img/2022-01-18-11-33-20.png)\n\n## slotted\n\n> 选定那些被放在 HTML模板 中的元素\n\n```css\n/* Selects any element placed inside a slot */\n::slotted(*) {\n  font-weight: bold;\n}\n\n/* Selects any <span> placed inside a slot */\n::slotted(span) {\n  font-weight: bold;\n}\n\n```\n\n## root\n\n> 表示 <html> 元素，除了优先级更高之外，与 html 选择器相同\n\n```css\n/* 声明css变量 */\n:root {\n  --main-color: hotpink;\n  --pane-padding: 5px 42px;\n}\n```\n\n```html\n<p id=\"firstParagraph\">This paragraph should have a blue background and yellow text.</p>\n<p id=\"secondParagraph\">This paragraph should have a yellow background and blue text.</p>\n<div id=\"container\">\n  <p id=\"thirdParagraph\">This paragraph should have a green background and yellow text.</p>\n</div>\n```\n\n```css\n:root {\n  --first-color: #16f;\n  --second-color: #ff7;\n}\n\n#firstParagraph {\n  background-color: var(--first-color);\n  color: var(--second-color);\n}\n\n#secondParagraph {\n  background-color: var(--second-color);\n  color: var(--first-color);\n}\n\n#container {\n  --first-color: #290;\n}\n\n#thirdParagraph {\n  background-color: var(--first-color);\n  color: var(--second-color);\n}\n\n```\n\n```css\n:root {\n  --first-color: #16f;\n  --second-color: #ff7;\n}\n\n#firstParagraph {\n  background-color: var(--first-color);\n  color: var(--second-color);\n}\n\n#secondParagraph {\n  background-color: var(--second-color);\n  color: var(--first-color);\n}\n\n#container {\n  --first-color: #290;\n}\n\n#thirdParagraph {\n  background-color: var(--first-color);\n  color: var(--second-color);\n}\n```\n\n![](/__assets__/img/2022-01-10-17-25-23.png)\n\n## link & visited & hover & active\n>\n> - :active 伪类一般被用在 `<a>` 和 `<button>` 元素中. 这个伪类的一些其他适用对象包括包含激活元素的元素，以及可以通过他们关联的`<label>`标签被激活的表格元素。\n>\n\n```html\n<p>This paragraph contains a link:\n  <a href=\"#\">This link will turn red while you click on it.</a>\n  The paragraph will get a gray background while you click on it or the link.\n</p>\n```\n\n```css\na:link { color: blue; }          /* 未访问链接 */\na:visited { color: purple; }     /* 已访问链接 */\na:hover { background: yellow; }  /* 用户鼠标悬停 */\na:active { color: red; }         /* 激活链接 */\np:active { background: #eee; }   /* 激活段落 */\n```\n\n![](/__assets__/img/2022-01-10-17-39-39.png)\n\n## default\n\n> 一组相关元素中的默认表单元素\n\n```html\n<input type=\"radio\" name=\"season\" id=\"spring\">\n<label for=\"spring\">Spring</label>\n\n<input type=\"radio\" name=\"season\" id=\"summer\" checked>\n<label for=\"summer\">Summer</label>\n\n<input type=\"radio\" name=\"season\" id=\"fall\">\n<label for=\"fall\">Fall</label>\n\n<input type=\"radio\" name=\"season\" id=\"winter\">\n<label for=\"winter\">Winter</label>\n```\n\n```css\n\ninput:default {\n  box-shadow: 0 0 2px 1px coral;\n}\n\ninput:default + label {\n  color: coral;\n}\n```\n\n![](/__assets__/img/2022-01-10-17-43-49.png)\n\n## defined\n\n> 表示任何已定义的元素。这包括任何浏览器内置的标准元素以及已成功定义的自定义\n\n```css\n/* 选择所有已定义的元素 */\n:defined {\n  font-style: italic;\n}\n\n/* 选择指定自定义元素的任何实例 */\nsimple-custom:defined {\n  display: block;\n}\n\n```\n\n## checked\n\n> 处于选中状态的radio(``<input type=\"radio\">``), checkbox (``<input type=\"checkbox\">``) 或(\"select\") 元素中的option HTML元素(\"option\")。\n\n```css\n/* 匹配任意被勾选/选中的radio(单选按钮),checkbox(复选框),或者option(select中的一项) */\n:checked {\n  margin-left: 25px;\n  border: 1px solid blue;\n} \n```\n\n```html\n<div>\n  <input type=\"radio\" name=\"my-input\" id=\"yes\">\n  <label for=\"yes\">Yes</label>\n\n  <input type=\"radio\" name=\"my-input\" id=\"no\">\n  <label for=\"no\">No</label>\n</div>\n\n<div>\n  <input type=\"checkbox\" name=\"my-checkbox\" id=\"opt-in\">\n  <label for=\"opt-in\">Check me!</label>\n</div>\n\n<select name=\"my-select\" id=\"fruit\">\n  <option value=\"opt1\">Apples</option>\n  <option value=\"opt2\">Grapes</option>\n  <option value=\"opt3\">Pears</option>\n</select>\n\n```\n\n```css\ndiv,\nselect {\n  margin: 8px;\n}\n\n/* Labels for checked inputs */\ninput:checked + label {\n  color: red;\n}\n\n/* Radio element, when checked */\ninput[type=\"radio\"]:checked {\n  box-shadow: 0 0 0 3px orange;\n}\n\n/* Checkbox element, when checked */\ninput[type=\"checkbox\"]:checked {\n  box-shadow: 0 0 0 3px hotpink;\n}\n\n/* Option elements, when selected */\noption:checked {\n  box-shadow: 0 0 0 3px lime;\n  color: red;\n}\n```\n\n![](/__assets__/img/2022-01-10-17-53-43.png)\n\n### 借用隐藏的checkbox来切换元素的样式（显示/隐藏）\n\n```html\n<input type=\"checkbox\" id=\"expand-toggle\" />\n\n<table>\n  <thead>\n    <tr><th>Column #1</th><th>Column #2</th><th>Column #3</th></tr>\n  </thead>\n  <tbody>\n    <tr class=\"expandable\"><td>[more text]</td><td>[more text]</td><td>[more text]</td></tr>\n    <tr><td>[cell text]</td><td>[cell text]</td><td>[cell text]</td></tr>\n    <tr><td>[cell text]</td><td>[cell text]</td><td>[cell text]</td></tr>\n    <tr class=\"expandable\"><td>[more text]</td><td>[more text]</td><td>[more text]</td></tr>\n    <tr class=\"expandable\"><td>[more text]</td><td>[more text]</td><td>[more text]</td></tr>\n  </tbody>\n</table>\n\n<label for=\"expand-toggle\" id=\"expand-btn\">Toggle hidden rows</label>\n\n```\n\n```css\n/* Hide the toggle checkbox */\n#expand-toggle {\n  display: none;\n}\n\n/* Hide expandable content by default */\n.expandable {\n  visibility: collapse;\n  background: #ddd;\n}\n\n/* Style the button */\n#expand-btn {\n  display: inline-block;\n  margin-top: 12px;\n  padding: 5px 11px;\n  background-color: #ff7;\n  border: 1px solid;\n  border-radius: 3px;\n}\n\n/* Show hidden content when the checkbox is checked */\n#expand-toggle:checked ~ * .expandable {\n  visibility: visible;\n}\n\n/* Style the button when the checkbox is checked */\n#expand-toggle:checked ~ #expand-btn {\n  background-color: #ccc;\n}\n\n```\n\n![](./../../__assets__/gif/checked.gif)\n\n## disabled\n\n> 表示任何被禁用的元素\n> 如果一个元素不能被激活（如选择、点击或接受文本输入）或获取焦点，则该元素处于被禁用状态。元素还有一个启用状态（enabled state），在启用状态下，元素可以被激活或获取焦点。\n\n```css\n/* Selects any disabled <input> */\ninput:disabled {\n  background: #ccc;\n}\n```\n\n## empty\n\n> 代表没有子元素的元素。子元素只可以是元素节点或文本（包括空格）。注释或处理指令都不会产生影响。\n\n```html\n<div class=\"box\"><!-- I will be lime --></div>\n<div class=\"box\">I will be pink</div>\n<div class=\"box\">\n    <!-- I will be red because of the whitespace around this comment -->\n</div>\n```\n\n```css\n.box {\n    background: pink;\n    height: 80px;\n    width: 80px;\n}\n\n.box:empty {\n    background: lime;\n}\n\n```\n\n![](/__assets__/img/2022-01-10-22-56-52.png)\n\n## enabled\n\n> 任何被启用的（enabled）元素。如果一个元素能够被激活（如选择、点击或接受文本输入），或者能够获取焦点，则该元素是启用的。元素也有一个禁用的状态（disabled state），在被禁用时，元素不能被激活或获取焦点\n\n```html\n<form action=\"url_of_form\">\n  <label for=\"FirstField\">First field (enabled):</label>\n  <input type=\"text\" id=\"FirstField\" value=\"Lorem\"><br>\n\n  <label for=\"SecondField\">Second field (disabled):</label>\n  <input type=\"text\" id=\"SecondField\" value=\"Ipsum\" disabled=\"disabled\"><br>\n\n  <input type=\"button\" value=\"Submit\">\n</form>\n```\n\n```css\ninput:enabled {\n  color: #2b2;\n}\n\ninput:disabled {\n  color: #aaa;\n}\n```\n\n![](/__assets__/img/2022-01-11-09-32-53.png)\n\n## focus*\n\n### focus\n\n> 表示获得焦点的元素（如表单输入）。当用户点击或触摸元素或通过键盘的 “tab” 键选择它时会被触发。\n> 此伪类仅适用于焦点元素本身。如果要选择包含焦点元素的元素，请使用`:focus-within`\n\n```html\n<input class=\"red-input\" value=\"I'll be red when focused.\"><br>\n<input class=\"blue-input\" value=\"I'll be blue when focused.\">\n```\n\n```css\n.red-input:focus {\n  background: yellow;\n  color: red;\n}\n\n.blue-input:focus {\n  background: yellow;\n  color: blue;\n}\n```\n\n![](/__assets__/img/2022-01-11-09-55-39.png)\n\n### focus-within\n\n> 表示一个元素获得焦点，或，该元素的后代元素获得焦点。换句话说，元素自身或者它的某个后代匹配 `:focus` 伪类\n\n```html\n<p>试试在这个表单中输入点什么。</p>\n\n<form>\n  <label for=\"given_name\">Given Name:</label>\n  <input id=\"given_name\" type=\"text\">\n  <br>\n  <label for=\"family_name\">Family Name:</label>\n  <input id=\"family_name\" type=\"text\">\n</form>\n```\n\n```css\nform {\n  border: 1px solid;\n  color: gray;\n  padding: 4px;\n}\n\nform:focus-within {\n  background: #ff8;\n  color: black;\n}\n\ninput {\n  margin: 4px;\n}\n\n```\n\n![](/__assets__/img/2022-01-11-10-01-26.png)\n\n### focus-visible\n\n> 当元素匹配:focus伪类并且客户端(UA)的启发式引擎决定焦点应当可见(在这种情况下很多浏览器默认显示“焦点框”。)时，:focus-visible 伪类将生效。\n> 这个选择器可以有效地根据用户的输入方式(鼠标 vs 键盘)展示不同形式的焦点。\n> 请注意Firefox通过较旧的前缀伪类 :-moz-focusring 支持类似的功能。更多细节请参考:-moz-focusring (en-US)页面。\n\n```html\n<input value=\"Default styles\"><br>\n<button>Default styles</button><br>\n<input class=\"focus-only\" value=\":focus only\"><br>\n<button class=\"focus-only\">:focus only</button><br>\n<input class=\"focus-visible-only\" value=\":focus-visible only\"><br>\n<button class=\"focus-visible-only\">:focus-visible only</button>\n```\n\n```css\ninput, button {\n  margin: 10px;\n}\n\n.focus-only:focus {\n  outline: 2px solid black;\n}\n\n.focus-visible-only:focus-visible {\n  outline: 4px dashed darkorange;\n}\n```\n\n![](/__assets__/img/2022-01-11-10-07-28.png)\n> `focus-visible btn` 不会触发点击按钮的边框\n\n## *range\n\n### out-of-range\n\n> CSS 伪类 表示一个 `<input>` 元素，其当前值处于属性 min 和 max 限定的范围外。\n\n### in-range\n\n> CSS 伪类 代表一个 `<input>` 元素，其当前值处于属性min 和max 限定的范围之内.\n\n```html\n<form action=\"\" id=\"form1\">\n  <ul>Values between 1 and 10 are valid.\n    <li>\n      <input id=\"value1\" name=\"value1\" type=\"number\" placeholder=\"1 to 10\" min=\"1\" max=\"10\" value=\"12\">\n      <label for=\"value1\">Your value is </label>\n    </li>\n  </ul>\n</form>\n```\n\n```css\nli {\n  list-style: none;\n  margin-bottom: 1em;\n}\n\ninput {\n  border: 1px solid black;\n}\n\ninput:in-range {\n  background-color: rgba(0, 255, 0, 0.25);\n}\n\ninput:out-of-range {\n  background-color: rgba(255, 0, 0, 0.25);\n  border: 2px solid red;\n}\n\ninput:in-range + label::after {\n  content: 'okay.';\n}\n\ninput:out-of-range + label::after {\n  content: 'out of range!';\n}\n```\n\n![](/__assets__/img/2022-01-11-10-30-41.png)\n![](/__assets__/img/2022-01-11-10-31-07.png)\n\n## autofill\n\n> 浏览器自动填充是触发, 用户编辑就会停止匹配\n> 注意：许多浏览器的用户代理样式表在其样式声明中使用，使它们无法被网页覆盖，而无需诉诸JavaScript黑客。例如，Chrome在其内部样式表中具有以下内容：!important:-webkit-autofill\n\n```html\n<form method=\"post\" action=\"\">\n  <label for=\"email\">Email</label> <input type=\"email\" name=\"email\" id=\"email\" autocomplete=\"email\">\n</form>\n\n```\n\n```css\ninput {\n  border: 3px solid grey;\n  border-radius: 3px;\n}\n\ninput:-webkit-autofill {\n  border: 3px solid blue;\n}\ninput:autofill {\n  border: 3px solid blue;\n}\n\n```\n\n![](/__assets__/img/2022-01-18-11-02-57.png)\n\n## not\n\n- 用来匹配不符合一组选择器的元素。由于它的作用是防止特定的元素被选中，它也被称为反选伪类（negation pseudo-class）。\n\n- :not() 伪类不能被嵌套，这意味着 :not(:not(...)) 是无效的。\n- 由于伪元素不是简单的选择器，他们不能被当作 :not() 中的参数，形如 :not(p::before) 这样的选择器将不会工作。\n- 可以利用这个伪类写一个完全没有用处的选择器。例如， :not(*) 匹配任何非元素的元素，因此，这个规则将永远不会被应用。\n- 可以利用这个伪类提高规则的优先级。例如， #foo:not(#bar) 和 #foo 会匹配相同的元素，但是前者的优先级更高。\n- :not(.foo) 将匹配任何非 .foo 的元素，包括 `<html>` 和 `<body>`。\n- 这个选择器只会应用在一个元素上，无法用它来排除所有父元素。比如， body :not(table) a 依旧会应用到表格元素 `<table>` 内部的 `<a>` 上, 因为`<tr>`将会被 `:not(table)` 这部分选择器匹配。\n\n```html\n<p>我是一个段落。</p>\n<p class=\"fancy\">我好看极了！</p>\n<div>我「不是」一个段落。</div>\n```\n\n```css\n.fancy {\n  text-shadow: 2px 2px 3px gold;\n}\n\n/* 类名不是 `.fancy` 的 <p> 元素 */\np:not(.fancy) {\n  color: green;\n}\n\n/* 非 <p> 元素 */\nbody :not(p) {\n  text-decoration: underline;\n}\n\n/* 既不是 <div> 也不是 <span> 的元素 */\nbody :not(div):not(span) {\n  font-weight: bold;\n}\n\n/* 类名不是 `.crazy` 或 `.fancy` 的元素 */\n/* 注意，此语法尚未获广泛支持。 */\nbody :not(.crazy, .fancy) {\n  font-family: sans-serif;\n}\n```\n\n![](/__assets__/img/2022-01-18-11-26-12.png)\n\n## target\n\n> 代表一个唯一的页面元素(目标元素)，其id 与当前URL片段匹配\n> 经常与`<a>`连用\n\n```html\n<h3>Table of Contents</h3>\n<ol>\n <li><a href=\"#p1\">Jump to the first paragraph!</a></li>\n <li><a href=\"#p2\">Jump to the second paragraph!</a></li>\n <li><a href=\"#nowhere\">This link goes nowhere,\n   because the target doesn't exist.</a></li>\n</ol>\n\n<h3>My Fun Article</h3>\n<p id=\"p1\">You can target <i>this paragraph</i> using a\n  URL fragment. Click on the link above to try out!</p>\n<p id=\"p2\">This is <i>another paragraph</i>, also accessible\n  from the links above. Isn't that delightful?</p>\n\n```\n\n```css\np:target {\n  background-color: gold;\n}\n\n/* 在目标元素中增加一个伪元素*/\np:target::before {\n  font: 70% sans-serif;\n  content: \"►\";\n  color: limegreen;\n  margin-right: .25em;\n}\n\n/*在目标元素中使用italic样式*/\np:target i {\n  color: red;\n}\n```\n\n![](/__assets__/img/2022-01-18-14-19-51.png)\n点击`Jump to the first paragraph`\n![](/__assets__/img/2022-01-18-14-32-58.png)\n\n## scope\n\n> 作为选择器要匹配的参考点的元素\n>\n> 不支持IE\n\n- 当需要获取已检索到的的直接后代元素时，:scope 伪类很有用\n\n```js\nvar context = document.getElementById('context');\nvar selected = context.querySelectorAll(':scope > div');\n\ndocument.getElementById('results').innerHTML = Array.prototype.map.call(selected, function (element) {\n    return '#' + element.getAttribute('id');\n}).join(', ');\n```\n\n```html\n<div id=\"context\">\n    <div id=\"element-1\">\n        <div id=\"element-1.1\"></div>\n        <div id=\"element-1.2\"></div>\n    </div>\n    <div id=\"element-2\">\n        <div id=\"element-2.1\"></div>\n    </div>\n</div>\n<p>\n    Selected elements ids :\n    <span id=\"results\"></span>\n</p>\n```\n\n![](/__assets__/img/2022-01-18-14-15-53.png)\n\n## read*\n\n### read-only\n\n> 元素不可被用户编辑的状态(锁文本输入)\n\n```html\n<input type=\"text\" value=\"Type whatever you want here.\">\n<input type=\"text\" value=\"This is a read-only field.\" readonly>\n<p>This is a normal paragraph.</p>\n<p contenteditable=\"true\">You can edit this paragraph!</p>\n```\n\n```css\ninput { min-width: 25em; }\ninput:-moz-read-only { background: cyan; }\ninput:read-only { background: cyan; }\n\np:-moz-read-only { background: lightgray; }\np:read-only { background: lightgray; }\np[contenteditable=\"true\"] { color: blue; }\n\n```\n\n![](/__assets__/img/2022-01-18-11-47-05.png)\n\n### read-write\n\n> 代表一个元素（例如可输入文本的 input元素）可以被用户编辑\n\n```html\n<input type=\"text\" value=\"Type whatever you want here.\">\n<input type=\"text\" value=\"This is a read-only field.\" readonly>\n<p>This is a normal paragraph.</p>\n<p contenteditable=\"true\">You can edit this paragraph!</p>\n```\n\n```css\ninput { min-width: 25em; }\ninput:-moz-read-write { background: cyan; }\ninput:read-write { background: cyan; }\n\np:-moz-read-write { background: lightgray; }\np:read-write { background: lightgray; }\np[contenteditable=\"true\"] { color: blue; }\n\n```\n\n![](/__assets__/img/2022-01-18-11-48-34.png)\n\n## 表单元素相关\n\n### required\n\n> 表示任意设置了required属性的`<input>`，`<select>`, 或 `<textarea>`元素\n> 这个伪类对于高亮显示在提交表单之前必须具有有效数据的字段非常有用。\n\n### optional\n\n> 表示任意`没有required`属性的 `<input>`，`<select>` 或  `<textarea>` 元素使用\n\n### indeterminate\n\n> 状态不确定的表单元素(例如checkbox没有初始化)\n\n### *valid\n\n#### valid\n\n> 表示内容验证正确的`<input>` 或其他 `<form>` 元素。这能简单地将校验字段展示为一种能让用户辨别出其输入数据的正确性的样式。\n> 选择正确校验通过的字段元素\n> `>ie10`\n\n#### invalid\n\n> 表示任意内容未通过验证的 `<input>` 或其他 `<form>` 元素 .\n\n```html\n<form>\n  <label for=\"url_input\">Enter a URL:</label>\n  <input type=\"url\" id=\"url_input\" />\n  <br />\n  <br />\n  <label for=\"email_input\">Enter an email address:</label>\n  <input type=\"email\" id=\"email_input\" required/>\n</form>\n```\n\n```css\ninput:invalid {\n  background-color: #ffdddd;\n}\n\nform:invalid {\n  border: 5px solid #ffdddd;\n}\n\ninput:valid {\n  background-color: #ddffdd;\n}\n\nform:valid {\n  border: 5px solid #ddffdd;\n}****\n\ninput:required {\n  border-color: #800000;\n  border-width: 3px;\n}\n\ninput:required:invalid {\n  border-color: #C00000;\n}\n```\n\n![](/__assets__/img/2022-01-18-10-25-37.png)\n\n## 打印相关\n\n### right\n\n> 必须与@规则  @page 一起配套使用，表示打印文档的所有右页。\n> 只能用于更改页面的 margin, padding, border, and background 属性。其它属性都将被忽略，只会影响页框，不会影响文档内容。\n\n### first\n\n> @page CSS 伪类选择器 描述的是：打印文档的时候，第一页的样式。\n\n```html\n\n<p>First Page.</p>\n<p>Second Page.</p>\n<button>Print!</button>\n```\n\n```css\n@page :first {\n  margin-left: 50%;\n  margin-top: 50%;\n}\np {\n  page-break-after: always;\n}\n```\n\n```js\ndocument.querySelector(\"button\").onclick = function(){ window.print() }\n```\n\n![](/__assets__/img/2022-01-11-09-48-13.png)\n![](/__assets__/img/2022-01-11-09-48-35.png)\n","children":[]},{"name":"光标.md","path":"../guanruihua.github.io/CSS","data":"# 光标\r\n\r\n## caret-color\r\n\r\n> 定义插入光标的颜色\r\n","children":[]},{"name":"标签","path":"../guanruihua.github.io/CSS","data":"","children":[{"name":"input.md","path":"../guanruihua.github.io/CSS/标签","data":"# input\r\n\r\n## 切换密码的显隐性\r\n\r\n```css\r\n.pwd{\r\n  text-security:disc;\r\n  -webkit-text-security:disc;\r\n}\r\n```\r\n","children":[]}]},{"name":"预编译语言","path":"../guanruihua.github.io/CSS","data":"","children":[{"name":"css-sass-scss-stylus.md","path":"../guanruihua.github.io/CSS/预编译语言","data":"# CSS  Sass Scss stylus\n\n> - css预处理器是为了给css添加一些编程的特性\n>   - 无需考虑浏览器的兼容性问题\n>   - 使用变量\n>   - 简单的程序逻辑\n>   - 函数\n\n## 变量\n\n> - sass:    $变量名 :  变量值\n>\n> - less, css:  @变量名: 变量值\n>\n> - stylus :\n>   - 可以是任何字符开头(@除外)\n>   - 变量之间可以使用冒号, 空格隔开\n>   - 变量名 = 变量值\n>   - 属性 属性值\n>   - 栗子:\n>\n\n```stylus\nmaincolor = #092873\nsiteWidth = 1024px\nborderStyle = dotted\nbody \n  color maincolor\n  border 1px borderStyle mainColor\n  max-width siteWidth\n```\n\n## 嵌套\n\n```scss\n//scss style //----------------------------------- \nnav { \n    ul { \n       margin: 0; \n       padding: 0; \n    } \n    li { \n       display: inline-block; \n    } \n    a { \n       display: block; \n       padding: 6px 12px; \n       text-decoration: none; \n    } \n}\n//css style //----------------------------------- \nnav ul { \n    margin: 0; \n    padding: 0; \n    list-style: none; \n} \nnav li { \n    display: inline-block; \n} \nnav a { \n    display: block; \n    padding: 6px 12px; \n    text-decoration: none; \n\n```\n\n## 运算符\n\n```css\nbody {\n  margin: (14px/2);\n  top: 50px + 100px;\n  right: 80 * 10%;\n}\n```\n\n## 颜色函数\n\n> 预处理语言都会内置一些颜色处理函数\n\n### sass颜色函数\n\n```sass\nlighten($color, 10%); \ndarken($color, 10%);  \nsaturate($color, 10%);   \ndesaturate($color, 10%);\ngrayscale($color);  \ncomplement($color); \ninvert($color); \nmix($color1, $color2, 50%); \n\n使用\n@color: #0982C1;\nborder : 3px solid darken($color, 50%);\n```\n\n### less css颜色函数\n\n```css\nlighten(@color, 10%); \ndarken(@color, 10%);  \nsaturate(@color, 10%);  \ndesaturate(@color, 10%); \nspin(@color, 10); \nspin(@color, -10); \nmix(@color1, @color2);\n\n@color: #0982C1;\nh1 {\n  background: @color;\n  border: 3px solid darken(@color, 50%);\n}\n```\n\n### Stylus颜色处理函数\n\n```css\nlighten(color, 10%); \ndarken(color, 10%);  \nsaturate(color, 10%);  \ndesaturate(color, 10%); \n\ncolor = #0982C1 \nh1\n  background color\n  border 3px solid darken(color, 50%)\n```\n\n## 导入(import)\n\n## 继承\n\n### sass\n\n```sass\n.message {\n  border: 1px solid #ccc;\n  padding: 10px;\n  color: #333;\n}\n.success {\n  @extend .message;\n  border-color: green;\n}\n.error {\n  @extend .message;\n  border-color: red;\n}\n.warning {\n  @extend .message;\n  border-color: yellow;\n}\n```\n\n### less css\n\n```less\n.message {\n  border: 1px solid #ccc;\n  padding: 10px;\n  color: #333;\n}\n.success {\n  .message;\n  border-color: green;\n}\n.error {\n  .message;\n  border-color: red;\n}\n.warning {\n  .message;\n  border-color: yellow;\n}\n```\n\n## Mixins混入\n\n### sass\n\n```sass\n@mixin error($borderWidth: 2px) {\n  border: $borderWidth solid #F00;\n  color: #F00;\n}\n.generic-error {\n  padding: 20px;\n  margin: 4px;\n  @ include error(); //这里调用默认 border: 2px solid #F00;\n}\n.login-error {\n  left: 12px;\n  position: absolute;\n  top: 20px;\n  @ include error(5px); //这里调用 border:5px solid #F00;\n}\n```\n\n### less\n\n```less\n.error(@borderWidth: 2px) {\n  border: @borderWidth solid #F00;\n  color: #F00;\n}\n.generic-error {\n  padding: 20px;\n  margin: 4px;\n  .error(); //这里调用默认 border: 2px solid #F00;\n}\n.login-error {\n  left: 12px;\n  position: absolute;\n  top: 20px;\n  .error(5px); //这里调用 border:5px solid #F00;\n}\n```\n\nStylus\n\n```\nerror(borderWidth = 2px){\n border: borderWidth solid #F00;\n color: #F00;\n}\n.login-error {\n  left: 12px;\n  position: absolute;\n  top: 20px;\n  error(5px); \n}\n```\n\n最后编译结果\n\n```css\n.generic-error {\n  padding: 20px;\n  margin: 4px;\n  border: 2px solid #f00;\n  color: #f00;\n}\n.login-error {\n  left: 12px;\n  position: absolute;\n  top: 20px;\n  border: 5px solid #f00;\n  color: #f00;\n}\n```\n\n## 3D文本\n\n### Sass\n\n```sass\n@mixin text3d($color) {\n  color: $color;\n  text-shadow: 1px 1px 0px darken($color, 5%),\n               2px 2px 0px darken($color, 10%),\n               3px 3px 0px darken($color, 15%),\n               4px 4px 0px darken($color, 20%),\n               4px 4px 2px #000;\n}\n \nh1 {\n  font-size: 32pt;\n  @ include text3d(#0982c1);\n}\n```\n\n### less\n\n```less\n.text3d(@color) {\n  color: @color;\n  text-shadow: 1px 1px 0px darken(@color, 5%),\n               2px 2px 0px darken(@color, 10%),\n               3px 3px 0px darken(@color, 15%),\n               4px 4px 0px darken(@color, 20%),\n               4px 4px 2px #000;\n}\n \nspan {\n  font-size: 32pt;\n  .text3d(#0982c1);\n}\n```\n\n### stylus\n\n```stylus\ntext3d(color)\n  color: color\n  text-shadow: 1px 1px 0px darken(color, 5%), \n               2px 2px 0px darken(color, 10%), \n               3px 3px 0px darken(color, 15%), \n               4px 4px 0px darken(color, 20%), \n               4px 4px 2px #000\nspan\n  font-size: 32pt\n  text3d(#0982c1)\n```\n\n### css\n\n```css\nspan {\n  font-size: 32pt;\n  color: #0982c1;\n  text-shadow:  1px 1px 0px #097bb7,\n            2px 2px 0px #0875ae,\n            3px 3px 0px #086fa4,\n            4px 4px 0px #07689a,\n            4px 4px 2px #000;\n}\n```\n\n## 高级语法\n\n> sass支持条件控制语句:@if @else  @for @while @each\n\n### @if @else\n\n```sass\n$lte7: true;\n$type: monster;\n.ib{\n    display:inline-block;\n    @if $lte7 {\n        *display:inline;\n        *zoom:1;\n    }\n}\np {\n  @if $type == ocean {\n    color: blue;\n  } @else if $type == matador {\n    color: red;\n  } @else if $type == monster {\n    color: green;\n  } @else {\n    color: black;\n  }\n}\n```\n\n### @for\n\n两种形式\n\n```sass\n@for $var from <start> throuh <end> (包括end这个数)\n@for $var from <start> to <end>   (不包括end这个数)\n```\n\n### @while\n\n```sass\n$i: 6;\n@while $i > 0 {\n  .item-#{$i} { width: 2em * $i; }\n  $i: $i - 2;\n}\n```\n\n### @each\n\n```sass\n$animal-list: puma, sea-slug, egret, salamander;\n@each $animal in $animal-list {\n  .#{$animal}-icon {\n    background-image: url('/images/#{$animal}.png');\n  }\n}\n```\n\n## Sass 和Scss区别\n\n> - scss是sass3引入的新的语法\n>   - 区别:\n>     - 拓展名\n>     - sass不带大括号和分号\n\n## Sass 和Less区别\n\n### Sass和Less编译环境不一样\n\n> - Sass的安装需要Ruby环境，是在服务端处理的\n> - Less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中，也有 Less.app、SimpleLess、CodeKit.app这样的工具，也有在线编译地址。\n\n### 输出设置不同\n\n> Less没有输出设置，Sass提供4中输出选项：nested, compact, compressed 和 expanded。\n\n输出样式的风格可以有四种选择，默认为nested\n\n- nested：嵌套缩进的css代码\n- expanded：展开的多行css代码\n- compact：简洁格式的css代码\n- compressed：压缩后的css代码\n","children":[]},{"name":"less","path":"../guanruihua.github.io/CSS/预编译语言","data":"","children":[{"name":"@plugin At-Rules.md","path":"../guanruihua.github.io/CSS/预编译语言/less","data":"# @plugin At-Rules\r\n\r\n```less\r\n\r\n@plugin \"my-plugin\";  // automatically appends .js if no extension\r\n.show-me-pi {\r\n  value: pi();\r\n}\r\n\r\n// output\r\n.show-me-pi {\r\n  value: 3.141592653589793;\r\n}\r\n```\r\n\r\n- 使用模块导出\r\n\r\n```js\r\n// my-plugin.js\r\nmodule.exports = {\r\n    install: function(less, pluginManager, functions) {\r\n        functions.add('pi', function() {\r\n            return Math.PI;\r\n        });\r\n    }\r\n};\r\n```\r\n","children":[]},{"name":"CSSGuards.md","path":"../guanruihua.github.io/CSS/预编译语言/less","data":"# CSS Guard\r\n\r\n```less\r\n.my-optional-style() when (@my-option = true) {\r\n  button {\r\n    color: white;\r\n  }\r\n}\r\n.my-optional-style();\r\n\r\n//  等同于\r\nbutton when (@my-option = true) {\r\n  color: white;\r\n}\r\n```\r\n","children":[]},{"name":"extend.md","path":"../guanruihua.github.io/CSS/预编译语言/less","data":"# Extend\r\n\r\n```less\r\n\r\nnav ul {\r\n  &:extend(.inline);\r\n  background: blue;\r\n}\r\n.inline {\r\n  color: red;\r\n}\r\n```\r\n\r\n```css\r\nnav ul {\r\n  background: blue;\r\n}\r\n.inline,\r\nnav ul {\r\n  color: red;\r\n}\r\n```\r\n\r\n## Extend Syntax\r\n\r\n```less\r\n.a:extend(.b) {}\r\n\r\n// the above block does the same thing as the below block\r\n.a {\r\n  &:extend(.b);\r\n}\r\n.c:extend(.d all) {\r\n  // extends all instances of \".d\" e.g. \".x.d\" or \".d.x\"\r\n}\r\n.c:extend(.d) {\r\n  // extends only instances where the selector will be output as just \".d\"\r\n}\r\n\r\n.e:extend(.f) {}\r\n.e:extend(.g) {}\r\n\r\n// the above and the below do the same thing\r\n.e:extend(.f, .g) {}\r\n```\r\n\r\n## nth Expression\r\n\r\n```less\r\n[title=identifier] {\r\n  color: blue;\r\n}\r\n[title='identifier'] {\r\n  color: blue;\r\n}\r\n[title=\"identifier\"] {\r\n  color: blue;\r\n}\r\n\r\n.noQuote:extend([title=identifier]) {}\r\n.singleQuote:extend([title='identifier']) {}\r\n.doubleQuote:extend([title=\"identifier\"]) {}\r\n```\r\n\r\n```css\r\n[title=identifier],\r\n.noQuote,\r\n.singleQuote,\r\n.doubleQuote {\r\n  color: blue;\r\n}\r\n\r\n[title='identifier'],\r\n.noQuote,\r\n.singleQuote,\r\n.doubleQuote {\r\n  color: blue;\r\n}\r\n\r\n[title=\"identifier\"],\r\n.noQuote,\r\n.singleQuote,\r\n.doubleQuote {\r\n  color: blue;\r\n}\r\n```\r\n\r\n## `extend 'all'`\r\n\r\n```less\r\n.a.b.test,\r\n.test.c {\r\n  color: orange;\r\n}\r\n.test {\r\n  &:hover {\r\n    color: green;\r\n  }\r\n}\r\n\r\n.replacement:extend(.test all) {}\r\n```\r\n\r\n```css\r\n.a.b.test,\r\n.test.c,\r\n.a.b.replacement,\r\n.replacement.c {\r\n  color: orange;\r\n}\r\n.test:hover,\r\n.replacement:hover {\r\n  color: green;\r\n}\r\n```\r\n","children":[]},{"name":"function","path":"../guanruihua.github.io/CSS/预编译语言/less","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/CSS/预编译语言/less/function","data":"# Less Function\r\n\r\n## if\r\n\r\n```less\r\n@some: foo;\r\n\r\ndiv {\r\n    margin: if((2 > 1), 0, 3px);\r\n    color:  if((iscolor(@some)), @some, black);\r\n}\r\n```\r\n\r\n```css\r\ndiv {\r\n    margin: 0;\r\n    color:  black;\r\n}\r\n```\r\n\r\n## boolean\r\n\r\n```less\r\n@bg: black;\r\n@bg-light: boolean(luma(@bg) > 50%);\r\n\r\ndiv {\r\n  background: @bg; \r\n  color: if(@bg-light, black, white);\r\n}\r\n```\r\n\r\n```css\r\ndiv {\r\n  background: black;\r\n  color: white;\r\n}\r\n```\r\n\r\n## escape\r\n\r\n- 将URL编码应用于在输入字符串中找到的特殊字符。\r\n- 未编码字符：，`/`，`？`，`@`，`&amp;`，`+`，`'`，`~`,`！`,`$`。\r\n- 最常见的编码字符：`\\<space\\>`，`\\`，`^`，`（`，`）`，`{`，`}`，`，`，`：`，`>`，`<`，`；`，`]`，`[`,`=`。\r\n- 参数：string：要转义的字符串。\r\n- 返回：不带引号的转义字符串内容。\r\n\r\n```less\r\nescape('a=1')\r\n```\r\n\r\n```css\r\na%3D1\r\n```\r\n\r\n## e\r\n\r\n- 字符串转义。\r\n- 它需要字符串作为参数，并按原样返回其内容，但不带引号。它可以用于输出无效CSS语法的CSS值，或者使用Less无法识别的专有语法。\r\n- 参数：string-要转义的字符串。\r\n- 返回：string-转义字符串，不带引号。\r\n\r\n```less\r\n@mscode: \"ms:alwaysHasItsOwnSyntax.For.Stuff()\" \r\nfilter: e(@mscode);\r\n```\r\n\r\n```css\r\nfilter: ms:alwaysHasItsOwnSyntax.For.Stuff();\r\n```\r\n\r\n## `% format`\r\n\r\n- 函数%（字符串，参数…）设置字符串格式。\r\n- 第一个参数是带占位符的字符串。所有占位符都以百分比符号%开头，后跟字母s、s、d、d、a或a。其余参数包含替换占位符的表达式。如果需要打印百分比符号，请按另一个百分比%%将其转义。\r\n- 如果需要将特殊字符转义到其utf-8转义码中，请使用大写占位符。函数将转义除（）'~！以外的所有特殊字符！。空间编码为%20。小写占位符保留特殊字符。\r\n- 占位符：\r\n  - d、 d、a、a-可以用任何类型的参数（颜色、数字、转义值、表达式等）替换。如果将它们与字符串结合使用，则将使用整个字符串，包括其引号。但是，引号按原样放在字符串中，它们不会以“/”或任何类似的方式转义。\r\n  - s、 s-可替换为任何表达式。如果将其与字符串一起使用，则只使用字符串值-省略引号。\r\n- 参数：\r\n  - `string`：使用占位符格式化字符串\r\n  - `anything*`：替换占位符的值\r\n- 返回：格式化`string`\r\n\r\n```less\r\nformat-a-d: %(\"repetitions: %a file: %d\", 1 + 2, \"directory/file.less\");\r\nformat-a-d-upper: %('repetitions: %A file: %D', 1 + 2, \"directory/file.less\");\r\nformat-s: %(\"repetitions: %s file: %s\", 1 + 2, \"directory/file.less\");\r\nformat-s-upper: %('repetitions: %S file: %S', 1 + 2, \"directory/file.less\");\r\n```\r\n\r\n```css\r\nformat-a-d: \"repetitions: 3 file: \"directory/file.less\"\";\r\nformat-a-d-upper: \"repetitions: 3 file: %22directory%2Ffile.less%22\";\r\nformat-s: \"repetitions: 3 file: directory/file.less\";\r\nformat-s-upper: \"repetitions: 3 file: directory%2Ffile.less\";\r\n```\r\n\r\n## replace\r\n\r\n- 参数:\r\n  - `string`: 待处理子符串\r\n  - `pattern`: 要搜索的字符串/正则\r\n  - `replacement`: 替换的子串\r\n  - `flags?`: 正则标志\r\n\r\n- 返回: 替换过字符串的字符串.\r\n\r\n```less\r\nreplace(\"Hello, Mars?\", \"Mars\\?\", \"Earth!\");\r\nreplace(\"One + one = 4\", \"one\", \"2\", \"gi\");\r\nreplace('This is a string.', \"(string)\\.$\", \"new $1.\");\r\nreplace(~\"bar-1\", '1', '2');\r\n```\r\n\r\n```css\r\n\"Hello, Earth!\";\r\n\"2 + 2 = 4\";\r\n'This is a new string.';\r\nbar-2;\r\n```\r\n","children":[]},{"name":"ListFunction.md","path":"../guanruihua.github.io/CSS/预编译语言/less/function","data":"# List Function\r\n\r\n## length\r\n\r\n```less\r\n@list: \"banana\", \"tomato\", \"potato\", \"peach\";\r\nn: length(@list);\r\n```\r\n\r\n```css\r\nn: 4;\r\n```\r\n\r\n## extract\r\n\r\n```less\r\n@list: apple, pear, coconut, orange;\r\nvalue: extract(@list, 3);\r\n```\r\n\r\n```css\r\nvalue: coconut;\r\n```\r\n\r\n## range\r\n\r\n- 生成列表\r\n- 参数\r\n  - `start`: （可选）开始值，例如1或1px\r\n  - `end`: 结束值，例如5px\r\n  - `step`: （可选）增量\r\n\r\n```less\r\nvalue: range(4);\r\nvalue: range(10px, 30px, 10);\r\n```\r\n\r\n```css\r\nvalue: 1 2 3 4;\r\nvalue: 10px 20px 30px;\r\n```\r\n\r\n## each\r\n\r\n- 将规则集的计算绑定到列表的每个成员\r\n- 参数\r\n  - `list` : 以逗号或空格分隔的值列表。\r\n  - `rule` : 匿名规则集/混合\r\n\r\n```less\r\n@selectors: blue, green, red;\r\n\r\neach(@selectors, {\r\n  .sel-@{value} {\r\n    a: b;\r\n  }\r\n});\r\n```\r\n\r\n```css\r\n.sel-blue {\r\n  a: b;\r\n}\r\n.sel-green {\r\n  a: b;\r\n}\r\n.sel-red {\r\n  a: b;\r\n}\r\n```\r\n\r\n```less\r\n@set: {\r\n  one: blue;\r\n  two: green;\r\n  three: red;\r\n}\r\n.set {\r\n  each(@set, {\r\n    @{key}-@{index}: @value;\r\n  });\r\n}\r\n```\r\n\r\n```css\r\n.set {\r\n  one-1: blue;\r\n  two-2: green;\r\n  three-3: red;\r\n}\r\n```\r\n\r\n```less\r\n.set-2() {\r\n  one: blue;\r\n  two: green;\r\n  three: red;\r\n}\r\n.set-2 {\r\n  each(.set-2(), .(@v, @k, @i) {\r\n    @{k}-@{i}: @v;\r\n  });\r\n}\r\n```\r\n\r\n```css\r\n.set-2 {\r\n  one-1: blue;\r\n  two-2: green;\r\n  three-3: red;\r\n}\r\n```\r\n\r\n```less\r\neach(range(4), {\r\n  .col-@{value} {\r\n    height: (@value * 50px);\r\n  }\r\n});\r\n```\r\n\r\n```css\r\n.col-1 {\r\n  height: 50px;\r\n}\r\n.col-2 {\r\n  height: 100px;\r\n}\r\n.col-3 {\r\n  height: 150px;\r\n}\r\n.col-4 {\r\n  height: 200px;\r\n}\r\n```\r\n","children":[]},{"name":"MathFunction.md","path":"../guanruihua.github.io/CSS/预编译语言/less/function","data":"# Math Function\r\n\r\n## ceil\r\n\r\n- 向上取整\r\n\r\n- Example: `ceil(2.4)`\r\n\r\n- Output: `3`\r\n\r\n## floor\r\n\r\n- 向下取整\r\n\r\n- Example: `floor(2.6)`\r\n\r\n- Output: `2`\r\n\r\n## percentage\r\n\r\n- 浮点数转百分数\r\n\r\n- Example: `percentage(0.5)`\r\n\r\n- Output: `50%`\r\n\r\n## round\r\n\r\n- 指定位数,四舍五入\r\n\r\n- Parameters:\r\n\r\n- number: 浮点数\r\n- decimalPlaces: 需要保留的位数\r\n- Returns: number\r\n\r\n- `Example`: `round(1.67)`\r\n\r\n- `Output`: `2`\r\n\r\n- `Example`: `round(1.67, 1)`\r\n\r\n- `Output`: `1.7`\r\n\r\n## sqrt\r\n\r\n- 开更号运算, 单位不变\r\n\r\n- parameters: number - 浮点数.\r\n\r\n- returns: number\r\n\r\n- example:\r\n\r\n```less\r\n\r\n sqrt(25cm)\r\n```\r\n\r\n- output:\r\n\r\n```css\r\n 5cm\r\n ```\r\n\r\n- example:\r\n\r\n```less\r\n sqrt(18.6%)\r\n ```\r\n\r\n- output:\r\n\r\n```css\r\n4.312771730569565%;\r\n```\r\n\r\n## abs\r\n\r\n- 绝对值, 单位不变\r\n\r\n- parameters: `number` - 浮点数\r\n\r\n- returns: `number`\r\n\r\n- example #1: `abs(25cm)`\r\n\r\n- output: `25cm`\r\n\r\n- example #2: `abs(-18.6%)`\r\n\r\n- output: `18.6%`\r\n\r\n## sin\r\n\r\n- 正弦运算\r\n\r\n- assumes radians on numbers without units.\r\n\r\n- parameters: number - 浮点数\r\n\r\n- returns: number\r\n\r\nexample:\r\n\r\n```less\r\nsin(1); // sine of 1 radian\r\nsin(1deg); // sine of 1 degree\r\nsin(1grad); // sine of 1 gradian\r\n```\r\n\r\noutput:\r\n\r\n```css\r\n0.8414709848078965; // sine of 1 radian\r\n0.01745240643728351; // sine of 1 degree\r\n0.015707317311820675; // sine of 1 gradian\r\n```\r\n\r\n## asin\r\n\r\ncalculates arcsine (inverse of sine) function.\r\n\r\nreturns number in radians e.g. a number between -π/2 and π/2.\r\n\r\nparameters: number - floating point number from [-1, 1] interval.\r\n\r\nreturns: number\r\n\r\nexample:\r\n\r\nasin(-0.8414709848078965)\r\nasin(0)\r\nasin(2)\r\noutput:\r\n\r\n-1rad\r\n0rad\r\nnanrad\r\n\r\n## cos\r\n\r\n- 余弦运算\r\n- assumes radians on numbers without units.\r\n\r\n- parameters: number - 浮点数\r\n\r\n- returns: number\r\n\r\nexample:\r\n\r\n```less\r\ncos(1) // cosine of 1 radian\r\ncos(1deg) // cosine of 1 degree\r\ncos(1grad) // cosine of 1 gradian\r\n```\r\n\r\noutput:\r\n\r\n```css\r\n0.5403023058681398 // cosine of 1 radian\r\n0.9998476951563913 // cosine of 1 degree\r\n0.9998766324816606 // cosine of 1 gradian\r\n```\r\n\r\n## acos\r\n\r\n- 反余弦运算\r\n\r\n- returns number in radians e.g. a number between 0 and π.\r\n\r\n- parameters: number - a floating point number from [-1, 1] interval.\r\n\r\n- returns: number\r\n\r\nexample:\r\n\r\n```less\r\nacos(0.5403023058681398)\r\nacos(1)\r\nacos(2)\r\n```\r\n\r\noutput:\r\n\r\n```css\r\n1rad\r\n0rad\r\nnanrad\r\n```\r\n\r\n## tan\r\n\r\n- 正切运算\r\n\r\n- Assumes radians on numbers without units.\r\n\r\n- Parameters: number - 浮点数\r\n\r\n- Returns: number\r\n\r\nExample:\r\n\r\n```less\r\n\r\ntan(1) // tangent of 1 radian\r\ntan(1deg) // tangent of 1 degree\r\ntan(1grad) // tangent of 1 gradian\r\n```\r\n\r\nOutput:\r\n\r\n```css\r\n1.5574077246549023   // tangent of 1 radian\r\n0.017455064928217585 // tangent of 1 degree\r\n0.015709255323664916 // tangent of 1 gradian\r\n```\r\n\r\n## atan\r\n\r\n- 正切逆运算\r\n\r\n- Returns number in radians e.g. a number between -π/2 and π/2.\r\n\r\n- Parameters: number - 浮点数\r\n\r\n- Returns: number\r\n\r\nExample:\r\n\r\n```less\r\natan(-1.5574077246549023)\r\natan(0)\r\nround(atan(22), 6) // arctangent of 22 rounded to 6 decimal places\r\n```\r\n\r\nOutput:\r\n\r\n```css\r\n-1rad\r\n0rad\r\n1.525373rad;\r\n```\r\n\r\n## pi\r\n\r\n- `π`\r\n- Returns π (pi);\r\n\r\n- Parameters: none\r\n\r\n- Returns: number\r\n\r\nExample:\r\n\r\n```\r\npi()\r\n```\r\n\r\nOutput:\r\n\r\n```\r\n3.141592653589793\r\n```\r\n\r\n## pow\r\n\r\nReturns the value of the first argument raised to the power of the second argument.\r\n\r\nReturned value has the same dimension as the first parameter and the dimension of the second parameter is ignored.\r\n\r\nParameters:\r\n\r\nnumber: base -浮点数\r\nnumber: exponent - 浮点数\r\nReturns: number\r\n\r\nExample:\r\n\r\npow(0cm, 0px)\r\npow(25, -2)\r\npow(25, 0.5)\r\npow(-25, 0.5)\r\npow(-25%, -0.5)\r\nOutput:\r\n\r\n1cm\r\n0.0016\r\n5\r\nNaN\r\nNaN%\r\n\r\n## mod\r\n\r\n- 模运算\r\n- 参数:\r\n  - number: 浮点数.\r\n  - number: 浮点数\r\n- Returns: number\r\n\r\nExample:\r\n\r\n```less\r\nmod(0cm, 0px)\r\nmod(11cm, 6px);\r\nmod(-26%, -5);\r\n```\r\n\r\nOutput:\r\n\r\n```css\r\nNaNcm;\r\n5cm\r\n-1%;\r\n```\r\n\r\n## min\r\n\r\n- 最小值\r\n\r\n- Example: `min(5, 10);`\r\n\r\n- Output: `5`\r\n\r\n- Example: `min(3px, 42px, 1px, 16px);`\r\n\r\n- Output: `1px`\r\n\r\n## max\r\n\r\n- 最大值\r\n\r\n- Example: `max(5, 10)`\r\n\r\n- Output: `10`\r\n\r\n- Example: `max(3%, 42%, 1%, 16%)`\r\n\r\n- Output: `42%`\r\n","children":[]},{"name":"MiscFunction.md","path":"../guanruihua.github.io/CSS/预编译语言/less/function","data":"# Misc Functions\r\n\r\n- 杂项方法\r\n\r\n## color\r\n\r\n- 解析颜色，使表示颜色的字符串成为颜色\r\n\r\n- Parameters: 颜色字符串\r\n\r\n- Returns: color\r\n\r\n- Example: `color(\"#aaa\")`\r\n\r\n- Output: `#aaa`\r\n\r\n## image-size\r\n\r\n- 获取图片文件尺寸\r\n\r\n- Parameters: 要获取图片尺寸的图片文件\r\n\r\n- Returns: 尺寸\r\n\r\n- Example: `image-size(\"file.png\")`\r\n\r\n- Output: `10px 10px`\r\n\r\n## image-width\r\n\r\n- 获取图片文件尺寸宽度\r\n\r\n- Example: `image-width(\"file.png\")`\r\n\r\n- Output: `10px`\r\n\r\n## image-height\r\n\r\n- 获取图片文件尺寸高度\r\n\r\n- `Example`: `image-height(\"file.png\")`\r\n\r\n- `Output`: `10px`\r\n\r\n## convert\r\n\r\n- 转换单位\r\n- 第一个参数包含一个带单位的数字，第二个参数包含单位。如果单位兼容，则转换数字。如果它们不兼容，则返回第一个参数，不作修改。\r\n\r\n- 可共用单位:\r\n\r\n- lengths: m, cm, mm, in, pt and pc\r\n- time: s and ms\r\n- angle: rad, deg, grad and turn\r\n\r\n- Parameters:\r\n\r\n  - number：带单位的浮点数。\r\n  - 标识符: 字符串或转义值：单位\r\n- Returns: number\r\n\r\nExample:\r\n\r\n```less\r\nconvert(9s, \"ms\")\r\nconvert(14cm, mm)\r\nconvert(8, mm) // incompatible  types\r\n```\r\n\r\nOutput:\r\n\r\n```css\r\n9000ms\r\n140mm\r\n8\r\n```\r\n\r\n## data-uri\r\n\r\n- 如果启用了ieCompat选项且资源太大，或者您在浏览器中使用了该函数，则内联资源并返回url（）。如果未给定MIME类型，则节点使用MIME包确定正确的MIME类型。\r\n\r\nParameters:\r\n\r\n- mimetype：（可选）MIME类型字符串。\r\n- url：要内联的文件的url。\r\n若并没有mimetype，数据uri函数将根据文件名后缀猜测它。文本和svg文件编码为utf-8，其他文件编码为base64。\r\n- 如果用户提供了mimetype，如果mimetype参数以结尾，则函数使用base64；base64。例如，图像/jpeg；base64编码为base64，而文本/html编码为utf-8。\r\n\r\n- `Example`:`data-uri('../data/image.jpg')`\r\n\r\n- `Output`:`url('data:image/jpeg;base64,bm90IGFjdHVhbGx5IGEganBlZyBmaWxlCg==')`\r\n\r\n- `Output`: in browser: `url('../data/image.jpg')`\r\n\r\n- `Example`:`data-uri('image/jpeg;base64', '../data/image.jpg')`\r\n\r\n- `Output`:`url('data:image/jpeg;base64,bm90IGFjdHVhbGx5IGEganBlZyBmaWxlCg==')`\r\n\r\n- `Example`:`data-uri('image/svg+xml;charset=UTF-8', 'image.svg')`\r\n\r\n- `Output`: `url(\"data:image/svg+xml;charset=UTF-8,%3Csvg%3E%3Ccircle%20r%3D%229%22%2F%3E%3C%2Fsvg%3E\")`\r\n\r\n## default\r\n\r\n- 仅在保护条件内可用，仅当没有其他mixin匹配时才返回true，否则返回false。\r\n\r\nExample:\r\n\r\n```less\r\n.mixin(1)                   {x: 11}\r\n.mixin(2)                   {y: 22}\r\n.mixin(@x) when (default()) {z: @x}\r\n\r\ndiv {\r\n  .mixin(3);\r\n}\r\n\r\ndiv.special {\r\n  .mixin(1);\r\n}\r\n```\r\n\r\nOutput:\r\n\r\n```css\r\ndiv {\r\n  z: 3;\r\n}\r\ndiv.special {\r\n  x: 11;\r\n}\r\n```\r\n\r\n- 可以将默认返回的值与guard运算符一起使用。例如只有当至少有一个以上的mixin定义匹配时，mixin（）when not（default（））{}才会匹配。mixin（）调用:\r\n\r\n```less\r\n\r\n.mixin(@value) when (ispixel(@value)) {width: @value}\r\n.mixin(@value) when not(default())    {padding: (@value / 5)}\r\n\r\ndiv-1 {\r\n  .mixin(100px);\r\n}\r\n\r\ndiv-2 {\r\n  /*...*/\r\n  .mixin(100%);\r\n}\r\n\r\n```\r\n\r\nresult:\r\n\r\n```css\r\n\r\ndiv-1 {\r\n  width: 100px;\r\n  padding: 20px;\r\n}\r\ndiv-2 {\r\n  /*...*/\r\n}\r\n```\r\n\r\n- 允许在相同的保护条件下或在具有相同名称的mixin的不同条件下进行多个default（）调用:\r\n\r\n```less\r\n\r\ndiv {\r\n  .m(@x) when (default()), not(default())    {always: @x}\r\n  .m(@x) when (default()) and not(default()) {never:  @x}\r\n\r\n  .m(1); // OK\r\n}\r\n```\r\n\r\n```less\r\n\r\ndiv {\r\n  .m(@x) when (default())    {}\r\n  .m(@x) when not(default()) {}\r\n\r\n  .m(1); // Error\r\n}\r\n```\r\n\r\nIn above example it is impossible to determine what value each default() call should return since they recursively depend on each other.\r\n\r\nAdvanced multiple default() usage:\r\n\r\n```less\r\n.x {\r\n  .m(red)                                    {case-1: darkred}\r\n  .m(blue)                                   {case-2: darkblue}\r\n  .m(@x) when (iscolor(@x)) and (default())  {default-color: @x}\r\n  .m('foo')                                  {case-1: I am 'foo'}\r\n  .m('bar')                                  {case-2: I am 'bar'}\r\n  .m(@x) when (isstring(@x)) and (default()) {default-string: and I am the default}\r\n\r\n  &-blue  {.m(blue)}\r\n  &-green {.m(green)}\r\n  &-foo   {.m('foo')}\r\n  &-baz   {.m('baz')}\r\n}\r\n```\r\n\r\nResult:\r\n\r\n```css\r\n\r\n.x-blue {\r\n  case-2: #00008b;\r\n}\r\n.x-green {\r\n  default-color: #008000;\r\n}\r\n.x-foo {\r\n  case-1: I am 'foo';\r\n}\r\n.x-baz {\r\n  default-string: and I am the default;\r\n}\r\n```\r\n\r\n- 默认函数仅在表达式中作为较少的内置函数提供。如果在mixin保护条件之外使用，则将其解释为常规CSS值：\r\n\r\nExample:\r\n\r\n```less\r\n\r\ndiv {\r\n  foo: default();\r\n  bar: default(42);\r\n}\r\n```\r\n\r\nResult:\r\n\r\n```css\r\n\r\ndiv {\r\n  foo: default();\r\n  bar: default(42);\r\n}\r\n```\r\n\r\n## unit\r\n\r\n- 删除或更改标注的\r\n\r\n- Example: `unit(5, px)`\r\n\r\n- Output: `5px`\r\n\r\n- Example: `unit(5em)`\r\n\r\n- Output: `5`\r\n\r\n## get-unit\r\n\r\n- 返回带有单位的数字的单位\r\n\r\n- Example: `get-unit(5px)`\r\n\r\n- Output: `px`\r\n\r\n- Example: `get-unit(5)`\r\n\r\n- Output: `//nothing`\r\n\r\n## svg-gradient\r\n\r\n```less\r\n\r\ndiv {\r\n  @list: red, green 30%, blue;\r\n  background-image: svg-gradient(to right, @list);\r\n}\r\nequivalent - color stops in arguments:\r\n\r\ndiv {\r\n  background-image: svg-gradient(to right, red, green 30%, blue);\r\n}\r\nboth result in:\r\n\r\ndiv {\r\n  background-image: url('data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20version%3D%221.1%22%20width%3D%22100%25%22%20height%3D%22100%25%22%20viewBox%3D%220%200%201%201%22%20preserveAspectRatio%3D%22none%22%3E%3ClinearGradient%20id%3D%22gradient%22%20gradients%3D%22userSpaceOnUse%22%20x1%3D%220%25%22%20y1%3D%220%25%22%20x2%3D%22100%25%22%20y2%3D%220%25%22%3E%3Cstop%20offset%3D%220%25%22%20stop-color%3D%22%23ff0000%22%2F%3E%3Cstop%20offset%3D%2230%25%22%20stop-color%3D%22%23008000%22%2F%3E%3Cstop%20offset%3D%22100%25%22%20stop-color%3D%22%230000ff%22%2F%3E%3C%2FlinearGradient%3E%3Crect%20x%3D%220%22%20y%3D%220%22%20width%3D%221%22%20height%3D%221%22%20fill%3D%22url(%23gradient)%22%20%2F%3E%3C%2Fsvg%3E');\r\n}\r\n```\r\n\r\n注意：在2.2.0之前的版本中，结果是base64编码的。\r\n生成的背景图像左侧为红色，宽度的30%为绿色，最后为蓝色。Base64编码部分包含以下svg渐变：\r\n\r\n```xml\r\n\r\n<?xml version=\"1.0\" ?>\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"100%\" height=\"100%\" viewBox=\"0 0 1 1\" preserveAspectRatio=\"none\">\r\n    <linearGradient id=\"gradient\" gradients=\"userSpaceOnUse\" x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\">\r\n        <stop offset=\"0%\" stop-color=\"#ff0000\"/>\r\n        <stop offset=\"30%\" stop-color=\"#008000\"/>\r\n        <stop offset=\"100%\" stop-color=\"#0000ff\"/>\r\n    </linearGradient>\r\n    <rect x=\"0\" y=\"0\" width=\"1\" height=\"1\" fill=\"url(#gradient)\" />\r\n</svg>\r\n```\r\n","children":[]},{"name":"TypeFunction.md","path":"../guanruihua.github.io/CSS/预编译语言/less/function","data":"# Type Function\r\n\r\n## isnumber\r\n\r\n```less\r\nisnumber(#ff0);     // false\r\nisnumber(blue);     // false\r\nisnumber(\"string\"); // false\r\nisnumber(1234);     // true\r\nisnumber(56px);     // true\r\nisnumber(7.8%);     // true\r\nisnumber(keyword);  // false\r\nisnumber(url(...)); // false\r\n```\r\n\r\n## isstring\r\n\r\n```less\r\n\r\nisstring(#ff0);     // false\r\nisstring(blue);     // false\r\nisstring(\"string\"); // true\r\nisstring(1234);     // false\r\nisstring(56px);     // false\r\nisstring(7.8%);     // false\r\nisstring(keyword);  // false\r\nisstring(url(...)); // false\r\n```\r\n\r\n## iscolor\r\n\r\n```less\r\niscolor(#ff0);     // true\r\niscolor(blue);     // true\r\niscolor(\"string\"); // false\r\niscolor(1234);     // false\r\niscolor(56px);     // false\r\niscolor(7.8%);     // false\r\niscolor(keyword);  // false\r\niscolor(url(...)); // false\r\n```\r\n\r\n## iskeyword\r\n\r\n- 关键字\r\n\r\n```less\r\n\r\niskeyword(#ff0);     // false\r\niskeyword(blue);     // false\r\niskeyword(\"string\"); // false\r\niskeyword(1234);     // false\r\niskeyword(56px);     // false\r\niskeyword(7.8%);     // false\r\niskeyword(keyword);  // true\r\niskeyword(url(...)); // false\r\n```\r\n\r\n## isurl\r\n\r\n```less\r\n\r\nisurl(#ff0);     // false\r\nisurl(blue);     // false\r\nisurl(\"string\"); // false\r\nisurl(1234);     // false\r\nisurl(56px);     // false\r\nisurl(7.8%);     // false\r\nisurl(keyword);  // false\r\nisurl(url(...)); // true\r\n```\r\n\r\n## ispixel\r\n\r\n- px\r\n\r\n```less\r\nispixel(#ff0);     // false\r\nispixel(blue);     // false\r\nispixel(\"string\"); // false\r\nispixel(1234);     // false\r\nispixel(56px);     // true\r\nispixel(7.8%);     // false\r\nispixel(keyword);  // false\r\nispixel(url(...)); // false\r\n```\r\n\r\n## isem\r\n\r\n- *em\r\n\r\n```less\r\n\r\nisem(#ff0);     // false\r\nisem(blue);     // false\r\nisem(\"string\"); // false\r\nisem(1234);     // false\r\nisem(56px);     // false\r\nisem(7.8em);    // true\r\nisem(keyword);  // false\r\nisem(url(...)); // false\r\n```\r\n\r\n## ispercentage\r\n\r\n```less\r\nispercentage(#ff0);     // false\r\nispercentage(blue);     // false\r\nispercentage(\"string\"); // false\r\nispercentage(1234);     // false\r\nispercentage(56px);     // false\r\nispercentage(7.8%);     // true\r\nispercentage(keyword);  // false\r\nispercentage(url(...)); // false\r\n```\r\n\r\n## isunit\r\n\r\n```less\r\n\r\nisunit(11px, px);  // true\r\nisunit(2.2%, px);  // false\r\nisunit(33px, rem); // false\r\nisunit(4rem, rem); // true\r\nisunit(56px, \"%\"); // false\r\nisunit(7.8%, '%'); // true\r\nisunit(1234, em);  // false\r\nisunit(#ff0, pt);  // false\r\nisunit(\"mm\", mm);  // false\r\n```\r\n\r\n## isruleset\r\n\r\n```less\r\n\r\n@rules: {\r\n    color: red;\r\n}\r\n\r\nisruleset(@rules);   // true\r\nisruleset(#ff0);     // false\r\nisruleset(blue);     // false\r\nisruleset(\"string\"); // false\r\nisruleset(1234);     // false\r\nisruleset(56px);     // false\r\nisruleset(7.8%);     // false\r\nisruleset(keyword);  // false\r\nisruleset(url(...)); // false\r\n```\r\n\r\n## isdefined\r\n\r\n```less\r\n@foo: 1;\r\nisdefined(@foo);     // true\r\nisdefined(@bar);     // false\r\n```\r\n","children":[]}]},{"name":"less.md","path":"../guanruihua.github.io/CSS/预编译语言/less","data":"# less\n\n## 变量（Variables）\n\n### 值变量\n\n```less\n@width: 10px;\n@height: @width + 10px;\n\n#header {\n  width: @width;\n  height: @height;\n}\n```\n\n编译为：\n\n```css\n#header {\n  width: 10px;\n  height: 20px;\n}\n```\n\n### 选择器变量\n\n- 让选择器变成动态\n\n```less\n/* Less */\n@mySelector: #wrap;\n@Wrap: wrap;\n\n@{mySelector}{ //变量名 必须使用大括号包裹\n  color: #999;\n  width: 50%;\n}\n.@{Wrap}{\n  color:#ccc;\n}\n#@{Wrap}{\n  color:#666;\n}\n\n/* 生成的 CSS */\n#wrap{\n  color: #999;\n  width: 50%;\n}\n.wrap{\n  color:#ccc;\n}\n#wrap{\n  color:#666;\n}\n\n```\n\n### 属性变量\n\n```less\n/* Less */\n@borderStyle: border-style;\n@Soild:solid;\n#wrap{\n  @{borderStyle}: @Soild;//变量名 必须使用大括号包裹\n}\n\n/* 生成的 CSS */\n#wrap{\n  border-style:solid;\n}\n\n```\n\n### url变量\n\n```less\n/* Less */\n@images: \"../img\";//需要加引号\nbody {\n  background: url(\"@{images}/dog.png\");//变量名 必须使用大括号包裹\n}\n\n/* 生成的 CSS */\nbody {\n  background: url(\"../img/dog.png\");\n}\n\n```\n\n### 声明变量\n\n> 结构: `@name:{属性: 值};`\n> 使用: `@name();`\n\n```less\n@background: {background:red;};\n#main{\n    @background();\n}\n@Rules:{\n    width: 200px;\n    height: 200px;\n    border: solid 1px red;\n};\n#con{\n  @Rules();\n}\n\n/* 生成的 CSS */\n#main{\n  background:red;\n}\n#con{\n  width: 200px;\n  height: 200px;\n  border: solid 1px red;\n}\n```\n\n### 变量运算\n\n> - 加减:以第一个数据单位为基准\n> - 乘除: 注意单位统一\n\n```less\n/* Less */\n@width:300px;\n@color:#222;\n#wrap{\n  width:@width-20;\n  height:@width-20*5;\n  margin:(@width-20)*5;\n  color:@color*2;\n  background-color:@color + #111;\n}\n\n/* 生成的 CSS */\n#wrap{\n  width:280px;\n  height:200px;\n  margin:1400px;\n  color:#444;\n  background-color:#333;\n}\n\n```\n\n### 变量作用域\n\n> 就近原则\n\n```less\n/* Less */\n@var: @a;\n@a: 100%;\n#wrap {\n  width: @var;\n  @a: 9%;\n}\n\n/* 生成的 CSS */\n#wrap {\n  width: 9%;\n}\n```\n\n### 用变量去定义变量\n\n```less\n/* Less */\n@fnord:  \"I am fnord.\";\n@var:    \"fnord\";\n#wrap::after{\n  content: @@var; //将@var替换为其值 content:@fnord;\n}\n/* 生成的 CSS */\n#wrap::after{\n  content: \"I am fnord.\";\n}\n\n```\n\n## 混合（Mixins）\n\n> 混合（Mixin）是一种将一组属性从一个规则集包含（或混入）到另一个规则集的方法。假设我们定义了一个类（class）如下：\n\n```less\n.bordered {\n  border-top: dotted 1px black;\n  border-bottom: solid 2px black;\n}\n```\n\n> 如果我们希望在其它规则集中使用这些属性呢？没问题，我们只需像下面这样输入所需属性的类（class）名称即可，如下所示：\n\n```css\n#menu a {\n  color: #111;\n  .bordered();\n}\n\n.post a {\n  color: red;\n  .bordered();\n}\n```\n\n> .bordered 类所包含的属性就将同时出现在 #menu a 和 .post a 中了。（也可以使用 #ids 作为 mixin 使用。）\n\n## 嵌套（Nesting）\n\n> Less 提供了使用嵌套（nesting）代替层叠或与层叠结合使用的能力。假设我们有以下 CSS 代码：\n\n```css\n#header {\n  color: black;\n}\n#header .navigation {\n  font-size: 12px;\n}\n#header .logo {\n  width: 300px;\n}\n```\n\n用 Less 语言我们可以这样书写代码：\n\n```less\n#header {\n  color: black;\n  .navigation {\n    font-size: 12px;\n  }\n  .logo {\n    width: 300px;\n  }\n}\n```\n\n### & 用法\n\n> `&`: 表示当前选择器的父级\n\n```less\n.clearfix {\n  display: block;\n  zoom: 1;\n\n  &:after { //(& 表示当前选择器的父级）\n    content: \" \";\n    display: block;\n    font-size: 0;\n    height: 0;\n    clear: both;\n    visibility: hidden;\n  }\n}\n```\n\n### @规则嵌套和冒泡 ( 媒体查询 )\n\n> @ 规则（例如 @media 或 @supports）可以与选择器以相同的方式进行嵌套。@ 规则会被放在前面，同一规则集中的其它元素的相对顺序保持不变。这叫做冒泡（bubbling）。\n\n```less\n.component {\n  width: 300px;\n  @media (min-width: 768px) {\n    width: 600px;\n    @media  (min-resolution: 192dpi) {\n      background-image: url(/img/retina2x.png);\n    }\n  }\n  @media (min-width: 1280px) {\n    width: 800px;\n  }\n}\n```\n\n编译为：\n\n```css\n.component {\n  width: 300px;\n}\n@media (min-width: 768px) {\n  .component {\n    width: 600px;\n  }\n}\n@media (min-width: 768px) and (min-resolution: 192dpi) {\n  .component {\n    background-image: url(/img/retina2x.png);\n  }\n}\n@media (min-width: 1280px) {\n  .component {\n    width: 800px;\n  }\n}\n```\n\n## 运算（Operations）\n\n### 算术运算符 +、-、*、/\n\n可以对任何数字、颜色或变量进行运算。如果可能的话，算术运算符在加、减或比较之前会进行单位换算。==计算的结果以最左侧操作数的单位类型为准==。如果单位换算无效或失去意义，则忽略单位。无效的单位换算例如：px 到 cm 或 rad 到 % 的转换。\n\n```less\n// 所有操作数被转换成相同的单位\n@conversion-1: 5cm + 10mm; // 结果是 6cm\n@conversion-2: 2 - 3cm - 5mm; // 结果是 -1.5cm\n\n// conversion is impossible\n@incompatible-units: 2 + 5px - 3cm; // 结果是 4px\n\n// example with variables\n@base: 5%;\n@filler: @base * 2; // 结果是 10%\n@other: @base + @filler; // 结果是 15%\n```\n\n### 乘法和除法不作转换\n\n因为这两种运算在大多数情况下都没有意义，一个长度乘以一个长度就得到一个区域，而 CSS 是不支持指定区域的。Less 将按数字的原样进行操作，并将为计算结果指定明确的单位类型。\n\n```less\n@base: 2cm * 3mm; // 结果是 6cm\n```\n\n你还可以对颜色进行算术运算：\n\n```less\n@color: #224488 / 2; //结果是 #112244\nbackground-color: #112244 + #111; // 结果是 #223355\n```\n\n### calc() 特例\n\n> 为了与 CSS 保持兼容，calc() 并不对数学表达式进行计算，但是在嵌套函数中会计算变量和数学公式的值。\n\n```less\n@var: 50vh/2;\nwidth: calc(50% + (@var - 20px));  // 结果是 calc(50% + (25vh - 20px))\n```\n\n## 转义（Escaping）\n\n> ==转义（Escaping）允许你使用任意字符串作为属性或变量值==。任何 `~\"anything\"` 或 `~'anything'` 形式的内容都将按原样输出，除非 interpolation。\n\n```less\n@min768: ~\"(min-width: 768px)\";\n.element {\n  @media @min768 {\n    font-size: 1.2rem;\n  }\n}\n```\n\n编译为：\n\n```css\n@media (min-width: 768px) {\n  .element {\n    font-size: 1.2rem;\n  }\n}\n```\n\n> ==注意，从 Less 3.5 开始，可以简写为：==\n\n```less\n@min768: (min-width: 768px);\n.element {\n  @media @min768 {\n    font-size: 1.2rem;\n  }\n}\n```\n\n## 函数（Functions）\n\n- Less 内置了多种函数用于转换颜色、处理字符串、算术运算等\n\n函数的用法非常简单。下面这个例子将介绍如何利用 percentage 函数将 0.5 转换为 50%，将颜色饱和度增加 5%，以及颜色亮度降低 25% 并且色相值增加 8 等用法：\n\n```css\n@base: #f04615;\n@width: 0.5;\n\n.class {\n  width: percentage(@width); // returns `50%`\n  color: saturate(@base, 5%);\n  background-color: spin(lighten(@base, 25%), 8);\n}\n```\n\n参见：[函数手册](https://less.bootcss.com/functions/)  \n\n### 判断类型\n\n|函数名|描述|使用|\n|:----|:----|:----|\n|isnumber| 判断类型|`isnumber(1234) //true`|\n|iscolor| 是否为颜色|`iscolor(123) //false`|\n|isurl|是否为url|`isurl(123)//false`|\n\n### 颜色操作\n\n|函数名|描述|使用|\n|:----|:----|:----|\n|saturate| 增加一定数值的颜色饱和度|\n|lighten| 增加一定数值的颜色亮度|\n|darken| 降低一定数值的颜色亮度|\n|fade| 给颜色设定一定数值的透明度|\n|mix| 根据比例混合两种颜色|\n\n### 数学相关\n\n|函数名|描述|使用|\n|:----|:----|:----|\n| ceil| 向上取整|\n| floor| 向下取整|\n| percentage| 将浮点数转换为百分比字符串|\n| round| 四舍五入|\n| sqrt| 计算一个数的平方根|\n| abs| 计算数字的绝对值，原样保持单位|\n| pow| 计算一个数的乘方|\n\n## 命名空间和访问符\n\n(不要和 CSS @namespace 或 namespace selectors 混淆了)。\n\n有时，出于组织结构或仅仅是为了提供一些封装的目的，你希望对混合（mixins）进行分组。你可以用 Less 更直观地实现这一需求。假设你希望将一些混合（mixins）和变量置于 #bundle 之下，为了以后方便重用或分发：\n\n```less\n#bundle() {\n  .button {\n    display: block;\n    border: 1px solid black;\n    background-color: grey;\n    &:hover {\n      background-color: white;\n    }\n  }\n  .tab { ... }\n  .citation { ... }\n}\n```\n\n现在，如果我们希望把 .button 类混合到 #header a 中，我们可以这样做：\n\n```less\n#header a {\n  color: orange;\n  #bundle.button();  // 还可以书写为 #bundle > .button 形式\n}\n```\n\n注意：如果不希望它们出现在输出的 CSS 中，例如 #bundle .tab，请将 () 附加到命名空间（例如 #bundle()）后面。\n\n## 映射（Maps）\n\n从 Less 3.5 版本开始，你还可以将混合（mixins）和规则集（rulesets）作为一组值的映射（map）使用。\n\n```less\n#colors() {\n  primary: blue;\n  secondary: green;\n}\n\n.button {\n  color: #colors[primary];\n  border: 1px solid #colors[secondary];\n}\n```\n\n输出符合预期：\n\n```css\n.button {\n  color: blue;\n  border: 1px solid green;\n}\n```\n\n## 作用域（Scope）\n\n> Less 中的作用域与 CSS 中的作用域非常类似。首先在本地查找变量和混合（mixins），如果找不到，则从“父”级作用域继承。\n\n```less\n@var: red;\n\n#page {\n  @var: white;\n  #header {\n    color: @var; // white\n  }\n}\n```\n\n> 与 CSS 自定义属性一样，混合（mixin）和变量的定义不必在引用之前事先定义。因此，下面的 Less 代码示例和上面的代码示例是相同的：\n\n```less\n@var: red;\n\n#page {\n  #header {\n    color: @var; // white\n  }\n  @var: white;\n}\n```\n\n参见：懒加载\n\n## 注释（Comments）\n\n块注释和行注释都可以使用：\n\n```less\n/* 一个块注释\n * style comment! */\n@var: red;\n\n// 这一行被注释掉了！\n@var: white;\n```\n\n## 导入（Importing）\n\n> “导入”的工作方式和你预期的一样。你可以导入一个 .less 文件，此文件中的所有变量就可以全部使用了。如果导入的文件是 .less 扩展名，则可以将扩展名省略掉：\n\n```less\n@import \"library\"; // library.less\n@import \"typo.css\";\n```\n\n## 混合方法\n\n```less\n/* Less */\n.generate-columns(4);\n\n.generate-columns(@n, @i: 1) when (@i =< @n) {\n  .column-@{i} {\n    width: (@i * 100% / @n);\n  }\n  .generate-columns(@n, (@i + 1));\n}\n/* 生成后的 CSS */\n.column-1 {\n  width: 25%;\n}\n.column-2 {\n  width: 50%;\n}\n.column-3 {\n  width: 75%;\n}\n.column-4 {\n  width: 100%;\n}\n\n```\n\n### 无参方法\n\n> 直接名称即可(建议还是写上括号, 避免混淆)\n\n```less\n/* Less */\n.card { // 等价于 .card()\n    background: #f6f6f6;\n    -webkit-box-shadow: 0 1px 2px rgba(151, 151, 151, .58);\n    box-shadow: 0 1px 2px rgba(151, 151, 151, .58);\n}\n#wrap{\n  .card;//等价于.card();\n}\n/* 生成的 CSS */\n#wrap{\n  background: #f6f6f6;\n  -webkit-box-shadow: 0 1px 2px rgba(151, 151, 151, .58);\n  box-shadow: 0 1px 2px rgba(151, 151, 151, .58);\n}\n```\n\n### 默认参数方法\n\n> `@arguments` 类似 js 中的 `arguments` 指代全部参数\n\n```less\n/* Less */\n.border(@a:10px, @b:50px, @c:30px, @color:#000){\n  border:solid 1px @color;\n  box-shadow: @arguments;//指代的是 全部参数\n}\n#main{\n  .border(0px,5px,30px,red);//必须带着单位\n}\n#wrap{\n  .border(0px);\n}\n#content{\n  .border;//等价于 .border()\n}\n\n/* 生成的 CSS */\n#main{\n  border:solid 1px red;\n  box-shadow:0px,5px,30px,red;\n}\n#wrap{\n  border:solid 1px #000;\n  box-shadow: 0px 50px 30px #000;\n}\n#content{\n  border:solid 1px #000;\n  box-shadow: 10px 50px 30px #000;\n}\n```\n\n### 方法匹配模式\n\n- 类似java多态\n\n```less\n/* Less */\n.triangle(top,@width:20px,@color:#000){\n    border-color:transparent  transparent @color transparent ;\n}\n.triangle(right,@width:20px,@color:#000){\n    border-color:transparent @color transparent  transparent ;\n}\n.triangle(bottom,@width:20px,@color:#000){\n    border-color:@color transparent  transparent  transparent ;\n}\n.triangle(left,@width:20px,@color:#000){\n    border-color:transparent  transparent  transparent @color;\n}\n\n.triangle(@_,@width:20px,@color:#000){\n    border-style: solid;\n    border-width: @width;\n}\n\n#main{\n  .triangle(left, 50px, #999)\n}\n\n/* 生成的 CSS */\n#main{\n  border-color:transparent  transparent  transparent #999;\n  border-style: solid;\n  border-width: 50px;\n}\n```\n\n### 方法命名空间\n\n```less\n/* Less */\n#card(){\n    background: #723232;\n    .d(@w:300px){\n        width: @w;\n        \n        #a(@h:300px){\n            height: @h;//可以使用上一层传进来的方法\n        }\n    }\n}\n#wrap{\n    #card > .d > #a(100px); // 父元素不能加 括号\n}\n#main{\n    #card .d();\n}\n#con{\n    //不得单独使用命名空间的方法\n    //.d() 如果前面没有引入命名空间 #card ，将会报错\n    \n    #card; // 等价于 #card();\n    .d(20px); //必须先引入 #card\n}\n/* 生成的 CSS */\n#wrap{\n  height:100px;\n}\n#main{\n  width:300px;\n}\n#con{\n  width:20px;\n}\n```\n\n### 方法的条件筛选\n\n```less\n/* Less */\n#card{\n    \n    // and 运算符 ，相当于 与运算 &&，必须条件全部符合才会执行\n    .border(@width,@color,@style) when (@width>100px) and(@color=#999){\n        border:@style @color @width;\n    }\n\n    // not 运算符，相当于 非运算 !，条件为 不符合才会执行\n    .background(@color) when not (@color>=#222){\n        background:@color;\n    }\n\n    // , 逗号分隔符：相当于 或运算 ||，只要有一个符合条件就会执行\n    .font(@size:20px) when (@size>50px) , (@size<100px){\n        font-size: @size;\n    }\n}\n#main{\n    #card>.border(200px,#999,solid);\n    #card .background(#111);\n    #card > .font(40px);\n}\n/* 生成后的 CSS */\n#main{\n  border:solid #999 200px;\n  background:#111;\n  font-size:40px;\n}\n\n```\n\n## 继承\n\n### extend\n\n```less\n/* Less */\n.animation{\n    transition: all .3s ease-out;\n    .hide{\n      transform:scale(0);\n    }\n}\n#main{\n    &:extend(.animation);\n}\n#con{\n    &:extend(.animation .hide);\n}\n\n/* 生成后的 CSS */\n.animation,#main{\n  transition: all .3s ease-out;\n}\n.animation .hide , #con{\n    transform:scale(0);\n}\n\n```\n\n### all\n\n```less\n/* Less */\n#main{\n  width: 200px;\n}\n#main {\n  &:after {\n    content:\"Less is good!\";\n  }\n}\n#wrap:extend(#main all) {}\n\n/* 生成的 CSS */\n#main,#wrap{\n  width: 200px;\n}\n#main:after, #wrap:after {\n    content: \"Less is good!\";\n}\n\n```\n\n## 导入\n\n### 导入less文件\n\n```less\nimport \"main\"; \n//等价于\nimport \"main.less\";\n#main{\n  font-size:15px;\n}\n\n// 可以随意放置\n@import \"style\";\n```\n\n### reference\n\n> 不会编译, 值会引入\n\n```less\n/* Less */\n@import (reference) \"bootstrap.less\"; \n\n#wrap:extend(.navbar all){}\n```\n\n### once\n\n> `@import`语句的默认行为。这表明相同的文件只会被导入一次，而随后的导入文件的重复代码都不会解析\n\n```less\n@import (once) \"foo.less\";\n@import (once) \"foo.less\"; // this statement will be ignored\n```\n\n### multiple\n\n> 使用`@import (multiple)`允许导入多个同名文件\n\n```less\n/*Less*/\n\n// file: foo.less\n.a {\n  color: green;\n}\n// file: main.less\n@import (multiple) \"foo.less\";\n@import (multiple) \"foo.less\";\n\n/*生成后的 CSS*/\n.a {\n  color: green;\n}\n.a {\n  color: green;\n}\n```\n\n## 其他\n\n### 注释\n\n> `/**/` CSS原生注释，会被编译在 CSS 文件中。\n> `/   /` Less提供的一种注释，不会被编译在 CSS 文件中。\n\n```less\n\n// 避免编译\n/*Less*/\n# main{\n  width:~'calc(300px-30px)';\n}\n\n/*生成后的 CSS*/\n# main{\n  width:calc(300px-30px);\n}\n```\n\n结构： `~' 值 '`\n\n### 变量拼串\n\n在平时工作中，这种需求 太常见了。 在下面例子中， 实现了不同的 transtion-delay、animation、@keyframes\n\n```less\n.judge(@i) when(@i=1){\n  @size:15px;\n}\n.judge(@i) when(@i>1){\n  @size:16px;\n}\n.loopAnimation(@i) when (@i<16) {\n  \n  .circle:nth-child(@{i}){\n      .judeg(@i);\n      border-radius:@size @size 0 0;\n      animation: ~\"circle-@{i}\" @duration infinite @ease;\n      transition-delay:~\"@{i}ms\";\n  }\n  @keyframes ~\"circle-@{i}\" {\n      // do something...\n  }\n  .loopAnimation(@i + 1);\n}\n```\n\n结构： `~\"字符@{变量}字符\"`\n\n### 使用js\n\n> less 是使用js编写\n\n```less\n/* Less */\n@content:`\"aaa\".toUpperCase()`;\n#randomColor{\n  @randomColor: ~\"rgb(`Math.round(Math.random() * 256)`,`Math.round(Math.random() * 256)`,`Math.round(Math.random() * 256)`)\";\n}\n#wrap{\n  width: ~\"`Math.round(Math.random() * 100)`px\";\n  &:after{\n      content:@content;\n  }\n  height: ~\"`window.innerHeight`px\";\n  alert:~\"`alert(1)`\";\n  #randomColor();\n  background-color: @randomColor;\n}\n/* 生成后的 CSS */\n\n// 弹出 1\n#wrap{\n  width: 随机值（0~100）px;\n  height: 743px;//由电脑而异\n  background: 随机颜色;\n}\n#wrap::after{\n  content:\"AAA\";\n}\n```\n","children":[]},{"name":"Merge.md","path":"../guanruihua.github.io/CSS/预编译语言/less","data":"# Merge\r\n\r\n## Comma\r\n\r\n```less\r\n.mixin() {\r\n  box-shadow+: inset 0 0 10px #555;\r\n}\r\n.myclass {\r\n  .mixin();\r\n  box-shadow+: 0 0 20px black;\r\n}\r\n```\r\n\r\n```css\r\n.myclass {\r\n  box-shadow: inset 0 0 10px #555, 0 0 20px black;\r\n}\r\n```\r\n\r\n## Space\r\n\r\n```less\r\n.mixin() {\r\n  transform+_: scale(2);\r\n}\r\n.myclass {\r\n  .mixin();\r\n  transform+_: rotate(15deg);\r\n}\r\n```\r\n\r\n```css\r\n.myclass {\r\n  transform: scale(2) rotate(15deg);\r\n}\r\n```\r\n","children":[]},{"name":"mixins.md","path":"../guanruihua.github.io/CSS/预编译语言/less","data":"# Mixins\r\n\r\n- 添加进已有的样式里\r\n\r\n```less\r\n.a, #b {\r\n  color: red;\r\n}\r\n.mixin-class {\r\n  .a();\r\n}\r\n.mixin-id {\r\n  #b();\r\n}\r\n```\r\n\r\n```css\r\n.a, #b {\r\n  color: red;\r\n}\r\n.mixin-class {\r\n  color: red;\r\n}\r\n.mixin-id {\r\n  color: red;\r\n}\r\n```\r\n\r\n## Mixins With Parentheses\r\n\r\n```less\r\n.my-mixin {\r\n  color: black;\r\n}\r\n// 不会添加多一个className\r\n.my-other-mixin() {\r\n  background: white;\r\n}\r\n.class {\r\n  .my-mixin();\r\n  .my-other-mixin();\r\n}\r\n```\r\n\r\n```css\r\n.my-mixin {\r\n  color: black;\r\n}\r\n.class {\r\n  color: black;\r\n  background: white;\r\n}\r\n```\r\n\r\n## Selectors in Mixins\r\n\r\n```less\r\n.my-hover-mixin() {\r\n  &:hover {\r\n    border: 1px solid red;\r\n  }\r\n}\r\nbutton {\r\n  .my-hover-mixin();\r\n}\r\n```\r\n\r\n```css\r\nbutton:hover {\r\n  border: 1px solid red;\r\n}\r\n```\r\n\r\n## Namespaces\r\n\r\n```less\r\n#outer() {\r\n  .inner {\r\n    color: red;\r\n  }\r\n}\r\n\r\n.c {\r\n  #outer.inner();\r\n}\r\n```\r\n\r\n```css\r\n.c {\r\n  color: red;\r\n}\r\n```\r\n\r\n## Guarded Namespaces\r\n\r\n- 如果名称空间具有保护，则仅当保护条件返回true时，才使用由其定义的混合。命名空间保护的计算方式与mixin上的保护完全相同，因此以下两个mixin的工作方式相同：\r\n\r\n```less\r\n#namespace when (@mode = huge) {\r\n  .mixin() { /* */ }\r\n}\r\n\r\n#namespace {\r\n  .mixin() when (@mode = huge) { /* */ }\r\n}\r\n```\r\n\r\n## The `!important` keyword\r\n\r\n```less\r\n.foo (@bg: #f5f5f5; @color: #900) {\r\n  background: @bg;\r\n  color: @color;\r\n}\r\n.unimportant {\r\n  .foo();\r\n}\r\n.important {\r\n  .foo() !important;\r\n}\r\n```\r\n\r\n```css\r\n.unimportant {\r\n  background: #f5f5f5;\r\n  color: #900;\r\n}\r\n.important {\r\n  background: #f5f5f5 !important;\r\n  color: #900 !important;\r\n}\r\n```\r\n\r\n## Parametric Mixins\r\n\r\n```less\r\n// .border-radius(@radius) { 这种没有没有默认值\r\n.border-radius(@radius: 5px) {\r\n  -webkit-border-radius: @radius;\r\n     -moz-border-radius: @radius;\r\n          border-radius: @radius;\r\n}\r\n\r\n#header {\r\n  .border-radius();\r\n}\r\n\r\n```\r\n\r\n```css\r\n#header {\r\n  -webkit-border-radius: 5px;\r\n  -moz-border-radius: 5px;\r\n  border-radius: 5px;\r\n}\r\n```\r\n\r\n## Overloading mixins\r\n\r\n```less\r\n.mixin(@color) {\r\n  color-1: @color;\r\n}\r\n.mixin(@color, @padding: 2) {\r\n  color-2: @color;\r\n  padding-2: @padding;\r\n}\r\n.mixin(@color, @padding, @margin: 2) {\r\n  color-3: @color;\r\n  padding-3: @padding;\r\n  margin: @margin @margin @margin @margin;\r\n}\r\n.some .selector div {\r\n  .mixin(#008000);\r\n}\r\n```\r\n\r\n```css\r\n.some .selector div {\r\n  color-1: #008000;\r\n  color-2: #008000;\r\n  padding-2: 2;\r\n}\r\n```\r\n\r\n## Named Parameters\r\n\r\n```less\r\n.mixin(@color: black; @margin: 10px; @padding: 20px) {\r\n  color: @color;\r\n  margin: @margin;\r\n  padding: @padding;\r\n}\r\n.class1 {\r\n  .mixin(@margin: 20px; @color: #33acfe);\r\n}\r\n.class2 {\r\n  .mixin(#efca44; @padding: 40px);\r\n}\r\n```\r\n\r\n```css\r\n.class1 {\r\n  color: #33acfe;\r\n  margin: 20px;\r\n  padding: 20px;\r\n}\r\n.class2 {\r\n  color: #efca44;\r\n  margin: 10px;\r\n  padding: 40px;\r\n}\r\n```\r\n\r\n## The `@arguments` Variable\r\n\r\n```less\r\n.box-shadow(@x: 0, @y: 0, @blur: 1px, @color: #000) {\r\n  -webkit-box-shadow: @arguments;\r\n     -moz-box-shadow: @arguments;\r\n          box-shadow: @arguments;\r\n}\r\n.big-block {\r\n  .box-shadow(2px, 5px);\r\n}\r\n```\r\n\r\n```css\r\n.big-block {\r\n  -webkit-box-shadow: 2px 5px 1px #000;\r\n     -moz-box-shadow: 2px 5px 1px #000;\r\n          box-shadow: 2px 5px 1px #000;\r\n}\r\n```\r\n\r\n## Advanced Arguments and the `@rest` Variable\r\n\r\n```less\r\n.mixin(@a, @rest...) {\r\n   // @rest is bound to arguments after @a\r\n   // @arguments is bound to all arguments\r\n}\r\n```\r\n\r\n## Pattern-matching\r\n\r\n```less\r\n.mixin(@s, @color) { ... }\r\n\r\n.class {\r\n  .mixin(@switch, #888);\r\n}\r\n```\r\n\r\n```less\r\n.mixin(dark, @color) {\r\n  color: darken(@color, 10%);\r\n}\r\n.mixin(light, @color) {\r\n  color: lighten(@color, 10%);\r\n}\r\n.mixin(@_, @color) {\r\n  display: block;\r\n}\r\n\r\n@switch: light;\r\n\r\n.class {\r\n  .mixin(@switch, #888);\r\n}\r\n```\r\n\r\n```css\r\n.class {\r\n  color: #a2a2a2;\r\n  display: block;\r\n}\r\n```\r\n\r\n## Using Mixins as Functions\r\n\r\n### Property / value accessors\r\n\r\n```less\r\n.average(@x, @y) {\r\n  @result: ((@x + @y) / 2);\r\n}\r\n\r\ndiv {\r\n  // call a mixin and look up its \"@result\" value\r\n  padding: .average(16px, 50px)[@result];\r\n}\r\n```\r\n\r\n```css\r\ndiv {\r\n  padding: 33px;\r\n}\r\n```\r\n\r\n### Overriding mixin values\r\n\r\n```less\r\n// library.less\r\n#library() {\r\n  .mixin() {\r\n    prop: foo;\r\n  }\r\n}\r\n\r\n// customize.less\r\n@import \"library\";\r\n#library() {\r\n  .mixin() {\r\n    prop: bar;\r\n  }\r\n}\r\n\r\n.box {\r\n  my-value: #library.mixin[prop];\r\n}\r\n\r\n// Outputs:\r\n\r\n.box {\r\n  my-value: bar;\r\n}\r\n```\r\n\r\n### Unnamed lookups\r\n\r\n```less\r\n.average(@x, @y) {\r\n  @result: ((@x + @y) / 2);\r\n}\r\n\r\ndiv {\r\n  // call a mixin and look up its final value\r\n  padding: .average(16px, 50px)[];\r\n}\r\n\r\n\r\n//  output :\r\n\r\ndiv {\r\n  padding: 33px;\r\n}\r\n```\r\n\r\n### Unlocking mixins & variables into caller scope\r\n\r\n```less\r\n.mixin() {\r\n  @width:  100%;\r\n  @height: 200px;\r\n}\r\n\r\n.caller {\r\n  .mixin();\r\n  width:  @width;\r\n  height: @height;\r\n}\r\n\r\n// Results :\r\n\r\n.caller {\r\n  width:  100%;\r\n  height: 200px;\r\n}\r\n```\r\n\r\n```less\r\n.unlock(@value) { // outer mixin\r\n  .doSomething() { // nested mixin\r\n    declaration: @value;\r\n  }\r\n}\r\n\r\n#namespace {\r\n  .unlock(5); // unlock doSomething mixin\r\n  .doSomething(); //nested mixin was copied here and is usable\r\n}\r\n\r\n// Results:\r\n\r\n#namespace {\r\n  declaration: 5;\r\n}\r\n```\r\n\r\n## Recursive Mixins\r\n\r\n```less\r\n.loop(@counter) when (@counter > 0) {\r\n  .loop((@counter - 1));    // next iteration\r\n  width: (10px * @counter); // code for each iteration\r\n}\r\n\r\ndiv {\r\n  .loop(5); // launch the loop\r\n}\r\n\r\n// Output:\r\n\r\ndiv {\r\n  width: 10px;\r\n  width: 20px;\r\n  width: 30px;\r\n  width: 40px;\r\n  width: 50px;\r\n}\r\n```\r\n\r\n```less\r\n.generate-columns(4);\r\n\r\n.generate-columns(@n, @i: 1) when (@i =< @n) {\r\n  .column-@{i} {\r\n    width: (@i * 100% / @n);\r\n  }\r\n  .generate-columns(@n, (@i + 1));\r\n}\r\n// Output:\r\n\r\n.column-1 {\r\n  width: 25%;\r\n}\r\n.column-2 {\r\n  width: 50%;\r\n}\r\n.column-3 {\r\n  width: 75%;\r\n}\r\n.column-4 {\r\n  width: 100%;\r\n}\r\n```\r\n\r\n## Mixin Guards\r\n\r\n```less\r\n.mixin(@a) when (lightness(@a) >= 50%) {\r\n  background-color: black;\r\n}\r\n.mixin(@a) when (lightness(@a) < 50%) {\r\n  background-color: white;\r\n}\r\n.mixin(@a) {\r\n  color: @a;\r\n}\r\n\r\n.class1 { .mixin(#ddd) }\r\n.class2 { .mixin(#555) }\r\n\r\n// output:\r\n\r\n.class1 {\r\n  background-color: black;\r\n  color: #ddd;\r\n}\r\n.class2 {\r\n  background-color: white;\r\n  color: #555;\r\n}\r\n\r\n```\r\n\r\n### Guard Comparison Operators\r\n\r\n```less\r\n.truth(@a) when (@a) { ... }\r\n.truth(@a) when (@a = true) { ... }\r\n\r\n@media: mobile;\r\n\r\n.mixin(@a) when (@media = mobile) { ... }\r\n.mixin(@a) when (@media = desktop) { ... }\r\n\r\n.max(@a; @b) when (@a > @b) { width: @a }\r\n.max(@a; @b) when (@a < @b) { width: @b }\r\n```\r\n\r\n### Guard Logical Operators\r\n\r\n```less\r\n.mixin(@a) when (isnumber(@a)) and (@a > 0) { ... }\r\n\r\n.mixin(@a) when (@a > 10), (@a < -10) { ... }\r\n\r\n.mixin(@b) when not (@b > 0) { ... }\r\n```\r\n\r\n### Type Checking Functions\r\n\r\n- iscolor\r\n- isnumber\r\n- isstring\r\n- iskeyword\r\n- isurl\r\n- ispixel\r\n- ispercentage\r\n- isem\r\n- isunit\r\n\r\n```less\r\n.mixin(@a; @b: 0) when (isnumber(@b)) { ... }\r\n.mixin(@a; @b: black) when (iscolor(@b)) { ... }\r\n```\r\n\r\n## Aliasing Mixins\r\n\r\n```less\r\n#theme.dark.navbar {\r\n  .colors(light) {\r\n    primary: purple;\r\n  }\r\n  .colors(dark) {\r\n    primary: black;\r\n    secondary: grey;\r\n  }\r\n}\r\n\r\n.navbar {\r\n  @colors: #theme.dark.navbar.colors(dark);\r\n  background: @colors[primary];\r\n  border: 1px solid @colors[secondary];\r\n}\r\n\r\n// output:\r\n\r\n.navbar {\r\n  background: black;\r\n  border: 1px solid grey;\r\n}\r\n```\r\n\r\n### Variable calls\r\n\r\n```less\r\n#library() {\r\n  .colors() {\r\n    background: green;\r\n  }\r\n}\r\n.box {\r\n  @alias: #library.colors();\r\n  @alias();\r\n}\r\n// Outputs:\r\n\r\n.box {\r\n  background: green;\r\n}\r\n```\r\n","children":[]},{"name":"variables.md","path":"../guanruihua.github.io/CSS/预编译语言/less","data":"# Variables\r\n\r\n- 变量\r\n\r\n## Overview\r\n\r\n```less\r\n// Variables\r\n@link-color:        #428bca; // sea blue\r\n@link-color-hover:  darken(@link-color, 10%);\r\n\r\n// Usage\r\na,\r\n.link {\r\n  color: @link-color;\r\n}\r\na:hover {\r\n  color: @link-color-hover;\r\n}\r\n.widget {\r\n  color: #fff;\r\n  background: @link-color;\r\n}\r\n```\r\n\r\n```css\r\na,\r\n.link {\r\n  color: #428bca;\r\n}\r\n.widget {\r\n  color: #fff;\r\n  background: #428bca;\r\n}\r\n```\r\n\r\n## Selectors\r\n\r\n```less\r\n// Variables\r\n@my-selector: banner;\r\n\r\n// Usage\r\n.@{my-selector} {\r\n  font-weight: bold;\r\n  line-height: 40px;\r\n  margin: 0 auto;\r\n}\r\n```\r\n\r\n```css\r\n\r\n.banner {\r\n  font-weight: bold;\r\n  line-height: 40px;\r\n  margin: 0 auto;\r\n}\r\n```\r\n\r\n## URLS\r\n\r\n```less\r\n// Variables\r\n@images: \"../img\";\r\n\r\n// Usage\r\nbody {\r\n  color: #444;\r\n  background: url(\"@{images}/white-sand.png\");\r\n}\r\n```\r\n\r\n## Import Statements\r\n\r\n```less\r\n// Variables\r\n@themes: \"../../src/themes\";\r\n\r\n// Usage\r\n@import \"@{themes}/tidal-wave.less\";\r\n```\r\n\r\n## Properties\r\n\r\n```less\r\n\r\n@property: color;\r\n\r\n.widget {\r\n  @{property}: #0ee;\r\n  background-@{property}: #999;\r\n}\r\n```\r\n\r\n```css\r\n.widget {\r\n  color: #0ee;\r\n  background-color: #999;\r\n}\r\n```\r\n\r\n## Variable Variables\r\n\r\n```less\r\n@primary:  green;\r\n@secondary: blue;\r\n\r\n.section {\r\n  @color: primary;\r\n\r\n  .element {\r\n    color: @@color;\r\n  }\r\n}\r\n```\r\n\r\n```css\r\n\r\n.section .element {\r\n  color: green;\r\n}\r\n```\r\n\r\n## Lazy Evaluation\r\n\r\n```less\r\n.lazy-eval {\r\n  width: @var;\r\n  @a: 9%;\r\n}\r\n\r\n@var: @a;\r\n@a: 100%;\r\n```\r\n\r\n```css\r\n.lazy-eval {\r\n  width: 9%;\r\n}\r\n```\r\n\r\n```less\r\n@var: 0;\r\n.class {\r\n  @var: 1;\r\n  .brass {\r\n    @var: 2;\r\n    three: @var;\r\n    @var: 3;\r\n  }\r\n  one: @var;\r\n}\r\n```\r\n\r\n```css\r\n.class {\r\n  one: 1;\r\n}\r\n.class .brass {\r\n  three: 3;\r\n}\r\n```\r\n\r\n## Properties as Variables\r\n\r\n```less\r\n.widget {\r\n  color: #efefef;\r\n  background-color: $color;\r\n}\r\n```\r\n\r\n```css\r\n.widget {\r\n  color: #efefef;\r\n  background-color: #efefef;\r\n}\r\n```\r\n\r\n```less\r\n.block {\r\n  color: red; \r\n  .inner {\r\n    background-color: $color; \r\n  }\r\n  color: blue;  \r\n} \r\n```\r\n\r\n```css\r\n.block {\r\n  color: red; \r\n  color: blue;  \r\n} \r\n.block .inner {\r\n  background-color: blue; \r\n}\r\n```\r\n\r\n## Default Variables\r\n\r\n```less\r\n// library\r\n@base-color: green;\r\n@dark-color: darken(@base-color, 10%);\r\n\r\n// use of library\r\n@import \"library.less\";\r\n@base-color: red; // 在当前文件, 可以覆盖掉library的\r\n```\r\n\r\n## Parent Selectors\r\n\r\n### 父选择器`&`\r\n\r\n```less\r\na {\r\n  color: blue;\r\n  &:hover {\r\n    color: green;\r\n  }\r\n}\r\n```\r\n\r\n```css\r\na {\r\n  color: blue;\r\n}\r\n\r\na:hover {\r\n  color: green;\r\n}\r\n```\r\n\r\n```less\r\n.button {\r\n  &-ok {\r\n    background-image: url(\"ok.png\");\r\n  }\r\n  &-cancel {\r\n    background-image: url(\"cancel.png\");\r\n  }\r\n\r\n  &-custom {\r\n    background-image: url(\"custom.png\");\r\n  }\r\n}\r\n```\r\n\r\n```css\r\n.button-ok {\r\n  background-image: url(\"ok.png\");\r\n}\r\n.button-cancel {\r\n  background-image: url(\"cancel.png\");\r\n}\r\n.button-custom {\r\n  background-image: url(\"custom.png\");\r\n}\r\n```\r\n\r\n### Multiple `&`\r\n\r\n```less\r\n.link {\r\n  & + & {\r\n    color: red;\r\n  }\r\n\r\n  & & {\r\n    color: green;\r\n  }\r\n\r\n  && {\r\n    color: blue;\r\n  }\r\n\r\n  &, &ish {\r\n    color: cyan;\r\n  }\r\n}\r\n```\r\n\r\n```css\r\n.link + .link {\r\n  color: red;\r\n}\r\n.link .link {\r\n  color: green;\r\n}\r\n.link.link {\r\n  color: blue;\r\n}\r\n.link, .linkish {\r\n  color: cyan;\r\n}\r\n```\r\n\r\n### Combinatorial Explosion\r\n\r\n```less\r\np, a, ul, li {\r\n  border-top: 2px dotted #366;\r\n  & + & {\r\n    border-top: 0;\r\n  }\r\n}\r\n```\r\n\r\n```css\r\np,\r\na,\r\nul,\r\nli {\r\n  border-top: 2px dotted #366;\r\n}\r\np + p,\r\np + a,\r\np + ul,\r\np + li,\r\na + p,\r\na + a,\r\na + ul,\r\na + li,\r\nul + p,\r\nul + a,\r\nul + ul,\r\nul + li,\r\nli + p,\r\nli + a,\r\nli + ul,\r\nli + li {\r\n  border-top: 0;\r\n}\r\n```\r\n","children":[]}]},{"name":"sass.md","path":"../guanruihua.github.io/CSS/预编译语言","data":"# Sass\n\n> Syntactically Awesome StyleSheets\n\nSass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。\n\n## 1. 特色功能 (Features)\n\n    完全兼容 CSS3\n    在 CSS 基础上增加变量、嵌套 (nesting)、混合 (mixins) 等功能\n    通过函数进行颜色值与属性值的运算\n    提供控制指令 (control directives)等高级功能\n    自定义输出格式\n\n## 2. 语法格式 (Syntax)\n\n    Sass 有两种语法格式。首先是 SCSS (Sassy CSS) —— 也是本文示例所使用的格式 —— 这种格式仅在 CSS3 语法的基础上进行拓展，所有 CSS3 语法在 SCSS 中都是通用的，同时加入 Sass 的特色功能。此外，SCSS 也支持大多数 CSS hacks 写法以及浏览器前缀写法 (vendor-specific syntax)，以及早期的 IE 滤镜写法。这种格式以 .scss 作为拓展名。\n    \n    另一种也是最早的 Sass 语法格式，被称为缩进格式 (Indented Sass) \n    通常简称 \"Sass\"，是一种简化格式。它使用 “缩进” 代替 “花括号” 表示属性属于某个选择器，\n    用 “换行” 代替 “分号” 分隔属性，很多人认为这样做比 SCSS 更容易阅读，书写也更快速。缩进格式也可以使用 Sass 的全部功能，\n    只是与 SCSS 相比个别地方采取了不同的表达方式，\n    具体请查看 the indented syntax reference。这种格式以 .sass 作为拓展名。\n\n### 2.1导入和转换成另外一种格式\n\n    任何一种格式可以直接 导入 (@import) 到另一种格式中使用，\n    或者通过 sass-convert 命令行工具转换成另一种格式：\n\n```\n# Convert Sass to SCSS\n$ sass-convert style.sass style.scss\n\n# Convert SCSS to Sass\n$ sass-convert style.scss style.sass\n```\n\n## 3. 使用 Sass (Using Sass)\n\nSass 可以通过以下三种方式使用：作为命令行工具；作为独立的 Ruby 模块 (Ruby module)；或者作为 Rack-enabled 框架的插件（例如 Ruby on Rails 与 Merb）。无论哪种方式都需要先安装 Sass gem （Windows 系统需要先安装 Ruby）：\n\n```\ngem install sass\n```\n\n在命令行中运行 Sass：\n\n```\nsass input.scss output.css\n```\n\n监视单个 Sass 文件，每次修改并保存时自动编译：\n\n```\nsass --watch input.scss:output.css\n```\n\n监视整个文件夹：\n\n```\nsass --watch app/sass:public/stylesheets\n```\n\n更多命令的用法请通过==sass --help==获取帮助。\n\n在 Ruby 中使用 Sass 也非常容易，Sass gem 安装完毕后运行 require \"sass\" 然后按照下面的方法使用 Sass::Engine：\n\n```\nengine = Sass::Engine.new(\"#main {background-color: #0000ff}\", :syntax => :scss)\nengine.render #=> \"#main { background-color: #0000ff; }\\n\"\n```\n\n### 3.1. Rack/Rails/Merb Plugin\n\n```\n在 Rails 3 之前的版本中使用 Sass，需要在 environment.rb 文件中添加：\n\nconfig.gem \"sass\"\n\nRails 3 则需要在 Gemfile 中添加：\n\ngem \"sass\"\n\n在 Merb 中使用 Sass，需要在 config/dependencies.rb 中添加：\n\ndependency \"merb-haml\"\n\n在 Rack 中使用 Sass，需要在 config.ru 中添加：\n\nrequire 'sass/plugin/rack'\nuse Sass::Plugin::Rack\n\n样式文件与 views 不同，不包含任何动态内容，因此 CSS 只需要在 Sass 文件被修改后再编译生成。\n默认情况下 .sass 与 .scss 文件放置在 public/stylesheets/sass 中（可通过 :template_location 修改路径），\n编译生成的 CSS 文件放置在 public/stylesheets 中。\n例如 public/stylesheets/sass/main.scss 编译生成 public/stylesheets/main.css。\n```\n\n### 3.2. 缓存 (Caching)\n\n> Sass 自动缓存编译后的模板与 partials，这样做能够显著提升重新编译的速度，尤其在处理由 @import 导入多个子文件的大型项目时。\n\n> 单独使用 Sass，缓存内容保存在 .sass-cache 文件夹中。在 Rails 和 Merb 项目中缓存文件保存在 tmp/sass-cache 文件夹中（可通过 :cache_location 修改路径）。禁用缓存可将 :cache 设为 false。\n\n### 3.3. 配置选项 (Options)<null>\n\n暂未翻译\n\n### 3.4. 判断语法格式 (Syntax Selection)\n\n> Sass 命令行工具根据文件的拓展名判断所使用的语法格式，没有文件名时 sass 命令默认编译 .sass 文件，添加 --scss 选项或者使用 scss 命令编译 SCSS 文件。\n\n### 3.5. 编码格式 (Encodings)\n\n> 在 Ruby 1.9 及以上环境中运行 Sass 时，Sass 对文件的编码格式比较敏感，首先会根据 CSS spec 判断样式文件的编码格式，如果失败则检测 Ruby string encoding。也就是说，Sass 首先检查 Unicode byte order mark，然后是 @charset 声明，最后是 Ruby string encoding，假如都没有检测到，默认使用 UTF-8 编码。\n\n> 与 CSS 相同，使用 @charset 可以声明特定的编码格式。在样式文件的起始位置（前面没有任何空白与注释）插入 @charset \"encoding-name\"， Sass 将会按照给出的编码格式编译文件。注意所使用的编码格式必须可转换为 Unicode 字符集。\n\n> Sass 以 UTF-8 编码输出 CSS 文件，当且仅当编译后的文件中包含非 ASCII 字符时，才会在输出文件中添加 @charset 声明，而在压缩模式下 (compressed mode) 使用 UTF-8 byte order mark 代替 @charset 声明语句。\n\n## 4. CSS 功能拓展 (CSS Extensions)\n\n### 4.1. 嵌套规则 (Nested Rules)\n\n> Sass 允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器，例如：\n\n```css\n#main p {\n  color: #00ff00;\n  width: 97%;\n\n  .redbox {\n    background-color: #ff0000;\n    color: #000000;\n  }\n}\n```\n\n编译为\n\n```\n#main p {\n  color: #00ff00;\n  width: 97%; \n}\n#main p .redbox {\n    background-color: #ff0000;\n    color: #000000; \n}\n```\n\n嵌套功能避免了重复输入父选择器，而且令复杂的 CSS 结构更易于管理：\n\n```\n#main {\n  width: 97%;\n\n  p, div {\n    font-size: 2em;\n    a { font-weight: bold; }\n  }\n\n  pre { font-size: 3em; }\n}\n```\n\n编译为\n\n```\n#main {\n  width: 97%; }\n  #main p, #main div {\n    font-size: 2em; }\n#main p a, #main div a {\n      font-weight: bold; }\n#main pre {\n    font-size: 3em; }\n```\n\n### 4.2. 父选择器 & (Referencing Parent Selectors: &)\n\n在嵌套 CSS 规则时，有时也需要直接使用嵌套外层的父选择器，例如，当给某个元素设定 hover 样式时，或者当 body 元素有某个 classname 时，可以用 ==& 代表嵌套规则外层的父选择器==。\n\n```\na {\n  font-weight: bold;\n  text-decoration: none;\n  &:hover { text-decoration: underline; }\n  body.firefox & { font-weight: normal; }\n}\n```\n\n编译为\n\n```\na {\n  font-weight: bold;\n  text-decoration: none; }\n  a:hover {\n    text-decoration: underline; }\n  body.firefox a {\n    font-weight: normal; }\n```\n\n编译后的 CSS 文件中 & 将被替换成嵌套外层的父选择器，如果含有多层嵌套，最外层的父选择器会一层一层向下传递：\n\n```css\n#main {\n  color: black;\n  a {\n    font-weight: bold;\n    &:hover { color: red; }\n  }\n}\n```\n\n编译为\n\n```\n#main {\n  color: black; }\n  #main a {\n    font-weight: bold; }\n    #main a:hover {\n      color: red; }\n```\n\n& 必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器，例如\n\n```\n#main {\n  color: black;\n  &-sidebar { border: 1px solid; }\n}\n```\n\n编译为\n\n```\n#main {\n  color: black; \n    \n}\n#main-sidebar {\n    border: 1px solid; \n}\n```\n\n> 当父选择器含有不合适的后缀时，Sass 将会报错。\n\n### 4.3. 属性嵌套 (Nested Properties)\n\n> 有些 CSS 属性遵循相同的命名空间 (namespace)，比如 font-family, font-size, font-weight 都以 font 作为属性的命名空间。为了便于管理这样的属性，同时也为了避免了重复输入，Sass 允许将属性嵌套在命名空间中，例如：\n\n```\n.funky {\n  font: {\n    family: fantasy;\n    size: 30em;\n    weight: bold;\n  }\n}\n```\n\n编译为\n\n```\n.funky {\n  font-family: fantasy;\n  font-size: 30em;\n  font-weight: bold; }\n```\n\n命名空间也可以包含自己的属性值，例如：\n\n```\n.funky {\n  font: 20px/24px {\n    family: fantasy;\n    weight: bold;\n  }\n}\n```\n\n编译为\n\n```\n.funky {\n  font: 20px/24px;\n    font-family: fantasy;\n    font-weight: bold; }\n```\n\n### 4.4. 占位符选择器 %foo (Placeholder Selectors: %foo)\n\n    Sass 额外提供了一种特殊类型的选择器：\n    占位符选择器 (placeholder selector)。与常用的 id 与 class 选择器写法相似，只是 # 或 . 替换成了 %。必须通过 @extend 指令调用，\n    更多介绍请查阅 @extend-Only Selectors。\n    \n    当占位符选择器单独使用时（未通过 @extend 调用），不会编译到 CSS 文件中。\n\n## 5. 注释\n\n> /**/ 与 // (Comments: /**/ and //)\n\nSass 支持标准的 CSS 多行注释 /**/，以及单行注释 //，前者会 被完整输出到编译后的 CSS 文件中，而后者则不会，例如：\n\n```\n/* This comment is\n * several lines long.\n * since it uses the CSS comment syntax,\n * it will appear in the CSS output. */\nbody { color: black; }\n\n// These comments are only one line long each.\n// They won't appear in the CSS output,\n// since they use the single-line comment syntax.\na { color: green; }\n```\n\n编译为\n\n```\n/* This comment is\n * several lines long.\n * since it uses the CSS comment syntax,\n * it will appear in the CSS output. */\nbody {\n  color: black; }\n\na {\n  color: green; }\n```\n\n将 ! 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。\n\n插值语句 (interpolation) 也可写进多行注释中输出变量值：\n\n```\n$version: \"1.2.3\";\n/* This CSS is generated by My Snazzy Framework version #{$version}. */\n```\n\n编译为\n\n```\n/* This CSS is generated by My Snazzy Framework version 1.2.3. */\n```\n\n## 6. SassScript\n\n在 CSS 属性的基础上 Sass 提供了一些名为 SassScript 的新功能。 SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能。\n\n通过 interpolation，SassScript 甚至可以生成选择器或属性名，这一点对编写 mixin 有很大帮助。\n\n### 6.1. Interactive Shell\n\nInteractive Shell 可以在命令行中测试 SassScript 的功能。在命令行中输入 sass -i，然后输入想要测试的 SassScript 查看输出结果：\n\n```\n$ sass -i\n>> \"Hello, Sassy World!\"\n\"Hello, Sassy World!\"\n>> 1px + 1px + 1px\n3px\n>> #777 + #777\n#eeeeee\n>> #777 + #888\nwhite\n```\n\n### 6.2. 变量 $ (Variables: $)\n\nSassScript 最普遍的用法就是变量，变量以美元符号开头，赋值方法与 CSS 属性的写法一样：\n\n```\n$width: 5em;\n```\n\n直接使用即调用变量：\n\n```scss\n#main {\n  width: $width;\n}\n```\n\n变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 !global 声明：\n\n```scss\n#main {\n  $width: 5em !global;\n  width: $width;\n}\n#sidebar {\n  width: $width;\n}\n```\n\n编译为\n\n```\n#main {\n  width: 5em;\n}\n\n#sidebar {\n  width: 5em;\n}\n```\n\n### 6.3. 数据类型 (Data Types)\n\nSassScript 支持 6 种主要的数据类型：\n\n    数字，1, 2, 13, 10px\n    字符串，有引号字符串与无引号字符串，\"foo\", 'bar', baz\n    颜色，blue, #04a3f9, rgba(255,0,0,0.5)\n    布尔型，true, false\n    空值，null\n    数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif\n    maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2)\n\nSassScript 也支持其他 CSS 属性值，比如 Unicode 字符集，或 !important 声明。然而Sass 不会特殊对待这些属性值，一律视为无引号字符串。\n\n#### 6.3.1. 字符串 (Strings)\n\nSassScript 支持 CSS 的两种字符串类型：有引号字符串 (quoted strings)，如 \"Lucida Grande\" 'http://sass-lang.com'；与无引号字符串 (unquoted strings)，如 sans-serif bold，在编译 CSS 文件时不会改变其类型。只有一种情况例外，使用 #{} (interpolation) 时，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名：\n\n@mixin firefox-message($selector) {\n  body.firefox #{$selector}:before {\n    content: \"Hi, Firefox users!\";\n  }\n}\n@include firefox-message(\".header\");\n\n编译为\n\nbody.firefox .header:before {\n  content: \"Hi, Firefox users!\"; }\n\n#### 6.3.2. 数组 (Lists)\n\n数组 (lists) 指 Sass 如何处理 CSS 中 margin: 10px 15px 0 0 或者 font-face: Helvetica, Arial, sans-serif 这样通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为数组 —— 只包含一个值的数组。\n\n数组本身没有太多功能，但 Sass list functions 赋予了数组更多新功能：nth 函数可以直接访问数组中的某一项；join 函数可以将多个数组连接在一起；append 函数可以在数组中添加新值；而 @each 指令能够遍历数组中的每一项。\n\n数组中可以包含子数组，比如 1px 2px, 5px 6px 是包含 1px 2px 与 5px 6px 两个数组的数组。如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层，所以也可以写成 (1px 2px) (5px 6px)。变化是，之前的 1px 2px, 5px 6px 使用逗号分割了两个子数组 (comma-separated)，而 (1px 2px) (5px 6px) 则使用空格分割(space-separated)。\n\n当数组被编译为 CSS 时，Sass 不会添加任何圆括号（CSS 中没有这种写法），所以 (1px 2px) (5px 6px) 与 1px 2px, 5px 6px 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。\n\n用 () 表示不包含任何值的空数组（在 Sass 3.3 版之后也视为空的 map）。空数组不可以直接编译成 CSS，比如编译 font-family: () Sass 将会报错。如果数组中包含空数组或空值，编译时将被清除，比如 1px 2px () 3px 或 1px 2px null 3px。\n\n基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时。例如 (1,) 表示只包含 1 的数组，而 (1 2 3,) 表示包含 1 2 3 这个以空格分隔的数组的数组。\n\n#### 6.3.3. Maps\n\nMaps可视为键值对的集合，键被用于定位值 在css种没有对应的概念。 和Lists不同Maps必须被圆括号包围，键值对被都好分割 。 Maps中的keys和values可以是sassscript的任何对象。（包括任意的sassscript表达式 arbitrary SassScript expressions） 和Lists一样Maps主要为sassscript函数服务，如 map-get函数用于查找键值，map-merge函数用于map和新加的键值融合，@each命令可添加样式到一个map中的每个键值对。 Maps可用于任何Lists可用的地方，在List函数中 Map会被自动转换为List ， 如 (key1: value1, key2: value2)会被List函数转换为 key1 value1, key2 value2 ，反之则不能。(网友Soledad提供)\n\n#### 6.3.4. 颜色 (Colors)\n\nAny CSS color expression returns a SassScript Color value. This includes a large number of named colors which are indistinguishable from unquoted strings. In compressed output mode, Sass will output the smallest CSS representation of a color. For example, #FF0000 will output as red in compressed mode, but blanchedalmond will output as #FFEBCD. A common issue users encounter with named colors is that since Sass prefers the same output format as was typed in other output modes, a color interpolated into a selector becomes invalid syntax when compressed. To avoid this, always quote named colors if they are meant to be used in the construction of a selector.\n\n### 6.4. 运算 (Operations)\n\n所有数据类型均支持相等运算 == 或 !=，此外，每种数据类型也有其各自支持的运算方式。\n\n#### 6.4.1. 数字运算 (Number Operations)\n\nSassScript 支持数字的加减乘除、取整等运算 (+, -, *, /, %)，如果必要会在不同单位间转换值。\n\n```\np {\n  width: 1in + 8pt;\n}\n```\n\n编译为\n\n```\np {\n  width: 1.111in; }\n```\n\n关系运算 <, >, <=, >= 也可用于数字运算，相等运算 ==, != 可用于所有数据类型。\n6.4.1.1. 除法运算 / (Division and /)\n\n/ 在 CSS 中通常起到分隔数字的用途，SassScript 作为 CSS 语言的拓展当然也支持这个功能，同时也赋予了 / 除法运算的功能。也就是说，如果 / 在 SassScript 中把两个数字分隔，编译后的 CSS 文件中也是同样的作用。\n\n以下三种情况 / 将被视为除法运算符号：\n\n    如果值，或值的一部分，是变量或者函数的返回值\n    如果值被圆括号包裹\n    如果值是算数表达式的一部分\n\n```\np {\n  font: 10px/8px;             // Plain CSS, no division\n  $width: 1000px;\n  width: $width/2;            // Uses a variable, does division\n  width: round(1.5)/2;        // Uses a function, does division\n  height: (500px/2);          // Uses parentheses, does division\n  margin-left: 5px + 8px/2px; // Uses +, does division\n}\n```\n\n编译为\n\n```\np {\n  font: 10px/8px;\n  width: 500px;\n  height: 250px;\n  margin-left: 9px; }\n```\n\n如果需要使用变量，同时又要确保 / 不做除法运算而是完整地编译到 CSS 文件中，只需要用 #{} 插值语句将变量包裹。\n\n```\np {\n  $font-size: 12px;\n  $line-height: 30px;\n  font: #{$font-size}/#{$line-height};\n}\n```\n\n编译为\n\n```\np {\n  font: 12px/30px; }\n```\n\n#### 6.4.2. 颜色值运算 (Color Operations)\n\n颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值：\n\n```\np {\n  color: #010203 + #040506;\n}\n```\n\n计算 01 + 04 = 05 02 + 05 = 07 03 + 06 = 09，然后编译为\n\n```\np {\n  color: #050709; }\n```\n\n使用 color functions 比计算颜色值更方便一些。\n\n数字与颜色值之间也可以进行算数运算，同样也是分段计算的，比如\n\n```\np {\n  color: #010203 * 2;\n}\n```\n\n计算 01 *2 = 02 02* 2 = 04 03 * 2 = 06，然后编译为\n\n```\np {\n```\n\n需要注意的是，如果颜色值包含 alpha channel（rgba 或 hsla 两种颜色值），必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值。\n\n```\np {\n  color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);\n}\n```\n\n编译为\n\n``````\np {\n  color: rgba(255, 255, 0, 0.75); }\n``````\n\n颜色值的 alpha channel 可以通过 opacify 或 transparentize 两个函数进行调整。\n\n``````\n$translucent-red: rgba(255, 0, 0, 0.5);\np {\n  color: opacify($translucent-red, 0.3);\n  background-color: transparentize($translucent-red, 0.25);\n}\n``````\n\n编译为\n\n``````\np {\n  color: rgba(255, 0, 0, 0.8);\n  background-color: rgba(255, 0, 0, 0.25); }\n``````\n\nIE 滤镜要求所有的颜色值包含 alpha 层，而且格式必须固定 #AABBCCDD，使用 ie_hex_str 函数可以很容易地将颜色转化为 IE 滤镜要求的格式。\n\n```\n$translucent-red: rgba(255, 0, 0, 0.5);\n$green: #00ff00;\ndiv {\n  filter: progid:DXImageTransform.Microsoft.gradient(enabled='false', startColorstr='#{ie-hex-str($green)}', endColorstr='#{ie-hex-str($translucent-red)}');\n}\n```\n\n编译为\n\n```\ndiv {\n  filter: progid:DXImageTransform.Microsoft.gradient(enabled='false', startColorstr=#FF00FF00, endColorstr=#80FF0000);\n}\n```\n\n#### 6.4.3. 字符串运算 (String Operations)\n\n+ 可用于连接字符串\n\n``````\np {\n  cursor: e + -resize;\n}\n``````\n\n编译为\n\n``````\np {\n  cursor: e-resize; }\n``````\n\n注意，如果有引号字符串（位于 + 左侧）连接无引号字符串，运算结果是有引号的，相反，无引号字符串（位于 + 左侧）连接有引号字符串，运算结果则没有引号。\n\n```\np:before {\n  content: \"Foo \" + Bar;\n  font-family: sans- + \"serif\";\n}\n```\n\n编译为\n\n```\np:before {\n  content: \"Foo Bar\";\n  font-family: sans-serif; }\n```\n\n运算表达式与其他值连用时，用空格做连接符：\n\n```\np {\n  margin: 3px + 4px auto;\n}\n```\n\n编译为\n\n```\np {\n  margin: 7px auto; }\n```\n\n在有引号的文本字符串中使用 #{} 插值语句可以添加动态的值：\n\n```\np:before {\n  content: \"I ate #{5 + 10} pies!\";\n}\n```\n\n编译为\n\n```\np:before {\n  content: \"I ate 15 pies!\"; }\n``````\n\n空的值被视作插入了空字符串：\n\n```\n$value: null;\np:before {\n  content: \"I ate #{$value} pies!\";\n}\n```\n\n编译为\n\n```\np:before {\n  content: \"I ate pies!\"; }\n```\n\n#### 6.4.4. 布尔运算 (Boolean Operations)\n\nSassScript 支持布尔型的 and or 以及 not 运算。\n\n#### 6.4.5. 数组运算 (List Operations)\n\n数组不支持任何运算方式，只能使用 list functions 控制。\n\n### 6.5. 圆括号 (Parentheses)\n\n圆括号可以用来影响运算的顺序：\n\n```\np {\n  width: 1em + (2em * 3);\n}\n```\n\n编译为\n\n```\np {\n  width: 7em; }\n```\n\n### 6.6. 函数 (Functions)\n\nSassScript 定义了多种函数，有些甚至可以通过普通的 CSS 语句调用：\n\n```\np {\n  color: hsl(0, 100%, 50%);\n}\n```\n\n编译为\n\n```\np {\n  color: #ff0000; }\n```\n\n#### 6.6.1. 关键词参数 (Keyword Arguments)\n\nSass 函数允许使用关键词参数 (keyword arguments)，上面的例子也可以写成：\n\n```\np {\n  color: hsl($hue: 0, $saturation: 100%, $lightness: 50%);\n}\n```\n\n虽然不够简明，但是阅读起来会更方便。关键词参数给函数提供了更灵活的接口，以及容易调用的参数。关键词参数可以打乱顺序使用，如果使用默认值也可以省缺，另外，参数名被视为变量名，下划线、短横线可以互换使用。\n\n通过 Sass::Script::Functions 查看完整的 Sass 函数列表，参数名，以及如何自定义函数。\n\n### 6.7. 插值语句 #{} (Interpolation: #{})\n\n通过 #{} 插值语句可以在选择器或属性名中使用变量：\n\n```\n$name: foo;\n$attr: border;\np.#{$name} {\n  #{$attr}-color: blue;\n}\n```\n\n编译为\n\n```\np.foo {\n  border-color: blue; }\n```\n\n{} 插值语句也可以在属性值中插入 SassScript，大多数情况下，这样可能还不如使用变量方便，但是使用 #{} 可以避免 Sass 运行运算表达式，直接编译 CSS。\n\n```\np {\n  $font-size: 12px;\n  $line-height: 30px;\n  font: #{$font-size}/#{$line-height};\n}\n```\n\n编译为\n\n```\np {\n  font: 12px/30px; }\n```\n\n### 6.8. & in SassScript\n\nJust like when it’s used in selectors, & in SassScript refers to the current parent selector. It’s a comma-separated list of space-separated lists. For example:\n\n```\n.foo.bar .baz.bang, .bip.qux {\n  $selector: &;\n}\n```\n\nThe value of $selector is now ((\".foo.bar\" \".baz.bang\"), \".bip.qux\"). The compound selectors are quoted here to indicate that they’re strings, but in reality they would be unquoted. Even if the parent selector doesn’t contain a comma or a space, & will always have two levels of nesting, so it can be accessed consistently.\n\nIf there is no parent selector, the value of & will be null. This means you can use it in a mixin to detect whether a parent selector exists:\n\n```\n@mixin does-parent-exist {\n  @if & {\n    &:hover {\n      color: red;\n    }\n  } @else {\n    a {\n      color: red;\n    }\n  }\n}\n```\n\n### 6.9. 变量定义 !default (Variable Defaults: !default)\n\n可以在变量的结尾添加 !default 给一个未通过 !default 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。\n\n```\n$content: \"First content\";\n$content: \"Second content?\" !default;\n$new_content: \"First time reference\" !default;\n\n#main {\n  content: $content;\n  new-content: $new_content;\n}\n```\n\n编译为\n\n```\n#main {\n  content: \"First content\";\n  new-content: \"First time reference\"; }\n```\n\n变量是 null 空值时将视为未被 !default 赋值。\n\n```\n$content: null;\n$content: \"Non-null content\" !default;\n\n#main {\n  content: $content;\n}\n```\n\n编译为\n\n```\n#main {\n  content: \"Non-null content\"; }\n```\n\n## 7. @-Rules 与指令 (@-Rules and Directives)\n\nSass 支持所有的 CSS3 @-Rules，以及 Sass 特有的 “指令”（directives）。这一节会详细解释，更多资料请查看 控制指令 (control directives) 与 混合指令 (mixin directives) 两个部分。\n\n### 7.1. @import\n\nSass 拓展了 @import 的功能，允许其导入 SCSS 或 Sass 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。\n\nSass 在当前地址，或 Rack, Rails, Merb 的 Sass 文件地址寻找 Sass 文件，如果需要设定其他地址，可以用 :load_paths 选项，或者在命令行中输入 --load-path 命令。\n\n通常，@import 寻找 Sass 文件并将其导入，但在以下情况下，@import 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。\n\n    文件拓展名是 .css；\n    文件名以 http:// 开头；\n    文件名是 url()；\n    @import 包含 media queries。\n\n如果不在上述情况内，文件的拓展名是 .scss 或 .sass，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 .scss 或 .sass 的文件并将其导入。\n\n```\n@import \"foo.scss\";\n\n或\n\n@import \"foo\";\n\n都会导入文件 foo.scss，但是\n\n@import \"foo.css\";\n@import \"foo\" screen;\n@import \"http://foo.com/bar\";\n@import url(foo);\n\n编译为\n\n@import \"foo.css\";\n@import \"foo\" screen;\n@import \"http://foo.com/bar\";\n@import url(foo);\n```\n\nSass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件：\n\n```\n@import \"rounded-corners\", \"text-shadow\";\n```\n\n导入文件也可以使用 #{ } 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 url() 导入方式：\n\n$family: unquote(\"Droid+Sans\");\n@import url(\"http://fonts.googleapis.com/css?family=\\#{$family}\");\n\n编译为\n\n@import url(\"http://fonts.googleapis.com/css?family=Droid+Sans\");\n\n#### 7.1.1. 分音 (Partials)\n\n如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，这样会告诉 Sass 不要编译这些文件，但导入语句中却不需要添加下划线。\n\n例如，将文件命名为 _colors.scss，便不会编译_colours.css 文件。\n\n```\n@import \"colors\";\n```\n\n上面的例子，导入的其实是 _colors.scss 文件\n\n注意，不可以同时存在添加下划线与未添加下划线的同名文件，添加下划线的文件将会被忽略。\n\n#### 7.1.2. 嵌套 @import\n\n大多数情况下，一般在文件的最外层（不在嵌套规则内）使用 @import，其实，也可以将 @import 嵌套进 CSS 样式或者 @media 中，与平时的用法效果相同，只是这样导入的样式只能出现在嵌套的层中。\n\n假设 example.scss 文件包含以下样式：\n\n```\n.example {\n  color: red;\n}\n```\n\n然后导入到 #main 样式内\n\n```\n#main {\n  @import \"example\";\n}\n```\n\n将会被编译为\n\n```\n#main .example {\n  color: red;\n}\n```\n\n    Directives that are only allowed at the base level of a document, \n    like @mixin or @charset, are not allowed in files that are\n    @imported in a nested context. 这一句不理解\n\n不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 @import。\n\n### 7.2. @media\n\nSass 中 @media 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 @media 嵌套在 CSS 规则内，编译时，@media 将被编译到文件的最外层，包含嵌套的父选择器。这个功能让 @media 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。\n\n```\n.sidebar {\n  width: 300px;\n  @media screen and (orientation: landscape) {\n    width: 500px;\n  }\n}\n```\n\n编译为\n\n```\n.sidebar {\n  width: 300px; }\n  @media screen and (orientation: landscape) {\n    .sidebar {\n      width: 500px; } }\n```\n\n@media 的 queries 允许互相嵌套使用，编译时，Sass 自动添加 and\n\n```\n@media screen {\n  .sidebar {\n    @media (orientation: landscape) {\n      width: 500px;\n    }\n  }\n}\n```\n\n编译为\n\n```\n@media screen and (orientation: landscape) {\n  .sidebar {\n    width: 500px; } }\n```\n\n@media 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值：\n\n```\n$media: screen;\n$feature: -webkit-min-device-pixel-ratio;\n$value: 1.5;\n\n@media #{$media} and ($feature: $value) {\n  .sidebar {\n    width: 500px;\n  }\n}\n```\n\n编译为\n\n```\n@media screen and (-webkit-min-device-pixel-ratio: 1.5) {\n  .sidebar {\n    width: 500px; } }\n```\n\n### 7.3. @extend\n\n在设计网页的时候常常遇到这种情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。通常会在 HTML 中给元素定义两个 class，一个通用样式，一个特殊样式。假设现在要设计一个普通错误样式与一个严重错误样式，一般会这样写：\n\n<div class=\"error seriousError\">\n  Oh no! You've been hacked!\n</div>\n\n样式如下\n\n```\n.error {\n  border: 1px #f00;\n  background-color: #fdd;\n}\n.seriousError {\n  border-width: 3px;\n}\n```\n\n麻烦的是，这样做必须时刻记住使用 .seriousError 时需要参考 .error 的样式，带来了很多不变：智能比如加重维护负担，导致 bug，或者给 HTML 添加无语意的样式。使用 @extend 可以避免上述情况，告诉 Sass 将一个选择器下的所有样式继承给另一个选择器。\n\n```\n.error {\n  border: 1px #f00;\n  background-color: #fdd;\n}\n.seriousError {\n  @extend .error;\n  border-width: 3px;\n}\n```\n\n上面代码的意思是将 .error 下的所有样式继承给 .seriousError，border-width: 3px; 是单独给 .seriousError 设定特殊样式，这样，使用 .seriousError 的地方可以不再使用 .error。\n\n其他使用到 .error 的样式也会同样继承给 .seriousError，例如，另一个样式 .error.intrusion 使用了 hacked.png 做背景，<div class=\"seriousError intrusion\"> 也同样会使用 hacked.png 背景。\n\n```\n.error.intrusion {\n  background-image: url(\"/image/hacked.png\");\n}\n```\n\n### 7.3.1. How it Works\n\n@extend 的作用是将重复使用的样式 (.error) 延伸 (extend) 给需要包含这个样式的特殊样式（.seriousError），刚刚的例子：\n\n```\n.error {\n  border: 1px #f00;\n  background-color: #fdd;\n}\n.error.intrusion {\n  background-image: url(\"/image/hacked.png\");\n}\n.seriousError {\n  @extend .error;\n  border-width: 3px;\n}\n```\n\n编译为\n\n```\n.error, .seriousError {\n  border: 1px #f00;\n  background-color: #fdd; }\n\n.error.intrusion, .seriousError.intrusion {\n  background-image: url(\"/image/hacked.png\"); }\n\n.seriousError {\n  border-width: 3px; }\n```\n\n当合并选择器时，@extend 会很聪明地避免无谓的重复，.seriousError.seriousError 将编译为 .seriousError，不能匹配任何元素的选择器（比如 #main#footer ）也会删除。\n\n#### 7.3.2. 延伸复杂的选择器 (Extending Complex Selectors)\n\nClass 选择器并不是唯一可以被延伸 (extend) 的，Sass 允许延伸任何定义给单个元素的选择器，比如 .special.cool，a:hover 或者 a.user[href^=\"http://\"] 等，例如：\n\n```\n.hoverlink {\n  @extend a:hover;\n}\n```\n\n同 class 元素一样，a:hover 的样式将继承给 .hoverlink。\n\n```\n.hoverlink {\n  @extend a:hover;\n}\na:hover {\n  text-decoration: underline;\n}\n```\n\n编译为\n\n```\na:hover, .hoverlink {\n  text-decoration: underline; }\n```\n\n与上面 .error.intrusion 的例子一样，所有 a:hover 的样式将继承给 .hoverlink，包括其他使用到 a:hover 的样式，例如：\n\n```\n.hoverlink {\n  @extend a:hover;\n}\n.comment a.user:hover {\n  font-weight: bold;\n}\n```\n\n编译为\n\n```\n.comment a.user:hover, .comment .user.hoverlink {\n  font-weight: bold; }\n```\n\n#### 7.3.3. 多重延伸 (Multiple Extends)\n\n同一个选择器可以延伸给多个选择器，它所包含的属性将继承给所有被延伸的选择器：\n\n```\n.error {\n  border: 1px #f00;\n  background-color: #fdd;\n}\n.attention {\n  font-size: 3em;\n  background-color: #ff0;\n}\n.seriousError {\n  @extend .error;\n  @extend .attention;\n  border-width: 3px;\n}\n```\n\n编译为\n\n```\n.error, .seriousError {\n  border: 1px #f00;\n  background-color: #fdd; }\n\n.attention, .seriousError {\n  font-size: 3em;\n  background-color: #ff0; }\n\n.seriousError {\n  border-width: 3px; }\n```\n\n每个 .seriousError 将包含 .error 与 .attention 下的所有样式，这时，后定义的样式享有优先权：.seriousError 的背景颜色是 #ff0 而不是 #fdd，因为 .attention 在 .error 之后定义。\n\n多重延伸可以使用逗号分隔选择器名，比如 @extend .error, .attention; 与 @extend .error; @extend.attention 有相同的效果。\n\n#### 7.3.4. 继续延伸 (Chaining Extends)\n\n当一个选择器延伸给第二个后，可以继续将第二个选择器延伸给第三个，例如：\n\n```\n.error {\n  border: 1px #f00;\n  background-color: #fdd;\n}\n.seriousError {\n  @extend .error;\n  border-width: 3px;\n}\n.criticalError {\n  @extend .seriousError;\n  position: fixed;\n  top: 10%;\n  bottom: 10%;\n  left: 10%;\n  right: 10%;\n}\n```\n\n现在，每个 .seriousError 选择器将包含 .error 的样式，而 .criticalError 不仅包含 .seriousError 的样式也会同时包含 .error 的所有样式，上面的代码编译为：\n\n```\n.error, .seriousError, .criticalError {\n  border: 1px #f00;\n  background-color: #fdd; }\n\n.seriousError, .criticalError {\n  border-width: 3px; }\n\n.criticalError {\n  position: fixed;\n  top: 10%;\n  bottom: 10%;\n  left: 10%;\n  right: 10%; }\n```\n\n#### 7.3.5. 选择器列 (Selector Sequences)\n\n暂时不可以将选择器列 (Selector Sequences)，比如 .foo .bar 或 .foo + .bar，延伸给其他元素，但是，却可以将其他元素延伸给选择器列：\n\n```\n#fake-links .link {\n  @extend a;\n}\n\na {\n  color: blue;\n  &:hover {\n    text-decoration: underline;\n  }\n}\n```\n\n编译为\n\n```\na, #fake-links .link {\n  color: blue; }\n  a:hover, #fake-links .link:hover {\n    text-decoration: underline; }\n```\n\n##### 7.3.5.1. 合并选择器列 (Merging Selector Sequences)\n\n有时会遇到复杂的情况，比如选择器列中的某个元素需要延伸给另一个选择器列，这种情况下，两个选择器列需要合并，比如：\n\n```\n#admin .tabbar a {\n  font-weight: bold;\n}\n#demo .overview .fakelink {\n  @extend a;\n}\n```\n\n技术上讲能够生成所有匹配条件的结果，但是这样生成的样式表太复杂了，上面这个简单的例子就可能有 10 种结果。所以，Sass 只会编译输出有用的选择器。\n\n当两个列 (sequence) 合并时，如果没有包含相同的选择器，将生成两个新选择器：第一列出现在第二列之前，或者第二列出现在第一列之前：\n\n```\n#admin .tabbar a {\n  font-weight: bold;\n}\n#demo .overview .fakelink {\n  @extend a;\n}\n```\n\n编译为\n\n```\n#admin .tabbar a,\n#admin .tabbar #demo .overview .fakelink,\n#demo .overview #admin .tabbar .fakelink {\n  font-weight: bold; }\n```\n\n如果两个列 (sequence) 包含了相同的选择器，相同部分将会合并在一起，其他部分交替输出。在下面的例子里，两个列都包含 #admin，输出结果中它们合并在了一起：\n\n```\n#admin .tabbar a {\n  font-weight: bold;\n}\n#admin .overview .fakelink {\n  @extend a;\n}\n```\n\n编译为\n\n```\n#admin .tabbar a,\n#admin .tabbar .overview .fakelink,\n#admin .overview .tabbar .fakelink {\n  font-weight: bold; }\n```\n\n#### 7.3.6. @extend-Only 选择器 (@extend-Only Selectors)\n\n有时，需要定义一套样式并不是给某个元素用，而是只通过 @extend 指令使用，尤其是在制作 Sass 样式库的时候，希望 Sass 能够忽略用不到的样式。\n\n如果使用普通的 CSS 规则，最后会编译出很多用不到的样式，也容易与其他样式名冲突，所以，Sass 引入了“占位符选择器” (placeholder selectors)，看起来很像普通的 id 或 class 选择器，只是 # 或 . 被替换成了 %。可以像 class 或者 id 选择器那样使用，当它们单独使用时，不会被编译到 CSS 文件中。\n\n```\n// This ruleset won't be rendered on its own.\n#context a%extreme {\n  color: blue;\n  font-weight: bold;\n  font-size: 2em;\n}\n```\n\n占位符选择器需要通过延伸指令使用，用法与 class 或者 id 选择器一样，被延伸后，占位符选择器本身不会被编译。\n\n```\n.notice {\n  @extend %extreme;\n}\n```\n\n编译为\n\n```\n#context a.notice {\n  color: blue;\n  font-weight: bold;\n  font-size: 2em; }\n```\n\n#### 7.3.7. !optional 声明 (The !optional Flag)\n\n如果 @extend 失败会收到错误提示，比如，这样写 a.important {@extend .notice}，当没有 .notice 选择器时，将会报错，只有 h1.notice 包含 .notice 时也会报错，因为 h1 与 a 冲突，会生成新的选择器。\n\n如果要求 @extend 不生成新选择器，可以通过 !optional 声明达到这个目的，例如：\n\n```\na.important {\n  @extend .notice !optional;\n}\n```\n\n#### 7.3.8. 在指令中延伸 (@extend in Directives)\n\n在指令中使用 @extend 时（比如在 @media 中）有一些限制：Sass 不可以将 @media 层外的 CSS 规则延伸给指令层内的 CSS，这样会生成大量的无用代码。也就是说，如果在 @media （或者其他 CSS 指令）中使用 @extend，必须延伸给相同指令层中的选择器。\n\n下面的例子是可行的：\n\n```\n@media print {\n  .error {\n    border: 1px #f00;\n    background-color: #fdd;\n  }\n  .seriousError {\n    @extend .error;\n    border-width: 3px;\n  }\n}\n```\n\n但不可以这样：\n\n```\n.error {\n  border: 1px #f00;\n  background-color: #fdd;\n}\n\n@media print {\n  .seriousError {\n    // INVALID EXTEND: .error is used outside of the \"@media print\" directive\n    @extend .error;\n    border-width: 3px;\n  }\n}\n```\n\n希望有一天，浏览器可以原生支持 @extend 指令，这样就可以在任何指令中使用延伸功能，不再受限制了。\n\n### 7.4. @at-root\n\nThe @at-root directive causes one or more rules to be emitted at the root of the document, rather than being nested beneath their parent selectors. It can either be used with a single inline selector:\n\n```\n.parent {\n  ...\n  @at-root .child { ... }\n}\n```\n\nWhich would produce:\n\n```\n.parent { ... }\n.child { ... }\n```\n\nOr it can be used with a block containing multiple selectors:\n\n```\n.parent {\n  ...\n  @at-root {\n    .child1 { ... }\n    .child2 { ... }\n  }\n  .step-child { ... }\n}\n```\n\nWhich would output the following:\n\n```\n.parent { ... }\n.child1 { ... }\n.child2 { ... }\n.parent .step-child { ... }\n```\n\n#### 7.4.1. @at-root (without: ...) and @at-root (with: ...)\n\nBy default, @at-root just excludes selectors. However, it’s also possible to use @at-root to move outside of nested directives such as @media as well. For example:\n\n```\n@media print {\n  .page {\n    width: 8in;\n    @at-root (without: media) {\n      color: red;\n    }\n  }\n}\n```\n\nproduces:\n\n```\n@media print {\n  .page {\n    width: 8in;\n  }\n}\n.page {\n  color: red;\n}\n```\n\nYou can use @at-root (without: ...) to move outside of any directive. You can also do it with multiple directives separated by a space: @at-root (without: media supports) moves outside of both @media and @supports queries.\n\nThere are two special values you can pass to @at-root. “rule” refers to normal CSS rules; @at-root (without: rule) is the same as @at-root with no query. @at-root (without: all) means that the styles should be moved outside of all directives and CSS rules.\n\nIf you want to specify which directives or rules to include, rather than listing which ones should be excluded, you can use with instead of without. For example, @at-root (with: rule) will move outside of all directives, but will preserve any CSS rules.\n\n### 7.5. @debug\n\nThe @debug directive prints the value of a SassScript expression to the standard error output stream. It’s useful for debugging Sass files that have complicated SassScript going on. For example:\n\n@debug 10em + 12em;\n\n编译为\n\nLine 1 DEBUG: 22em\n\n### 7.6. @warn\n\nThe @warn directive prints the value of a SassScript expression to the standard error output stream. It’s useful for libraries that need to warn users of deprecations or recovering from minor mixin usage mistakes. There are two major distinctions between @warn and @debug:\n\n    You can turn warnings off with the --quiet command-line option or the :quiet Sass option.\n    A stylesheet trace will be printed out along with the message so that the user being warned can see where their styles caused the warning.\n\nUsage Example:\n\n```\n@mixin adjust-location($x, $y) {\n  @if unitless($x) {\n    @warn \"Assuming #{$x} to be in pixels\";\n    $x: 1px * $x;\n  }\n  @if unitless($y) {\n    @warn \"Assuming #{$y} to be in pixels\";\n    $y: 1px * $y;\n  }\n  position: relative; left: $x; top: $y;\n}\n```\n\n### 7.7. @warn\n\nThe @error directive throws the value of a SassScript expression as a fatal error, including a nice stack trace. It’s useful for validating arguments to mixins and functions. For example:\n\n```\n@mixin adjust-location($x, $y) {\n  @if unitless($x) {\n    @error \"$x may not be unitless, was #{$x}.\";\n  }\n  @if unitless($y) {\n    @error \"$y may not be unitless, was #{$y}.\";\n  }\n  position: relative; left: $x; top: $y;\n}\n```\n\nThere is currently no way to catch errors.\n\n## 8. 控制指令 (Control Directives)\n\nSassScript 提供了一些基础的控制指令，比如在满足一定条件时引用样式，或者设定范围重复输出格式。控制指令是一种高级功能，日常编写过程中并不常用到，主要与混合指令 (mixin) 配合使用，尤其是用在 Compass 等样式库中。\n8.1. if()\n\nThe built-in if() function allows you to branch on a condition and returns only one of two possible outcomes. It can be used in any script context. The if function only evaluates the argument corresponding to the one that it will return – this allows you to refer to variables that may not be defined or to have calculations that would otherwise cause an error (E.g. divide by zero).\n\n### 8.2. @if\n\n当 @if 的表达式返回值不是 false 或者 null 时，条件成立，输出 {} 内的代码：\n\n```\np {\n  @if 1 + 1 == 2 { border: 1px solid; }\n  @if 5 < 3 { border: 2px dotted; }\n  @if null  { border: 3px double; }\n}\n```\n\n编译为\n\n```\np {\n  border: 1px solid; }\n```\n\n@if 声明后面可以跟多个 @else if 声明，或者一个 @else 声明。如果 @if 声明失败，Sass 将逐条执行 @else if 声明，如果全部失败，最后执行 @else 声明，例如：\n\n```\n$type: monster;\np {\n  @if $type == ocean {\n    color: blue;\n  } @else if $type == matador {\n    color: red;\n  } @else if $type == monster {\n    color: green;\n  } @else {\n    color: black;\n  }\n}\n```\n\n编译为\n\n```\np {\n  color: green; }\n```\n\n### 8.3. @for\n\n@for 指令可以在限制的范围内重复输出格式，每次按要求（变量的值）对输出结果做出变动。这个指令包含两种格式：@for $var from <start> through <end>，或者 @for $var from <start> to <end>，区别在于 through 与 to 的含义：当使用 through 时，条件范围包含 <start> 与 <end> 的值，而使用 to 时条件范围只包含 <start> 的值不包含 <end> 的值。另外，$var 可以是任何变量，比如 $i；<start> 和 <end> 必须是整数值。\n\n```\n@for $i from 1 through 3 {\n  .item-#{$i} { width: 2em * $i; }\n}\n```\n\n编译为\n\n```\n.item-1 {\n  width: 2em; }\n.item-2 {\n  width: 4em; }\n.item-3 {\n  width: 6em; }\n```\n\n### 8.4. @each\n\n@each 指令的格式是 $var in <list>, $var 可以是任何变量名，比如 $length 或者 $name，而 <list> 是一连串的值，也就是值列表。\n\n@each 将变量 $var 作用于值列表中的每一个项目，然后输出结果，例如：\n\n```\n@each $animal in puma, sea-slug, egret, salamander {\n  .#{$animal}-icon {\n    background-image: url('/images/#{$animal}.png');\n  }\n}\n```\n\n编译为\n\n```\n.puma-icon {\n  background-image: url('/images/puma.png'); }\n.sea-slug-icon {\n  background-image: url('/images/sea-slug.png'); }\n.egret-icon {\n  background-image: url('/images/egret.png'); }\n.salamander-icon {\n  background-image: url('/images/salamander.png'); }\n```\n\n#### 8.4.1 Multiple Assignment\n\nThe @each directive can also use multiple variables, as in @each $var1, $var2, ... in . If is a list of lists, each element of the sub-lists is assigned to the respective variable. For example:\n\n```\n@each $animal, $color, $cursor in (puma, black, default),\n                                  (sea-slug, blue, pointer),\n                                  (egret, white, move) {\n  .#{$animal}-icon {\n    background-image: url('/images/#{$animal}.png');\n    border: 2px solid $color;\n    cursor: $cursor;\n  }\n}\n```\n\nis compiled to:\n\n```\n.puma-icon {\n  background-image: url('/images/puma.png');\n  border: 2px solid black;\n  cursor: default; }\n.sea-slug-icon {\n  background-image: url('/images/sea-slug.png');\n  border: 2px solid blue;\n  cursor: pointer; }\n.egret-icon {\n  background-image: url('/images/egret.png');\n  border: 2px solid white;\n  cursor: move; }\n```\n\nSince maps are treated as lists of pairs, multiple assignment works with them as well. For example:\n\n```\n@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) {\n  #{$header} {\n    font-size: $size;\n  }\n}\n```\n\nis compiled to:\n\n```\nh1 {\n  font-size: 2em; }\nh2 {\n  font-size: 1.5em; }\nh3 {\n  font-size: 1.2em; }\n```\n\n### 8.5. @while\n\n@while 指令重复输出格式直到表达式返回结果为 false。这样可以实现比 @for 更复杂的循环，只是很少会用到。例如：\n\n```\n$i: 6;\n@while $i > 0 {\n  .item-#{$i} { width: 2em * $i; }\n  $i: $i - 2;\n}\n\n.item-6 {\n  width: 12em; }\n\n.item-4 {\n  width: 8em; }\n\n.item-2 {\n  width: 4em; }\n```\n\n## 9. 混合指令 (Mixin Directives)\n\n混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 .float-left。混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。\n\n### 9.1. 定义混合指令 @mixin (Defining a Mixin: @mixin)\n\n混合指令的用法是在 @mixin 后添加名称与样式，比如名为 large-text 的混合通过下面的代码定义：\n\n```\n@mixin large-text {\n  font: {\n    family: Arial;\n    size: 20px;\n    weight: bold;\n  }\n  color: #ff0000;\n}\n```\n\n混合也需要包含选择器和属性，甚至可以用 & 引用父选择器：\n\n```\n@mixin clearfix {\n  display: inline-block;\n  &:after {\n    content: \".\";\n    display: block;\n    height: 0;\n    clear: both;\n    visibility: hidden;\n  }\n  * html & { height: 1px }\n}\n```\n\n### 9.2. 引用混合样式 @include (Including a Mixin: @include)\n\n使用 @include 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）：\n\n```\n.page-title {\n  @include large-text;\n  padding: 4px;\n  margin-top: 10px;\n}\n```\n\n编译为\n\n```\n.page-title {\n  font-family: Arial;\n  font-size: 20px;\n  font-weight: bold;\n  color: #ff0000;\n  padding: 4px;\n  margin-top: 10px; }\n```\n\n也可以在最外层引用混合样式，不会直接定义属性，也不可以使用父选择器。\n\n```\n@mixin silly-links {\n  a {\n    color: blue;\n    background-color: red;\n  }\n}\n@include silly-links;\n```\n\n编译为\n\n```\na {\n  color: blue;\n  background-color: red; }\n```\n\n混合样式中也可以包含其他混合样式，比如\n\n```\n@mixin compound {\n  @include highlighted-background;\n  @include header-text;\n}\n@mixin highlighted-background { background-color: #fc0; }\n@mixin header-text { font-size: 20px; }\n```\n\n混合样式中应该只定义后代选择器，这样可以安全的导入到文件的任何位置。\n\n### 9.3. 参数 (Arguments)\n\n参数用于给混合指令中的样式设定变量，并且赋值使用。在定义混合指令的时候，按照变量的格式，通过逗号分隔，将参数写进圆括号里。引用指令时，按照参数的顺序，再将所赋的值对应写进括号：\n\n```\n@mixin sexy-border($color, $width) {\n  border: {\n    color: $color;\n    width: $width;\n    style: dashed;\n  }\n}\np { @include sexy-border(blue, 1in); }\n```\n\n编译为\n\n```\np {\n  border-color: blue;\n  border-width: 1in;\n  border-style: dashed; }\n```\n\n混合指令也可以使用给变量赋值的方法给参数设定默认值，然后，当这个指令被引用的时候，如果没有给参数赋值，则自动使用默认值：\n\n```\n@mixin sexy-border($color, $width: 1in) {\n  border: {\n    color: $color;\n    width: $width;\n    style: dashed;\n  }\n}\np { @include sexy-border(blue); }\nh1 { @include sexy-border(blue, 2in); }\n```\n\n编译为\n\n```\np {\n  border-color: blue;\n  border-width: 1in;\n  border-style: dashed; }\n\nh1 {\n  border-color: blue;\n  border-width: 2in;\n  border-style: dashed; }\n```\n\n#### 9.3.1. 关键词参数 (Keyword Arguments)\n\n混合指令也可以使用关键词参数，上面的例子也可以写成：\n\n```\np { @include sexy-border($color: blue); }\nh1 { @include sexy-border($color: blue, $width: 2in); }\n```\n\n虽然不够简明，但是阅读起来会更方便。关键词参数给函数提供了更灵活的接口，以及容易调用的参数。关键词参数可以打乱顺序使用，如果使用默认值也可以省缺，另外，参数名被视为变量名，下划线、短横线可以互换使用。\n\n#### 9.3.2. 参数变量 (Variable Arguments)\n\n有时，不能确定混合指令需要使用多少个参数，比如一个关于 box-shadow 的混合指令不能确定有多少个 'shadow' 会被用到。这时，可以使用参数变量 … 声明（写在参数的最后方）告诉 Sass 将这些参数视为值列表处理：\n\n```\n@mixin box-shadow($shadows...) {\n  -moz-box-shadow: $shadows;\n  -webkit-box-shadow: $shadows;\n  box-shadow: $shadows;\n}\n.shadows {\n  @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);\n}\n```\n\n编译为\n\n```\n.shadowed {\n  -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;\n  -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;\n  box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;\n}\n```\n\n参数变量也可以用在引用混合指令的时候 (@include)，与平时用法一样，将一串值列表中的值逐条作为参数引用：\n\n```\n@mixin colors($text, $background, $border) {\n  color: $text;\n  background-color: $background;\n  border-color: $border;\n}\n$values: #ff0000, #00ff00, #0000ff;\n.primary {\n  @include colors($values...);\n}\n```\n\n编译为\n\n```\n.primary {\n  color: #ff0000;\n  background-color: #00ff00;\n  border-color: #0000ff;\n}\n```\n\n    You can use variable arguments to wrap a mixin and add additional styles without changing the argument signature of the mixin. If you do so, even keyword arguments will get passed through to the wrapped mixin. For example:\n\n```\n@mixin wrapped-stylish-mixin($args...) {\n  font-weight: bold;\n  @include stylish-mixin($args...);\n}\n.stylish {\n  // The $width argument will get passed on to \"stylish-mixin\" as a keyword\n  @include wrapped-stylish-mixin(#00ff00, $width: 100px);\n}\n```\n\n上面注释内的意思是：$width 参数将会传递给 stylish-mixin 作为关键词。\n\n### 9.4. 向混合样式中导入内容 (Passing Content Blocks to a Mixin)\n\n在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 @content 标志的地方：\n\n```\n@mixin apply-to-ie6-only {\n  * html {\n    @content;\n  }\n}\n@include apply-to-ie6-only {\n  #logo {\n    background-image: url(/logo.gif);\n  }\n}\n```\n\n编译为\n\n```\n* html #logo {\n  background-image: url(/logo.gif);\n}\n```\n\n为便于书写，@mixin 可以用 = 表示，而 @include 可以用 + 表示，所以上面的例子可以写成：\n\n```\n=apply-to-ie6-only\n  * html\n    @content\n\n+apply-to-ie6-only\n  #logo\n    background-image: url(/logo.gif)\n```\n\n注意： 当 @content 在指令中出现过多次或者出现在循环中时，额外的代码将被导入到每一个地方。\n\n#### 9.4.1. Variable Scope and Content Blocks\n\n    The block of content passed to a mixin are evaluated in the scope where the block is defined, not in the scope of the mixin. This means that variables local to the mixin cannot be used within the passed style block and variables will resolve to the global value:\n\n```\n$color: white;\n@mixin colors($color: blue) {\n  background-color: $color;\n  @content;\n  border-color: $color;\n}\n.colors {\n  @include colors { color: $color; }\n}\n```\n\n编译为\n\n```\n.colors {\n  background-color: blue;\n  color: white;\n  border-color: blue;\n}\n```\n\n    Additionally, this makes it clear that the variables and mixins that are used within the passed block are related to the other styles around where the block is defined. For example:\n\n```\n#sidebar {\n  $sidebar-width: 300px;\n  width: $sidebar-width;\n  @include smartphone {\n    width: $sidebar-width / 3;\n  }\n}\n```\n\n## 10. 函数指令 (Function Directives)\n\nSass 支持自定义函数，并能在任何属性值或 Sass script 中使用：\n\n```\n$grid-width: 40px;\n$gutter-width: 10px;\n\n@function grid-width($n) {\n  @return $n * $grid-width + ($n - 1) * $gutter-width;\n}\n\n#sidebar { width: grid-width(5); }\n```\n\n编译为\n\n```\n#sidebar {\n  width: 240px; }\n```\n\n与 mixin 相同，也可以传递若干个全局变量给函数作为参数。一个函数可以含有多条语句，需要调用 @return 输出结果。\n\n自定义的函数也可以使用关键词参数，上面的例子还可以这样写：\n\n```\n#sidebar { width: grid-width($n: 5); }\n```\n\n建议在自定义函数前添加前缀避免命名冲突，其他人阅读代码时也会知道这不是 Sass 或者 CSS 的自带功能。\n\n自定义函数与 mixin 相同，都支持 variable arguments\n\n## 11. 输出格式 (Output Style)\n\nSass 默认的 CSS 输出格式很美观也能清晰反映文档结构，为满足其他需求 Sass 也提供了多种输出格式。\n\nSass 提供了四种输出格式，可以通过 :style option 选项设定，或者在命令行中使用 --style 选项。\n\n### 11.1. :nested\n\nNested （嵌套）样式是 Sass 默认的输出格式，能够清晰反映 CSS 与 HTML 的结构关系。选择器与属性等单独占用一行，缩进量与 Sass 文件中一致，每行的缩进量反映了其在嵌套规则内的层数。当阅读大型 CSS 文件时，这种样式可以很容易地分析文件的主要结构。\n\n```\n#main {\n  color: #fff;\n  background-color: #000; }\n  #main p {\n    width: 10em; }\n\n.huge {\n  font-size: 10em;\n  font-weight: bold;\n  text-decoration: underline; }\n```\n\n### 11.2. :expanded\n\nExpanded 输出更像是手写的样式，选择器、属性等各占用一行，属性根据选择器缩进，而选择器不做任何缩进。\n\n```\n#main {\n  color: #fff;\n  background-color: #000;\n}\n#main p {\n  width: 10em;\n}\n\n.huge {\n  font-size: 10em;\n  font-weight: bold;\n  text-decoration: underline;\n}\n```\n\n### 11.3. :compact\n\nCompact 输出方式比起上面两种占用的空间更少，每条 CSS 规则只占一行，包含其下的所有属性。嵌套过的选择器在输出时没有空行，不嵌套的选择器会输出空白行作为分隔符。\n\n```\n#main { color: #fff; background-color: #000; }\n#main p { width: 10em; }\n\n.huge { font-size: 10em; font-weight: bold; text-decoration: underline; }\n```\n\n### 11.4. :compressed\n\nCompressed 输出方式删除所有无意义的空格、空白行、以及注释，力求将文件体积压缩到最小，同时也会做出其他调整，比如会自动替换占用空间最小的颜色表达方式。\n\n```css\nmain{\n  color:#fff;\n  background-color:#000\n}\n#main p{\n  width:10em;\n}\n.huge{\n  font-size:10em;\n  font-weight:bold;\n  text-decoration:underline\n}\n```\n\n## 12. 拓展 Sass (Extending Sass)\n\nSass 提供了很多高级自定义功能，使用这些功能需要有良好的 Ruby 基础。\n\n### 12.1. 自定义 Sass 函数 (Defining Custom Sass Functions)\n\n通过 Ruby API 可以自定义 Sass 函数，具体请查看 source documentation。\n\n### 12.2. 存储缓存 (Cache Stores)\n\nSass caches parsed documents so that they can be reused without parsing them again unless they have changed. By default, Sass will write these cache files to a location on the filesystem indicated by :cache_location. If you cannot write to the filesystem or need to share cache across ruby processes or machines, then you can define your own cache store and set the:cache_store option. For details on creating your own cache store, please see the source documentation.\n\n### 12.3. 自定义导入 (Custom Importers)\n\nSass importers are in charge of taking paths passed to @import and finding the appropriate Sass code for those paths. By default, this code is loaded from the filesystem, but importers could be added to load from a database, over HTTP, or use a different file naming scheme than what Sass expects.\n\nEach importer is in charge of a single load path (or whatever the corresponding notion is for the backend). Importers can be placed in the :load_paths array alongside normal filesystem paths.\n\nWhen resolving an @import, Sass will go through the load paths looking for an importer that successfully imports the path. Once one is found, the imported file is used.\n\nUser-created importers must inherit from Sass::Importers::Base.\n\nSass中文网（Sass中国）©2017 - 友情链接 - 文章/教程征集\n反馈建议\n[sass](https://www.sass.hk/docs/)\n","children":[]}]},{"name":"黑白灰主题.md","path":"../guanruihua.github.io/CSS","data":"# 黑白灰主题\n\n```css\n-webkit-filter: grayscale(100%);\n-webkit-filter: grayscale(100%);\n-moz-filter: grayscale(100%);\n-ms-filter: grayscale(100%);\n-o-filter: grayscale(100%);\nfilter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);\n\n```\n","children":[]}]},{"name":"Data","path":"../guanruihua.github.io","data":"","children":[{"name":"Game.md","path":"../guanruihua.github.io/Data","data":"# Game\r\n\r\n## Minecraft\r\n\r\n### 模组\r\n\r\n- [RealisticCraft](https://modrinth.com/modpack/realisticcraft/version/1.0.2)\r\n","children":[]},{"name":"README.md","path":"../guanruihua.github.io/Data","data":"# [ruihuag](https://guanruihua.github.io/#/)\r\n\r\n<!-- ![](../__assets__/001.jpg) -->\r\n<!-- ![Metrics](https://metrics.lecoq.io/guanruihua?template=classic&isocalendar=1&languages=1&base=header%2C%20activity%2C%20community%2C%20repositories%2C%20metadata&base.indepth=false&base.hireable=false&base.skip=false&isocalendar=false&isocalendar.duration=half-year&languages=false&languages.limit=8&languages.threshold=0%25&languages.other=false&languages.colors=github&languages.sections=most-used&languages.indepth=false&languages.analysis.timeout=15&languages.categories=markup%2C%20programming&languages.recent.categories=markup%2C%20programming&languages.recent.load=300&languages.recent.days=14&config.timezone=Asia%2FShanghai) -->\r\n","children":[]},{"name":"_sidebar.md","path":"../guanruihua.github.io/Data","data":"* [Game](Game.md)\n* [书](书.md)\n* [像素](像素.md)\n* [其他](其他.md)\n* [动画](动画.md)\n* [单词](单词.md)\n* 图画\n  * [icons](图画/icons.md)\n  * [图标&Logo](图画/图标&Logo.md)\n  * [图片](图画/图片.md)\n  * [图画工具](图画/图画工具.md)\n  * [海报](图画/海报.md)\n  * [画](图画/画.md)\n  * [矢量图](图画/矢量图.md)\n* [地图](地图/index.md)\n  * [home](地图/index.md)\n* [多种素材](多种素材.md)\n* [娱乐](娱乐.md)\n* [字体](字体.md)\n* [工具](工具.md)\n* [插件](插件.md)\n* [数据](数据.md)\n* 文件\n  * [markdown](文件/markdown.md)\n  * [pdf](文件/pdf.md)\n* 模型\n  * [资源](模型/资源.md)\n* [浏览器](浏览器.md)\n* [色彩](色彩.md)\n* [虚拟号码](虚拟号码.md)\n* [视频](视频.md)\n* [课程](课程.md)\n* [软件](软件.md)\n* [镜像](镜像.md)\n* [音乐](音乐.md)\n","children":[]},{"name":"书.md","path":"../guanruihua.github.io/Data","data":"# 书\n\n<https://www.ituring.com.cn/>\n\n[Jiumo Search 鸠摩搜索 - 文档搜索引擎 (jiumodiary.com)](https://www.jiumodiary.com/)\n\n[免费的编程中文书籍索引](https://github.com/justjavac/free-programming-books-zh_CN)\n\n[书格](https://new.shuge.org/)\n\n- 古籍\n","children":[]},{"name":"像素.md","path":"../guanruihua.github.io/Data","data":"# 像素\n\n> <http://www.gmkiss.com/>\n","children":[]},{"name":"其他.md","path":"../guanruihua.github.io/Data","data":"# 其他\n\n[世界统计 - 实时世界统计 (worldometers.info)](https://www.worldometers.info/)\n","children":[]},{"name":"动画.md","path":"../guanruihua.github.io/Data","data":"# 动画\n\n> - [AutoDraw](https://www.autodraw.com/): 在线画图\n> - [Get Waves – Create SVG waves for your next design](https://getwaves.io/): 波浪\n> - [CSS Section Separator Generator | wweb.dev](https://wweb.dev/resources/css-separator-generator/) : 分段分离特效\n> - [cubic-bezier(.73,.2,.36,.85) ✿ cubic-bezier.com](https://cubic-bezier.com/#.73,.2,.36,.85): 曲线\n> - [Codrops | Creative front-end resources and inspiration for web professionals (tympanus.net)](https://tympanus.net/codrops/)\n> - [Animate.css](https://animate.style/) 开箱即用的跨浏览器 CSS 动画效果\n> - [animista](http://animista.net/) 按需定制 CSS 动画效果\n> - [CSSeffectsSnippets](https://emilkowalski.github.io/css-effects-snippets/) CSS 动画效果收集，点击某个效果即可复制相应的代码片段至剪贴板\n> - [SpinKit](https://tobiasahlin.com/spinkit/) 汇集了实现各种加载效果的 CSS 代码片段\n","children":[]},{"name":"单词.md","path":"../guanruihua.github.io/Data","data":"# 常用单词\r\n\r\n## 导航类\r\n\r\n- 导航：nav 主导航：mainBav 子导航：subBav 顶导航：topNav\r\n- 边导航：sidebar 左导航：leftSidebar 右导航：rightSidebar 菜单：menu\r\n- 子菜单：submenu 标题：title 摘要：summary\r\n\r\n## 页面结构\r\n\r\n- 容器：container 页头：header 内容：content/container 页面主体：main\r\n- 页尾：footer 导航：nav 侧栏：sidebar 栏目：column\r\n- 页面外围控制整体布局宽度：wrapper 左右中：left right center\r\n\r\n## 功能\r\n\r\n- 标志：logo 滚动：scroll 广告：banner 标签页：tab\r\n- 登录：login 文章列表：list 登录条：loginBar 提示信息：msg\r\n- 注册：register 当前的：current 搜索：search 小技巧：tips\r\n- 功能区：shop 图标：icon 标题：title 注释：note\r\n- 加入：joinUs 指南：guild 状态：status 服务：service\r\n- 按钮：btn 热点：hot 合作伙伴：partner 新闻：news\r\n- 友情链接：friendLink 下载：download 版权：copyright 投票：vote\r\n\r\n## div英文释译\r\n\r\n- 标题 title 字体 font 身体 body 大小 size\r\n- 列表 list 文本 text 样式 style 对齐 align\r\n- 图像 image 修饰 decoration 资源 source 线 line\r\n- 宽度 width 穿过 through 高度 height 缩进 indent\r\n- 行 line 斜体 italic 链接 link 加粗 bold\r\n- 斜体 italic 加重 weight 加粗 bold 宽 width\r\n- 输入 input 高 height 下面的 under 背景 background\r\n- 顶部 top 主体 main\r\n\r\n## css英文释译\r\n\r\n- 重复 repeat 填充 padding 位置 position 正常 normal\r\n- 显示类型 display 父级 parent 显示可见 visibility 子级 children\r\n- 隐藏 hidden 顶部导航topNav显示 visible 溢出 overflow\r\n- 列表 list 样式 style 边框 border 导航 nav\r\n- 广告图片 banner 行高line-height边界 margin 页眉 header\r\n\r\n## 样式文件命名\r\n\r\n- 主要的master.css 模块module.css 基本共用base.css 布局，版面layout.css\r\n- 主题themes.css 专栏columns.css 文字font.css 表单forms.css\r\n- 补丁mend.css 打印print.css\r\n\r\n## 颜色释译\r\n\r\n- 绿 green 红 red 蓝 blue 黑 black\r\n- 灰 gray 黄 yellow 紫 purple 白 white\r\n- 棕 brown 卡其色 khaki\r\n\r\n## 命名参考\r\n\r\n- 登录条loginBar 标志：logo 侧边栏：sideBar 广告：banner\r\n- 导航：nav 子导航：navBar 菜单：menu 子菜单：subMenu\r\n- 搜索：search 滚动：scroll 页面主体：main 内容：content\r\n- 标签页：tab 文章列表：list 提示信息：msg 小技巧：tips\r\n- 栏目标题：title 加入：joins 指南：guild 服务：service\r\n- 热点：hot 新闻：news 按钮：btn 投票：vote\r\n- 状态：status 合作伙伴：partner 外套：wrap 商标：label\r\n- 顶导航：topNav 左导航：leftSideBar 右导航：rightSideBar菜单内容：menuContent\r\n- 菜单容器：menuContainer注释：note 边导航图标：sidebarIcon版权：copyright\r\n- 友情链接：friendLink容器：container 页脚：footer 当前：current\r\n- 激活：active 购物车：shop 登录：login 注册：register\r\n- 下载：download 面包屑：breadCrumb\r\n","children":[]},{"name":"图画","path":"../guanruihua.github.io/Data","data":"","children":[{"name":"icons.md","path":"../guanruihua.github.io/Data/图画","data":"# icons\r\n\r\n[iconfont-阿里巴巴矢量图标库](https://www.iconfont.cn/)\r\n\r\n<https://unicornicons.com/icons>\r\n<https://www.aigei.com/s?q=%E6%96%87%E4%BB%B6%E5%A4%B9&type=design_icon>\r\n\r\n[GIF, SVG, APNG loading animations](https://icons8.com/preloaders/en/7/2/loading)\r\n\r\n## 生成 icons\r\n\r\n<https://www.logosc.cn/logo/favicon?s>=\r\n\r\n[loading.io](https://loading.io/)\r\n","children":[]},{"name":"图标&Logo.md","path":"../guanruihua.github.io/Data/图画","data":"# 图标 & logo\r\n","children":[]},{"name":"图片.md","path":"../guanruihua.github.io/Data/图画","data":"# 图片网站\n\n## 画\n\n名画\n\n- <https://useum.org/download-artworks/free-smartphone-wallpapers>\n- <https://useum.org/download-artworks/free-laptop-wallpapers>\n\n## 图片\n\n> [动态图片生成](https://dummyimage.com/)\n>\n> [免费正版高清图片素材库 超过2.3百万张优质图片和视频素材可供免费使用和下载 - Pixabay](https://pixabay.com/zh/)\n>\n> [Wallpaper Abyss - 高清壁纸, 桌面背景 (alphacoders.com)](https://wall.alphacoders.com/?lang=Chinese)\n>\n> [Samsung Wallpaper Gallery S8 HD for Android - Free Download - Page 9 (wallpapershome.com)](https://wallpapershome.com/download-wallpapers/samsung/?page=9)\n>\n> - [Unsplash](https://unsplash.com/) 可供免费使用的图片\n> - [Pexels](https://www.pexels.com/) 精美的免费图片和视频\n> - [Burst](https://burst.shopify.com/) 免费高分辨率图片，可用于网站和商业用途\n> - [ISO Republic](https://isorepublic.com/) 使用 CC0 许可的免费高分辨率图片和视频\n> - [Pixabay](https://pixabay.com/) 令人惊叹的免费（公共领域）图片和视频站点\n> - [StockSnap.io](https://stocksnap.io/) 精美的免费图片，同样使用 CC0 许可\n> - [Photopea](https://www.photopea.com/) 在线图片编辑工具，支持大量高级功能\n> - [Online Image Compressor](https://imagecompressor.com/) 在线图片压缩工具，一次可以压缩多达 20 张图片\n> - [Bulk Resize Photos](https://bulkresizephotos.com/en) 最快的在线图片缩放工具（图片缩放和压缩在本地完成，无需上传到服务器）\n\n1.FOCA\n<https://focastock.com/>\n\n2.SkitterPhoto\n<https://skitterphoto.com/>\n\n3.Life Of Pix\n<https://www.lifeofpix.com/>\n\n4.Image Finder\n<https://imagefinder.co/>\n\n5.Splitshire\nwww.splitshire.com\n\n6.Foodiesfeed\n<https://www.foodiesfeed.com/>\n\n7.stocksnap\n<https://stocksnap.io/>\n\n8.Pxhere‍\n<https://pxhere.com/>‍\n\n9.Pixabay\n<https://pixabay.com/>\n\n10.Reshot\n<https://www.reshot.com/>\n\n11.OnTap\n<https://on.thisistap.com/stock-images>\n\n12.Magdeleine\n<https://magdeleine.co/>\n\n13.Freeimages\nwww.freeimages.co.uk\n\n14.Brust\n<https://burst.shopify.com/>\n\n15.StyleStock\n<https://styledstock.co/>\n\n16.Gratisography\n<https://gratisography.com/>\n\n17.streetwill\n<http://streetwill.co/>\n\n18.New Old Stock\n<https://nos.twnsnd.co/>\n\n19.Isorepublic\n<https://isorepublic.com/>\n\n20.Resplashed\n<https://wunderstock.com/>\n\n21.FreePhotos.cc\n<https://freephotos.cc>\n\n22.Picography\n<https://picography.co/>\n\n23.Freestocks\nfreestocks.org\n\n24.Jaymantri\n<https://jaymantri.com/>\n\n25.Sozai Page\n<http://www.sozai-page.com>\n\n26.photoAC\n<https://photo-ac.com/>\n\n27.無料写真素材\n<http://freephoto.bizutart.com>\n\n28.Food.foto\n<https://food.foto.ne.jp>\n\n29.modelfoto\n<https://model-foto.jp/>\n\n30.Retro Vectors\n<http://retrovectors.com/category/free-vectors>\n","children":[]},{"name":"图画工具.md","path":"../guanruihua.github.io/Data/图画","data":"# 图画工具\r\n\r\n## 改图鸭\r\n\r\n[改图鸭](https://www.gaituya.com/?ckt0821)\r\n\r\n- 图片压缩\r\n- 图片转换\r\n- 图片转文字\r\n- 图片改大小\r\n- 修改分辨率\r\n- 老照片修复\r\n- 图片编辑\r\n- 图片加水印\r\n- 图片变漫画\r\n- 图片特效\r\n\r\n## AI人工智能图片放大\r\n\r\n[AI人工智能图片放大](https://bigjpg.com/)\r\n","children":[]},{"name":"海报.md","path":"../guanruihua.github.io/Data/图画","data":"# 海报\r\n\r\n## 模板\r\n\r\n[创客贴](https://www.chuangkit.com/adlp/haibaolp.html?utm_source=%E7%9F%A5%E4%B9%8E%E5%86%85%E5%AE%B9&utm_medium=&utm_campaign=wz&utm_content=20030360&utm_term=)\r\n[Canvas可画](https://www.canva.cn/templates/)\r\n\r\n- 小红书模板\r\n","children":[]},{"name":"画.md","path":"../guanruihua.github.io/Data/图画","data":"","children":[]},{"name":"矢量图.md","path":"../guanruihua.github.io/Data/图画","data":"# 矢量图\r\n\r\n## 适量半色制作器\r\n\r\n[Vector Halftone Maker](https://halftone.xoihazard.com/)\r\n","children":[]}]},{"name":"地图","path":"../guanruihua.github.io/Data","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Data/地图","data":"# 地图数据\r\n\r\n> - [GeoJSON Maps of the globe](https://geojson-maps.ash.ms/)\r\n> - [地理空间分析工具](https://kepler.gl/)\r\n","children":[]}]},{"name":"多种素材.md","path":"../guanruihua.github.io/Data","data":"# 多种素材\n\n> [Download Sample Videos / Dummy Videos For Demo Use (sample-videos.com)](https://sample-videos.com/index.php#sample-mp4-video)\n","children":[]},{"name":"娱乐.md","path":"../guanruihua.github.io/Data","data":"# 娱乐\n\n## 视频\n\n## 表情包\n\n> [表情包制作](http://gif.zhiniao.com.cn/content/634.html)\n","children":[]},{"name":"字体.md","path":"../guanruihua.github.io/Data","data":"# 字体网站\n\n> [100font.com - 免版权字体下载、免费商用字体下载网站](https://www.100font.com/)\n>\n> [字体下载-求字体网提供中文和英文字体库下载、识别与预览服务，找字体的好帮手 (qiuziti.com)](https://www.qiuziti.com/)\n","children":[]},{"name":"工具.md","path":"../guanruihua.github.io/Data","data":"# 工具\n\n## 网页相关\n\n> [UserAgent](https://www.ip138.com/useragent/)\n> [shotcut](https://www.shotcut.org/) 剪辑视频\n> [](https://www.ipaddress.com/)\n\n## 可访问性\n\n- [NV Access](https://www.nvaccess.org/) Windows 平台下的屏幕阅读器\n- [ChromeVox Chrome Extension](https://chrome.google.com/webstore/detail/chromevox/kgejglhpjiefppelpmljglcjbhoiplfn) Google 出品的 Chrome 屏幕阅读插件\n- [axe Chrome Extension](https://chrome.google.com/webstore/detail/axe/lhdoppojpmngadmnindnejefpokejbdd) 给 Chrome 开发者工具增加可访问性测试的插件\n\n## 科学上网\n\n> [大机场](https://xn--mesr8b36x.net/#/login)\n> [快橙](https://content.hmeic.com/preland/binom_directtest?click_id=tXiCLWODWH4&zone_id=12253895813&source=Binom&app=Desktop&trafficSource=ActiveRevenue&platform=Desktop&campaign_name=Zeroclick)\n\n## 其他\n\n- [图片在线转换base64编码-在线base64编码转换成图片工具](http://www.jsons.cn/img2base64/)\n\n- [web.dev](https://web.dev/measure/) 评测网站性能（基于 Lighthouse）\n- [Shape Divider](https://www.shapedivider.app/) 定制各种形状的网站分区 SVG 的工具\n- [GTmetrix](https://gtmetrix.com/) 网页性能分析工具\n- [Can I Use](https://caniuse.com/) 前端技术的浏览器支持情况\n- [Carbon](https://carbon.now.sh/) 代码转图片工具\n- [Wappalyzer](https://www.wappalyzer.com/) 检测某个网站使用的技术栈\n\n## 软件\n\n> - uTools ： 工具合集\n> - autohotKey ： 自定义快捷键(热键等)\n> - deskpins ： 屏幕置顶\n> - potplayer ： 播放器\n> - 7z ： 压缩工具\n> - QTTabBar ：文件资源增强器\n> - Snipaste ：截图工具\n> - [PowerToys](https://github.com/microsoft/PowerToys/releases/)\n> - [Mouse without Borders](https://www.microsoft.com/en-us/download/confirmation.aspx?id=35460) : 一套键鼠控制 多个windows电脑\n\n## 浏览器插件\n\n> [极简插件_Chrome扩展插件商店_优质crx应用 (zzzmh.cn)](https://chrome.zzzmh.cn/)\n\n## 文件转换\n\n> [PDF转Word](http://www.pdfdo.com/pdf-to-word.aspx)\n\n## 工具软件\n\n> [下载4k应用 | 4K Download](https://www.4kdownload.com/zh-cn/downloads)\n> [下载视频网站 硕鼠](https://www.flvcd.com/index.htm)\n> [视频下载](https://www.videofk.com/)\n\n## 软件激活\n\n> [jetbrains 激活](https://www.macwk.com/article/jetbrains-crack)\n\n## 梯子\n\n> [Clash.for.Windows.7z](https://clo8ud.lanzoui.com/itgf5i2dwxi)\n> <https://xn--mesr8b36x.com/#/login>\n> <https://xn--mesr8b36x.net/#/login>\n>\n## 前端在线编辑工具\n\n> - [CodePen](https://codepen.io/trending) : 在线编辑\n> - [StackBlitz](https://stackblitz.com/): 在线编辑(多语言)\n> - [兼容性查看](https://www.caniuse.com/?search=console)\n> - [获取框架包](https://www.bootcdn.cn/)\n\n## 设计\n\n> [切图,UI 布局推荐](https://juejin.cn/post/6979821352576352269)\n","children":[]},{"name":"插件.md","path":"../guanruihua.github.io/Data","data":"# 插件\n\n## 浏览器插件\n\n> [Chrome](https://www.extfans.com/)\n","children":[]},{"name":"数据.md","path":"../guanruihua.github.io/Data","data":"# API\r\n\r\n## OMDb\r\n\r\nOMDb API: <http://www.omdbapi.com/?i=tt3896198&apikey=16f467aa>\r\n\r\nClick the following URL to activate your key: <http://www.omdbapi.com/apikey.aspx?VERIFYKEY=3e37538d-046a-48d8-93e2-5fe8f5cd262c>\r\nIf you did not make this request, please disregard this email.\r\n\r\n## 梗百科\r\n\r\napi:<https://bili.imba97.cn/ji.php?kw>=恶臭\r\n\r\n## 随机图片\r\n\r\n> <https://source.unsplash.com/>\r\n> [动态图片](https://dummyimage.com/)\r\n> 随机不同图片的: <http://placekitten.com/>\r\n>\r\n> - <http://placekitten.com/300/300> => 获得一张300*300的图片\r\n\r\n## 虚拟接口\r\n\r\n> - [jsonplaceholder.typicode.com/users](http://jsonplaceholder.typicode.com/users)\r\n>   - 使用指导 [JSONPlaceholder - Guide (typicode.com)](http://jsonplaceholder.typicode.com/guide/)\r\n> - [Daily Forecast 16 Days - OpenWeatherMap](https://openweathermap.org/forecast16) : 获取16天的天气\r\n> - [OMDb API - The Open Movie Database](https://www.omdbapi.com/)\r\n> - [Open Trivia DB: Free to use, user-contributed trivia question database. (opentdb.com)](https://opentdb.com/api_config.php)\r\n\r\n## 翻译\r\n\r\n<http://fanyi.youdao.com/translate?&doctype=json&type=AUTO&i>=计算\r\n\r\n```json\r\n{\r\n    \"type\": \"ZH_CN2EN\",\r\n    \"errorCode\": 0,\r\n    \"elapsedTime\": 1,\r\n    \"translateResult\": [\r\n        [\r\n            {\r\n                \"src\": \"计算\",\r\n                \"tgt\": \"To calculate\"\r\n            }\r\n        ]\r\n    ]\r\n}\r\n```\r\n\r\ntype的类型有：\r\n\r\n```\r\nZH_CN2EN 中文　»　英语\r\nZH_CN2JA 中文　»　日语\r\nZH_CN2KR 中文　»　韩语\r\nZH_CN2FR 中文　»　法语\r\nZH_CN2RU 中文　»　俄语\r\nZH_CN2SP 中文　»　西语\r\nEN2ZH_CN 英语　»　中文\r\nJA2ZH_CN 日语　»　中文\r\nKR2ZH_CN 韩语　»　中文\r\nFR2ZH_CN 法语　»　中文\r\nRU2ZH_CN 俄语　»　中文\r\nSP2ZH_CN 西语　»　中文\r\n```\r\n","children":[]},{"name":"文件","path":"../guanruihua.github.io/Data","data":"","children":[{"name":"markdown.md","path":"../guanruihua.github.io/Data/文件","data":"# Markdown\r\n\r\n## 图\r\n\r\n### 流程图\r\n\r\n#### 横向流程图\r\n\r\n```mermaid\r\ngraph LR\r\nA[方形] -->B(圆角)\r\n    B --> C{条件a}\r\n    C -->|a=1| D[结果1]\r\n    C -->|a=2| E[结果2]\r\n    F[横向流程图]\r\n\r\n```\r\n\r\n#### 竖向流程图\r\n\r\n```mermaid\r\n\r\ngraph TD\r\n\r\nA[方形] -->B(圆角)\r\n\r\n    B --> C{条件a}\r\n\r\n    C -->|a=1| D[结果1]\r\n\r\n    C -->|a=2| E[结果2]\r\n\r\n    F[竖向流程图]\r\n\r\n```\r\n\r\n### 时序图\r\n\r\n#### 标准时序图\r\n\r\n```mermaid\r\n\r\n%% 时序图例子,-> 直线，-->虚线，->>实线箭头\r\n\r\n  sequenceDiagram\r\n\r\n    participant 张三\r\n\r\n    participant 李四\r\n\r\n    张三->王五: 王五你好吗？\r\n\r\n    loop 健康检查\r\n\r\n        王五->王五: 与疾病战斗\r\n\r\n    end\r\n\r\n    Note right of 王五: 合理 食物 <br/>看医生...\r\n\r\n    李四-->>张三: 很好!\r\n\r\n    王五->李四: 你怎么样?\r\n\r\n    李四-->王五: 很好!\r\n\r\n```\r\n\r\n## 数学表达式\r\n\r\n- 需要在TeX或LaTeX格式的数学公式前后添加$$来实现\r\n\r\n- 可以使用数学公式块 \"$$\" + 回车\r\n  - 快捷键: Ctrl + Shift +  m\r\n  - 点击 \"段落\" + \" 公式块\"\r\n\r\n- `$2^{2}$` : $2^{2}$\r\n\r\n$$ y(x) = \\begin{cases} \\sqrt\\frac{1}{x},x = 0\\\\ \\sqrt\\frac{2}{x}, x\\neq0 \\end{cases} $$\r\n\r\n| 上/下标  | x^2, y_2                              | $x^2,y_2$                                 |\r\n| -------- | ------------------------------------- | ----------------------------------------- |\r\n| 分式     | 1/2, \\frac{1}{2}                      | $1/2$, $ \\frac{1}{2}$                     |\r\n| 省略号   | \\cdots                                | $\\cdots$                                  |\r\n| 开根号   | \\sqrt{2}                              | $\\sqrt{2}$                                |\r\n| 矢量     | \\vec{a}                               | $\\vec{a}$                                 |\r\n| 积分     | \\int{x}dx, \\int_{1}^{2}{x}dx          | $\\int{x}dx$,$\\int_{1}^{2}{x}dx$           |\r\n| 极限     | \\lim{a+b}, \\lim_{n\\rightarrow+\\infty} | $\\lim{a+b}$, $\\lim_{n\\rightarrow+\\infty}$ |\r\n| 累加     | \\sum{a}, \\sum_{n=1}^{100}{a_n}        | $\\sum{a}$, $\\sum_{n=1}^{100}{a_n}$        |\r\n| 累乘     | \\prod{x},\\prod_{n=1}^{n=99}{x_n}      | $\\prod{x}$, $\\prod_{n=1}^{99}{x_n}$       |\r\n| 三角函数 | \\sin                                  | $\\sin$                                    |\r\n| 对数函数 | \\ln2, \\log_2^8, \\lg10                 | $\\ln2$, $\\log_2^8$,$\\lg10$                |\r\n\r\n### 关系运算符\r\n\r\n| 运算符   | Markdown |\r\n| -------- | -------- |\r\n| $\\pm$    | \\pm      |\r\n| $\\times$ | \\times   |\r\n| $\\cdot$  | \\cdot    |\r\n| $\\div$   | \\div     |\r\n| $\\neq$   | \\neq     |\r\n| $\\leq$   | \\leq     |\r\n| $\\geq$   | \\geq     |\r\n|          |          |\r\n\r\n### 其他特殊字符\r\n\r\n| 符号         | Markdown   |\r\n| ------------ | ---------- |\r\n| $\\forall$    | \\forall    |\r\n| $\\infty$     | \\infty     |\r\n| $\\emptyset$  | \\emptyset  |\r\n| $\\exists$    | \\exists    |\r\n| $\\nabla$     | \\nabla     |\r\n| $\\bot$       | \\bot       |\r\n| $\\angle$     | \\angle     |\r\n| $\\because$   | \\because   |\r\n| $\\therefore$ | \\therefore |\r\n| 空格         | \\quad      |\r\n|              |            |\r\n\r\n### 希腊字母\r\n\r\n| 大写     | Markdown | 小写          | Markdown    |\r\n| -------- | -------- | ------------- | ----------- |\r\n| $A$      | A        | $\\alpha$      | \\alpha      |\r\n| $B$      | B        | $\\beta$       | \\beta       |\r\n| $\\Gamma$ | \\Gamma   | $\\gamma$      | \\gamma      |\r\n| $\\Delta$ | \\Delta   | $\\delta$      | \\delta      |\r\n| $E$      | E        | $\\epsilon$    | \\epsilon    |\r\n|          |          | $\\varepsilon$ | \\varepsilon |\r\n| $Z$      | Z        | $\\zeta$       | \\zeta       |\r\n| $H$        | H        | $\\eta$     | \\eta     |\r\n| $\\Theta$   | \\Theta   | $\\theta$   | \\theta   |\r\n| $I$      | I        | $\\iota$    | \\iota    |\r\n| $K$      | K        | $\\kappa$   | \\kappa   |\r\n| $\\Lambda$  | \\Lambda  | $\\lambda$  | \\lambda  |\r\n| $M$      | M        | $\\mu$      | \\mu      |\r\n| $N$      | N        | $\\nu$      | \\nu      |\r\n| $\\Xi$      | \\Xi      | $\\xi$     | \\xi      |\r\n| $O$      | O        | $\\omicron$ | \\omicron |\r\n| $\\Pi$      | \\Pi      | $\\pi$      | \\pi      |\r\n| $P$      | P        | $\\rho$     | \\rho     |\r\n| $\\Sigma$   | \\Sigma   | $\\sigma$   | \\sigma   |\r\n| $T$      | T        | $\\tau$     | \\tau     |\r\n| $\\Upsilon$ | \\Upsilon | $\\upsilon$ | \\upsilon |\r\n| $\\Phi$     | \\Phi     | $\\phi$     | \\phi     |\r\n|            |          | $\\varphi$  | \\varphi  |\r\n| $X$      | X        | $\\chi$     | \\chi     |\r\n| $\\Psi$     | \\Psi     | $\\psi$     | \\psi     |\r\n| $\\Omega$   | \\Omega   | $\\omega$   | \\omega   |\r\n","children":[]},{"name":"pdf.md","path":"../guanruihua.github.io/Data/文件","data":"# pdf\r\n\r\n## 工具\r\n\r\n[Smallpdf](https://smallpdf.com/)\r\n","children":[]}]},{"name":"模型","path":"../guanruihua.github.io/Data","data":"","children":[{"name":"资源.md","path":"../guanruihua.github.io/Data/模型","data":"# 模型资源\r\n\r\n<https://www.cpengx.cn/1128.html>\r\n","children":[]}]},{"name":"浏览器.md","path":"../guanruihua.github.io/Data","data":"# 浏览器\r\n\r\n## 一键开启浏览器多线程下载\r\n\r\n- *Chrome 浏览器，地址栏输入并回车：`chrome://flags/#enable-parallel-downloading`*\r\n- *Edge 新版浏览器，地址栏输入并回车：`edge://flags/#enable-parallel-downloading`*\r\n","children":[]},{"name":"色彩.md","path":"../guanruihua.github.io/Data","data":"# 色彩\n\n- [Material Design Colors](https://www.materialui.co/colors) Material Design 色彩\n- [Flat UI Colors 2](https://flatuicolors.com/) 14 组配色、280 种颜色\n- [Color Hunt](https://colorhunt.co/) 分享色彩搭配的自由开放平台，包括成千上万人工选取的配色，可以从中获取配色的灵感\n- [Color Space](https://mycolor.space/) 配色方案、CSS 颜色渐变生成工具\n- [uiGradients](http://www.uigradients.com/) 美观的颜色渐变\n- [Colors and Fonts](https://colorsandfonts.com/) 色彩和字体工具\n- [Coolors](https://coolors.co/) 配色方案生成工具\n","children":[]},{"name":"虚拟号码.md","path":"../guanruihua.github.io/Data","data":"# 虚拟号码\n\n> [超级云短信-在线短信接收-Receive SMS (bfkdim.com)](http://www.bfkdim.com/)\n>\n> [Human-machine safety verification (receive-sms-free.cc)](https://receive-sms-free.cc/)\n>\n> [免费在线收短信 | 临时手机号码 (freesms-online.com)](https://freesms-online.com/zh)\n","children":[]},{"name":"视频.md","path":"../guanruihua.github.io/Data","data":"# 视频\n\n## 视频制作&修改\n\n> [Shotcup剪辑视频工具](https://www.shotcut.org/)\n\n## 通过台词找影片\n\n>\n> [33台词 - 通过台词找影片素材 (agilestudio.cn)](http://33.agilestudio.cn/)\n","children":[]},{"name":"课程.md","path":"../guanruihua.github.io/Data","data":"# 课程\r\n\r\n## libpku\r\n\r\n<https://lib-pku.github.io/>\r\n\r\n多门课程\r\n\r\n## 北大\r\n\r\n<https://github.com/tongtzeho/PKUCourse>\r\n\r\n北京大学信息学院计算机系 本科&研究生课程大作业选集\r\n计算概论（2011秋 大一上）：神奇翻转\r\n\r\n程序设计实习（2012春 大一下）：OpenJudge魔兽世界、Botzone四色地图\r\n\r\n计算机系统导论（2012秋 大二上）：Proxy Lab\r\n\r\n数据结构与算法实习（2012秋 大二上）：电梯模拟器、连连看、miniSQL\r\n\r\nJava程序设计（2013春 大二下）：网络爬虫\r\n\r\n微机实验（2013春 大二下）：双面贪吃蛇\r\n\r\n计算机组织与体系结构（2013秋 大三上）：指令级模拟及高级缓存模拟\r\n\r\n高级编译技术（2015秋 研一上）：三地址码到C代码翻译器及编译优化\r\n\r\n分布式系统概念与设计（2016春 研一下）：分布式PageRank\r\n\r\n## 清华\r\n\r\n<https://github.com/PKUanonym/REKCARC-TSC-UHT>\r\n\r\n## 浙大\r\n\r\n<https://link.zhihu.com/?target=https%3A//github.com/QSCTech/zju-icicles>\r\n\r\n## 中国科学技术大学\r\n\r\n<https://link.zhihu.com/?target=https%3A//github.com/USTC-Resource/USTC-Course>\r\n<https://ustc-resource.github.io/USTC-Course/>\r\n\r\n## 中山大学\r\n\r\n<https://github.com/sysuexam/SYSU-Exam>\r\n\r\n## Bilibili\r\n\r\n<https://github.com/elder-frog/OpenCourseCatalog>\r\n<https://space.bilibili.com/12721139>\r\n","children":[]},{"name":"软件.md","path":"../guanruihua.github.io/Data","data":"# 软件\r\n\r\n[破解软件](https://foxirj.com/)\r\n","children":[]},{"name":"镜像.md","path":"../guanruihua.github.io/Data","data":"# 镜像\n\n> [清华大学开源软件镜像站 | Tsinghua Open Source Mirror](https://mirrors.tuna.tsinghua.edu.cn/)\n","children":[]},{"name":"音乐.md","path":"../guanruihua.github.io/Data","data":"# 音乐\n\n> [音乐专辑下载](https://downloads.khinsider.com/)\n> [爱给网_音效配乐_3D模型_视频素材_游戏素材_免费下载 (aigei.com)](https://www.aigei.com/)\n>\n> [耳聆网 - 听见世界之美 - (声音分享云|音效素材库) (ear0.com)](https://www.ear0.com/)\n\n## 乐谱\n\n### 生日快乐\n\n![img](https://iknow-pic.cdn.bcebos.com/f3d3572c11dfa9ecad95962a6fd0f703918fc150?x-bce-process%3Dimage%2Fresize%2Cm_lfit%2Cw_600%2Ch_800%2Climit_1%2Fquality%2Cq_85%2Fformat%2Cf_jpg)\n\n# [卡农 钢琴数字简谱-C调初学简单版](https://www.xueqinji.com/2035.html)\n\n![卡农 钢琴数字简谱-C调初学简单版](https://www.xueqinji.com/wp-content/uploads/2021/04/01j-666x1024.jpg)\n\n![卡农 钢琴数字简谱-C调初学简单版](https://www.xueqinji.com/wp-content/uploads/2021/04/02j-666x1024.jpg)\n\n![卡农 钢琴数字简谱-C调初学简单版](https://www.xueqinji.com/wp-content/uploads/2021/04/03j-666x1024.jpg)\n","children":[]}]},{"name":"Database","path":"../guanruihua.github.io","data":"","children":[{"name":"MongoDB","path":"../guanruihua.github.io/Database","data":"","children":[{"name":"mongo.md","path":"../guanruihua.github.io/Database/MongoDB","data":"# Mongo\n\n## 查询\n\nfind方法,\n\ndb.collection_name.find(); \n\n查询所有的结果： \n\nselect * from users;\n\ndb.users.find();\n\n \n\n指定返回那些列（键）： \n\nselect name, skills from users;\n\ndb.users.find({}, {'name' : 1, 'skills' : 1}); \n\n补充说明： 第一个{} 放where条件 第二个{} 指定那些列显示和不显示 （0表示不显示 1表示显示)\n\n \n\nwhere条件： \n\n1.简单的等于: \n\nselect name, age, skills from users where name = 'hurry'; \n\ndb.users.find({'name' : 'hurry'},{'name' : 1, 'age' : 1, 'skills' : 1});\n\n \n\n2.使用and \n\nselect name, age, skills from users where name = 'hurry' and age = 18; \n\ndb.users.find({'name' : 'hurry', 'age' : 18},{'name' : 1, 'age' : 1, 'skills' : 1});\n\n \n\n3.使用or \n\nselect name, age, skills from users where name = 'hurry' or age = 18; \n\ndb.users.find({ '$or' : [{'name' : 'hurry'}, {'age' : 18}] },{'name' : 1, 'age' : 1, 'skills' : 1});\n\n \n\n4.<, <=, >, >= ($lt, $lte, $gt, $gte ) \n\nselect * from users where age >= 20 and age <= 30; \n\ndb.users.find({'age' : {'$gte' : 20, '$lte' : 30}});\n\n \n\n5.使用in, not in ($in, $nin) \n\nselect * from users where age in (10, 22, 26); \n\ndb.users.find({'age' : {'$in' : [10, 22, 26]}});\n\n \n\n6.匹配null \n\nselect * from users where age is null; \n\ndb.users.find({'age' : null);\n\n \n\n7.like (mongoDB 支持正则表达式) \n\nselect * from users where name like \"%hurry%\"; \n\ndb.users.find({name:/hurry/}); \n\n \n\nselect * from users where name like \"hurry%\"; \n\ndb.users.find({name:/^hurry/}); \n\n \n\n8.使用distinct \n\nselect distinct (name) from users; \n\ndb.users.distinct('name');\n\n \n\n9.使用count \n\nselect count(*) from users; \n\ndb.users.count(); \n\n \n\n10.数组查询 （mongoDB自己特有的） \n\n如果skills是 ['java','python'] \n\ndb.users.find({'skills' : 'java'}); 该语句可以匹配成功 \n\n \n\n$all \n\ndb.users.find({'skills' : {'$all' : ['java','python']}}) skills中必须同时包含java 和 python \n\n \n\n$size \n\ndb.users.find({'skills' : {'$size' : 2}}) 遗憾的是$size不能与$lt等组合使用\n\n \n\n$slice \n\ndb.users.find({'skills' : {'$slice : [1,1]}}) \n\n两个参数分别是偏移量和返回的数量\n\n \n\n11.查询内嵌文档 \n\n12.强大的$where查询\n\ndb.foo.find();          \n\n{ \"_id\" : ObjectId(\"4e17ce0ac39f1afe0ba78ce4\"), \"a\" : 1, \"b\" : 3, \"c\" : 10 }\n\n{ \"_id\" : ObjectId(\"4e17ce13c39f1afe0ba78ce5\"), \"a\" : 1, \"b\" : 6, \"c\" : 6 } \n\n如果要查询 b = c 的文档怎么办？ \n\n\\> db.foo.find({\"$where\":function(){\n\n  for(var current in this){\n\n​    for(var other in this){\n\n​      if(current != other && this[current] == this[other]){\n\n​        return true;   \n\n​      }\n\n​    }\n\n  }\n\n  return false; \n\n}}); \n\n \n\n{ \"_id\" : ObjectId(\"4e17ce13c39f1afe0ba78ce5\"), \"a\" : 1, \"b\" : 6, \"c\" : 6 } \n\n \n\n1 ) . 大于，小于，大于或等于，小于或等于\n\n$gt:大于\n\n$lt:小于\n\n$gte:大于或等于\n\n$lte:小于或等于\n\n例子：\n\ndb.collection.find({ \"field\" : { $gt: value } } ); // greater than : field > value\n\ndb.collection.find({ \"field\" : { $lt: value } } ); // less than : field < value\n\ndb.collection.find({ \"field\" : { $gte: value } } ); // greater than or equal to : field >= value\n\ndb.collection.find({ \"field\" : { $lte: value } } ); // less than or equal to : field <= value\n\n \n\n如查询j大于3,小于4: \n\ndb.things.find({j : {$lt: 3}});\n\ndb.things.find({j : {$gte: 4}}); \n\n也可以合并在一条语句内: \n\ndb.collection.find({ \"field\" : { $gt: value1, $lt: value2 } } ); // value1 < field < value\n\n \n\n\\2) 不等于 $ne \n\n例子： \n\ndb.things.find( { x : { $ne : 3 } } ); \n\n \n\n\\3) in 和 not in ($in $nin)\n\n语法：\n\ndb.collection.find( { \"field\" : { $in : array } } ); \n\n例子：\n\ndb.things.find({j:{$in: [2,4,6]}});\n\ndb.things.find({j:{$nin: [2,4,6]}});\n\n \n\n\\4) 取模运算$mod\n\n如下面的运算：\n\ndb.things.find( \"this.a % 10 == 1\") \n\n可用$mod代替：\n\ndb.things.find( { a : { $mod : [ 10 , 1 ] } } )\n\n \n\n\\5)  $all\n\n$all和$in类似，但是他需要匹配条件内所有的值：\n\n如有一个对象：\n\n{ a: [ 1, 2, 3 ] } \n\n下面这个条件是可以匹配的： \n\ndb.things.find( { a: { $all: [ 2, 3 ] } } ); \n\n但是下面这个条件就不行了： \n\ndb.things.find( { a: { $all: [ 2, 3, 4 ] } } );\n\n \n\n\\6)  $size\n\n$size是匹配数组内的元素数量的，如有一个对象：{a:[\"foo\"]}，他只有一个元素：\n\n下面的语句就可以匹配：\n\ndb.things.find( { a : { $size: 1 } } ); \n\n官网上说不能用来匹配一个范围内的元素，如果想找$size<5之类的，他们建议创建一个字段来保存元素的数量。 \n\nYou cannot use $size to find a range of sizes (for example: arrays with more than 1 element). If you need to query for a range, create an extra size field that you increment when you add elements.\n\n \n\n7）$exists \n\n$exists用来判断一个元素是否存在： \n\n如： \n\ndb.things.find( { a : { $exists : true } } ); // 如果存在元素a,就返回\n\ndb.things.find( { a : { $exists : false } } ); // 如果不存在元素a，就返回\n\n \n\n\\8)  $type \n\n$type 基于 bson type来匹配一个元素的类型，像是按照类型ID来匹配 \n\n类型 和 ID  对应列表 如下 ：\n\nhttp://www.w3cschool.cc/mongodb/mongodb-operators-type.html\n\n更改字段类型 如下 ：\n\nhttp://loo2k.com/blog/mongodb-change-field-type/\n\nhttp://blog.chinaunix.net/uid-15795819-id-3873422.html\n\n类型和java类型对比如下：\n\nhttp://docs.mongodb.org/ecosystem/drivers/java-types/\n\nhttp://docs.mongodb.org/manual/reference/bson-types/ \n\ndb.things.find( { a : { $type : 2 } } ); // matches if a is a string\n\ndb.things.find( { a : { $type : 16 } } ); // matches if a is an int \n\n \n\n9）正则表达式\n\nmongo支持正则表达式，如：\n\ndb.customers.find( { name : /acme.*corp/i } ); // 后面的i的意思是区分大小写 \n\n \n\n\\10)  查询数据内的值\n\n下面的查询是查询colors内red的记录，如果colors元素是一个数据,数据库将遍历这个数组的元素来查询。\n\ndb.things.find( { colors : \"red\" } ); \n\n \n\n\\11) $elemMatch\n\n如果对象有一个元素是数组，那么$elemMatch可以匹配内数组内的元素：\n\n\\> t.find( { x : { $elemMatch : { a : 1, b : { $gt : 1 } } } } ) \n\n{ \"_id\" : ObjectId(\"4b5783300334000000000aa9\"), \n\n\"x\" : [ { \"a\" : 1, \"b\" : 3 }, 7, { \"b\" : 99 }, { \"a\" : 11 } ]\n\n} \n\n$elemMatch : { a : 1, b : { $gt : 1 } } 所有的条件都要匹配上才行。 \n\n注意，上面的语句和下面是不一样的。 \n\n\\> t.find( { \"x.a\" : 1, \"x.b\" : { $gt : 1 } } ) \n\n$elemMatch是匹配{ \"a\" : 1, \"b\" : 3 }，而后面一句是匹配{ \"b\" : 99 }, { \"a\" : 11 } \n\n \n\n\\12)  查询嵌入对象的值\n\ndb.postings.find( { \"author.name\" : \"joe\" } ); \n\n注意用法是author.name，用一个点就行了。更详细的可以看这个链接： dot notation \n\n举个例子： \n\n\\> db.blog.save({ title : \"My First Post\", author: {name : \"Jane\", id : 1}}) \n\n如果我们要查询 authors name 是Jane的, 我们可以这样： \n\n\\> db.blog.findOne({\"author.name\" : \"Jane\"}) \n\n如果不用点，那就需要用下面这句才能匹配： \n\ndb.blog.findOne({\"author\" : {\"name\" : \"Jane\", \"id\" : 1}}) \n\n下面这句： \n\ndb.blog.findOne({\"author\" : {\"name\" : \"Jane\"}}) \n\n是不能匹配的，因为mongodb对于子对象，他是精确匹配。 \n\n \n\n\\13) 元操作符 $not 取反\n\n如： \n\ndb.customers.find( { name : { $not : /acme.*corp/i } } ); \n\ndb.things.find( { a : { $not : { $mod : [ 10 , 1 ] } } } ); \n\nmongodb还有很多函数可以用，如排序，统计等，请参考原文。 \n\nmongodb目前没有或(or)操作符，只能用变通的办法代替，可以参考下面的链接： \n\nhttp://www.mongodb.org/display/DOCS/OR+operations+in+query+expressions\n\n分类: MongoDB \n\n \n\n二、更新\n\nmongodb更新有两个命令：\n\n1).update()命令\n\ndb.collection.update( criteria, objNew, upsert, multi ) \n\ncriteria : update的查询条件，类似sql update查询内where后面的\n\nobjNew  : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的\n\nupsert  : 这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。\n\nmulti   : mongodb默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。 \n\n例：\n\ndb.test0.update( { \"count\" : { $gt : 1 } } , { $set : { \"test2\" : \"OK\"} } ); 只更新了第一条记录\n\ndb.test0.update( { \"count\" : { $gt : 3 } } , { $set : { \"test2\" : \"OK\"} },false,true ); 全更新了\n\ndb.test0.update( { \"count\" : { $gt : 4 } } , { $set : { \"test5\" : \"OK\"} },true,false ); 只加进去了第一条\n\ndb.test0.update( { \"count\" : { $gt : 5 } } , { $set : { \"test5\" : \"OK\"} },true,true ); 全加进去了\n\ndb.test0.update( { \"count\" : { $gt : 15 } } , { $inc : { \"count\" : 1} },false,true );全更新了\n\ndb.test0.update( { \"count\" : { $gt : 10 } } , { $inc : { \"count\" : 1} },false,false );只更新了第一条\n\n \n\n2).save()命令 \n\ndb.collection.save( x ) \n\nx就是要更新的对象，只能是单条记录。 \n\n如果在collection内已经存在一个和x对象相同的\"_id\"的记录。mongodb就会把x对象替换collection内已经存在的记录，否则将会插入x对象，如果x内没有_id,系统会自动生成一个再插入。相当于上面update语句的upsert=true,multi=false的情况。\n\n例：\n\ndb.test0.save({count:40,test1:\"OK\"}); #_id系统会生成\n\ndb.test0.save({_id:40,count:40,test1:\"OK\"}); #如果test0内有_id等于40的，会替换，否则插入。 \n\nmongodb的更新操作符：\n\n\\1) $inc\n\n用法：{ $inc : { field : value } }\n\n意思对一个数字字段field增加value，例：\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 16, \"test1\" : \"TESTTEST\", \"test2\" : \"OK\", \"test3\" : \"TESTTEST\", \"test4\" : \"OK\", \"test5\" : \"OK\" }\n\n \n\n\\> db.test0.update( { \"_id\" : 15 } , { $inc : { \"count\" : 1 } } );\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 17, \"test1\" : \"TESTTEST\", \"test2\" : \"OK\", \"test3\" : \"TESTTEST\", \"test4\" : \"OK\", \"test5\" : \"OK\" }\n\n \n\n\\> db.test0.update( { \"_id\" : 15 } , { $inc : { \"count\" : 2 } } );\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 19, \"test1\" : \"TESTTEST\", \"test2\" : \"OK\", \"test3\" : \"TESTTEST\", \"test4\" : \"OK\", \"test5\" : \"OK\" }\n\n \n\n\\> db.test0.update( { \"_id\" : 15 } , { $inc : { \"count\" : -1 } } );\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 18, \"test1\" : \"TESTTEST\", \"test2\" : \"OK\", \"test3\" : \"TESTTEST\", \"test4\" : \"OK\", \"test5\" : \"OK\" }\n\n \n\n\\2) $set\n\n用法：{ $set : { field : value } }\n\n就是相当于sql的set field = value，全部数据类型都支持$set。例：\n\n\\> db.test0.update( { \"_id\" : 15 } , { $set : { \"test1\" : \"testv1\",\"test2\" : \"testv2\",\"test3\" : \"testv3\",\"test4\" : \"testv4\" } } );\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 18, \"test1\" : \"testv1\", \"test2\" : \"testv2\", \"test3\" : \"testv3\", \"test4\" : \"testv4\", \"test5\" : \"OK\" }\n\n \n\n\\3) $unset\n\n用法：{ $unset : { field : 1} }\n\n顾名思义，就是删除字段了。例：\n\n\\> db.test0.update( { \"_id\" : 15 } , { $unset : { \"test1\":1 } } );\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 18, \"test2\" : \"testv2\", \"test3\" : \"testv3\", \"test4\" : \"testv4\", \"test5\" : \"OK\" }\n\n \n\n\\> db.test0.update( { \"_id\" : 15 } , { $unset : { \"test2\": 0 } } );\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 18, \"test3\" : \"testv3\", \"test4\" : \"testv4\", \"test5\" : \"OK\" }\n\n \n\n\\> db.test0.update( { \"_id\" : 15 } , { $unset : { \"test3\":asdfasf } } );\n\nFri May 14 16:17:38 JS Error: ReferenceError: asdfasf is not defined (shell):0\n\n \n\n\\> db.test0.update( { \"_id\" : 15 } , { $unset : { \"test3\":\"test\" } } );\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 18, \"test4\" : \"testv4\", \"test5\" : \"OK\" }\n\n \n\n没看出field : 1里面的1是干什么用的，反正只要有东西就行。\n\n \n\n\\4) $push\n\n用法：{ $push : { field : value } }\n\n把value追加到field里面去，field一定要是数组类型才行，如果field不存在，会新增一个数组类型加进去。例：\n\n \n\n\\> db.test0.update( { \"_id\" : 15 } , { $set : { \"test1\" : [\"aaa\",\"bbb\"] } } );\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 18, \"test1\" : [ \"aaa\", \"bbb\" ], \"test4\" : \"testv4\", \"test5\" : \"OK\" }\n\n \n\n\\> db.test0.update( { \"_id\" : 15 } , { $push : { \"test1\": \"ccc\" } } );\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 18, \"test1\" : [ \"aaa\", \"bbb\", \"ccc\" ], \"test4\" : \"testv4\", \"test5\" : \"OK\" }\n\n \n\n\\> db.test0.update( { \"_id\" : 15 } , { $push : { \"test2\": \"ccc\" } } );\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 18, \"test1\" : [ \"aaa\", \"bbb\", \"ccc\" ], \"test2\" : [ \"ccc\" ], \"test4\" : \"testv4\", \"test5\" : \"OK\" }\n\n \n\n\\> db.test0.update( { \"_id\" : 15 } , { $push : { \"test1\": [\"ddd\",\"eee\"] } } );\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 18, \"test1\" : [ \"aaa\", \"bbb\", \"ccc\", [ \"ddd\", \"eee\" ] ], \"test2\" : [ \"ccc\" ], \"test4\" : \"testv4\", \"test5\" : \"OK\" }5) $pushAll\n\n \n\n \n\n\\5) $pushAll\n\n用法：{ $pushAll : { field : value_array } }\n\n同$push,只是一次可以追加多个值到一个数组字段内。例：\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 18, \"test1\" : [ \"aaa\", \"bbb\", \"ccc\", [ \"ddd\", \"eee\" ] ], \"test2\" : [ \"ccc\" ], \"test4\" : \"testv4\", \"test5\" : \"OK\" }\n\n \n\n\\> db.test0.update( { \"_id\" : 15 } , { $pushAll : { \"test1\": [\"fff\",\"ggg\"] } } );\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 18, \"test1\" : [ \"aaa\", \"bbb\", \"ccc\", [ \"ddd\", \"eee\" ], \"fff\", \"ggg\" ], \"test2\" : [ \"ccc\" ], \"test4\" : \"testv4\", \"test5\" : \"OK\" }\n\n \n\n\\6)  $addToSet\n\n用法：{ $addToSet : { field : value } }\n\n增加一个值到数组内，而且只有当这个值不在数组内才增加。例：\n\n\\> db.test0.update( { \"_id\" : 15 } , { $addToSet : { \"test1\": {$each : [\"444\",\"555\"] } } } );\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 18, \n\n \"test1\" : [\"aaa\",\"bbb\",\"ccc\",[\"ddd\",\"eee\"],\"fff\",\"ggg\",[\"111\",\"222\"],\"444\",\"555\"], \n\n \"test2\" : [ \"ccc\" ], \"test4\" : \"testv4\", \"test5\" : \"OK\" \n\n }\n\n\\> db.test0.update( { \"_id\" : 15 } , { $addToSet : { \"test1\": {$each : [\"444\",\"555\"] } } } );\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 18, \n\n \"test1\" : [\"aaa\",\"bbb\",\"ccc\",[\"ddd\",\"eee\"],\"fff\",\"ggg\",[\"111\",\"222\"],\"444\",\"555\"], \"test2\" : [ \"ccc\" ], \n\n \"test4\" : \"testv4\", \"test5\" : \"OK\" \n\n}\n\n\\> db.test0.update( { \"_id\" : 15 } , { $addToSet : { \"test1\": [\"444\",\"555\"] } } );\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 18, \n\n \"test1\" : [\"aaa\",\"bbb\",\"ccc\",[\"ddd\",\"eee\"],\"fff\",\"ggg\",[\"111\",\"222\"],\"444\",\"555\",[\"444\",\"555\"]], \"test2\" : [ \"ccc\" ], \n\n \"test4\" : \"testv4\", \"test5\" : \"OK\" \n\n}\n\n\\> db.test0.update( { \"_id\" : 15 } , { $addToSet : { \"test1\": [\"444\",\"555\"] } } );\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 18, \"test1\" : [\"aaa\",\"bbb\",\"ccc\",[\"ddd\",\"eee\"],\"fff\",\"ggg\",[\"111\",\"222\"],\"444\",\"555\",[\"444\",\"555\"]], \"test2\" : [ \"ccc\" ], \n\n \"test4\" : \"testv4\", \"test5\" : \"OK\" \n\n}\n\n \n\n\\7) $pop\n\n删除数组内的一个值\n\n用法：\n\n删除最后一个值：{ $pop : { field : 1 } }删除第一个值：{ $pop : { field : -1 } }\n\n注意，只能删除一个值，也就是说只能用1或-1，而不能用2或-2来删除两条。mongodb 1.1及以后的版本才可以用，例：\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 18, \n\n \"test1\" : [\"bbb\",\"ccc\",[\"ddd\",\"eee\"],\"fff\",\"ggg\",[\"111\",\"222\"],\"444\"], \n\n \"test2\" : [ \"ccc\" ], \"test4\" : \"testv4\", \"test5\" : \"OK\" \n\n}\n\n\\> db.test0.update( { \"_id\" : 15 } , { $pop : { \"test1\": -1 } } );\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 18, \n\n \"test1\" : [\"ccc\",[\"ddd\",\"eee\"],\"fff\",\"ggg\",[\"111\",\"222\"],\"444\"], \n\n \"test2\" : [ \"ccc\" ], \"test4\" : \"testv4\", \"test5\" : \"OK\" \n\n }\n\n\\> db.test0.update( { \"_id\" : 15 } , { $pop : { \"test1\": 1 } } );\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 18, \n\n \"test1\" : [ \"ccc\", [ \"ddd\", \"eee\" ], \"fff\", \"ggg\", [ \"111\", \"222\" ] ], \"test2\" : [ \"ccc\" ], \"test4\" : \"testv4\",\n\n \"test5\" : \"OK\" \n\n}\n\n \n\n\\8) $pull\n\n用法：$pull : { field : value } }\n\n从数组field内删除一个等于value值。例：\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 18, \"test1\" : [ \"ccc\", [ \"ddd\", \"eee\" ], \"fff\", \"ggg\", [ \"111\", \"222\" ] ], \"test2\" : [ \"ccc\" ], \"test4\" : \"testv4\",\n\n\"test5\" : \"OK\" }\n\n \n\n\\> db.test0.update( { \"_id\" : 15 } , { $pull : { \"test1\": \"ggg\" } } );\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 18, \"test1\" : [ \"ccc\", [ \"ddd\", \"eee\" ], \"fff\", [ \"111\", \"222\" ] ], \"test2\" : [ \"ccc\" ], \"test4\" : \"testv4\", \"test5\"\n\n: \"OK\" }\n\n \n\n\\9) $pullAll\n\n用法：{ $pullAll : { field : value_array } }\n\n同$pull,可以一次删除数组内的多个值。例：\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 18, \"test1\" : [ \"ccc\", [ \"ddd\", \"eee\" ], \"fff\", [ \"111\", \"222\" ] ], \"test2\" : [ \"ccc\" ], \"test4\" : \"testv4\", \"test5\"\n\n: \"OK\" }\n\n \n\n\\> db.test0.update( { \"_id\" : 15 } , { $pullAll : { \"test1\": [ \"ccc\" , \"fff\" ] } } );\n\n\\> db.test0.find( { \"_id\" : 15 } );\n\n{ \"_id\" : { \"floatApprox\" : 15 }, \"count\" : 18, \"test1\" : [ [ \"ddd\", \"eee\" ], [ \"111\", \"222\" ] ], \"test2\" : [ \"ccc\" ], \"test4\" : \"testv4\", \"test5\" : \"OK\" }\n\n \n\n \n\n\\10) $ 操作符\n\n$是他自己的意思，代表按条件找出的数组里面某项他自己。呵呵，比较坳口。看一下官方的例子：\n\n\\> t.find()\n\n{ \"_id\" : ObjectId(\"4b97e62bf1d8c7152c9ccb74\"), \"title\" : \"ABC\", \"comments\" : [ { \"by\" : \"joe\", \"votes\" : 3 }, { \"by\" : \"jane\", \"votes\" : 7 } ] }\n\n \n\n\\> t.update( {'comments.by':'joe'}, {$inc:{'comments.$.votes':1}}, false, true )\n\n \n\n\\> t.find()\n\n{ \"_id\" : ObjectId(\"4b97e62bf1d8c7152c9ccb74\"), \"title\" : \"ABC\", \"comments\" : [ { \"by\" : \"joe\", \"votes\" : 4 }, { \"by\" : \"jane\", \"votes\" : 7 } ] }\n\n \n\n需要注意的是，$只会应用找到的第一条数组项，后面的就不管了。还是看例子：\n\n\\> t.find();\n\n{ \"_id\" : ObjectId(\"4b9e4a1fc583fa1c76198319\"), \"x\" : [ 1, 2, 3, 2 ] }\n\n\\> t.update({x: 2}, {$inc: {\"x.$\": 1}}, false, true);\n\n\\> t.find();\n\n \n\n还有注意的是$配合$unset使用的时候，会留下一个null的数组项，不过可以用{$pull:{x:null}}删除全部是null的数组项。例：\n\n\\> t.insert({x: [1,2,3,4,3,2,3,4]})\n\n\\> t.find()\n\n{ \"_id\" : ObjectId(\"4bde2ad3755d00000000710e\"), \"x\" : [ 1, 2, 3, 4, 3, 2, 3, 4 ] }\n\n\\> t.update({x:3}, {$unset:{\"x.$\":1}})\n\n\\> t.find()\n\n{ \"_id\" : ObjectId(\"4bde2ad3755d00000000710e\"), \"x\" : [ 1, 2, null, 4, 3, 2, 3, 4 ] }\n\n \n\n{ \"_id\" : ObjectId(\"4b9e4a1fc583fa1c76198319\"), \"x\" : [ 1, 3, 3, 2 ] } \n\n \n\n============  数组元素操作示例 ================ \n\n\\> db.arraytest.insert({id:2, name:'leon', comments:[{id:'011', content:'cmt11'}, {id:'012', content:'cmt12'}, {id:'013', content:'cmt13'}]}) \n\n\\1. 数组内的元素可以直接查询 \n\n\\> db.arraytest.find({'comments.id':'002'})\n\n \n\n\\2. 更新数组中的某个节点的值,用$符号 \n\ndb.arraytest.update({'comments.id':'012'}, {$set: {'comments.$.content':'cmtttt012'}})\n\n \n\n\\3. 删除数组中的某一列，变成null \n\n\\> db.arraytest.update({'comments.id':'012'}, {$unset: {'comments.$':1}})\n\n \n\n \\4. 向数组中添加一个元素，如果之前没有元素则会新建数组 \n\n\\> db.arraytest.update({'comments.id':'112'}, {$push: {'comments.$.reply': {'rid':'r21', content:'reply22'}}}) ","children":[]},{"name":"mongodb-basic.md","path":"../guanruihua.github.io/Database/MongoDB","data":"# MongoDB\n\n> [MongoDB安装](https://blog.csdn.net/weixin_41466575/article/details/105326230)\n\n## 启动与关闭\n\n```js\n// 启动\n.\\bin\\mongod -dbpath C:\\RUIHUA\\env\\MongoDB\\data\\db\n\n\n// 关闭\n.\\bin\\mongo localhost:27017\n\nuse admin;\ndb.shutdownServer();\nexit\n```\n\n","children":[]},{"name":"mongodb-node.md","path":"../guanruihua.github.io/Database/MongoDB","data":"# Node.js 连接 MongoDB\n\n> [Mongoose v5.13.2: API docs (mongoosejs.com)](https://mongoosejs.com/docs/api.html)\n>\n> MongoDB是一种文档导向数据库管理系统，由C++撰写而成。\n\n### 安装驱动\n\n```shell\ncnpm install mongodb\n```\n\n------\n\n## 创建数据库\n\n要在 MongoDB 中创建一个数据库，首先我们需要创建一个 MongoClient 对象，然后配置好指定的 URL 和 端口号。\n\n如果数据库不存在，MongoDB 将创建数据库并建立连接。\n\n## 创建连接\n\n```js\nvar MongoClient = require('mongodb').MongoClient; \nvar url = \"mongodb://localhost:27017/runoob\";  \nMongoClient.connect(url, function(err, db) {  \n  if (err) throw err;  \n  console.log(\"数据库已创建!\");  \n  db.close(); \n});\n```\n\n------\n\n## 创建集合\n\n我们可以使用 createCollection() 方法来创建集合：\n\n## 创建集合\n\n```js\nvar MongoClient = require('mongodb').MongoClient; \nvar url = 'mongodb://localhost:27017/runoob'; \nMongoClient.connect(url, function (err, db) {    \n  if (err) throw err;    \n  console.log('数据库已创建');    \n  var dbase = db.db(\"runoob\");    \n  dbase.createCollection('site', function (err, res) {        \n    if (err) throw err;        \n    console.log(\"创建集合!\");        \n    db.close();    \n  }); \n});\n```\n\n------\n\n## 数据库操作( CURD )\n\n与 MySQL 不同的是 MongoDB 会自动创建数据库和集合，所以使用前我们不需要手动去创建。\n\n### 插入数据\n\n以下实例我们连接数据库 runoob 的 site 表，并插入一条数据条数据，使用 **insertOne()**：\n\n## 插入一条数据\n\n```js\nvar MongoClient = require('mongodb').MongoClient; \nvar url = \"mongodb://localhost:27017/\";  \nMongoClient.connect(url, function(err, db) {    \n  if (err) throw err;    \n  var dbo = db.db(\"site\");    \n  var myobj = { name: \"grh\", url: \"ruihua\" };    \n  dbo.collection(\"site\").insertOne(myobj, function(err, res) {        \n    if (err) throw err;        \n    console.log(\"文档插入成功\");        \n    db.close();    \n  }); \n});\n```\n\n执行以下命令输出就结果为：\n\n```shell\n$ node test.js\n文档插入成功\n```\n\n从输出结果来看，数据已插入成功。\n\n我们也可以打开 MongoDB 的客户端查看数据，如：\n\n```shell\n> show dbs\nrunoob  0.000GB          # 自动创建了 runoob 数据库\n> show tables\nsite                     # 自动创建了 site 集合（数据表）\n> db.site.find()\n{ \"_id\" : ObjectId(\"5a794e36763eb821b24db854\"), \"name\" : \"菜鸟教程\", \"url\" : \"www.runoob\" }\n> \n```\n\n如果要插入多条数据可以使用 **insertMany()**：\n\n## 插入多条数据\n\n```js\nvar MongoClient = require('mongodb').MongoClient; \nvar url = \"mongodb://localhost:27017/\";  \nMongoClient.connect(url, function(err, db) {    \n  if (err) throw err;    \n  var dbo = db.db(\"koadb\");    \n  var myobj =  [        \n    { name: 'grh', url: 'https://github.com', type: 'cn'},        \n    { name: 'Google', url: 'https://www.google.com', type: 'en'},        \n    { name: 'Facebook', url: 'https://www.google.com', type: 'en'}       \n  ];    \n  dbo.collection(\"site\").insertMany(myobj, function(err, res) {        \n    if (err) throw err;        \n    console.log(\"插入的文档数量为: \" + res.insertedCount);        \n    db.close();    \n  }); \n});\n```\n\nres.insertedCount 为插入的条数。\n\n### 查询数据\n\n可以使用 find() 来查找数据, find() 可以返回匹配条件的所有数据。 如果未指定条件，find() 返回集合中的所有数据。\n\n## find()\n\n```js\nvar MongoClient = require('mongodb').MongoClient; \nvar url = \"mongodb://localhost:27017/\";  \nMongoClient.connect(url, function(err, db) {    \n  if (err) throw err;    \n  var dbo = db.db(\"koadb\");    \n  dbo.collection(\"site\"). find({}).toArray(function(err, result) { \n    // 返回集合中所有数据        \n    if (err) throw err;        \n    console.log(result);        \n    db.close();    \n  }); \n});\n```\n\n以下实例检索 name 为 \"菜鸟教程\" 的实例：\n\n## 查询指定条件的数据\n\n```js\nvar MongoClient = require('mongodb').MongoClient; \nvar url = \"mongodb://localhost:27017/\";  \nMongoClient.connect(url, function(err, db) {    \n  if (err) throw err;    \n  var dbo = db.db(\"koadb\");     \n  var whereStr = {\"name\":'菜鸟教程'};  // 查询条件 \n  dbo.collection(\"site\").find(whereStr).toArray(function(err, result) {        \n    if (err) throw err;        \n    console.log(result);        \n    db.close();    \n  }); \n});\n```\n\n执行以下命令输出就结果为：\n\n```shell\n[ { _id: 5a794e36763eb821b24db854,\n    name: '菜鸟教程',\n    url: 'www.runoob' } ]\n```\n\n### 更新数据\n\n我们也可以对数据库的数据进行修改，以下实例将 name 为 \"菜鸟教程\" 的 url 改为 <https://www.runoob.com>：\n\n## 更新一条数据\n\n```js\nvar MongoClient = require('mongodb').MongoClient; \nvar url = \"mongodb://localhost:27017/\";  \nMongoClient.connect(url, function(err, db) {    \n  if (err) throw err;    \n  var dbo = db.db(\"runoob\");    \n  var whereStr = {\"name\":'菜鸟教程'};  \n  // 查询条件    \n  var updateStr = {$set: { \"url\" : \"https://www.runoob.com\" }};    \n  dbo.collection(\"site\").updateOne(whereStr, updateStr, function(err, res) {        \n    if (err) throw err;        \n    console.log(\"文档更新成功\");        \n    db.close();    \n  }); \n});\n```\n\n执行成功后，进入 mongo 管理工具查看数据已修改：\n\n```shell\n> db.site.find().pretty()\n{\n    \"_id\" : ObjectId(\"5a794e36763eb821b24db854\"),\n    \"name\" : \"菜鸟教程\",\n    \"url\" : \"https://www.runoob.com\"     // 已修改为 https\n}\n```\n\n如果要更新所有符合条的文档数据可以使用 **updateMany()**：\n\n## 更新多条数据\n\n```js\nvar MongoClient = require('mongodb').MongoClient; \nvar url = \"mongodb://localhost:27017/\";  \nMongoClient.connect(url, function(err, db) {    \n  if (err) throw err;    \n  var dbo = db.db(\"runoob\");    \n  var whereStr = {\"type\":'en'};  // 查询条件    \n  var updateStr = {$set: { \"url\" : \"https://www.runoob.com\" }};    dbo.collection(\"site\").updateMany(whereStr, updateStr, function(err, res) {        \n    if (err) throw err;         \n    console.log(res.result.nModified + \" 条文档被更新\");        \n    db.close();    \n  }); \n});\n```\n\nresult.nModified 为更新的条数。\n\n### 删除数据\n\n以下实例将 name 为 \"菜鸟教程\" 的数据删除 :\n\n## 删除一条数据\n\n```js\nvar MongoClient = require('mongodb').MongoClient; \nvar url = \"mongodb://localhost:27017/\";  \nMongoClient.connect(url, function(err, db) {    \n  if (err) throw err;    \n  var dbo = db.db(\"runoob\");    \n  var whereStr = {\"name\":'菜鸟教程'};  // 查询条件 \n  dbo.collection(\"site\").deleteOne(whereStr, function(err, obj) {        \n    if (err) throw err;        \n    console.log(\"文档删除成功\");        \n    db.close();    \n  }); \n});\n```\n\n执行成功后，进入 mongo 管理工具查看数据已删除：\n\n```shell\n> db.site.find()\n> \n```\n\n如果要删除多条语句可以使用 **deleteMany()** 方法\n\n以下实例将 type 为 en 的所有数据删除 :\n\n## 删除多条数据\n\n```js\nvar MongoClient = require('mongodb').MongoClient; \nvar url = \"mongodb://localhost:27017/\";  \nMongoClient.connect(url, function(err, db) {    \n  if (err) throw err;    \n  var dbo = db.db(\"runoob\");    \n  var whereStr = { type: \"en\" };  // 查询条件   \n  dbo.collection(\"site\").deleteMany(whereStr, function(err, obj) {        \n    if (err) throw err;        \n    console.log(obj.result.n + \" 条文档被删除\");        \n    db.close();    \n  }); \n});\n```\n\nobj.result.n 删除的条数。\n\n### 排序\n\n排序 使用 sort() 方法，该方法接受一个参数，规定是升序(1)还是降序(-1)。\n\n例如：\n\n```shell\n{ type: 1 }  // 按 type 字段升序\n{ type: -1 } // 按 type 字段降序\n```\n\n按 type 升序排列:\n\n## 排序\n\n```js\nvar MongoClient = require('mongodb').MongoClient; \nvar url = \"mongodb://localhost:27017/\";  \nMongoClient.connect(url, function(err, db) {    \n  if (err) throw err;    \n  var dbo = db.db(\"runoob\");    \n  var mysort = { type: 1 };    \n  dbo.collection(\"site\").find().sort(mysort).toArray(function(err, result) {        \n    if (err) throw err;        \n    console.log(result);        \n    db.close();    \n  }); \n});\n```\n\n### 查询分页\n\n如果要设置指定的返回条数可以使用 **limit()** 方法，该方法只接受一个参数，指定了返回的条数。\n\n## limit()：读取两条数据\n\n```js\nvar MongoClient = require('mongodb').MongoClient; \nvar url = \"mongodb://localhost:27017/\";  \nMongoClient.connect(url, function(err, db) {    \n  if (err) throw err;    \n  var dbo = db.db(\"runoob\");    \n  dbo.collection(\"site\").find().limit(2).toArray(function(err, result) {        \n    if (err) throw err;        \n    console.log(result);        \n    db.close();  \n  }); \n});\n```\n\n如果要指定跳过的条数，可以使用 **skip()** 方法。\n\n## skip(): 跳过前面两条数据，读取两条数据\n\n```js\nvar MongoClient = require('mongodb').MongoClient; \nvar url = \"mongodb://localhost:27017/\";  \nMongoClient.connect(url, function(err, db) {    \n  if (err) throw err;    \n  var dbo = db.db(\"runoob\");    \n  dbo.collection(\"site\").find().skip(2).limit(2).toArray(function(err, result) {        \n    if (err) throw err;        \n    console.log(result);        \n    db.close();  \n  }); \n});\n```\n\n### 连接操作\n\nmongoDB 不是一个关系型数据库，但我们可以使用 **$lookup** 来实现左连接。\n\n例如我们有两个集合数据分别为：\n\n集合1：orders\n\n```js\n[\n  { _id: 1, product_id: 154, status: 1 }\n]\n```\n\n集合2：products\n\n```js\n[\n  { _id: 154, name: '笔记本电脑' },\n  { _id: 155, name: '耳机' },\n  { _id: 156, name: '台式电脑' }\n]\n```\n\n## $lookup 实现左连接\n\n```js\nvar MongoClient = require('mongodb').MongoClient; \nvar url = \"mongodb://127.0.0.1:27017/\";  \nMongoClient.connect(url, function(err, db) {  \n  if (err) throw err;  \n  var dbo = db.db(\"runoob\");  \n  dbo.collection('orders').aggregate([    \n    { \n      $lookup:{         \n        from: 'products',            // 右集合         \n         localField: 'product_id',    // 左集合 join 字段         \n         foreignField: '_id',         // 右集合 join 字段         \n         as: 'orderdetails'           // 新生成字段（类型array）       \n       }     \n    }    \n  ]).toArray(function(err, res) {    \n    if (err) throw err;    \n    console.log(JSON.stringify(res));    \n    db.close();  \n  }); \n});\n```\n\n### 删除集合\n\n我们可以使用 **drop()** 方法来删除集合：\n\n## drop()\n\n```js\nvar MongoClient = require('mongodb').MongoClient; \nvar url = \"mongodb://localhost:27017/\";  \nMongoClient.connect(url, function(err, db) {    \n  if (err) throw err;    \n  var dbo = db.db(\"test\");    // 删除 test 集合\n  dbo.collection(\"test\").drop(function(err, delOK) {  // 执行成功 delOK 返回 true，否则返回 false        \n    if (err) throw err;        \n    if (delOK) console.log(\"集合已删除\");        \n    db.close();    \n  }); \n});\n```\n\n------\n\n## 使用 Promise\n\nPromise 是一个 ECMAScript 6 提供的类，目的是更加优雅地书写复杂的异步任务。\n\n如果你还不了解 Promise，可以参考 [JavaScript Promise](https://www.runoob.com/js/js-promise.html)。\n\n以下实例使用 Promise 创建集合：\n\n## 实例\n\n```js\nconst MongoClient = require(\"mongodb\").MongoClient; \nconst url = \"mongodb://localhost/runoob\"; \nMongoClient.connect(url).then((conn) => {    \n  console.log(\"数据库已连接\");    \n  var dbase = conn.db(\"runoob\");    \n  dbase.createCollection(\"site\").then((res) => {        \n    console.log(\"已创建集合\");    \n  }).catch((err) => {        \n    console.log(\"数据库操作错误\");    \n  }).finally(() => {        \n    conn.close();    \n  }); \n}).catch((err) => {    \n  console.log(\"数据库连接失败\"); \n});\n```\n\n### Promise 数据操作\n\n现在我们在一个程序中实现四个连续操作：增加 、查询 、更改 、删除。\n\n## 实例\n\n```js\nconst MongoClient = require(\"mongodb\").MongoClient; \nconst url = \"mongodb://localhost/\"; \nMongoClient.connect(url).then((conn) => {    \n  console.log(\"数据库已连接\");    \n  const test = conn.db(\"testdb\").collection(\"test\");    // 增加    \n  test.insertOne({ \"site\": \"runoob.com\" }).then((res) => {        // 查询        \n    return test.find().toArray().then((arr) => {            \n      console.log(arr);        \n    });    \n  }).then(() => {        // 更改        \n    return test.updateMany({ \"site\": \"runoob.com\" },{ $set: { \"site\": \"example.com\" } }); \n  }).then((res) => {        // 查询        \n    return test.find().toArray().then((arr) => {            \n      console.log(arr);        \n    });    \n  }).then(() => {        // 删除        \n    return test.deleteMany({ \"site\": \"example.com\" });   \n  }).then((res) => {        // 查询        \n    return test.find().toArray().then((arr) => {            \n      console.log(arr);        \n    });    \n  }).catch((err) => {        \n    console.log(\"数据操作失败\" + err.message);    \n  }).finally(() => {        \n    conn.close();    \n  }); \n}).catch((err) => {    \n  console.log(\"数据库连接失败\"); \n});\n```\n\n执行结果：\n\n```js\n数据库已连接\n[ { _id: 5f1664966833e531d83d3ac6, site: 'runoob.com' } ]\n[ { _id: 5f1664966833e531d83d3ac6, site: 'example.com' } ]\n[]\n```\n\n### 用异步函数实现相同的数据操作\n\n## 实例\n\n```js\nconst MongoClient = require(\"mongodb\").MongoClient; \nconst url = \"mongodb://localhost/\";  \nasync function dataOperate() {    \n  var conn = null;    \n  try {        \n    conn = await MongoClient.connect(url);        \n    console.log(\"数据库已连接\");        \n    const test = conn.db(\"testdb\").collection(\"test\");        \n    // 增加        \n    await test.insertOne({ \"site\": \"runoob.com\" });        \n    // 查询        \n    var arr = await test.find().toArray();        \n    console.log(arr);        \n    // 更改        \n    await test.updateMany({ \"site\": \"runoob.com\" },{ $set: { \"site\": \"example.com\" } });     // 查询        \n    arr = await test.find().toArray();        \n    console.log(arr);        \n    // 删除        \n    await test.deleteMany({ \"site\": \"example.com\" });        \n    // 查询        \n    arr = await test.find().toArray();        \n    console.log(arr);    \n  } catch (err) {        \n    console.log(\"错误：\" + err.message);    \n  } finally {        \n    if (conn != null) conn.close();    \n  } \n}  \ndataOperate();\n```\n\n运行结果：\n\n```js\n数据库已连接\n[ { _id: 5f169006a2780f0cd4ea640b, site: 'runoob.com' } ]\n[ { _id: 5f169006a2780f0cd4ea640b, site: 'example.com' } ]\n[]\n```\n","children":[]}]},{"name":"mybatis","path":"../guanruihua.github.io/Database","data":"","children":[{"name":"annotation-crud.md","path":"../guanruihua.github.io/Database/mybatis","data":"\n\n# Mybatis\n\n\n\n## 静态SQL\n\n### mapper.xml\n\n```java\npackage com.how2java.mapper;\n \nimport java.util.List;\n\nimport org.apache.ibatis.annotations.Delete;\nimport org.apache.ibatis.annotations.Insert;\nimport org.apache.ibatis.annotations.Select;\nimport org.apache.ibatis.annotations.Update;\n\nimport com.how2java.pojo.Category;\n \npublic interface CategoryMapper {\n \n    @Insert(\" insert into category_ ( name ) values (#{name}) \")  \n    public int add(Category category);  \n       \n    @Delete(\" delete from category_ where id= #{id} \")  \n    public void delete(int id);  \n       \n    @Select(\"select * from category_ where id= #{id} \")  \n    public Category get(int id);  \n     \n    @Update(\"update category_ set name=#{name} where id=#{id} \")  \n    public int update(Category category);   \n       \n    @Select(\" select * from category_ \")  \n    public List<Category> list();  \n}\n\n```\n\n\n\n### mybatis-config.xml\n\n```xml-dtd\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\nPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n\"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <typeAliases>\n      <package name=\"com.how2java.pojo\"/>\n    </typeAliases>\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n            <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n            <property name=\"url\" value=\"jdbc:mysql://localhost:3306/dbName?characterEncoding=UTF-8\"/>\n            <property name=\"username\" value=\"root\"/>\n            <property name=\"password\" value=\"admin\"/>\n            </dataSource>\n        </environment>\n    </environments>\n    <mappers>\n        <mapper resource=\"com/how2java/pojo/Category.xml\"/>\n        <mapper class=\"com.how2java.mapper.CategoryMapper\"/>  \n    </mappers>\n</configuration>\n\n```\n\n\n\n### Test Class3\n\n```java\npackage com.how2java;\n  \nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\n\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\nimport com.how2java.mapper.CategoryMapper;\nimport com.how2java.pojo.Category;\n  \npublic class TestMybatis {\n  \n    public static void main(String[] args) throws IOException {\n        String resource = \"mybatis-config.xml\";\n        InputStream inputStream = Resources.getResourceAsStream(resource);\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n        SqlSession session = sqlSessionFactory.openSession();\n        CategoryMapper mapper = session.getMapper(CategoryMapper.class);\n \n//        add(mapper);\n//        delete(mapper);\n//        get(mapper);\n//        update(mapper);\n        listAll(mapper);\n             \n        session.commit();\n        session.close();\n  \n    }\n \n    private static void update(CategoryMapper mapper) {\n        Category c= mapper.get(8);\n        c.setName(\"修改了的Category名稱\");\n        mapper.update(c);\n        listAll(mapper);\n    }\n \n    private static void get(CategoryMapper mapper) {\n        Category c= mapper.get(8);\n        System.out.println(c.getName());\n    }\n \n    private static void delete(CategoryMapper mapper) {\n        mapper.delete(2);\n        listAll(mapper);\n    }\n \n    private static void add(CategoryMapper mapper) {\n        Category c = new Category();\n        c.setName(\"新增加的Category\");\n        mapper.add(c);\n        listAll(mapper);\n    }\n  \n    private static void listAll(CategoryMapper mapper) {\n        List<Category> cs = mapper.list();\n        for (Category c : cs) {\n            System.out.println(c.getName());\n        }\n    }\n}\n\t\n```\n\n\n\n## 动态SQL\n\n> - mapper使用\n>\n>   -  @UpdateProvider(type=VideoSqlProvider.class,method=\"updateVideo\")  更新\n>   - @InsertProvider   插入\n>   - @DeleteProvider   删除\n>   - @SelectProvider   查询\n>\n>   \n>\n> -  method使用\n>   - UPDATE()\n>   - INSERT()\n>   - SELECT()\n>   - SET()\n>   - WHERE()\n>   - VALUE()\n>   - DELETE()\n>   - OR()\n>   - FORM()\n\n\n\n\n\n```java\nimport org.apache.ibatis.jdbc.SQL; \n/**\n * video构建动态sql语句\n */\npublic class VideoProvider {\n \n    /**\n     * 更新video动态语句\n     * @param video\n     * @return\n     */\n    public String updateVideo(final Video video){\n        return new SQL(){{\n            UPDATE(\"video\");\n            //条件写法.\n            if(video.getTitle()!=null){\n                SET(\"title=#{title}\");\n            }\n            if(video.getSummary()!=null){\n                SET(\"summary=#{summary}\");\n            }\n            if(video.getCoverImg()!=null){\n                SET(\"cover_img=#{coverImg}\");\n            }\n            if(video.getViewNum()!=null){\n                SET(\"view_num=#{viewNum}\");\n            }\n            if(video.getPrice()!=null){\n                SET(\"price=#{price}\");\n            }\n            if(video.getOnline()!=null){\n                SET(\"online=#{online}\");\n            }\n            if(video.getPoint()!=null){\n                SET(\"point=#{point}\");\n            }\n            WHERE(\"id=#{id}\");\n        }}.toString();\n    }\n \n}\n```\n\n","children":[]},{"name":"mybatis-Plus.md","path":"../guanruihua.github.io/Database/mybatis","data":"# Mybatis-Plus\n\n\n\n\n\n## 查到数据，但是返回空\n\n> -  数据库定义字段名为`name1_name2`, 实体类要定义`name1Name2`, 而不是`name1_name2`\n> - 或者写`mapper.xml`文件","children":[]},{"name":"mybatis.md","path":"../guanruihua.github.io/Database/mybatis","data":"# mybatis\n\n> [mybatis-spring –](http://mybatis.org/spring/zh/getting-started.html)\n\n## Mybatis 注解增删改查\n\n### 要点\n\n- 有另一种方法来完成语句映射。 它们映射的语句可以不用 XML 来配置，而可以使用 Java 注解来配置。\n- **使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让你本就复杂的 SQL 语句更加混乱不堪。**\n- **如果你需要做一些很复杂的操作，最好用 XML 来映射语句。**\n- 需要在config.xml中注册Java接口\n\n```xml\n<mappers>\n        <mapper class=\"com.mybatis.DAO.PeopleMapper\"/>\n</mappers>\n```\n\n> 要用class=\n\n### 查\n\n```java\npublic interface PeopleMapper {\n    @Select(\"select * from people\")\n    List<People> getPeopleList();\n}\n```\n\n### 增\n\n可以先开启事务自动提交\n\n```java\npublic static SqlSession getSqlSession(){\n       return sqlSessionFactory.openSession(true);\n    }\n}\n```\n\nMapper.java\n\n```java\npublic interface PeopleMapper {\n    @Select(\"select * from people\")\n    List<People> getPeopleList();\n    @Insert(\"insert into people(id, name, age, address) VALUES (#{id},#{name},#{age},#{address})\")\n    int addPeople(People people);\n}\n```\n\ntest\n\n```java\npublic class PeopleDAOtest {\n    @Test\n    public void print() {\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        PeopleMapper peopleMapper = sqlSession.getMapper(PeopleMapper.class);\n        List<People> people = peopleMapper.getPeopleList();\n        for (People p :people){\n            System.out.println(p);\n        }\n        sqlSession.close();\n    }\n    @Test\n    public void add(){\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        PeopleMapper peopleMapper = sqlSession.getMapper(PeopleMapper.class);\n        peopleMapper.addPeople(new People(6,\"圣迭戈\",456,\"啥地方\"));\n        print();\n    }\n}\n```\n\n> 因为已经自动提交了，所以不需要sqlSession.commit();\n\n### 删\n\n- **注解@Param**\n\n1. 只能用于基本数据类型\n2. 传入的参数只能和sql语句中参数一样\n\n![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6be7cb5164e48d2b417e8af39fddfa2~tplv-k3u1fbpfcp-watermark.image)\n\n1. 多个参数\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/753abf07c5f04361a1e7de31c2ff8175~tplv-k3u1fbpfcp-watermark.image)\n\n- 样例\n\nMapper.java\n\n```java\npublic interface PeopleMapper {\n    @Delete(\"delete people from people where id=#{uid}\")\n    int delPeople(@Param(\"uid\") int i);\n}\n```\n\ntest\n\n```java\npublic class PeopleDAOtest {\n    @Test\n    public void del(){\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        PeopleMapper peopleMapper = sqlSession.getMapper(PeopleMapper.class);\n        peopleMapper.delPeople(6);\n        print();\n    }\n}\n```\n\n### 改\n\nMapper.java\n\n```java\npublic interface PeopleMapper {\n    @Update(\"update mybatis.people set name=#{name} ,age=#{age} ,address=#{address} where id=#{id}\")\n    int updateP(People people);\n}\n```\n\ntest\n\n```java\npublic class PeopleDAOtest {\n    @Test\n    public void update(){\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        PeopleMapper peopleMapper = sqlSession.getMapper(PeopleMapper.class);\n        peopleMapper.updateP(new People(5,\"圣迭戈\",456,\"啥地方\"));\n        print();\n    }\n}\n```\n\n> <https://blog.csdn.net/weixin_43168190/article/details/102959304>\n\n## DEMO\n\n### pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>org.example</groupId>\n  <artifactId>MybatisDemo</artifactId>\n  <version>1.0-SNAPSHOT</version>\n\n  <name>MybatisDemo</name>\n  <!-- FIXME change it to the project's website -->\n  <url>http://www.example.com</url>\n\n  <properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <maven.compiler.source>1.7</maven.compiler.source>\n    <maven.compiler.target>1.7</maven.compiler.target>\n  </properties>\n\n  <dependencies>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.11</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.mybatis</groupId>\n      <artifactId>mybatis</artifactId>\n      <version>3.2.8</version>\n    </dependency>\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n      <version>8.0.18</version>\n    </dependency>\n    <dependency>\n      <groupId>log4j</groupId>\n      <artifactId>log4j</artifactId>\n      <version>1.2.17</version>\n    </dependency>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.12</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.projectlombok</groupId>\n      <artifactId>lombok</artifactId>\n      <version>RELEASE</version>\n      <scope>compile</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.junit.jupiter</groupId>\n      <artifactId>junit-jupiter</artifactId>\n      <version>RELEASE</version>\n      <scope>compile</scope>\n    </dependency>\n  </dependencies>\n\n  <build>\n    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->\n      <plugins>\n        <!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle -->\n        <plugin>\n          <artifactId>maven-clean-plugin</artifactId>\n          <version>3.1.0</version>\n        </plugin>\n        <!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging -->\n        <plugin>\n          <artifactId>maven-resources-plugin</artifactId>\n          <version>3.0.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-compiler-plugin</artifactId>\n          <version>3.8.0</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-surefire-plugin</artifactId>\n          <version>2.22.1</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-jar-plugin</artifactId>\n          <version>3.0.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-install-plugin</artifactId>\n          <version>2.5.2</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-deploy-plugin</artifactId>\n          <version>2.8.2</version>\n        </plugin>\n        <!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle -->\n        <plugin>\n          <artifactId>maven-site-plugin</artifactId>\n          <version>3.7.1</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-project-info-reports-plugin</artifactId>\n          <version>3.0.0</version>\n        </plugin>\n      </plugins>\n    </pluginManagement>\n  </build>\n</project>\n\n```\n\n### log4j.properties\n\n```properties\nlog4j.rootLogger=DEBUG, stdout\n\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=[service] %d - %c -%-4r [%t] %-5p %c %x - %m%n\n\n#log4j.appender.R=org.apache.log4j.DailyRollingFileAppender\n#log4j.appender.R.File=../logs/service.log\n#log4j.appender.R.layout=org.apache.log4j.PatternLayout\n#log4j.appender.R.layout.ConversionPattern=[service] %d - %c -%-4r [%t] %-5p %c %x - %m%n\n\n#log4j.logger.com.ibatis = debug\n#log4j.logger.com.ibatis.common.jdbc.SimpleDataSource = debug\n#log4j.logger.com.ibatis.common.jdbc.ScriptRunner = debug\n#log4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate = debug\n#log4j.logger.java.sql.Connection = debug\nlog4j.logger.java.sql.Statement = debug\nlog4j.logger.java.sql.PreparedStatement = debug\nlog4j.logger.java.sql.ResultSet =debug\n```\n\n### SqlMapConfig.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<!-- MyBatis的主配置文件 -->\n<configuration>\n    <!-- 配置环境 -->\n    <environments default=\"mysql\">\n        <!-- 配置MySQL环境 -->\n        <environment id=\"mysql\">\n            <!-- 配置事务类型 -->\n            <transactionManager type=\"JDBC\"/>\n            <!-- 配置数据源/连接池 -->\n            <dataSource type=\"POOLED\">\n                <!-- 配置连接数据库的4个基本信息  -->\n                <property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306/node?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"\"/>\n            </dataSource>\n        </environment>\n    </environments>\n\n    <!-- 指定映射配置文件的位置 -->\n    <mappers>\n<!--        <mapper resource=\"IUserDao.xml\"/>--> //使用配置文件的用法\n        <mapper class = \"org.example.dao.IUserDao\"/> // 使用注解开发的用法\n    </mappers>\n</configuration>\n```\n\n### User\n\n```java\npackage org.example.entity;\n\nimport lombok.Data;\nimport java.util.Date;\n\n@Data\npublic class User {\n    private int id;\n    private String username;\n    private Date birthday;\n    private String sex;\n    private String address;\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", username='\" + username + '\\'' +\n                \", birthday=\" + birthday +\n                \", sex='\" + sex + '\\'' +\n                \", address='\" + address + '\\'' +\n                '}';\n    }\n}\n```\n\n### IUserDao.java\n\n```java\npackage org.example.dao;\n\nimport org.apache.ibatis.annotations.Select;\nimport org.example.entity.User;\n\nimport java.util.List;\n\npublic interface IUserDao {\n    List<User> findAll();\n    @Select(\"select * from eesy_mybatis\")\n    List<User> findAllUser();\n}\n```\n\n### IUserDao.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"org.example.dao.IUserDao\">\n    <!-- 配置查询所有 -->\n    <select id=\"findAll\" resultType=\"org.example.entity.User\">\n        select * from eesy_mybatis\n    </select>\n</mapper>\n```\n\n### MybatisTest.java\n\n```java\npackage org.example.test;\n\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.example.dao.IUserDao;\nimport org.example.entity.User;\nimport org.junit.jupiter.api.Test;\n\nimport org.apache.ibatis.io.Resources;\nimport java.io.InputStream;\nimport java.util.List;\n\npublic class MybatisTest {\n    @Test //使用mapper.xml开发\n    public void DEMO() throws Exception{\n        InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();\n        SqlSessionFactory factory = builder.build(in);\n        SqlSession session = factory.openSession();\n        IUserDao userDao = session.getMapper(IUserDao.class);\n        List<User> users = userDao.findAll();\n        for(User user: users){\n            System.out.println(user);\n        }\n        session.close();\n        in.close();\n    }\n\n    @Test // 使用注解开发 \n    public void DEMO2() throws Exception{\n        InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();\n        SqlSessionFactory factory = builder.build(in);\n        SqlSession session = factory.openSession();\n        IUserDao userDao = session.getMapper(IUserDao.class);\n        List<User> users = userDao.findAllUser();\n        for(User user: users){\n            System.out.println(user);\n        }\n        session.close();\n        in.close();\n    }\n\n}\n```\n\n## 动态注解SQL\n\n```java\nimport org.apache.ibatis.jdbc.SQL;\npublic class CategoryDynaSqlProvider {\npublic String list() {\nreturn new SQL()\n  .SELECT(\"*\")\n  .FROM(\"category_\")\n  .toString();\n}\npublic String get() {\nreturn new SQL()\n  .SELECT(\"*\")\n  .FROM(\"category_\")\n  .WHERE(\"id=#{id}\")\n  .toString();\n}\npublic String add(){\n  return new SQL()\n  .INSERT_INTO(\"category_\")\n  .VALUES(\"name\", \"#{name}\")\n  .toString();\n}\npublic String update(){\n  return new SQL()\n  .UPDATE(\"category_\")\n  .SET(\"name=#{name}\")\n  .WHERE(\"id=#{id}\")\n  .toString();\n}\npublic String delete(){\n  return new SQL()\n  .DELETE_FROM(\"category_\")\n  .WHERE(\"id=#{id}\")\n  .toString();\n  }\n}\n```\n\n```java\n@Insert(\" insert into category_ ( name ) values (#{name}) \")\npublic int add(Category category);\n//修改为了注解@InsertProvider配合CategoryDynaSqlProvider的add方法\n@InsertProvider(type=CategoryDynaSqlProvider.class,method=\"add\")\npublic int add(Category category);\n```\n\n```java\npublic interface CategoryMapper {\n  @InsertProvider(type=CategoryDynaSqlProvider.class,method=\"add\")\n  public int add(Category category);\n  @DeleteProvider(type=CategoryDynaSqlProvider.class,method=\"delete\")\n  public void delete(int id);\n  @SelectProvider(type=CategoryDynaSqlProvider.class,method=\"get\")\n  public Category get(int id);\n  @UpdateProvider(type=CategoryDynaSqlProvider.class,method=\"update\")\n  public int update(Category category);\n  @SelectProvider(type=CategoryDynaSqlProvider.class,method=\"list\")\n public List<Category> list();\n}\n  \n\n**步骤** **7** **:** **关于SQL类**\nSQL类是用于进行动态SQL生成的，如下代码是一个相对复杂的SQL类的使用举例，以后需要用到的时候，再来参考。\nprivate String selectPersonSql() {\n  return new SQL() {{\n    SELECT(\"P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME\");\n    SELECT(\"P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON\");\n    FROM(\"PERSON P\");\n    FROM(\"ACCOUNT A\");\n    INNER_JOIN(\"DEPARTMENT D on D.ID = P.DEPARTMENT_ID\");\n    INNER_JOIN(\"COMPANY C on D.COMPANY_ID = C.ID\");\n    WHERE(\"P.ID = A.ID\");\n    WHERE(\"P.FIRST_NAME like ?\");\n    OR();\n    WHERE(\"P.LAST_NAME like ?\");\n    GROUP_BY(\"P.ID\");\n    HAVING(\"P.LAST_NAME like ?\");\n    OR();\n    HAVING(P.FIRST_NAME like ?\");\n    ORDER_BY(\"P.ID\");\n    ORDER_BY(\"P.FULL_NAME\");\n  }}.toString();\n}\n```\n","children":[]}]},{"name":"mysql","path":"../guanruihua.github.io/Database","data":"","children":[{"name":"mysql-basic.md","path":"../guanruihua.github.io/Database/mysql","data":"# MySQL-basic\n\n> [MySQL :: Download MySQL Community Server (Archived Versions)](https://downloads.mysql.com/archives/community/)\n>\n> [MySQL :: MySQL Community Downloads](https://dev.mysql.com/downloads/)\n\n## 推荐文章\n\n> [MYSQL创建表的约束条件（可选） - 迎风而来 - 博客园 (cnblogs.com)](https://www.cnblogs.com/sui776265233/p/9343690.html)\n>\n> [(1条消息) MySQL索引的创建与使用_mysql创建索引](https://blog.csdn.net/justry_deng/article/details/81458470)\n\n## 环境搭建\n\n> [免安装版安装](https://blog.csdn.net/qq_39135287/article/details/82117234)\n>\n> [官方下载路径](https://downloads.mysql.com/archives/community/)\n\n## 基础使用\n\n```shell\nmysqld --install # 安装mysql服务\nnet start mysql # 启动mysql服务\nnet stop mysql # 关闭mysql服务\nmysql -u root -p[密码] # 登录 [-p后面没有空格]\n```\n\n登录成功后\n\n```shell\nALLER USER 'root'@'localhost' IDENTFIED BY '新密码'; # 修改密码\nexit; # 退出\n```\n\n## 控制台使用mysql\n\n```sql\nselect user(); # 查询用户\n\nshow databases; # 显示所有数据库\ncreate database [数据库名] # 创建数据库\ndrop database [数据库名] # 删除数据库 \ncreate database if not exists # [数据库名] # 判断数据库时候存在\n\nuse [数据库名] # 使用数据库\nshow tables; # 显示所有表\n# 显示数据表的字段\nshow columns from [数据表名];\ndescribe [数据表名];\ndesc [数据表名];\nselect * from [数据表]; # 查询数据\n\n# 其他\nselect now(); # 查询时间\nselect version(); # 查询数据库版本\n\nsource C:\\RUIHUA\\Project\\mysql\\init.sql # 执行本地脚本\n```\n\n## 基础使用\n\n### 基本数据类型\n\n> 整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT\n>\n> 浮点数类型：FLOAT、DOUBLE、DECIMAL\n>\n> 字符串类型：CHAR、VARCHAR、NVARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB\n>\n> 日期类型：Date、DateTime、TimeStamp、Time、Year\n>\n> 其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等\n\n### 数据库\n\n> 创建: `crate database databaseName`\n>\n> 删除: `drop database databaseName`\n>\n> 使用: `use databaseName`\n\n### 表\n\n> 删除: `drop table tableName`\n>\n> 插入数据: `insert into table_name( field1, field2, ...) values ( value1, value2, ...)`\n\n#### 创建表\n\n```sql\nCREATE TABLE IF NOT EXISTS `user`(\n   `user_id` INT UNSIGNED AUTO_INCREMENT,\n   `user_title` VARCHAR(100) NOT NULL,\n   `user_author` VARCHAR(40) NOT NULL,\n   `submission_date` DATE,\n   PRIMARY KEY ( `user_id` ))ENGINE=InnoDB DEFAULT CHARSET=utf8;\n```\n\n> auto_increment: 自增的属性, 一般用于主键\n>\n> not null: 不可为空\n>\n> primary key: 关键字用于定义主键,  使用多列来定义组件, 列间以逗号分隔开\n>\n> engine: 设置存储引擎\n>\n> charset : 设置编码\n\n#### 更新\n\n> `update table_name set field1 = new_value1, field2 = new_value2...[ where clause ]`\n\n### 列\n\n#### 添加列，修改列，删除列\n\n```sql\nALTER TABLE：添加，修改，删除表的列，约束等表的定义。\n\n查看列：desc 表名;\n修改表名：alter table t_book rename to bbb;\n添加列：alter table 表名 add column 列名 varchar(30);\n删除列：alter table 表名 drop column 列名;\n修改列名MySQL： alter table bbb change nnnnn hh int;\n修改列名SQLServer：exec sp_rename't_student.name','nn','column';\n修改列名Oracle：lter table bbb rename column nnnnn to hh int;\n修改列属性：alter table t_book modify name varchar(22);\n```\n\n#### MySQL 查看约束，添加约束，删除约束 添加列，修改列，删除列\n\n```sql\n查看表的字段信息：desc 表名;\n查看表的所有信息：show create table 表名;\n添加主键约束：alter table 表名 add constraint 主键 （形如：PK_表名） primary key 表名(主键字段);\n添加外键约束：alter table 从表 add constraint 外键（形如：FK_从表_主表） foreign key 从表(外键字段) references 主表(主键字段);\n删除主键约束：alter table 表名 drop primary key;\n删除外键约束：alter table 表名 drop foreign key 外键（区分大小写）;\n修改表名：alter table t_book rename to bbb;\n添加列：alter table 表名 add column 列名 varchar(30);\n删除列：alter table 表名 drop column 列名;\n修改列名MySQL： alter table bbb change nnnnn hh int;\n修改列属性：alter table t_book modify name varchar(22);\n```\n\n### **select查询**\n\n```sql\n//查询某张表所有数据\nselect * from temp;\n\n//查询指定列和条件的数据\n//查询name和age这两列，age等于22的数据\nselect name,age from temp where age = 22;\n\n//as对列重命名\n//as可以省略不写，如果重命名的列名出现特殊字符，如单引号，那就需要用双引号引在外面\nselect name as '名称' from temp;\n\n//给table去别名\nselect t.name Name from temp as t;\n\n//where条件查询\n>、>=、<、<=、=、<>都可以出现在where语句中\nselect from t where a > 2 or a>=3 or a<5 or a<=6 or a=7 or a<>0;\n\n//and 并且\n//查询名称等于Jack并且年龄大于20的\nselect * from temp where age > 20 and name = 'jack';\n\n//or或者\n--满足一个条件即可\nselect * from temp where name = 'jack' or name = 'jackson';\n\n//between v and v2\n--大于等于v且小于等于v2\nselect * from temp where age between 20 and 25;\n\n//in 查询\n--可以多个条件，类似于or\n--查询id 在括号中出现的数据\nselect *from temp where id in (1, 2, 3);\n\n//like模糊查询\n--查询name以j开头的\nselect * from temp where name like 'j%';\n--查询name包含k的\nselect * from temp where name like '%k%';\n--escape转义,指定\\为转义字符，上面的就可以查询name中包含“_”的数据\n--select * from temp where name like '\\_%' escape '\\';\n\n//is null、is not null\n--查询为null的数据\nselect * from temp where name is null;\n--查询不为null 的数据\nselect * from temp where name is not null;\n\n//order by\n--排序，升序(desc)、降序(asc)\n--默认升序\nselect * from temp order by id;\nselect * from temp order by id asc;\n--多列组合\nselect * from temp order by id, age;\n\n//not\nselect * from temp where not (age > 20);\nselect * from temp where id not in(1, 2);\n\n//distinct去掉重复数据\nselect distinct id from temp;\n//多列将是组合的重复数据\nselect distinct id, age from temp;\n\n//查询常量\nselect 5+2;\nselect concat('a', 'bbb');\n\n//concat函数，字符串连接\n//concat和null进行连接，会导致连接后的数据成为null\nselect concat(name, '-eco') from temp;\n\n//对查询的数据进行运算操作\nselect age +2, age / 2, age - 2, age * 2 from temp where age - 2 > 22;\n```\n\n### 分页\n\n```sql\nselect * from t_areainfo where limit 10,10; // 查询第11-20条\n\n// 使用子查询\n```\n\n### 索引\n\n### 分区\n","children":[]},{"name":"mysql-expand.md","path":"../guanruihua.github.io/Database/mysql","data":"# mysql-expand\n\n## 变量声明与赋值\n\n#### 单变量赋值\n\n```sql\ndeclare @id int(16);\nset @a = '12';\nset @b = (select count(*) from user);\n```\n\n#### 多变量赋值\n\n```sql\ndeclare id int(16);\ndeclare name varchar(128);\nselect id, name into @id, @name from user where id = 1;\nselect @id:= id, @name:= name from user where id = 1;\n```\n\n## 循环的使用\n\n### 函数中使用\n\n```sql\n-- 获取根分类中的根分类名称\ndelimiter //\ndrop function if exists 'getRootCateName' //\nCREATE FUNCTION getRootCateName(cate_id varchar(32))\nRETURNS varchar(128) DETERMINISTIC --deterministic\nBEGIN\n  select pid,category into @p_id,@cate_name from system_category where id=cate_id;\n  set @temp_id = @p_id;\n  while @temp_id > 0 do\n     select pid,category into @p_id,@cate_name from system_category where id=@temp_id;\n     set @temp_id = @p_id;\n  end while;  \nRETURN @cate_name;\nend//\ndelimiter ;\n\n-- 调用\nselect getRootCateName(28);\n```\n\n### 选择语句使用\n\n```sql\ndelimiter //\ncreate function getScoreName(score int(10))\nRETURNS varchar(128) DETERMINISTIC\nBEGIN\n  if score>=90 then \n        set @grade ='A';  \n    elseif score<90 and score>=80 then \n        set @grade ='B';  \n    elseif score<80 and score>=70 then \n        set @grade ='C';  \n    elseif score<70 and score>=60 then \n        set @grade ='D';  \n    else \n        set @grade ='E';  \n    end if; \nRETURN @grade;\nEND //\ndelimiter ;\n\n-- 调用\nselect getScoreName(91);\n```\n\n### 分支语句使用\n\n```sql\ndelimiter //\ncreate function getScoreName2(score int(10))\nRETURNS varchar(128) DETERMINISTIC\nBEGIN\n  SELECT case \n    when score>=90 then '甲' \n    when score>=80 then '乙' \n    when score>=70 then '丙' \n    when score>=60 then '丁' \n    else '差' \n    end as grade  into @commont_grade ;\nRETURN @commont_grade;\nEND //\ndelimiter ;\n\n-- 调用\nselect getScoreName2(98);\n```\n\n### 存储过程使用\n\n```sql\nDELIMITER $$\nDROP PROCEDURE IF EXISTS 'delete_session' $$\nCREATE DEFINER=`root`@`localhost` PROCEDURE `delete_session`(IN top int)  \nBEGIN  \n  \n    DECLARE done INT DEFAULT 0;   \n    DECLARE temp_id INT;  \n \n    DECLARE cur CURSOR for( SELECT id from user);   \n    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;  \n \n    OPEN cur;  \n    FETCH cur INTO temp_id;  \n    WHILE done <> 1 DO  \n      DELETE FROM user_session WHERE id = temp_id;  \n      FETCH cur INTO temp_id;  \n    END WHILE;  \n \n    CLOSE cur;  \nEND $$\nDELIMITER; \n```\n\n### 存储过程输入输出变量\n\n```sql\nDELIMITER $$  \nDROP PROCEDURE IF EXISTS `user_banlance` $$  \nCREATE PROCEDURE user_banlance (IN `in_userId` INT , IN `in_banlance` INT, OUT out_code INT, OUT out_message VARCHAR(100))  \n_return:BEGIN  \nDECLARE _userId bigint(20); \n    DECLARE _banlance int; -- 余额\n    DECLARE _verison INT DEFAULT 0;  \n    DECLARE _error  INT DEFAULT 0;  \n    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET _error = 1;   -- 异常处理\n    SET out_code = -1;\n    SET out_message = '执行失败';\n \n    #用户账户不存在\n    IF NOT EXISTS (select id from user_banlance where id=in_userId) THEN\n        SET out_code = 1;\n        SET out_message = '用户不存在';\n        LEAVE _return;\n    END IF;\n \n    select verison,banlance into _verison, _banlance from user_banlance where id=in_userId;\n \n    START TRANSACTION; -- 开启事务 乐观锁的使用\n    update user_banlance set banlance = banlance - in_banlance,verison = verison + 1 where id = in_userId and verison = _verison;\n \n    SET @ret_update = ROW_COUNT();\n    IF @ret_update = 0 THEN\n        ROLLBACK;\n        SET out_code = -4;\n        SET out_message = '系统错误';\n        LEAVE _return;\n    END IF;\n \n    IF  _error  <>  0   THEN\n        ROLLBACK; \n        SET out_code = -3;\n        SET out_message = '系统错误';\n        LEAVE _return;\n    ELSE    \n        COMMIT;\n        SET out_code = 1;\n        SET out_message = '';\n    END IF;\n \nEND $$  \n \nDELIMITER ;  \n\n-- 调用  注意输出参数必须是声明的变量，否则会报错\n\nset @b = 0;\nset @c = '';\ncall user_banlance(1,10,@b,@c);\n \nselect @b,@c\n```\n\n### 存储过程的使用( 查询游标 )\n\n```sql\nDELIMITER $$  \nDROP PROCEDURE IF EXISTS `user_banlance` $$  \nCREATE PROCEDURE user_banlance (IN `in_userId` INT , IN `in_banlance` INT)  \nBEGIN\n  #遍历数据结束标志\n  DECLARE done INT DEFAULT FALSE;\n  DECLARE _id INT; \n  DECLARE _banlance BIGINT(20);\n#游标\n  DECLARE cur CURSOR FOR SELECT id,banlance FROM user_banlance where id > in_userId and banlance > in_banlance ;\n    #将结束标志绑定到游标\n  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n \n-- 建表tb_temp\n DROP TABLE IF EXISTS tb_temp;\n CREATE TEMPORARY TABLE tb_temp(\n   `id` int UNSIGNED NOT NULL , \n   `banlance` bigint(20) NOT NULL,\n   PRIMARY KEY (`id`)\n ) ENGINE = MYISAM DEFAULT charset = utf8 ;\n \n  -- 打开游标\n  OPEN cur;\n  -- 开始循环\n  read_loop: LOOP\n    -- 提取游标里的数据\n    FETCH cur INTO _id,_banlance; \n    IF done THEN\n      LEAVE read_loop;\n    ELSE \n    replace into tb_temp( id ,banlance) values(_id,_banlance);  -- 替换具有唯一索引 和 主键索引的 相同记录\n    END IF;\n END LOOP;\n -- 关闭游标 \nCLOSE cur; \nselect * from tb_temp;\nDROP TABLE IF EXISTS tb_temp;\nEND $$  \n \nDELIMITER ;  \n\n-- 调用\n\ncall user_banlance(2,1500);\n```\n\n### 游标循环另一种实现方式\n\n```sql\n-- 打开游标\nOPEN cur;\n-- 开始循环\nREPEAT\n-- 提取游标里的数据\n    FETCH cur INTO _id,_banlance; \n    IF not done THEN\n    insert into tb_temp( id ,banlance) values(_id,_banlance);  -- 替换具有唯一索引 和 主键索引的 相同记录\n    END IF;\nUNTIL done \nEND REPEAT;\n -- 关闭游标 \nCLOSE cur; \n```\n\n## 存储过程与函数\n\n### 区别\n\n> 调用方式:\n>\n> - 存储过程: call procedure_name(args, args2 ...);\n> - 函数: select function_name(arges);\n>\n> 返回值：\n>\n> - 存储过程： 多个值\n> - 函数： 只有一个返回值\n\n### 存储过程与存储函数\n\n#### 存储过程\n\n> - 存储过程是一组为了完成某项特定功能的sql语句集，其实质上就是一段存储在数据库中的代码，他可以由声明式的sql语句（如CREATE,UPDATE,SELECT等语句）和过程式sql语句（如IF...THEN...ELSE控制结构语句）组成。\n>\n> - 就是数据库 SQL 语言层面的代码封装与重用。\n\n##### 存储过程的优缺点\n\n**优点:**\n\n> 1. 可增强sql语言的功能和灵活性\n>    存储过程可以用流程控制语言编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。\n> 2. 良好的封装性\n>    存储过程被创建后，可以在程序中被多次调用，而不必担心重写编写该存储过程的sql语句。\n> 3. 高性能\n>    存储过程执行一次后，其执行规划就驻留在高速缓冲存储器中，以后的操作中只需要从高速缓冲器中调用已编译好的二进制代码执行即可，从而提高了系统性能。\n\n**缺点:**\n\n> - 存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。\n\n##### 创建存储过程\n\n##### DELIMITER定界符\n\n> - 解决存储过程/函数里面有分号会导致该存储过程/函数提前结束的问题\n\n   **DELIMITER语法格式：**\n\n```sql\nDELIMITER ? \n```\n\n> `?`是用户定义的结束符，通常这个符号可以是一些特殊的符号。另外应避免使用反斜杠,因为他是转义字符。 若希望换回默认的分号作为结束标记，只需再在命令行输入下面的sql语句即可。\n\n```sql\nDELIMITER ;\n```\n\n##### 存储过程创建\n\n> 使用`CREATE PROCEDURE`语句来创建存储过程。\n\n```sql\nCREATE PROCEDURE p_name([proc_parameter[,...]])\nroutine_body\n```\n\n> 语法项“proc_parameter”的语法格式是：\n\n```sql\n[IN|OUT|INOUT]parame_name type\n```\n\n> p_name : 存储过程的名称\n>\n> proc_parameter: 指定存储过程中的参数列表\n>\n> - parame_name:　参数名\n> - type: 参数类型\n> - IN:　输入参数，OUT: 输出参数, INOUT: 输入输出类型\n>\n> rountine_body: 存储过程的主体部分\n>\n> - 以`BEGIN`开始, `END`结束\n> - 若只有一条语句可以忽略`BEGIN...END`\n\n##### 局部变量\n\n```sql\nDECLARE var_name type [DEFAULT value]\n```\n\n- \"var_name\"用于指定局部变量的名称；\n- \"type\"用来声明变量的类型；\n- \"DEFAULT\"用来指定默认值，如果没有指定则为NULL。\n\n> 注意：局部变量只能在存储过程体的BEGIN...END语句块中;局部变量必须在存储过程体的开头处声明;局部变量的作用范围仅限于声明它的BEGIN...END语句块，其他语句块中的语句不可以使用它。\n\n##### 用户变量\n\n用户变量一般以@开头。\n注意：滥用用户变量会导致程序难以理解及管理。\n\n##### SET语句\n\n> 通过SET语句对局部变量赋值，其格式是：\n\n```sql\nSET var_name = expr[,var_name2 = expr]....\n```\n\n##### SELECT....INTO语句\n\n> 用SELECT...INTO语句把选定的列的值存储到局部变量中。格式是：\n\n```sql\nSELECT col_name[,..] INTO var_name[,....] table_expr\n```\n\n- \"col_name\"用于指定列名；\n- \"var_name\"用于指定要赋值的变量名；\n- \"table_expr\"表示SELECT语句中FROM后面的部分。\n\n> 注意：SELECT...INTO语句返回的结果集只能有一行数据。\n\n##### 流程控制语句\n\n###### if-then-else\n\n```sql\nDELIMITER &&  \nCREATE PROCEDURE proc2(r int)  \nbegin \n  declare var int;  \n  set var=parameter+1;  \n  if var=0 then \n   insert into t values(17);  \n  end if;  \n  if parameter=0 then \n   update t set s1=s1+1;  \n  else \n   update t set s1=s1+2;  \n  end if;  \nend;  \n&&  \nDELIMITER ; \n```\n\n###### **case语句:**\n\n```sql\nDELIMITER &&  \nCREATE PROCEDURE proc3 (in parameter int)  \nbegin \n  declare var int;  \n  set var=parameter+1;  \n  case var  \n  when 0 then   \n   insert into t values(17);  \n  when 1 then   \n   insert into t values(18);  \n  else   \n   insert into t values(19);  \n  end case;  \nend;  \n&&  \nDELIMITER ; \n```\n\n###### **while ···· end while:**\n\n```sql\nDELIMITER &&  \nCREATE PROCEDURE proc4()  \nbegin \n  declare var int;  \n  set var=0;  \n  while var<6 do  \n    insert into t values(var);  \n    set var=var+1;  \n  end while;  \nend;  \n&&  \nDELIMITER ;\n```\n\n###### **repeat···· end repea：**\n\n> 在执行操作后检查结果，而 while 则是执行前进行检查。\n\n```sql\nDELIMITER &&  \nCREATE PROCEDURE proc5 ()  \nbegin   \n  declare v int;  \n  set v=0;  \n  repeat  \n    insert into t values(v);  \n    set v=v+1;  \n    until v>=5  \n  end repeat;  \nend;  \n&&  \nDELIMITER ;\n\nrepeat\n    --循环体\n    until 循环条件  \nend repeat;\n```\n\n###### **loop ·····endloop:**\n\nloop 循环不需要初始条件，这点和 while 循环相似，同时和 repeat 循环一样不需要结束条件, leave 语句的意义是离开循环。\n\n```sql\nDELIMITER &&  \nCREATE PROCEDURE proc6 ()  \nbegin \n  declare v int;  \n  set v=0;  \n  LOOP_LABLE:loop  \n    insert into t values(v);  \n    set v=v+1;  \n    if v >=5 then \n      leave LOOP_LABLE;  -- 离开循环\n    end if;  \n  end loop;  \nend;  \n&&  \nDELIMITER ;\n```\n\n###### **ITERATE迭代：**\n\n```sql\nDELIMITER &&  \nCREATE PROCEDURE proc10 ()  \nbegin \n  declare v int;  \n  set v=0;  \n  LOOP_LABLE:loop  \n    if v=3 then   \n      set v=v+1;  \n      ITERATE LOOP_LABLE;  \n    end if;  \n    insert into t values(v);  \n    set v=v+1;  \n    if v>=5 then \n     leave LOOP_LABLE;  \n    end if;  \n  end loop;  \nend;  \n&&  \nDELIMITER ;\n```\n\n###### 游标\n\n> 可以用来存储select 语句查询到的结果集，这个结果集可以包含多行数据，从而使我们可以使用迭代的方法从游标中依次取出每行数据。\n\n> MySQL游标的特点：\n>\n> 1. 只读：无法通过光标更新基础表中的数据。\n> 2. 不可滚动：只能按照select语句确定的顺序获取行。不能以相反的顺序获取行。 此外，不能跳过行或跳转到结果集中的特定行。\n> 3. 敏感：有两种游标：敏感游标和不敏感游标。\n>    1. 敏感游标指向实际数据，不敏感游标使用数据的临时副本。\n>    2. 敏感游标比一个不敏感的游标执行得更快，因为它不需要临时拷贝数据。MySQL游标是敏感的。\n\n1. 声明游标\n   游标声明必须在变量声明之后。如果在变量声明之前声明游标，MySQL将会发出一个错误。游标必须始终与select语句相关联。\n\n```sql\ndeclare cursor_name cursor for select_statement;\n```\n\n2. 打开游标\n   使用open语句打开游标，只有先打开游标才能读取数据。\n\n```sql\nopen cursor_name\n```\n\n3. 读取游标\n   使用fetch语句来检索游标指向的一行数据，并将游标移动到结果集中的下一行。\n\n```sql\nfetch cursor_name into var_name;\n```\n\n4. 关闭游标\n   使用close语句关闭游标。\n\n```sql\nclose cursor_name;\n```\n\n当游标不再使用时，应该关闭它。 当使用MySQL游标时，还必须声明一个`not found`处理程序来处理当游标找不到任何行时的情况。 因为每次调用fetch语句时，游标会尝试依次读取结果集中的每一行数据。 当游标到达结果集的末尾时，它将无法获得数据，并且会产生一个条件。 处理程序用于处理这种情况。\n\n```sql\ndeclare continue handler for not found set type = 1;\n```\n\ntype是一个变量，示游标到达结果集的结尾。\n\n```sql\ndelimiter ?\ncreate PROCEDURE phoneDeal()\nBEGIN\n    DECLARE  id varchar(64);   -- id\n    DECLARE  phone1  varchar(16); -- phone\n    DECLARE  password1  varchar(32); -- 密码\n    DECLARE  name1 varchar(64);   -- id\n    -- 遍历数据结束标志\n    DECLARE done INT DEFAULT FALSE;\n    -- 游标\n    DECLARE cur_account CURSOR FOR select phone,password,name from account_temp;\n    -- 将结束标志绑定到游标\n    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n    \n    -- 打开游标\n    OPEN  cur_account;     \n    -- 遍历\n    read_loop: LOOP\n            -- 取值 取多个字段\n            FETCH  NEXT from cur_account INTO phone1,password1,name1;\n            IF done THEN\n                LEAVE read_loop;\n             END IF;\n \n        -- 你自己想做的操作\n        insert into account(id,phone,password,name) value(UUID(),phone1,password1,CONCAT(name1,'的家长'));\n    END LOOP;\n \n    -- 关闭游标\n    CLOSE cur_account;\nEND ?\n```\n\n##### 调用存储过程\n\n使用call语句调用存储过程\n\n```sql\ncall sp_name[(传参)];\n```\n\n##### 删除存储过程\n\n使用drop语句删除存储过程\n\n```sql\nDROP PROCEDURE sp_name\n```\n\n#### 存储函数\n\n> - 存储函数和存储过程一样，都是sql和语句组成的代码块。-\n> - 存储函数不能有输入参数，并且可以直接调用，不需要call语句，且必须有一条包含RETURN语句。\n\n##### 创建存储函数\n\n使用CREATE FUNCTION语句创建：\n\n```sql\nCREATE FUNCTION fun_name (par_name type[,...])\nRETURNS type\n[characteristics] \nfun_body\n```\n\n- fun_name为函数名，并且名字唯一，不能与存储过程重名。\n  - par_name是指定的参数，type为参数类型；\n  - RETURNS字句用来声明返回值和返回值类型。fun_body是函数体，所有存储过程中的sql在存储函数中同样可以使用。但是存储函数体中必须包含一个RETURN 语句。\n- characteristics指定存储过程的特性，有以下取值：\n  - LANGUAGE SQL:说明routine_body部分是由SQL语句组成的，当前系统支持的语言为SQL，SQL是LANGUAGE特性的唯一值。\n  - [NOT] DETERMINISTIC:指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定的，每次执行存储过程时，相同的输入会得到相同的输出，NOT DETERMINISTIC表示结果是不确定的，相同的输入可能得到不同的输出，如果没有指定任意一个值，默认为NOT DETERMINISTIC。\n  - [CONTAINS SQL|NO SQL|READS SQL DATA|MODIFIES SQL DATA]：指明子程序使用SQL语句的限制。CONTAINS SQL表明子程序包含SQL语句，但不包含读写数据语句；NO SQL表明子程序不包含SQL语句；READS SQL DATA说明子程序包含读数据的语句；MODIFIES SQL DATA表名子程序包含写数据的语句。默认情况下，系统会指定为CONTAINS SQL。\n  - SQL SECURITY[DEFINER|INVOKER]：指明谁有权限来执行。DEFINER表示只有定义着才能执行。INVOKER表示用友权限的调用者可以执行。默认情况下，系统指定为DEFINER。\n  - COMMENT 'string'：注释信息，用来描述存储过程或函数。\n\n```sql\ndelimiter ?\ncreate function getAnimalName(animalId int) \nRETURNS VARCHAR(50)\nDETERMINISTIC\nbegin\n   declare name VARCHAR(50);\n   set name=(select name from animal where id=animalId);\n   return (name);\nend?\ndelimiter;\n\n-- 调用\nselect getAnimalName(4)\n```\n\n### **函数**\n\n> [官网地址](  https://dev.mysql.com/doc/refman/8.0/en/functions.html[)\n>\n> mysql中的函数可分为两类：系统函数、用户自定义函数。\n>\n> 函数体里面不用直接`select`\n\n| 函数                    |                         | 功能                   |\n| ----------------------- | ----------------------- | ---------------------- |\n| SUBSTRING               | substring               | 截取字符串             |\n| CHAR_LENGTH             | char_length             | 获取字符串长度         |\n| DATE_FORMAT             | date_format             | 格式化日期时间         |\n| CONCAT                  | concat                  | 字符串连接             |\n| CONCAT_GROUP...GOURP BY | concat_group...gourp by | 将分组的各个字符串连接 |\n| SUBSTRING_INDEX         | substring_index         | 字符串截取             |\n| ROUND                   | round                   | 数值保留几位小数       |\n\n#### 普通函数\n\n> 返回值是一个标量\n\n创建函数：\n\n```sql\n// msyql中的函数一定有返回值\n// 创建函数的语法，注意:参数和返回值一定要写长度，避免使用到关键字\n\ncreate function 函数名（[形参列表]） returns 数据类型\nbegin\n    -- 函数体\n    -- 返回值 \nend\n// 写一个实例,通过子订单child_order_no 的订单号获取其最高父订单的订单金额sale_price \ncreate function calcPrice(child_order_no varchar(30)) \nreturns decimal(12,2)\nbegin\n    // 声明变量，注意：一定要写长度\n    declare sale_price decimal default 0.00;\n    declare f_order_no varchar(30) default order_no;\n    WHILE f_order_no is not null  DO\n  set order_no = f_order_no; \n        SET f_order_no = (SELECT o.PARENT_ORDER_NO FROM order o WHERE o.ORDER_NO = f_order_no); \n    END WHILE;\n        SELECT f.SALE_PRICE AS SALE_PRICE FROM order f WHERE f.ORDER_NO = order_no into sale_price;\n    return sale_price;\nend\n\n// 使用这个函数\n\nselect calcPrice(1000011);\n```\n\n查看自定义函数：\n\n```\n// 查看自定义的所有函数\nshow function status\n// 可以根据名称查看所有自定义的函数，支持模糊查询\nshow function status like '名字';\nshow function status like '%me';\n// 查看函数的创建语句\nshow create function '函数名字';\nshow create function getName;\n```\n\n使用函数：\n\n```sql\n// 使用select关键字查看\nselect getNames();\n```\n\n删除函数：\n\n```sql\n// 删除对应函数\ndrop function '函数名'；\ndrop function getNames;\n```\n\n有的时候创建函数和使用函数时，会被告诉没有权限，这时需要给用户添加上权限，如下：\n\n| create routine | 创建函数       |\n| -------------- | -------------- |\n| alter routine  | 修改和删除函数 |\n| execute        | 使用函数       |\n\n上边只是对mysql中函数的使用做了简单的介绍，想要熟练使用还需要在实战中多使用。\n\n函数类似于存储过程，只是调用方式不同\n\n```sql\n//创建函数\ncreate function addAge(age int) returns int\n    return age + 5;\n//使用函数：\nselect addAge(age) from temp;\n//删除函数\ndrop function if exists addAge;\ndrop function addAge;\n//显示创建语法\nshow create function addAge;\n```\n\n#### 表格值函数\n\n> 内联表格函数\n>\n> 多句表格值函数\n\n- **A、**内联表格值函数：返回一个表格\n\n语法：\n\n```sql\ncreate function 函数名（参数）\nreturns table\nas\nreturn(一条SQL语句)\n```\n\n例子：\n\n1.创建函数：\n\n```sql\nCREATE  FUNCTION  tabcmess(@title VARCHAR(10))\nRETURNS  TABLE \nAS \nreturn(select title,des from product where title like '%'+@title+'%')\n```\n\n2.执行：\n\n```sql\nSELECT * FROM tabcmess('aaa')\n```\n\n- **B.多句表格值函数**\n\n语法：\n\n```sql\n create function 函数名（参数）\n   returns 表格变量名table (表格变量定义)\nas\n   begin\n    -- SQL语句\n   end\n```\n\n例子：\n\n```sql\nCREATE function tabcmessalot (@title varchar(10))\nReturns @ctable table(title varchar(10) null,des varchar(100) null)\nAs\nBegin\n  Insert @ctable Select title,des from product WHERE title LIKE '%'+@title+'%'\n  return\nEnd\n--执行\nSELECT * FROM tabcmessalot('aaa')\n```\n\n## **触发器**\n\n触发器分为insert、update、delete三种触发器事件类型，还有after、before触发时间\n\n```sql\n//创建触发器\ncreate trigger trg_temp_ins\nbefore insert\non temp for each row\nbegin\ninsert into temp_log values(NEW.id, NEW.name);\nend\n//删除触发器\ndrop trigger trg_temp_ins\n```\n\n## DEMO\n\n### 递归查询\n\n> 父子查询: 根据父id 查询所有的子节点数据\n>\n> 子父查询: 根据子id 查询上面所有父节点数据\n\n#### **创建表，并添加测试数据**\n\n```sql\nDROP TABLE IF EXISTS `vrv_org_tab`;\nCREATE TABLE `vrv_org_tab` (\n`id` bigint(8) NOT NULL AUTO_INCREMENT,\n`org_name` varchar(50) NOT NULL,\n`org_level` int(4) NOT NULL DEFAULT ‘0’,\n`org_parent_id` bigint(8) NOT NULL DEFAULT ‘0’,\nPRIMARY KEY (`id`),\nUNIQUE KEY `unique_org_name` (`org_name`)\n) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8;\n```\n\n```sql\nINSERT INTO `vrv_org_tab` VALUES (‘1’, ‘北信源’, ‘1’, ‘0’);\nINSERT INTO `vrv_org_tab` VALUES (‘2’, ‘北京’, ‘2’, ‘1’);\nINSERT INTO `vrv_org_tab` VALUES (‘3’, ‘南京’, ‘2’, ‘1’);\nINSERT INTO `vrv_org_tab` VALUES (‘4’, ‘武汉’, ‘2’, ‘1’);\nINSERT INTO `vrv_org_tab` VALUES (‘5’, ‘上海’, ‘2’, ‘1’);\nINSERT INTO `vrv_org_tab` VALUES (‘6’, ‘北京研发中心’, ‘3’, ‘2’);\nINSERT INTO `vrv_org_tab` VALUES (‘7’, ‘南京研发中心’, ‘3’, ‘3’);\nINSERT INTO `vrv_org_tab` VALUES (‘8’, ‘武汉研发中心’, ‘3’, ‘4’);\nINSERT INTO `vrv_org_tab` VALUES (‘9’, ‘上海研发中心’, ‘3’, ‘5’);\nINSERT INTO `vrv_org_tab` VALUES (‘10’, ‘北京EMM项目组’, ‘4’, ‘6’);\nINSERT INTO `vrv_org_tab` VALUES (‘11’, ‘北京linkdd项目组’, ‘4’, ‘6’);\nINSERT INTO `vrv_org_tab` VALUES (‘12’, ‘南京EMM项目组’, ‘4’, ‘7’);\nINSERT INTO `vrv_org_tab` VALUES (‘13’, ‘南京linkdd项目组’, ‘4’, ‘7’);\nINSERT INTO `vrv_org_tab` VALUES (‘14’, ‘武汉EMM项目组’, ‘4’, ‘8’);\nINSERT INTO `vrv_org_tab` VALUES (‘15’, ‘武汉linkdd项目组’, ‘4’, ‘8’);\nINSERT INTO `vrv_org_tab` VALUES (‘16’, ‘上海EMM项目组’, ‘4’, ‘9’);\nINSERT INTO `vrv_org_tab` VALUES (‘17’, ‘上海linkdd项目组’, ‘4’, ‘9’);\n```\n\n#### **根据父id递归查询所有子节点**\n\n> cast( variable as variable_type ) : 将变量转换为指定的类型\n>\n> concat() : 连接多个数据\n>\n> group_concat(): 连接多个数据(消除重复值)\n>\n> find_in_set( str, strList):   查询字段strList中包含str的结果, 返回null 或 记录\n>\n> - str : 要查询的字符串\n> - strList: 支付数组\n\n```sql\ncreate function getChildrenOrg(orgid INT)\nreturns varchar(4000)\nBEGIN\n  DECLARE oTemp VARCHAR(4000);\n  DECLARE oTempChild VARCHAR(4000);\n  SET oTemp = '';\n  SET oTempChild = CAST(orgid AS CHAR);\n  WHILE oTempChild IS NOT NULL\n  DO\n    SET oTemp = CONCAT(oTemp,',',oTempChild);\n    SELECT GROUP_CONCAT(id) INTO oTempChild FROM vrv_org_tab WHERE FIND_IN_SET(org_parent_id,oTempChild) > 0;\n  END WHILE;\n  RETURN oTemp;\nEND;\n\n-- 查询组织机构为1的下面的所有的组织结构\nselect * from vrv_org_tab where find_in_set(id, getChildrenOrg(1));\n```\n\n#### **根据子id递归查询所有父节点**\n\n```sql\nSELECT id,org_name,org_level,org_parent_id\n    FROM ( \n        SELECT \n                @r AS _id, \n                (SELECT @r := org_parent_id FROM vrv_org_tab WHERE id = _id) AS parent_id, \n                 @l := @l + 1 AS lvl \n        FROM \n                (SELECT @r := 10000, @l := 0) vars, \n                vrv_org_tab h \n        WHERE @r <> 0) T1 \n    JOIN vrv_org_tab T2 \n    ON T1._id = T2.id\nORDER BY id;\n```\n\n注意：大家看到那个10000了吗，就是我们的子节点id。\n\n注意：只支持单个查询，意思是不可以根据两个或者两个以上的子节点同时查询出所有父节点。我们可以看到，上面参数都是单个值进行递归查询的。\n西面提供一个函数支持多个查询\n\n#### **根据组织机构名称模糊查询所有父节点**\n\n> distinct : 删除重复行\n>\n> substring( string, position ) : 截取string指定长度的字符串\n>\n> substring_index( str[ 被截取字段 ], delim[ 关键字 ], count[ 关键字出现的次数 ] ) :  按关键字截取字符串\n>\n> length( str ): 返回字串的长度\n\n```sql\nCREATE FUNCTION getParentOrgByOrgName(orgName VARCHAR(20))\nRETURNS VARCHAR(4000)\nBEGIN\n    DECLARE sPid VARCHAR(1000);\n    DECLARE sPidTemp VARCHAR(1000);\n    DECLARE pid VARCHAR(1000);\n    DECLARE count INT DEFAULT 0;\n    DECLARE allpid VARCHAR(4000);\n    SET sPidTemp = '';\n    SELECT GROUP_CONCAT(DISTINCT(CAST(id AS CHAR))) INTO sPid \n    FROM vrv_org_tab WHERE org_name LIKE CONCAT('%',orgName,'%');\n    SET allpid = '';\n  WHILE count = 0\n  DO\n  IF sPid IS NULL THEN\n  SET allpid = '-1';\n  SET count = 1;\n  ELSE\n      SET pid = SUBSTRING_INDEX(sPid,',',1);\n      SET sPidTemp = CONCAT(sPidTemp,',',pid);\n      IF LENGTH(pid) = LENGTH(sPid) THEN\n          SET count = 1;\n          SET sPid = SUBSTRING(sPid FROM LENGTH(SUBSTRING_INDEX(sPid,',',1)) FOR LENGTH(sPid)+1);\n      ELSE\n          SET sPid = SUBSTRING(sPid FROM LENGTH(SUBSTRING_INDEX(sPid,',',1))+2 FOR LENGTH(sPid)+1);\n      END IF;\n      SELECT GROUP_CONCAT(CAST(id AS CHAR)) INTO sPidTemp\n              FROM ( \n                      SELECT \n                              @r AS _id, \n                              (SELECT @r := org_parent_id FROM vrv_org_tab WHERE id = _id) AS parent_id, \n                              @l := @l + 1 AS lvl \n                      FROM \n                              (SELECT @r := pid, @l := 0) vars, \n                              vrv_org_tab h \n                      WHERE @r <> 0) T1 \n              JOIN vrv_org_tab T2 \n              ON T1._id = T2.id;\n      SET allpid = CONCAT_WS(',',pid,sPidTemp,allpid);\n  END IF;\n  END WHILE;\nRETURN allpid;\nEND\n```\n","children":[]},{"name":"mysql-node.md","path":"../guanruihua.github.io/Database/mysql","data":"# Node.js 连接 MySQL\n\n> <https://github.com/mysqljs/mysql>\n\n## 安装驱动\n\n```shell\ncnpm install mysql\n```\n\n## 连接数据库\n\n在以下实例中根据你的实际配置修改数据库用户名、及密码及数据库名：\n\n```js\nvar mysql = require('mysql'); \nvar connection = mysql.createConnection({  \n  host     : 'localhost',  \n  user     : 'root',  \n  password : '123456',  \n  database : 'test' });  \nconnection.connect();  \nconnection.query('SELECT 1 + 1 AS solution', function (error, results, fields) {  \n  if (error) throw error;  \n  console.log('The solution is: ', results[0].solution); \n});\n```\n\n执行以下命令输出结果为：\n\n```shell\n$ node test.js\nThe solution is: 2\n```\n\n### 数据库连接参数说明\n\n| 参数               | 描述                                                         |\n| :----------------- | :----------------------------------------------------------- |\n| host               | 主机地址 （默认：localhost）                                 |\n| user               | 用户名                                                       |\n| password           | 密码                                                         |\n| port               | 端口号 （默认：3306）                                        |\n| database           | 数据库名                                                     |\n| charset            | 连接字符集（默认：'UTF8_GENERAL_CI'，注意字符集的字母都要大写） |\n| localAddress       | 此IP用于TCP连接（可选）                                      |\n| socketPath         | 连接到unix域路径，当使用 host 和 port 时会被忽略             |\n| timezone           | 时区（默认：'local'）                                        |\n| connectTimeout     | 连接超时（默认：不限制；单位：毫秒）                         |\n| stringifyObjects   | 是否序列化对象                                               |\n| typeCast           | 是否将列值转化为本地JavaScript类型值 （默认：true）          |\n| queryFormat        | 自定义query语句格式化方法                                    |\n| supportBigNumbers  | 数据库支持bigint或decimal类型列时，需要设此option为true （默认：false） |\n| bigNumberStrings   | supportBigNumbers和bigNumberStrings启用 强制bigint或decimal列以JavaScript字符串类型返回（默认：false） |\n| dateStrings        | 强制timestamp,datetime,data类型以字符串类型返回，而不是JavaScript Date类型（默认：false） |\n| debug              | 开启调试（默认：false）                                      |\n| multipleStatements | 是否许一个query中有多个MySQL语句 （默认：false）             |\n| flags              | 用于修改连接标志                                             |\n| ssl                | 使用ssl参数（与crypto.createCredenitals参数格式一至）或一个包含ssl配置文件名称的字符串，目前只捆绑Amazon RDS的配置文件 |\n\n------\n\n## 数据库操作( CURD )\n\n```js\nlet sql = ''; // 相当于在sql中执行的语句 [可以写insert, delete, select, update ]\nlet Params = [];// 当 sql 有?, Params 中的参数和sql一一对应 \nconnection.query(sql, [Params], function (err, result) { }\n```\n\n### 查询数据\n\n```js\nvar mysql  = require('mysql');    \nvar connection = mysql.createConnection({       \n  host     : 'localhost',         \n  user     : 'root',                \n  password : '123456',         \n  port: '3306',                     \n  database: 'test'  });   \nconnection.connect();  \nvar  sql = 'SELECT * FROM websites'; \n//查 \nconnection.query(sql,function (err, result) {        \n  if(err){          \n    console.log('[SELECT ERROR] - ',err.message);          \n    return;        \n  }        \n  console.log('--------------------------SELECT----------------------------');             console.log(result);       \n  console.log('------------------------------------------------------------\\n\\n');   \n});  \nconnection.end();\n```\n\n执行以下命令输出就结果为：\n\n```shell\n$ node test.js\n--------------------------SELECT----------------------------\n[ RowDataPacket {\n    id: 1,\n    name: 'Google',\n    url: 'https://www.google.cm/',\n    alexa: 1,\n    country: 'USA' },\n  RowDataPacket {\n    id: 2,\n    name: '淘宝',\n    url: 'https://www.taobao.com/',\n    alexa: 13,\n    country: 'CN' },\n  RowDataPacket {\n    id: 3,\n    name: '菜鸟教程',\n    url: 'http://www.runoob.com/',\n    alexa: 4689,\n    country: 'CN' },\n  RowDataPacket {\n    id: 4,\n    name: '微博',\n    url: 'http://weibo.com/',\n    alexa: 20,\n    country: 'CN' },\n  RowDataPacket {\n    id: 5,\n    name: 'Facebook',\n    url: 'https://www.facebook.com/',\n    alexa: 3,\n    country: 'USA' } ]\n------------------------------------------------------------\n```\n\n### 插入数据\n\n```js\nvar mysql  = require('mysql');    \nvar connection = mysql.createConnection({       \n  host     : 'localhost',         \n  user     : 'root',                \n  password : '123456',         \n  port: '3306',                     \n  database: 'test'  });   \nconnection.connect();  \nvar  addSql = 'INSERT INTO websites(Id,name,url,alexa,country) VALUES(0,?,?,?,?)'; \nvar  addSqlParams = ['菜鸟工具', 'https://c.runoob.com','23453', 'CN']; \n//增 \nconnection.query(addSql, addSqlParams,function (err, result) {        \n  if(err){         \n    console.log('[INSERT ERROR] - ',err.message);         \n    return;        \n  }                \n  console.log('--------------------------INSERT----------------------------');       //console.log('INSERT ID:',result.insertId);               \n  console.log('INSERT ID:',result);               \n  console.log('-----------------------------------------------------------------\\n\\n');   });  \nconnection.end();\n```\n\n执行以下命令输出就结果为：\n\n```shell\n$ node test.js\n--------------------------INSERT----------------------------\nINSERT ID: OkPacket {\n  fieldCount: 0,\n  affectedRows: 1,\n  insertId: 6,\n  serverStatus: 2,\n  warningCount: 0,\n  message: '',\n  protocol41: true,\n  changedRows: 0 }\n-----------------------------------------------------------------\n```\n\n执行成功后，查看数据表，即可以看到添加的数据：\n\n![img](https://www.runoob.com/wp-content/uploads/2017/03/1E2D27C5-45F3-4E57-90D3-4AE35AEB17F7.jpg)\n\n### 更新数据\n\n```js\nvar mysql  = require('mysql');    \nvar connection = mysql.createConnection({       \n  host     : 'localhost',         \n  user     : 'root',                \n  password : '123456',         \n  port: '3306',                     \n  database: 'test'  });   \nconnection.connect();  \nvar modSql = 'UPDATE websites SET name = ?,url = ? WHERE Id = ?'; \nvar modSqlParams = ['菜鸟移动站', 'https://m.runoob.com',6]; \n//改 \nconnection.query(modSql, modSqlParams,function (err, result) {   \n  if(err){         \n    console.log('[UPDATE ERROR] - ',err.message);         \n    return;   \n  }          \n  console.log('--------------------------UPDATE----------------------------');  console.log('UPDATE affectedRows',result.affectedRows);  \n  console.log('-----------------------------------------------------------------\\n\\n'); });  \nconnection.end();\n```\n\n执行以下命令输出就结果为：\n\n```\n--------------------------UPDATE----------------------------\nUPDATE affectedRows 1\n-----------------------------------------------------------------\n```\n\n执行成功后，查看数据表，即可以看到更新的数据：\n\n![img](https://www.runoob.com/wp-content/uploads/2017/03/A5C8911B-E07B-48DD-9C3E-28F1E73A1A30.jpg)\n\n### 删除数据\n\n```js\nvar mysql  = require('mysql');    \nvar connection = mysql.createConnection({       \n  host     : 'localhost',         \n  user     : 'root',                \n  password : '123456',         \n  port: '3306',                     \n  database: 'test'  });   \nconnection.connect();  \nvar delSql = 'DELETE FROM websites where id=6'; \n//删 \nconnection.query(delSql,function (err, result) {        \n  if(err){          \n    console.log('[DELETE ERROR] - ',err.message);          \n    return;        \n  }                \n  console.log('--------------------------DELETE----------------------------');          console.log('DELETE affectedRows',result.affectedRows);       \n  console.log('-----------------------------------------------------------------\\n\\n');   });  \nconnection.end();\n```\n\n执行以下命令输出就结果为：\n\n```\n--------------------------DELETE----------------------------\nDELETE affectedRows 1\n-----------------------------------------------------------------\n```\n\n执行成功后，查看数据表，即可以看到 id=6 的数据已被删除：\n\n![img](https://www.runoob.com/wp-content/uploads/2017/03/27BEB36A-0DCE-4C75-961F-93D55CBECC54.jpg)\n\n## websites.sql\n\n```sql\n/*\n Navicat MySQL Data Transfer\n\n Source Server         : 127.0.0.1\n Source Server Version : 50621\n Source Host           : localhost\n Source Database       : RUNOOB\n\n Target Server Version : 50621\n File Encoding         : utf-8\n\n Date: 05/18/2016 11:44:07 AM\n*/\n\nSET NAMES utf8;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n--  Table structure for `websites`\n-- ----------------------------\nDROP TABLE IF EXISTS `websites`;\nCREATE TABLE `websites` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` char(20) NOT NULL DEFAULT '' COMMENT '站点名称',\n  `url` varchar(255) NOT NULL DEFAULT '',\n  `alexa` int(11) NOT NULL DEFAULT '0' COMMENT 'Alexa 排名',\n  `country` char(10) NOT NULL DEFAULT '' COMMENT '国家',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;\n\n-- ----------------------------\n--  Records of `websites`\n-- ----------------------------\nBEGIN;\nINSERT INTO `websites` VALUES ('1', 'Google', 'https://www.google.cm/', '1', 'USA'), ('2', '淘宝', 'https://www.taobao.com/', '13', 'CN'), ('3', '菜鸟教程', 'http://www.runoob.com/', '4689', 'CN'), ('4', '微博', 'http://weibo.com/', '20', 'CN'), ('5', 'Facebook', 'https://www.facebook.com/', '3', 'USA');\nCOMMIT;\n\nSET FOREIGN_KEY_CHECKS = 1;\n\n```\n","children":[]},{"name":"navicat.md","path":"../guanruihua.github.io/Database/mysql","data":"# Navicat\n\n>  数据库可视化工具\n>\n>  [Navicat Premium v15.0.25 中文最新破解版（附：激活工具） – DEFCON笔记](https://defcon.cn/214.html)\n\n","children":[]},{"name":"question.md","path":"../guanruihua.github.io/Database/mysql","data":"# question\n\n## MYSQL ERROR 2003\n\n> 原因: 使用电脑管家关掉mysql\n>\n> 解决方法: 重启mysql\n\n```shell\n// 打开命令窗口(管理员)\n$ mysqld --install\n$ net start mysql\n$ mysql -u root -p [密码]\n```\n","children":[]},{"name":"规范.md","path":"../guanruihua.github.io/Database/mysql","data":"# 数据库命名规范\n\n采用小写字母、数字（通常不需要）和下划线组成。禁止使用’-’，命名简洁、含义明确。\n\n2. #### 表命名\n\n- 根据业务类型不同，采用不同的前缀，小写字母、下划线组成\n\n- 长度控制在30个字符以内\n\n  推荐的命名规则\n\n  | 类型                 | 前缀       | 说明     |\n  | -------------------- | ---------- | -------- |\n  | 业务表               | tb_        |          |\n  | 关系表               | tr_        |          |\n  | 历史表               | th_        |          |\n  | 统计表               | ts_        |          |\n  | 日志表               | tl_xx_log  |          |\n  | 系统表、字典表、码表 | sys_       |          |\n  | 临时表               | tmp_       | 禁止使用 |\n  | 备份表               | bak_xx_ymd |          |\n  | 视图                 | view_      | 避免使用 |\n\n1. #### 引擎\n\n   使用默认Innodb引擎（5.5以后默认）\n\n   支持事务、支持行级锁、更好的恢复性、高并发下性能更好。\n\n2. #### 字符集\n\n   - 数据库和表的字符集统一,尽量使用UTF8（根据业务需求）\n\n   - 兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效\n\n   - UTF8和UTF8MB4字段进行关联，会导致索引失效\n\n   - 除非特殊情况，禁止建表指定字符集（采用库默认字符集），降低出现字符集不统一导致性能问题的风险。\n\n   - 无特殊要求，禁止指定表COLLATE -----\n\n     COLLATE主要的作用是排序的规则以及检索的规则，utf8字符集默认的是 utf8_general_ci ，utf8mb4字符集默认的是utf8mb4_general_ci，结尾的ci意思是不区分大小写。\n\n     COLLATE会影响到ORDER BY语句的顺序，会影响到WHERE条件中大于小于号筛选出来的结果，会影响**DISTINCT**、**GROUP BY**、**HAVING**语句的查询结果。比如：select * from test where name like 'A%',在 utf8_bin字符集下，是无法检索出 ‘abc’字段的，并且排序的情况下Abc和abc所在的顺序是不一致的。\n\n   - 慎重选择row_format（行记录格式）\n\n     Barracuda: 新的文件格式。它支持InnoDB的所有行格式，包括新的行格式：**COMPRESSED** 和 **DYNAMIC**\n\n     在 msyql 5.7.9 及以后版本，默认行格式由innodb_default_row_format变量决定，它的默认值是**DYNAMIC**\n\n     db默认的innodb_file_format  为 Barracuda，默认的innodb_default_row_format为 dynamic；其中COMPRESSED 压缩比经测试最大也就 1/2，但读取和写入会有额外cpu开销，并且申请内存是按照解压后的原大小申请，在高并发情况下容易导致性能问题。\n\n     Dynamic行格式，列存储是否放到off-page页，主要取决于行大小，他会把行中最长的一列放到off-page，直到数据页能存放下两行。TEXT或BLOB列<=40bytes时总是存在于数据页。这种方式可以避免compact那样把太多的大列值放到B-tree Node（数据页中只存放20个字节的指针，实际的数据存放在Off Page中，之前的Compact 和 Redundant 两种格式会存放768个字前缀字节）。\n\n     Compressed物理结构上与Dynamic类似，Compressed行记录格式的另一个功能就是存储在其中的行数据会以zlib的算法进行压缩，因此对于BLOB、TEXT、VARCHAR这类大长度数据能够进行有效的存储（减少40%，但对CPU要求更高）。\n\n3. #### 字段设计\n\n   - 所有表和字段都需要添加注释，使用comment从句添加表和列的备注 从一开始就进行数据字典的维护\n\n   - 尽量控制单表数据量的大小，建议控制在500万以内\n\n     500万并不是MySQL数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题，可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小\n\n   - 谨慎使用MySQL分区表\n\n     分区表在物理上表现为多个文件，在逻辑上表现为一个表。谨慎选择分区键，跨分区查询效率可能更低，另外，对于表结构维护，分区表的维护造成的开销更集中，建议采用物理分表的方式管理大数据\n\n   - 建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据，尽量做到冷热数据分离，减小表的宽度\n\n   - MySQL限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节。为减少磁盘IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的IO），更有效的利用缓存，避免读入无用的冷数据，经常一起使用的列放到一个表中（避免更多的关联操作）。对于非常用字段，建议采用扩展表的方式进行分表。\n\n     注意：每一行数据的65535字节中，utf8字符集下，varchar每一个长度占用3个字节，utf8mb4字符集下，每一个长度占用4个字节\n\n   - 尽量不在表中建立预留字段\n\n     预留字段的命名很难做到见名识义，预留字段无法确认存储的数据类型，所以无法选择合适的类型。对预留字段类型的修改，会对表进行锁\n\n   - 禁止使用外键约束\n\n     外键使得表之间相互耦合，影响update/delete等SQL性能，有可能造成死锁，高并发情况下容易成为数据库瓶颈。建议在业务端实现。\n\n4. #### 数据库字段设计规范---**愿君学长松 慎勿作桃李**🏆🏆🏆🏆\n\n   - 关于数据长度\n\n     够用前提下，越短越好，这样能够消耗更少的存储空间；因排序申请的内存大小和字段长度有关，需要进行排序时，长度小的字段消耗更少的内存空间；优先选择符合存储需要的最小的数据类型\n\n   - 禁止使用TEXT/BLOB类型，禁止在数据库中存储图片，文件等大的二进制数据\n\n     通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息\n\n   - 避免使用ENUM(枚举)类型\n\n     修改ENUM值需要使用ALTER语句;ENUM类型的ORDER BY操作效率低，需要额外操作；禁止使用数值作为ENUM的枚举值\n\n   - 尽可能把所有列定义为NOT NULL\n\n     索引NULL列需要额外的空间来保存，所以要占用更多的空间\n\n     进行比较和计算时要对NULL值做特别的处理\n\n     NULL只能采用IS NULL或者IS NOT NULL，而在=/!=/in/not in时很容易造成查询结果与设计逻辑不符\n\n   - 使用TIMESTAMP（4个字节）或DATETIME类型（5个字节）存储时间\n\n     网上很多博客都说DATETIME是8个字节，其实在5.6.4版本一上就减少到5个字节\n\n     [mysql 源码 github 地址](https://github.com/mysql/mysql-server)\n\n     ```java\n     longlong TIME_to_longlong_datetime_packed(const MYSQL_TIME &my_time) {\n      longlong ymd = ((my_time.year * 13 + my_time.month) << 5) | my_time.day;\n      longlong hms = (my_time.hour << 12) | (my_time.minute << 6) | my_time.second;\n      longlong tmp = my_packed_time_make(((ymd << 17) | hms), my_time.second_part);\n      assert(!check_datetime_range(my_time)); /* Make sure no overflow */\n      return my_time.neg ? -tmp : tmp;\n     }\n     根据上述算法，计算极限时间 9999-12-31 23:59:59\n            时间各部分依次是 year-month-day hour:minute:second\n     \n     1. 计算 longlong ymd\n        year*13 + month = 9999*13 + 12 = 129999\n        将 129999 左移 5 位，再与 31 进行或运算\n            ‬0000 0000 0011 1111 0111 1001 111[0 0000]   --- 129999 左移 5 位 （年*13 + 月）\n            0000 0000 0000 0000 0000 0000 ‭0001 1111‬     ---  31 （日）\n          = ‬0000 0000 0011 1111 0111 1001 1111 1111     ---  得出 longlong ymd 低位，极限有         22 位\n         \n     2. 计算 longlong hms\n         将 hour 左移 12 位，与 minute 左移 6 位，再与 second 进行或运算\n         0001 0111 [0000 0000 0000]   ---   23 左移 12 位 （时）\n                   1110 11‬[00 0000]   ---   59 左移 6 位 （分）\n                           11 1011    ---   59 （秒）\n        = 0001 0111 1110 1111 1011    ---   得出 longlong hms 的低位，极限有 17 位\n     \n     3. 计算 longlong tmp\n          ymd 右移 17 位，与 hms 进行或运算，这样刚好存到 39 位。（至此，再加上 1 位标识位，也           就刚好 40 位，为 5 字节了）\n          再使用 my_packed_time_make(）函数，将 ymd 与 小数秒部分 连起来。\n     \n     \n     \n     ```\n\n     TIMESTAMP存储的时间范围：1970-01-01 00:00:01 ~ 2038-01-19-03:14:07。\n\n     TIMESTAMP占用4字节和INT相同，但比INT可读性高\n\n     超出TIMESTAMP取值范围的使用DATETIME类型存储。\n\n   - 同财务相关的金额类数据{设计使用小数}必须使用decimal类型\n\n     Decimal类型为精准浮点数，在计算时不会丢失精度。\n\n   - 同一意义的字段定义必须相同\n\n   - 同一意义的字段定义包括字段类型和长度范围必须相同\n\n   - 增加字段时禁止指定after\n\n   - VARCHAR(N)，N尽可能小\n\n     如果N<256时会使用一个字节来存储长度，如果N>=256则使用两个字节来存储长度。\n\n   - 数值型字段，default值建议选用0\n\n5. #### 索引设计规范 ---**共矜然诺心 各负纵横志**❤❤❤❤\n\n   - 创建表一定要有主键（PRIMARY KEY），推荐使用雪花或梨花。\n\n   - 不要使用UUID、MD5、HASH、字符串列作为主键（无法保证数据的顺序增长）。\n\n   - 限制每张表上的索引数量\n\n     索引并不是越多越好！索引可以提高效率同样可以降低效率。索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。因为mysql优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会**增加mysql优化器生成执行计划的时间**，同样会降低查询性能。\n\n   - 区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）；\n\n   - 尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好）；\n\n   - 使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）。\n\n   - 避免建立冗余索引和重复索引---因为这样会增加查询优化器生成执行计划的时间。\n\n     重复索引示例：primary key(id)、index(id)、unique index(id)\n\n     冗余索引示例：index(a,b,c)、index(a,b)、index(a)\n\n   - 优先考虑覆盖索引\n\n     对于频繁的查询优先考虑使用覆盖索引。覆盖索引就是包含了所有查询字段(where,select,ordery by,group by包含的字段)的索引\n\n     覆盖索引的好处：1.可以把随机IO变成顺序IO加快查询效率；2.能够避免回表查询，提升查询效率\n\n   - 一定要在表与表之间的关联键上建立索引\n\n6. #### sql开发规划 --- **月缺不改光 剑折不改刚**❤️❤️❤️❤️\n\n   - 建议使用预编译语句进行数据库操作\n\n     预编译语句可以重复使用这些计划，减少SQL编译所需要的时间，还可以解决动态SQL所带来的SQL注入的问题；只传参数，比传递SQL语句更高效；相同语句可以一次解析，多次使用，提高处理效率。\n\n     在实际生产环境中，如MyBatis等ORM框架大量使用了预编译语句，最终底层调用都会走到MySQL驱动里，从驱动中了解相关实现细节有助于更好地理解预编译语句\n\n     就像我们熟悉的#{}是经过预编译的，是安全的；${}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入\n\n     MySQL驱动里对于server预编译的情况维护了两个**基于LinkedHashMap使用LRU策略的cache**，分别是serverSideStatementCheckCache用于缓存sql语句是否可以由服务端来缓存以及serverSideStatementCache用于缓存服务端预编译sql语句，这两个缓存的大小由**prepStmtCacheSize**参数控制。\n\n   - 避免数据类型的隐式转换\n\n     隐式转换会导致索引失效。如：select name,phone from customer where id = '111';\n\n   - 充分利用表上已经存在的索引\n\n   - 避免使用双%号的查询条件\n\n     如a like '%123%'，（如果无前置%,只有后置%，是可以用到列上的索引的）。\n\n   - 一个SQL只能利用到复合索引中的一列进行范围查询\n\n     如：有 a,b,c列的联合索引，在查询条件中有a列的范围查询，则在b,c列上的索引将不会被用到，在定义联合索引时，如果a列要用到范围查找的话，就要把a列放到联合索引的右侧。\n\n   - WHERE从句中禁止对列进行函数转换和计算\n\n     不推荐：where date(create_time)=20190101\n\n     推荐：where create_time >= 20190101 and create_time < 20190102\n\n   - 在明显不会有重复值时使用**UNION ALL**而不是UNION\n\n     UNION会把两个结果集的所有数据放到临时表中后再进行去重和排序操作\n\n     UNION ALL不会再对结果集进行去重和排序操作\n\n   - 拆分复杂的大SQL为多个小SQL\n\n   - SQL 性能优化的目标:至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。\n\n   - 不要使用 count(列名)或 count(常量)来替代 count(*)，count(*)就是 SQL92 定义 的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。\n","children":[]}]},{"name":"mysql.md","path":"../guanruihua.github.io/Database","data":"# mysql\n\n## mysql启动失败\n\n1. 删除data文件夹\n\n2. 修改my.ini\n\n   ```sh\n   basedir =\"C:\\RUIHUA\\env\\mysql\\5.7.31.2\"   # 设置mysql的安装目录 \n   datadir =\"C:\\RUIHUA\\env\\mysql\\5.7.31.2\\data\"   # 设置mysql数据库的数据的存放目录，必须是data，或者是//xxx/data  \n   ```\n\n3. 管理员身份模式进入mysql下的bin目录\n\n4. 移除已注册服务`mysqld remove`\n\n5. 初始化 `mysqld --initialize --console`\n\n   - root@localhost: [ 这里是密码 ]\n\n6. 注册服务: `mysqld -install`\n\n7. 启动服务: `net start mysql`\n\n8. 启动: `mysql -u root -p`\n\n   1. 修改密码\n\n      MySQL8.0.4以前，执行\n\n      ```\n      SET PASSWORD=PASSWORD('[修改的密码]');\n      \n      mysql8.0.4以后\n      \n      ALTER` `USER` `'root'``@``'localhost'` `IDENTIFIED ``WITH` `mysql_native_password ``BY` `'修改的密码'``;\n      ```\n\n目前密码: `ruihuag`\n","children":[]},{"name":"README.md","path":"../guanruihua.github.io/Database","data":"# [ruihuag](https://guanruihua.github.io/#/)\r\n\r\n<!-- ![](../__assets__/001.jpg) -->\r\n<!-- ![Metrics](https://metrics.lecoq.io/guanruihua?template=classic&isocalendar=1&languages=1&base=header%2C%20activity%2C%20community%2C%20repositories%2C%20metadata&base.indepth=false&base.hireable=false&base.skip=false&isocalendar=false&isocalendar.duration=half-year&languages=false&languages.limit=8&languages.threshold=0%25&languages.other=false&languages.colors=github&languages.sections=most-used&languages.indepth=false&languages.analysis.timeout=15&languages.categories=markup%2C%20programming&languages.recent.categories=markup%2C%20programming&languages.recent.load=300&languages.recent.days=14&config.timezone=Asia%2FShanghai) -->\r\n","children":[]},{"name":"_sidebar.md","path":"../guanruihua.github.io/Database","data":"* MongoDB\n  * [mongo](MongoDB/mongo.md)\n  * [mongodb-basic](MongoDB/mongodb-basic.md)\n  * [mongodb-node](MongoDB/mongodb-node.md)\n* mybatis\n  * [annotation-crud](mybatis/annotation-crud.md)\n  * [mybatis-Plus](mybatis/mybatis-Plus.md)\n  * [mybatis](mybatis/mybatis.md)\n* mysql\n  * [mysql-basic](mysql/mysql-basic.md)\n  * [mysql-expand](mysql/mysql-expand.md)\n  * [mysql-node](mysql/mysql-node.md)\n  * [navicat](mysql/navicat.md)\n  * [question](mysql/question.md)\n  * [规范](mysql/规范.md)\n* [mysql](mysql.md)\n","children":[]}]},{"name":"Front-End","path":"../guanruihua.github.io","data":"","children":[{"name":"Node","path":"../guanruihua.github.io/Front-End","data":"","children":[{"name":"git.md","path":"../guanruihua.github.io/Front-End/Node","data":"# git\r\n\r\n<https://git-scm.com/docs/pretty-formats>\r\n\r\n首先肯用到的node的核心模块，不再多说了，具体使用方法可以看一下node.js官网。\r\n\r\n```js\r\nconst exec = require('child_process').exec; //异步子进程\r\nconst execSync = require('child_process').execSync; //同步子进程\r\nconst fs = require('fs'); //文件读取模块\r\n```\r\n\r\n如果version.txt存在的话，将先读取里边的版本信息\r\n\r\n```js\r\nif (fs.existsSync(versionPath)) {\r\n    versionStr = fs.readFileSync(versionPath).toString() + '\\n';\r\n}\r\n```\r\n\r\n根据版本信息是已存在commit，进行不同处理\r\n\r\n```js\r\n\r\nif (versionStr.indexOf(commit) != -1) {\r\n    console.warn('\\x1B[33m%s\\x1b[0m', 'warming: 当前的git版本数据已经存在了!\\n')\r\n} else {\r\n    let name = execSync('git show -s --format=%cn').toString().trim(); //姓名\r\n    let email = execSync('git show -s --format=%ce').toString().trim(); //邮箱\r\n    let date = new Date(execSync('git show -s --format=%cd').toString()); //日期\r\n    let message = execSync('git show -s --format=%s').toString().trim(); //说明\r\n    versionStr = `git:${commit}\\n作者:${name}<${email}>\\n日期:${date.getFullYear()+'-'+(date.getMonth()+1)+'-'+date.getDate()+' '+date.getHours()+':'+date.getMinutes()}\\n说明:${message}\\n${new Array(80).join('*')}\\n${versionStr}`;\r\n    fs.writeFileSync(versionPath, versionStr);\r\n    // 写入版本信息之后，自动将版本信息提交到当前分支的git上\r\n    if (autoPush) {\r\n        execSync(`git commit ${versionPath} -m 自动提交版本信息`);\r\n        execSync(`git push origin ${execSync('git rev-parse --abbrev-ref HEAD').toString().trim()}`);\r\n    }\r\n}\r\n```\r\n\r\n附上获取git指定信息方法（<https://git-scm.com/docs/pretty-formats>）\r\n\r\n```sh\r\n%H: commit hash\r\n%h: 缩短的commit hash\r\n%T: tree hash\r\n%t: 缩短的 tree hash\r\n%P: parent hashes\r\n%p: 缩短的 parent hashes\r\n%an: 作者名字\r\n%aN: mailmap的作者名字 (.mailmap对应，详情参照git-shortlog(1)或者git-blame(1))\r\n%ae: 作者邮箱\r\n%aE: 作者邮箱 (.mailmap对应，详情参照git-shortlog(1)或者git-blame(1))\r\n%ad: 日期 (--date= 制定的格式)\r\n%aD: 日期, RFC2822格式\r\n%ar: 日期, 相对格式(1 day ago)\r\n%at: 日期, UNIX timestamp\r\n%ai: 日期, ISO 8601 格式\r\n%cn: 提交者名字\r\n%cN: 提交者名字 (.mailmap对应，详情参照git-shortlog(1)或者git-blame(1))\r\n%ce: 提交者 email\r\n%cE: 提交者 email (.mailmap对应，详情参照git-shortlog(1)或者git-blame(1))\r\n%cd: 提交日期 (--date= 制定的格式)\r\n%cD: 提交日期, RFC2822格式\r\n%cr: 提交日期, 相对格式(1 day ago)\r\n%ct: 提交日期, UNIX timestamp\r\n%ci: 提交日期, ISO 8601 格式\r\n%d: ref名称\r\n%e: encoding\r\n%s: commit信息标题\r\n%f: sanitized subject line, suitable for a filename\r\n%b: commit信息内容\r\n%N: commit notes\r\n%gD: reflog selector, e.g., refs/stash@{1}\r\n%gd: shortened reflog selector, e.g., stash@{1}\r\n%gs: reflog subject\r\n%Cred: 切换到红色\r\n%Cgreen: 切换到绿色\r\n%Cblue: 切换到蓝色\r\n%Creset: 重设颜色\r\n%C(...): 制定颜色, as described in color.branch.* config option\r\n%m: left, right or boundary mark\r\n%n: 换行\r\n%%: a raw %\r\n%x00: print a byte from a hex code\r\n%w([[,[,]]]): switch line wrapping, like the -w option of git-shortlog(1).\r\n```\r\n\r\n将version文件移植到打包文件中\r\n\r\n```js\r\n\r\nif (fs.existsSync(buildPath)) {\r\n    fs.writeFileSync(`${buildPath}/${versionPath}`, fs.readFileSync(versionPath));\r\n}\r\n```\r\n\r\n程序运行后，打印一个字母图案（显得高大上一些），附上一个可以根据输入的字母生成打印的字体的网站（<http://patorjk.com/software/taag/#p=testall&v=2&f=Graffiti&t=PERSAGY>）\r\n\r\n```js\r\n// 打包成功并且版本信息写入成功\r\nconsole.info([\r\n  \"██████╗ ███████╗██████╗ ███████╗ █████╗  ██████╗██╗   ██╗\",\r\n  \"██╔══██╗██╔════╝██╔══██╗██╔════╝██╔══██╗██╔════╝╚██╗ ██╔╝\",\r\n  \"██████╔╝█████╗  ██████╔╝███████╗███████║██║  ███╗╚████╔╝ \",\r\n  \"██╔═══╝ ██╔══╝  ██╔══██╗╚════██║██╔══██║██║   ██║ ╚██╔╝  \",\r\n  \"██║     ███████╗██║  ██║███████║██║  ██║╚██████╔╝  ██║   \",\r\n  \"╚═╝     ╚══════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝ ╚═════╝   ╚═╝   \",\r\n].join('\\n'));\r\n```\r\n\r\n通过node 执行该代码之后，就可以得到预期效果了。\r\n\r\n默认打印的颜色是白色，如果想根据成功失败警告打印不同的颜色的话，也可以加上对应的状态色彩哦。\r\n\r\n```js\r\n\r\nconsole.log('\\x1B[36m%s\\x1B[0m', info);  //cyan\r\nconsole.log('\\x1B[33m%s\\x1b[0m:', path);  //yellow\r\nvar styles = {\r\n    'bold'          : ['\\x1B[1m',  '\\x1B[22m'],\r\n    'italic'        : ['\\x1B[3m',  '\\x1B[23m'],\r\n    'underline'     : ['\\x1B[4m',  '\\x1B[24m'],\r\n    'inverse'       : ['\\x1B[7m',  '\\x1B[27m'],\r\n    'strikethrough' : ['\\x1B[9m',  '\\x1B[29m'],\r\n    'white'         : ['\\x1B[37m', '\\x1B[39m'],\r\n    'grey'          : ['\\x1B[90m', '\\x1B[39m'],\r\n    'black'         : ['\\x1B[30m', '\\x1B[39m'],\r\n    'blue'          : ['\\x1B[34m', '\\x1B[39m'],\r\n    'cyan'          : ['\\x1B[36m', '\\x1B[39m'],\r\n    'green'         : ['\\x1B[32m', '\\x1B[39m'],\r\n    'magenta'       : ['\\x1B[35m', '\\x1B[39m'],\r\n    'red'           : ['\\x1B[31m', '\\x1B[39m'],\r\n    'yellow'        : ['\\x1B[33m', '\\x1B[39m'],\r\n    'whiteBG'       : ['\\x1B[47m', '\\x1B[49m'],\r\n    'greyBG'        : ['\\x1B[49;5;8m', '\\x1B[49m'],\r\n    'blackBG'       : ['\\x1B[40m', '\\x1B[49m'],\r\n    'blueBG'        : ['\\x1B[44m', '\\x1B[49m'],\r\n    'cyanBG'        : ['\\x1B[46m', '\\x1B[49m'],\r\n    'greenBG'       : ['\\x1B[42m', '\\x1B[49m'],\r\n    'magentaBG'     : ['\\x1B[45m', '\\x1B[49m'],\r\n    'redBG'         : ['\\x1B[41m', '\\x1B[49m'],\r\n    'yellowBG'      : ['\\x1B[43m', '\\x1B[49m']\r\n};\r\n```\r\n\r\n在package.json里的打包命令上加上执行该程序，（&&为同步执行，&为异步执行）\r\n\r\n```js\r\n\"scripts\": {\r\n  \"build\": \"vue-cli-service build --mode production --dest dist&&node version.js\",\r\n},\r\n```\r\n\r\n打包之后version.txt效果：\r\n","children":[]},{"name":"中台","path":"../guanruihua.github.io/Front-End/Node","data":"","children":[{"name":"egg.md","path":"../guanruihua.github.io/Front-End/Node/中台","data":"# Egg\n\n> [官网](https://eggjs.org/zh-cn/intro/quickstart.html)\n\n## 特性\n\n- 提供基于 Egg [定制上层框架](https://eggjs.org/zh-cn/advanced/framework.html)的能力\n- 高度可扩展的[插件机制](https://eggjs.org/zh-cn/basics/plugin.html)\n- 内置[多进程管理](https://eggjs.org/zh-cn/advanced/cluster-client.html)\n- 基于 [Koa](http://koajs.com/) 开发，性能优异\n- 框架稳定，测试覆盖率高\n- [渐进式开发](https://eggjs.org/zh-cn/tutorials/progressive.html)\n\n## 环境搭建\n\n```basic\n$ mkdir egg-example && cd egg-example\n$ npm init egg --type=simple\n$ npm i\n# 启动\n$ npm run dev\n$ open http://localhost:7001\n```\n","children":[]},{"name":"express.md","path":"../guanruihua.github.io/Front-End/Node/中台","data":"# Express\n\n## 安装\n\n### 直接安装\n\n`cnpm install express --save`\n\n### 脚手架安装\n\n#### 使用express-generator安装\n\n使用命令行进入项目目录，依次执行：\n\n```\ncnpm i express-generator\n```\n\n可通过express -h查看命令行的指令含义\n\n```\nexpress -h\n```\n\n```\nUsage: express [options] [dir]\n```\n\n```basic\nOptions:\n    --version        输出版本号\n-e, --ejs            添加对 ejs 模板引擎的支持\n    --pug            添加对 pug 模板引擎的支持\n    --hbs            添加对 handlebars 模板引擎的支持\n-H, --hogan          添加对 hogan.js 模板引擎的支持\n-v, --view <engine>  添加对视图引擎（view） <engine> 的支持 (ejs|hbs|hjs|jade|pug|twig|vash) （默认是 jade 模板引擎）\n    --no-view        创建不带视图引擎的项目\n-c, --css <engine>   添加样式表引擎 <engine> 的支持 (less|stylus|compass|sass) （默认是普通的 css 文件）\n    --git            添加 .gitignore\n-f, --force          强制在非空目录下创建\n-h, --help           输出使用方法\n```\n\n创建了一个名为 myapp 的 Express 应用，并使用ejs模板引擎\n\n```\nexpress --view=ejs app\n```\n\n进入app，并安装依赖\n\n```\ncd myapp\nnpm install\n```\n\n**在Windows 下，使用以下命令启Express应用：**\n\n```\nset DEBUG=app:* & npm start\n```\n\n**在 MacOS 或 Linux 下，使用以下命令启Express应用：**\n\n```\nDEBUG=app:* npm start\n```\n\n## 第一个Express应用\n\n```js\nconst express = require('express');     //引入express模块\nvar app= express();     //express()是express模块顶级函数\n\napp.get('/',function(req,res){      //访问根路径时输出hello world\n    res.send(`<h1 style='color: blue'>hello world</h1>`);\n});\n\napp.listen(8080);       //设置访问端口号\n```\n\n## get请求\n\n一般在网站开发中，get都用作数据获取和查询，类似于数据库中的查询操作，当服务器解析前台资源后即传输相应内容；而查询字符串是在URL上进行的，形如：\n\n```js\nhttp://localhost:8080/login?goods1=0001&goods2=0002\n```\n\n### 二、获取前台get请求\n\n通过req.query可以获得用户发送的get请求，之后通过node操作将相应数据返回给用户。\n\n如果发送的是：\n\n```js\nhttp://localhost:8080/login?goods1=0001&goods2=0002\n```\n\n响应的话则通过：\n\n```js\nreq.query\n```\n\n他会获取到全部数据，或\n\n```js\nreq.query.goods1 // 0001\nreq.query.goods2 // 0002\n```\n\n来单独或去每一个数据。总之不同的需求对应不同的业务，大家按自己的需要来获取；\n\n### 三、实例\n\n下面通过一个实例来对获取get参数进行一个总结：\n\nHTML:\n\n```html\n<form action=\"http://localhost:8080/login\" method=\"get\">\n  用户：\n  <input type=\"text\" name=\"user\" id=\"user\" placeholder=\"用户名\"/>\n  <br>\n  密码：\n  <input type=\"password\" name=\"password\" id=\"password\" placeholder=\"密码\"/>\n  <br>\n  <input type=\"submit\" value=\"提交\"/>\n</form>\n```\n\nNODE:\n\n```javascript\nconst express = require(\"express\");\nvar app = express();\n\napp.get(\"/\",function(req,res){\n    res.send(\"主页\");\n});\n\napp.get(\"/login\",function(req,res){\n    console.log(req.query);\n    res.send(\"登录路由，user为：\"+req.query.user+\"==>   password为：\"+req.query.password);\n});\n\napp.listen(8080);\n```\n\n当在html页面中输入用户和密码提交后：\n\n就能得到想要的传输数据； 总之，虽然获取get参数并不复杂，但使用频率却相当的高，对于任何技术我们都应该秉持认真的态度去了解和学习它。\n\n## POST请求\n\npost方法作为http请求很重要的一部分，几乎所有的网站都有用到它，与get不同，post请求更像是在服务器上做修改操作，它一般用于数据资源的更新。 相比于get请求，post所请求的数据会更加安全。上一章中我们发现get请求会在地址栏显示输入的用户名和密码(有中文时会转化为BASE64加密)，而post请求则会将数据放入http包的包体中，这使得别人无法直接看到用户名和密码！\n\n### 二、Express如何设置POST请求\n\n1.我们的知道，首先我们得知道在form表单进行post请求，enctype属性一般设置为“application/x-www-form-urlencoded”，如果设置成multipart/form-data，则多用于文件上传，如下：\n\n```html\n<form action=\"#\" method=\"post\" enctype=\"application/x-www-form-urlencoded\">\n</form>\n```\n\n2设置解析body中间件\n\n```js\napp.use(express.urlencoded())\n```\n\n3获取body数据\n\n```javascript\nreq.body.username \n```\n\n登陆案例：\n\nHTML:\n\n```html\n<h1>登陆</h1>\n<form action=\"/login\" method=\"POST\">\n    <div>\n        用户名：<input type=\"text\" name=\"username\">\n    </div>\n    <div>\n        密码：<input type=\"password\" name=\"password\">\n    </div>\n    <button>登陆</button>\n</form>\n```\n\nAPP.JS\n\n```javascript\nvar express = require('express');\nvar path = require('path')\nvar app = express();\nvar sqlQuery = require('./lcMysql')\n\n// view engine setup\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'ejs');\napp.use(express.static(path.join(__dirname, 'public')));\n//解析post提交的数据\napp.use(express.urlencoded())\n\n//搜索首页\napp.get('/',(req,res)=>{\n  res.render('index.ejs')\n})\n\n//登陆页\napp.get('/login',(req,res)=>{\n  res.render('login')\n})\n//处理登陆请求\napp.post('/login',async (req,res)=>{\n  //获取用户名和密码\n  let username = req.body.username \n  let password = req.body.password\n  //查询数据库是否由此用户名和密码\n  let sqlStr = 'select * from user where username = ? and password = ?';\n  let arr = [username,password];\n  let result = await sqlQuery(sqlStr,arr)\n  if(result.length == 0 ){\n    res.send(\"登陆失败\")\n  }else{\n    res.send(\"登陆成功\")\n  }\n\n})\n\n\n\nmodule.exports = app;\n\n```\n\n## 中间件\n\n> 从字面意思，我们可以了解到它大概就是做中间代理操作，事实也是如此；大多数情况下，中间件就是在做接收到请求和发送响应中间的一系列操作。事实上，express是一个路由和中间件的web框架，Express 应用程序基本上是一系列中间件函数的调用。\n\n1. 浏览器发送请求\n\n2.express接受请求\n\n中间处理的过程\n\n3.路由函数处理渲染（req,res）\n\n4.res.render渲染\n\n中间件函数可以执行以下任务：\n\n- 执行任何代码。\n- 对请求和响应对象进行更改。\n- 结束请求/响应循环。\n- 调用堆栈中的下一个中间件函数。\n\n中间件也分为应用层中间件、路由中间件、内置中间件、错误处理中间件和第三方中间件。下面分别对以下进行说明：\n\n### 1.应用层中间件\n\n应用级中间键绑定到app对象使用app.use和app.METHOD()-需要处理http请求的方法，例如GET、PUT、POST，将之前的get或者post替换为use就行。 例如下面实例：\n\n```javascript\nconst express=require(\"express\");\n\nvar app=express();\n\n//匹配路由之前的操作\napp.use(function(req,res,next()){\n    console.log(\"访问之前\");\n});\n\napp.get(\"/\",function(req,res){\n    res.send(\"主页\");\n});\n\napp.listen(8080);\n```\n\n这时我们会发现<http://localhost:8080/地址一直在加载，但命令行里显示了“访问之前”，说明程序并不会同步执行，如果使用next>来是路由继续向下匹配，那么就能又得到主页数据了：\n\n```js\nconst express=require(\"express\");\n\nvar app=express();\n\n//匹配路由之前的操作\napp.use(function(req,res,next){\n    console.log(\"访问之前\");\n    next();\n});\n\napp.get(\"/\",function(req,res){\n    res.send(\"主页\");\n});\n\napp.listen(8080);\n```\n\n当然也可以简化写法：\n\n```js\nconst express=require(\"express\");\n\nvar app=express();\n\napp.use(function(req,res,next){\n    console.log(\"访问之前\");\n    next();\n},function(req,res){\n    res.send(\"主页\");\n});\n\napp.listen(8080);\n```\n\n因此，在进行路由匹配之前或再录又要继续向下执行时想做个操作，那么应用层中间件无疑是好的选择。\n\n### 2.路由中间件\n\n路由级中间件和应用级中间件类似，只不过他需要绑定express.Router();\n\n```js\nvar router = express.Router()\n```\n\n在匹配路由时，我们使用 router.use() 或 router.VERB() ,路由中间件结合多次callback可用于用户登录及用户状态检测。\n\n```js\nconst express = require(\"express\");\nvar app = express();\nvar router=express.Router();\n\nrouter.use(\"/\",function(req,res,next){\n    console.log(\"匹配前\");\n    next();\n});\n\nrouter.use(\"/user\",function(req,res,next){\n    console.log(\"匹配地址：\",req.originalUrl);\n    next();\n},function(req,res){\n    res.send(\"用户登录\");\n});\n\napp.use(\"/\",router);\n\napp.listen(8080);\n```\n\n总之在检测用户登录和引导用户应该访问哪个页面是，路由中间件绝对好用。\n\n### 3.错误处理中间件\n\n顾名思义，它是指当我们匹配不到路由时所执行的操作。错误处理中间件和其他中间件基本一样，只不过其需要开发者提供4个自变量参数。\n\n```js\napp.use((err, req, res, next) => {\n        res.sendStatus(err.httpStatusCode).json(err);\n});\n```\n\n一般情况下，我们把错误处理放在最下面，这样我们即可对错误进行集中处理。\n\n```js\nconst express=require(\"express\");\n\nvar app=express();\n\napp.get(\"/\",function(req,res,next){\n    const err=new Error('Not Found');\n    res.send(\"主页\");\n    next(err);\n});\n\napp.use(\"/user\",function(err,req,res,next){\n    console.log(\"用户登录\");\n    next(err);\n},function(req,res,next){\n    res.send(\"用户登录\");\n    next();\n});\n\napp.use(function(req,res){\n    res.status(404).send(\"未找到指定页面\");\n});\n\napp.listen(8080);\n```\n\n### 4.内置中间件\n\n从版本4.x开始，Express不再依赖Content，也就是说Express以前的内置中间件作为单独模块，express.static是Express的唯一内置中间件。\n\n```js\nexpress.static(root, [options]);\n```\n\n通过express.static我们可以指定要加载的静态资源。\n\n### 5.第三方中间件\n\n形如之前我们的body-parser，采用引入外部模块的方式来获得更多的应用操作。如后期的cookie和session。\n\n```js\nvar express = require('express');\nvar app = express();\nvar cookieParser = require('cookie-parser');\n```\n\n以上就是关于express中间件类型，在实际项目中，中间件都是必不可少的，因此熟悉使用各种中间件会加快项目的开发效率。\n\n## Cookie\n\n### 关于Cookie\n\n在我们关闭一个登录过的网址并重新打开它后，我们的登录信息依然没有丢失；当我们浏览了商品后历史记录里出现了我们点击过的商品；当我们推回到首页后，推荐商品也为我们选出了相似物品；事实上当我们有过此类操作后，浏览器会将我们的操作信息保存到cookie上面。阿进而言之，cookie就是储存在用户本地终端上的数据。\n\n**Cookie的特点**\n\n1. cookie保存在浏览器本地，只要不过期关闭浏览器也会存在。\n2. 正常情况下cookie不加密，用户可轻松看到\n3. 用户可以删除或者禁用cookie\n4. cookie可以被篡改\n5. cookie可用于攻击\n6. cookie存储量很小，大小一般是4k\n7. 发送请求自动带上登录信息\n\n### Cookie的安装及使用\n\n#### 1.安装\n\n```bash\ncnpm install cookie-parser --save\n```\n\n#### 2.引入\n\n```\nconst cookieParser=require(\"cookie-parser\"); \n```\n\n#### 3.设置中间件\n\n```\napp.use(cookieParser());\n```\n\n#### 4.设置cookie\n\n```js\nres.cookie(\"name\",'zhangsan',{maxAge: 900000, httpOnly: true});\n//res.cookie(名称,值,{配置信息})\n```\n\n关于设置cookie的参数说明：\n\n1. domain: 域名  \n2. name=value：键值对，可以设置要保存的 Key/Value，注意这里的 name 不能和其他属性项的名字一样\n3. Expires： 过期时间（秒），在设置的某个时间点后该 Cookie 就会失效，如 expires=Wednesday, 09-Nov-99 23:12:40 GMT。\n4. maxAge： 最大失效时间（毫秒），设置在多少后失效 。\n5. secure： 当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效 。\n6. Path： 表示 在那个路由下可以访问到cookie。\n7. httpOnly：是微软对 COOKIE 做的扩展。如果在 COOKIE 中设置了“httpOnly”属性，则通过程序（JS 脚本、applet 等）将无法读取到COOKIE 信息，防止 XSS 攻击的产生 。\n8. singed：表示是否签名cookie, 设为true 会对这个 cookie 签名，这样就需要用 res.signedCookies 而不是 res.cookies 访问它。被篡改的签名 cookie 会被服务器拒绝，并且 cookie 值会重置为它的原始值。\n\n#### 5.获取cookie\n\n```\nreq.cookies.name;\n```\n\n下面是一个基础实例：\n\n```js\nconst express=require(\"express\");\nconst cookieParser=require(\"cookie-parser\");\n\nvar app=express();\n\n//设置中间件\napp.use(cookieParser());\n\napp.get(\"/\",function(req,res){\n res.send(\"首页\");\n});\n\n//设置cookie\napp.get(\"/set\",function(req,res){\n res.cookie(\"userName\",'张三',{maxAge: 20000, httpOnly: true});\n res.send(\"设置cookie成功\");\n});\n\n//获取cookie\napp.get(\"/get\",function(req,res){\n console.log(req.cookies.userName);\n res.send(\"获取cookie成功，cookie为：\"+ req.cookies.userName);\n});\n\napp.listen(8080);\n```\n\n当访问set路由后会设置cookie，当访问get路由后会获取到设置的cookie值。当然你也可以在其他页面继续获取当前cookie，以实现cookie共享。\n\n### 多个二级域名共享cookie\n\n只需要增加res.cookie中option对象的值，即可实现对相应路由下多个二级路由的cookie进行共享，代码如下：\n\n```js\nconst express=require(\"express\");\nconst cookieParser=require(\"cookie-parser\");\n\nvar app=express();\n\n//设置中间件\napp.use(cookieParser());\n\napp.get(\"/\",function(req,res){\n res.send(\"首页\");\n});\n\n//设置cookie\napp.get(\"/set\",function(req,res){\n res.cookie(\"userName\",'张三',{maxAge: 200000, httpOnly: true,domain: \"ccc.com\"});\n res.send(\"设置cookie成功\");\n});\n\n//获取cookie\napp.get(\"/get\",function(req,res){\n console.log(req.cookies.userName);\n res.send(\"获取cookie成功，cookie为：\"+ req.cookies.userName);\n});\n\napp.listen(8080);\n```\n\n我们可以看到\n\n不同的二级域名也能访问到相同的cookie，只要满足ccc.com这个顶级域名就行。\n\n## Cookie加密\n\ncookie加密是让客户端用户无法的获取cookie明文信息，是数据安全的重要部分；一般的我们可以在保存cookie时对cookie信息进行加密，或者在res.cookie中对option对象的signed属性设置设置成true即可。\n\n### 二、使用 signed 属性进行cookie加密\n\n如下列代码：\n\n```js\nconst express = require(\"express\");\nconst cookieParser = require(\"cookie-parser\");\n\nvar app = express();\napp.use(cookieParser('secret'));\n\napp.get(\"/\",function(req,res){\n res.send(\"主页\");\n});\n\n//获取cookie\napp.use(function(req,res,next){\n console.log(req.signedCookies.name);\n next();\n});\n\n//设置cookie\napp.use(function(req,res,next){\n console.log(res.cookie(\"name\",\"zhangsan\",{httpOnly: true,maxAge: 200000,signed: true}));\n res.end(\"cookie为：\"+req.signedCookies.name);\n});\n\napp.listen(8080);\n```\n\n**签名原理**\nExpress用于对cookie签名，而cookie-parser则是实现对签名的解析。实质是把cookie设置的值和cookieParser(‘secret’);中的secret进行hmac加密，之后和cookie值加“.”的方式拼接起来。\n当option中signed设置为true后，底层会将cookie的值与“secret”进行hmac加密；\n\n**如何解析**\ncookie-parser中间件在解析签名cookie时做了两件事：\n\n1. 将签名cookie对应的原始值提取出来\n2. 验证签名cookie是否合法\n\n### 3、直接对cookie值加密\n\nnode为我们提供了一个核心安全模块“crypto”，它提供了很多安全相关的功能，如摘要运算、加密、电子签名等。\n这是，我们便可很轻易的封装一个加密模块：\n\n```js\nconst crypto=require('crypto');\n\nmodule.exports={\n //MD5封装\n MD5_SUFFIX:'s5w84&&d4d473885s2025s5*4s2',\n md5:function(str){\n  var obj=crypto.createHash('md5');\n  obj.update(str);  \n  return obj.digest('hex');\n }\n}\n```\n\n之后只需要进行相应导入即可\n\n```js\nconst common=require('./MD5');\n\nvar str='123456';\nvar str=common.md5(str+'s5w84&&d4d473885s2025s5*4s2');\nconsole.log(str);\n```\n\n设置cookie代码如下：\n\n```js\nconst express=require(\"express\");\nconst cookieParser=require(\"cookie-parser\");\nvar cry = require('./md5');\n\nvar app=express();\n\nvar str='hello-123';\nvar str=cry.md5(str+'s5w84&&d4d473885s2025s5*4s2');\n\n//设置中间件\napp.use(cookieParser());\n\n//获取加密cookie\napp.use(function(req,res,next){\n console.log(req.cookies.userName);\n next();\n});\n\n//设置并加密cookie\napp.use(function(req,res,next){\n res.cookie(\"userName\", str, {maxAge: 5*60*1000, httpOnly: true});\n res.end(\"set ok\");\n});\n\napp.listen(8080);\n```\n\n如果是在判断登录时，只需将用户输入的账号进行同样加密操作在进行比较即可知道账户是否正确。\ncrypto所涉及的加密方式有很多，推荐大家都写模块引用，这样更方便后期的维护。\n\n## session\n\n### 一、关于session\n\nsession是另一种记录客户状态的机制，与cookie保存在客户端浏览器不同，session保存在服务器当中；\n当客户端访问服务器时，服务器会生成一个session对象，对象中保存的是key:value值，同时服务器会将key传回给客户端的cookie当中；当用户第二次访问服务器时，就会把cookie当中的key传回到服务器中，最后服务器会吧value值返回给客户端。\n因此上面的key则是全局唯一的标识，客户端和服务端依靠这个全局唯一的标识来访问会话信息数据。\n\n### 二、设置session\n\n我们使用express-session模块来设置session\n\n##### 1.安装express-session\n\n```\ncnpm install express-session --save\n```\n\n##### 2.引入express-session模块\n\n```\nconst session=require(\"express-session\");\n```\n\n##### 3.设置session\n\n```\nsession(options);\n```\n\n如下列代码：\n\n```js\nconst express=require(\"express\");\nconst session=require(\"express-session\");\n\nvar app=express();\n\n//配置中间件\napp.use(session({\n secret: \"keyboard cat\",\n  resave: false,\n  saveUninitialized: true,\n  cookie: ('name', 'value',{maxAge:  5*60*1000,secure: false})\n}));\n\napp.use('/login',function(req,res){\n //设置session\n req.session.userinfo='张三';\n res.send(\"登陆成功！\");\n});\n\napp.use('/',function(req,res){\n //获取session\n if(req.session.userinfo){\n  res.send(\"hello \"+req.session.userinfo+\"，welcome\");\n }else{\n  res.send(\"未登陆\");\n }\n});\n\napp.listen(8080);\n```\n\n在session(option)中对session进行设置\n\n### 三、session的常用方法\n\n```js\n//设置session\nreq.session.username=\"张三\"\n\n//获取session\nreq.session.username\n\n//重新设置cookie的过期时间\nreq.session.cookie.maxAge=1000;\n\n//销毁session\nreq.session.destroy(function(err){\n \n})\n```\n\n以下演示通过销毁session的方式来退出登录\n\n```js\nconst express=require(\"express\");\nconst session=require(\"express-session\");\n\nvar app=express();\n\n//配置中间件\napp.use(session({\n secret: \"keyboard cat\",\n  resave: false,\n  saveUninitialized: true,\n  cookie: ('name', 'value',{ maxAge:  5*60*1000,\n        secure: false,\n        name: \"seName\",\n        resave: false})\n}));\n\napp.use('/login',function(req,res){\n //设置session\n req.session.userinfo='张三';\n res.send(\"登陆成功！\");\n});\n\napp.use('/loginOut',function(req,res){\n //注销session\n req.session.destroy(function(err){\n  res.send(\"退出登录！\"+err);\n });\n});\n\napp.use('/',function(req,res){\n //获取session\n if(req.session.userinfo){\n  res.send(\"hello \"+req.session.userinfo+\"，welcome to index\");\n }else{\n  res.send(\"未登陆\");\n }\n});\n\napp.listen(8080);\n```\n\n当我们进入到主页时，未显示任何信息，进入login路由后，自动设置session，这是回到主页则显示session信息，之后进入loginOut路由已注销session信息，再回到首页显示为登陆。\n\n## sobooks登陆功能\n\n### 1-引入session和cookie相关模块\n\n```js\nvar cookieParser = require('cookie-parser');\n//引入session模块\nlet session = require('express-session');\n```\n\n### 2-引入session\n\n```js\napp.use(session({\n  secret: \"xzsagjasoigjasoi\",\n  resave:true,//强制保存session\n  cookie:{\n    maxAge:7*24*60*60*1000,//设置session的有效期为1周\n  },\n  saveUninitialized:true//是否保存初始化的session\n}))\n```\n\n### 3-引入cookie中间件\n\n```json\napp.use(cookieParser('secret'));\n```\n\n### 4-写判断是否登陆的中间件\n\n```js\nfunction isLoginMid(req,res,next){\n    if(req.session.username==undefined){\n        res.render('info',{\n            title:\"未登录\",\n            content:\"尚未登陆，请进入登陆页面登陆\",\n            href:\"/login\",\n            hrefTxt:\"登录页\"\n        })\n    }else{\n        //一登录进入正常页面\n        next()\n    }\n}\n```\n\n### 5-引入一个跳转的模板信息页面\n\n可以显示登陆成功或者失败的信息内容，并且可以在一定时间内进行跳转。\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title><%-title%></title>\n</head>\n<body>\n    <h1><%-title%></h1>\n    <h3><%-content%></h3>\n    <p><span class=\"num\">5</span>秒后跳转至：<a href=\"<%-href%>\"><%-hrefTxt%></a></p>\n    <script>\n        n = 5;\n        setInterval(()=>{\n            n--;\n            if(n<0){\n                location.href = '<%-href%>';\n            }else{\n                document.querySelector('.num').innerHTML = n;\n            }\n        },1000)\n    </script>\n</body>\n</html>\n```\n\n### 6-登陆页面\n\n```javascript\n<form action=\"/login\" method=\"POST\">\n    <div class=\"form-group\">\n        <input class=\"form-control\" type=\"email\" name=\"mail\" placeholder=\"邮箱\" required=\"required\"/>\n            </div>\n<div class=\"form-group\">\n    <input class=\"form-control\" type=\"password\" name=\"password\" placeholder=\"密码\" required=\"required\"/>\n        </div>\n<p><a href=\"#\">忘记密码?</a></p>\n    <button class=\"btn btn-lg\">登录</button>\n</form>\n```\n\n### 7-处理POST方式提交的请求\n\n1-获取表单提交的数据\n\n2-查询表单提交的账号密码是否正确\n\n3-如果正确，设置session,req.session.username = user.username;\n\n4-显示登陆是否成功信息\n\n```js\nrouter.post('/',async function(req,res){\n    console.log(req.body)\n    //根据提交的邮箱和密码判断是否是正确的账号密码\n    let strSql = \"select * from user where mail=? and password = ?\"\n    let arr = [req.body.mail,req.body.password]\n    let result = await sqlQuery(strSql,arr)\n    if(result.length!=0){\n        //登陆成功\n        user = result[0];\n        req.session.username = user.username;\n        res.render('info',{\n            title:\"登陆成功\",\n            content:\"账号密码正确，即将进入首页\",\n            href:\"/\",\n            hrefTxt:\"首页\"\n        })\n    }else{\n        res.render('info',{\n            title:\"登陆失败\",\n            content:\"账号或密码不正确，即将进入登录页\",\n            href:\"/login\",\n            hrefTxt:\"登录页\"\n        })\n    }\n})\n```\n\n## sobook注册\n\n### 1-注册页\n\n1-设置表单\n\n```HTML\n<form action=\"/register\" method=\"POST\">\n    <div class=\"form-group\">\n        <input class=\"form-control\" type=\"email\" name=\"mail\" placeholder=\"邮箱\" required=\"required\"/>\n    </div>\n    <div class=\"form-group\">\n        <input class=\"form-control\" type=\"text\" name=\"username\" placeholder=\"用户名\" required=\"required\"/>\n    </div>\n    <div class=\"form-group\">\n        <input class=\"form-control\" type=\"password\" name=\"password\" placeholder=\"密码\" required=\"required\"/>\n    </div>\n    <div class=\"form-group\">\n        <input class=\"form-control\" type=\"password\" name=\"repassword\" placeholder=\"再次输入密码\" required=\"required\"/>\n    </div>\n\n    <p><a href=\"/login\">登陆</a></p>\n    <button id=\"registerBtn\" disabled=\"disable\" style=\"cursor: not-allowed;\" class=\"btn btn-lg\">注册</button>\n</form>\n```\n\n2-前端校验表单数据\n\n```javascript\nvar formDiv = document.querySelector('form');\n var inputs =  document.querySelectorAll('form input');\n var btn = document.querySelector('#registerBtn');\n formDiv.oninput = function(){\n  //判断是否有内容为空\n  isAble = true;\n  inputs.forEach((item,i)=>{\n   if(item.value==\"\"){\n    isAble = false;\n   }\n  })\n  //正则匹配邮箱地址\n  let reg = /^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$/\n  //密码与再次输入的密码是否匹配\n  if(inputs[2].value==inputs[3].value&&isAble&&reg.test(inputs[0].value)){\n   btn.disabled = false;\n   btn.style.cursor = 'pointer'\n  }else{\n   btn.disabled = true;\n   btn.style.cursor = 'not-allow'\n  }\n }\n```\n\n### 2-注册页的路由\n\n1-正常浏览器GET请求的路由\n\n```\nrouter.get('/', function(req, res, next) {\n  res.render('register')\n});\n```\n\n2-表单提交的POST请求路由，先判断是否已注册，没有注册即将数据插入到数据库\n\n```javascript\nrouter.post('/',async function(req,res){\n    //获取表单提交的邮箱，密码，用户名\n    console.log(req.body)\n    let mail = req.body.mail;\n    let password = jiami(req.body.password);\n    let username = req.body.username;\n    //判断邮箱是否已注册，如果已注册，将不在注册；\n    let strSql = \"select * from user where mail=?\"\n    let result = await sqlQuery(strSql,[mail])\n    if(result.length!=0){\n        //邮箱已注册\n        res.render('info',{\n            title:\"注册失败\",\n            content:\"此邮箱已注册过，可直接登陆，或找寻密码\",\n            href:\"/register\",\n            hrefTxt:\"注册页\"\n        })\n        \n    }else{\n       //此邮箱尚未注册，可注册\n       strSql = \"insert into user (mail,username,password) values (?,?,?)\"\n       await sqlQuery(strSql,[mail,username,password])\n       res.render('info',{\n        title:\"注册成功\",\n        content:\"注册成功请登陆，即将进入登陆页面\",\n        href:\"/login\",\n        hrefTxt:\"登录页\"\n    })\n    }\n})\n```\n\n### 3-加密密码并保存至数据库\n\n加密：\n\n```\nfunction jiami(str){\n    let salt = \"fjdsoigijasoigjasdiodgjasdiogjoasid\"\n    let obj = crypto.createHash('md5')\n    str = salt+str;\n    obj.update(str)\n    return obj.digest('hex')\n}\n```\n\n### 4-修改登陆也为加密操作\n\n```javascript\nfunction jiami(str){\n    let salt = \"fjdsoigijasoigjasdiodgjasdiogjoasid\"\n    let obj = crypto.createHash('md5')\n    str = salt+str;\n    obj.update(str)\n    return obj.digest('hex')\n}\n\nrouter.post('/',async function(req,res){\n    console.log(req.body)\n    //根据提交的邮箱和密码判断是否是正确的账号密码\n    let strSql = \"select * from user where mail=? and password = ?\"\n    let arr = [req.body.mail,jiami(req.body.password)]\n    let result = await sqlQuery(strSql,arr)\n    if(result.length!=0){\n        //登陆成功\n        user = result[0];\n        req.session.username = user.username;\n        res.render('info',{\n            title:\"登陆成功\",\n            content:\"账号密码正确，即将进入首页\",\n            href:\"/\",\n            hrefTxt:\"首页\"\n        })\n    }else{\n        res.render('info',{\n            title:\"登陆失败\",\n            content:\"账号或密码不正确，即将进入登录页\",\n            href:\"/login\",\n            hrefTxt:\"登录页\"\n        })\n    }\n    \n})\n```\n\n## 文件上传\n\n### 一、multer中间件\n\n再上传文件时，我们通常会使用到他。Multer用于处理multipart/form-data 类型的表单数据。首先我们先安装它：\n\n```\ncnpm install multer --save\n```\n\n### 二、使用\n\n首先在form表单中我们需要设置enctype为：multipart/form-data表单类型。同时我们也需要用到fs模块对文件重命名。下面是单文件上传实例：\n\n```\n<!DOCTYPE html>\n<html>\n <head>\n  <meta charset=\"utf-8\">\n  <title></title>\n </head>\n <body>\n  <form action=\"http://localhost:8080/\" method=\"post\" enctype=\"multipart/form-data\">\n   <input type=\"file\" name=\"files\" value=\"指定文件\">\n   <br><br>\n   <input type=\"submit\" value=\"上传\">\n  </form>\n </body>\n</html>\n```\n\nNODE代码：\n\n```\nconst express=require(\"express\");\nconst multer=require('multer');\n//初始化上传对象\nvar upload=multer({dest:'./upload/'});\nvar fs = require('fs');\n\n\nvar app=express();\n\napp.use(\"/\",upload.single(\"files\"),function(req,res){ //files为input type=\"file\"的name值\n var oldFile=req.file.destination+req.file.filename; //指定旧文件\n var newFile=req.file.destination + req.file.originalname; //指定新文件\n fs.rename(oldFile,newFile,function(err){\n  if(err){\n   res.send('上传失败！');\n  }else{\n   res.send('上传成功！');\n  }\n });\n});\n\napp.listen(8080);\n```\n\n在这里我们可以指定单个文件上传到根目录的upload文件夹里。这里值得注意的是req.file会返回文件的基本信息：\n\n```\n  fieldname: ***, //input type=\"file\"的name值\n  originalname: ***, //用户计算机上的文件的名称\n  encoding: '***',  //文件编码\n  mimetype: ***',  //文件的 MIME 类型\n  destination: './***/',  //保存路径\n  filename: ***,  //保存在 destination 中的文件名\n  path: ***,  //已上传文件的完整路径\n  size: **  //文件大小（字节单位）\n```\n\n### 三、上传多个文件\n\n在HTML找中input type=\"file\"需要加上multiple来实现过滤，multiple不写参数则可以读取·所有文件。而在服务端上，我们需要将single()改为array(“name”,num);的形式来接收多个文件的上传请求。最后对他们全部进行重命名。在这之前我们首先看看multer支持哪些文件上传方式：\n\n```\n.single(fieldname) //接受一个以 fieldname 命名的文件。.fields(fields)\n.array(fieldname[, maxCount]) //接受一个以 fieldname 命名的文件数组。可以配置 maxCount 来限制上传的最大数量。\n.fields(fields) //接受指定 fields 的混合文件。fields是一个拥有name和maxCount的数组对象。\n.none()  //只接受文本域。如果任何文件上传到这个模式，将发生 \"LIMIT_UNEXPECTED_FILE\" 错误。\n.any() //接受一切上传的文件。\n```\n\n下面我们将会演示如何上传多个文件：\nhtml：\n\n```\n<!DOCTYPE html>\n<html>\n <head>\n  <meta charset=\"utf-8\">\n  <title></title>\n </head>\n <body>\n  <form action=\"http://localhost:8080/\" method=\"post\" enctype=\"multipart/form-data\">\n   <input type=\"file\" name=\"files\" value=\"指定文件\" multiple>\n   <br><br>\n   <input type=\"submit\" value=\"上传\">\n  </form>\n </body>\n</html>\n```\n\nnode代码：\n\n```\nconst express=require(\"express\");\nconst multer=require('multer');\nvar upload=multer({dest:'./upload/'});\nvar fs = require('fs');\n\n\nvar app=express();\n\napp.use(\"/\",upload.array(\"files\",5),function(req,res,next){\n req.files.forEach(function(ele,index){\n  console.log(ele);\n  var oldFile=ele.destination+ele.filename; //指定旧文件\n  var newFile=ele.destination+ele.originalname; //指定新文件\n  fs.rename(oldFile,newFile,function(err){\n   err?console.log('上传失败！'):console.log('上传成功！');\n  });\n });\n res.send(\"成功上传\");\n});\n\napp.listen(8080);\n```\n\n这里，我们获取文件信息是通过req.files来获取，他是由数组构成的对象，之后用foreach循环对其进行重命名即可。\n\n### 四、通过limits来限制上传文件\n\nMulter通过使用limits这个对象来对数据进行限制，它允许使用以下参数：\n\n```\nKey Description Default\nfieldNameSize field 名字最大长度 100 bytes\nfieldSize field 值的最大长度 1MB\nfields 非文件 field 的最大数量 无限\nfileSize 在 multipart 表单中，文件最大长度 (字节单位) 无限\nfiles 在 multipart 表单中，文件最大数量 无限\nparts 在 multipart 表单中，part 传输的最大数量(fields + files) 无限\nheaderPairs 在 multipart 表单中，键值对最大组数 2000\n如果你上传的文件超出这些设定，MulterError模块将会启用，该模块在node_modules/multer/lib/multer-error.js上：\n```\n\n我们可以使用err.code定位到该错误，他有7种code方式，不同设置会返回不同code;\n\n```\nLIMIT_PART_COUNT\nLIMIT_FILE_SIZE\nLIMIT_FILE_COUNT\nLIMIT_FIELD_KEY\nLIMIT_FIELD_VALUE\nLIMIT_FIELD_COUNT\nLIMIT_FIELD_COUNT\n```\n\n下面就给大家做个简单实例：\nhtml依然不变，js代码如下：\n\n```\nconst express=require(\"express\");\nconst multer=require('multer');\nvar upload=multer({dest:'./upload/',limits:{fileSize: 1024 * 1024 * 20,files: 5}});\nvar fs = require('fs');\n\nvar app=express();\n\napp.use(\"/\",upload.array(\"files\",5),function(req,res,next){\n req.files.forEach(function(ele,index){\n  var oldFile=ele.destination+ele.filename; //指定旧文件\n  var newFile=ele.destination+ele.originalname; //指定新文件\n  fs.rename(oldFile,newFile,function(err){\n   err?console.log('上传失败！'):console.log('上传成功！');\n  });\n });\n next();\n res.send(\"上传成功！\");\n});\n\napp.use(function(err,req,res,next){\n if (err.code==='LIMIT_FILE_SIZE'){\n  res.send('File is too large');\n }else if(err.code==='LIMIT_FILE_COUNT'){\n  res.send('Too many files');\n }\n})\n\napp.listen(8080);\n```\n\n## 文件下载\n\n### 文件下载\n\n文件下载非常简单，仅需通过res.download()执行即可，他可以写为3种形式：\n\n```\nres.download('/report-12345.pdf');\n```\n\n以下是一个对选择对应文件进行下载的实例：\nhtml：\n\n```\n<!DOCTYPE html>\n<html>\n <head>\n  <meta charset=\"utf-8\">\n  <title></title>\n </head>\n <body>\n  <form action=\"http://localhost:8080/\" method=\"post\" enctype=\"application/x-www-form-urlencoded\">\n   <input type=\"file\" name=\"files\" value=\"选择下载的文件\"><br><br>\n   <input type=\"submit\" value=\"下载\">\n  </form>\n </body>\n</html>\n```\n\njs：\n\n```\nconst express=require(\"express\");\nconst bodyParser=require(\"body-parser\");\n\nvar app=express();\n\nvar jsonParser = bodyParser.json();\nvar urlencodedParser = bodyParser.urlencoded({ extended: false });\n\napp.post('/',urlencodedParser,function(req,res){\n res.download(\"./public/\"+req.body.files,err=>{\n  if(err){\n   res.send(\"下载失败！\");\n  }else{\n   console.log(\"下载成功！\");\n  }\n });\n});\n\napp.listen(8080);\n```\n\n我们可以选择根目录public下的文件对其进行下载。\n\n## AJAX上传图片\n\n### 图片上传实现步骤\n\n#### 图片上传\n\n通过jquery监听input change事件，这样我们可以获取到上传的图片流信息，从而可以获取到图片的地址、大小、格式以及名称等信息\n\n这里创建3个数组，imgName、imgSrc、imgFile分别用于存放上传图片的名称、url地址以及图片流信息\n\n```\nvar fileList = this.files;\n        for(var i = 0; i < fileList.length; i++) {\n            var imgSrcI = getObjectURL(fileList[i]);\n            imgName.push(fileList[i].name);\n            imgSrc.push(imgSrcI);\n            imgFile.push(fileList[i]);\n        }\n```\n\ngetObjectURL方法是一个用于获取本地图片的地址，使用该url可以显示图片\n\n```\nfunction getObjectURL(file) {\n    var url = null ;\n    if (window.createObjectURL!=undefined) { // basic\n        url = window.createObjectURL(file) ;\n    } else if (window.URL!=undefined) { // mozilla(firefox)\n        url = window.URL.createObjectURL(file) ;\n    } else if (window.webkitURL!=undefined) { // webkit or chrome\n        url = window.webkitURL.createObjectURL(file) ;\n    }\n    return url ;\n}\n```\n\n#### 控制上传图片大小、格式以及上传数量\n\n```\n    $('#upload').on('change',function(){        \n          if(imgSrc.length==4){\n            return alert(\"最多只能上传4张图片\");\n        }\n        var imgSize = this.files[0].size;  //b\n        if(imgSize>1024*1024*1){//1M\n            return alert(\"上传图片不能超过1M\");\n        }\n        if(this.files[0].type != 'image/png' && this.files[0].type != 'image/jpeg' && this.files[0].type != 'image/gif'){\n            return alert(\"图片上传格式不正确\");\n        }\n    })\n```\n\n#### 图片预览\n\n创建一个addNewContent方法用于动态展示添加的图片实现图片预览，在每次上传图片的时候调用该方法\n\n```\nfunction addNewContent(obj) {\n    $(obj).html(\"\");\n    for(var a = 0; a < imgSrc.length; a++) {\n        var oldBox = $(obj).html();\n        $(obj).html(oldBox + '<li class=\"content-img-list-item\"><img src=\"'+imgSrc[a]+'\" alt=\"\"><a index=\"'+a+'\" class=\"hide delete-btn\"><i class=\"ico-delete\"></i></a></li>');\n    }\n}\n```\n\n#### 图片删除\n\n1.通过监听鼠标的mouseover事件，显示图片删除按钮\n\n```\n$('.content-img-list').on('mouseover','.content-img-list-item',function(){\n        $(this).children('a').removeClass('hide');\n    });\n```\n\n2.监听鼠标的mouseleave事件，隐藏图片删除按钮\n\n```\n$('.content-img-list').on('mouseleave','.content-img-list-item',function(){\n        $(this).children('a').addClass('hide');\n    });\n```\n\n3.获取图片index下标属性，通过js的splice方法删除数组元素，重新调用addNewContent方法遍历图片数组显示预览图片\n\n```\n$(\".content-img-list\").on(\"click\",'.content-img-list-item a',function(){\n            var index = $(this).attr(\"index\");\n            imgSrc.splice(index, 1);\n            imgFile.splice(index, 1);\n            imgName.splice(index, 1);\n            var boxId = \".content-img-list\";\n            addNewContent(boxId);\n            if(imgSrc.length<4){//显示上传按钮\n                $('.content-img .file').show();\n            }\n      });\n```\n\n#### 图片上传提交\n\n这里主要使用FormData来拼装好数据参数，提交到后台\n\n```\nvar formFile = new FormData();\n```\n\n遍历imgFile图片流数组拼装到FormData中\n\n```\n $.each(imgFile, function(i, file){\n            formFile.append('myFile[]', file);\n        });\n```\n\n添加其他参数\n\n```\n    formFile.append(\"type\", type); \n        formFile.append(\"content\", content); \n        formFile.append(\"mobile\", mobile); \n```\n\n最后使用ajax提交内容\n\n```\n $.ajax({\n            url: 'http://zhangykwww.yind123.com/webapi/feedback',\n            type: 'POST',\n            data: formFile,\n            async: true,  \n            cache: false,  \n            contentType: false, \n            processData: false, \n            // traditional:true,\n            dataType:'json',\n            success: function(res) {\n                console.log(res);\n            }\n        })\n```\n\n以上就实现了图片上传、图片预览和图片删除的功能\n\njquery设置 ajax属性\n\n```\nprocessData : false, // 告诉jQuery不要去处理发送的数据\ncontentType : false,// 告诉jQuery不要去设置Content-Type请求头\n```\n","children":[]},{"name":"koa.md","path":"../guanruihua.github.io/Front-End/Node/中台","data":"# koa\n\n> nodejs平台web开发框架\n>\n> [Koa项目基础框架搭建](https://blog.csdn.net/weixin_36554693/article/details/105683996)\n\n## 简介\n\nKoa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。\n\n## 安装\n\nKoa 依赖 **node v7.6.0** 或 ES2015及更高版本和 async 方法支持.\n\n你可以使用自己喜欢的版本管理器快速安装支持的 node 版本：\n\n```bash\nnvm install 7\nnpm i koa\nnode my-koa-app.js\n```\n\n### 使用 Babel 实现 Async 方法\n\n要在 node < 7.6 版本的 Koa 中使用 `async` 方法, 我们推荐使用 [babel's require hook](https://www.babeljs.cn/docs/usage/babel-register/).\n\n```js\nrequire('babel-register');\n// 应用的其余 require 需要被放到 hook 后面\nconst app = require('./app');\n```\n\n要解析和编译 async 方法, 你至少应该有 [transform-async-to-generator](https://www.babeljs.cn/docs/plugins/transform-async-to-generator/) 或 [transform-async-to-module-method](https://www.babeljs.cn/docs/plugins/transform-async-to-module-method/) 插件.\n\n例如, 在你的 `.babelrc` 文件中, 你应该有:\n\n```json\n{\n  \"plugins\": [\"transform-async-to-generator\"]\n}\n```\n\n你也可以用 [env preset](https://www.babeljs.cn/docs/plugins/preset-env/) 的 target 参数 `\"node\": \"current\"` 替代.\n\n## 应用程序\n\nKoa 应用程序是一个包含一组中间件函数的对象，它是按照类似堆栈的方式组织和执行的。 Koa 类似于你可能遇到过的许多其他中间件系统，例如 Ruby 的 Rack ，Connect 等，然而，一个关键的设计点是在其低级中间件层中提供高级“语法糖”。 这提高了互操作性，稳健性，并使书写中间件更加愉快。\n\n这包括诸如内容协商，缓存清理，代理支持和重定向等常见任务的方法。 尽管提供了相当多的有用的方法 Koa 仍保持了一个很小的体积，因为没有捆绑中间件。\n\n必修的 hello world 应用:\n\n```js\nconst Koa = require('koa');\nconst app = new Koa();\n\napp.use(async ctx => {\n  ctx.body = 'Hello World';\n});\n\napp.listen(3000);\n```\n\n### 级联\n\nKoa 中间件以更传统的方式级联，您可能习惯使用类似的工具 - 之前难以让用户友好地使用 node 的回调。然而，使用 async 功能，我们可以实现 “真实” 的中间件。对比 Connect 的实现，通过一系列功能直接传递控制，直到一个返回，Koa 调用“下游”，然后控制流回“上游”。\n\n下面以 “Hello World” 的响应作为示例，当请求开始时首先请求流通过 `x-response-time` 和 `logging` 中间件，然后继续移交控制给 `response` 中间件。当一个中间件调用 `next()` 则该函数暂停并将控制传递给定义的下一个中间件。当在下游没有更多的中间件执行后，堆栈将展开并且每个中间件恢复执行其上游行为。\n\n```js\nconst Koa = require('koa');\nconst app = new Koa();\n\n// logger\n\napp.use(async (ctx, next) => {\n  await next();\n  const rt = ctx.response.get('X-Response-Time');\n  console.log(`${ctx.method} ${ctx.url} - ${rt}`);\n});\n\n// x-response-time\n\napp.use(async (ctx, next) => {\n  const start = Date.now();\n  await next();\n  const ms = Date.now() - start;\n  ctx.set('X-Response-Time', `${ms}ms`);\n});\n\n// response\n\napp.use(async ctx => {\n  ctx.body = 'Hello World';\n});\n\napp.listen(3000);\n```\n\n### 设置\n\n应用程序设置是 `app` 实例上的属性，目前支持如下：\n\n- `app.env` 默认是 **NODE_ENV** 或 \"development\"\n- `app.keys` 签名的 cookie 密钥数组\n- `app.proxy` 当真正的代理头字段将被信任时\n- 忽略 `.subdomains` 的 `app.subdomainOffset` 偏移量，默认为 2\n- `app.proxyIpHeader` 代理 ip 消息头, 默认为 `X-Forwarded-For`\n- `app.maxIpsCount` 从代理 ip 消息头读取的最大 ips, 默认为 0 (代表无限)\n\n您可以将设置传递给构造函数:\n\n```js\n  const Koa = require('koa');\n  const app = new Koa({ proxy: true });\n```\n\n或动态的:\n\n```js\n  const Koa = require('koa');\n  const app = new Koa();\n  app.proxy = true;\n```\n\n### app.listen(...)\n\nKoa 应用程序不是 HTTP 服务器的1对1展现。 可以将一个或多个 Koa 应用程序安装在一起以形成具有单个HTTP服务器的更大应用程序。\n\n创建并返回 HTTP 服务器，将给定的参数传递给 `Server#listen()`。这些内容都记录在 [nodejs.org](http://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback).\n\n以下是一个无作用的 Koa 应用程序被绑定到 `3000` 端口：\n\n```js\nconst Koa = require('koa');\nconst app = new Koa();\napp.listen(3000);\n```\n\n这里的 `app.listen(...)` 方法只是以下方法的语法糖:\n\n```js\nconst http = require('http');\nconst Koa = require('koa');\nconst app = new Koa();\nhttp.createServer(app.callback()).listen(3000);\n```\n\n这意味着您可以将同一个应用程序同时作为 HTTP 和 HTTPS 或多个地址：\n\n```js\nconst http = require('http');\nconst https = require('https');\nconst Koa = require('koa');\nconst app = new Koa();\nhttp.createServer(app.callback()).listen(3000);\nhttps.createServer(app.callback()).listen(3001);\n```\n\n### app.callback()\n\n返回适用于 `http.createServer()` 方法的回调函数来处理请求。你也可以使用此回调函数将 koa 应用程序挂载到 Connect/Express 应用程序中。\n\n### app.use(function)\n\n将给定的中间件方法添加到此应用程序。`app.use()` 返回 `this`, 因此可以链式表达.\n\n```js\napp.use(someMiddleware)\napp.use(someOtherMiddleware)\napp.listen(3000)\n```\n\n它等同于\n\n```js\napp.use(someMiddleware)\n  .use(someOtherMiddleware)\n  .listen(3000)\n```\n\n参阅 [Middleware](https://github.com/koajs/koa/wiki#middleware) 获取更多信息.\n\n### app.keys=\n\n设置签名的 Cookie 密钥。\n\n这些被传递给 [KeyGrip](https://github.com/crypto-utils/keygrip)，但是你也可以传递你自己的 `KeyGrip` 实例。\n\n例如，以下是可以接受的：\n\n```js\napp.keys = ['im a newer secret', 'i like turtle'];\napp.keys = new KeyGrip(['im a newer secret', 'i like turtle'], 'sha256');\n```\n\n这些密钥可以倒换，并在使用 `{ signed: true }` 参数签名 Cookie 时使用。\n\n```js\nctx.cookies.set('name', 'tobi', { signed: true });\n```\n\n### app.context\n\n`app.context` 是从其创建 `ctx` 的原型。您可以通过编辑 `app.context` 为 `ctx` 添加其他属性。这对于将 `ctx` 添加到整个应用程序中使用的属性或方法非常有用，这可能会更加有效（不需要中间件）和/或 更简单（更少的 `require()`），而更多地依赖于`ctx`，这可以被认为是一种反模式。\n\n例如，要从 `ctx` 添加对数据库的引用：\n\n```js\napp.context.db = db();\n\napp.use(async ctx => {\n  console.log(ctx.db);\n});\n```\n\n注意:\n\n- `ctx` 上的许多属性都是使用 `getter` ，`setter` 和 `Object.defineProperty()` 定义的。你只能通过在 `app.context` 上使用 `Object.defineProperty()` 来编辑这些属性（不推荐）。查阅 <https://github.com/koajs/koa/issues/652>.\n- 安装的应用程序目前使用其父级的 `ctx` 和设置。 因此，安装的应用程序只是一组中间件。\n\n#### 错误处理\n\n默认情况下，将所有错误输出到 stderr，除非 `app.silent` 为 `true`。 当 `err.status` 是 `404` 或 `err.expose` 是 `true` 时默认错误处理程序也不会输出错误。 要执行自定义错误处理逻辑，如集中式日志记录，您可以添加一个 “error” 事件侦听器：\n\n```js\napp.on('error', err => {\n  log.error('server error', err)\n});\n```\n\n如果 req/res 期间出现错误，并且 _无法_ 响应客户端，`Context`实例仍然被传递：\n\n```js\napp.on('error', (err, ctx) => {\n  log.error('server error', err, ctx)\n});\n```\n\n当发生错误 _并且_ 仍然可以响应客户端时，也没有数据被写入 socket 中，Koa 将用一个 500 “内部服务器错误” 进行适当的响应。在任一情况下，为了记录目的，都会发出应用级 “错误”。\n\n### 上下文(Context)\n\nKoa Context 将 node 的 `request` 和 `response` 对象封装到单个对象中，为编写 Web 应用程序和 API 提供了许多有用的方法。 这些操作在 HTTP 服务器开发中频繁使用，它们被添加到此级别而不是更高级别的框架，这将强制中间件重新实现此通用功能。\n\n_每个_ 请求都将创建一个 `Context`，并在中间件中作为接收器引用，或者 `ctx` 标识符，如以下代码片段所示：\n\n```js\napp.use(async ctx => {\n  ctx; // 这是 Context\n  ctx.request; // 这是 koa Request\n  ctx.response; // 这是 koa Response\n});\n```\n\n为方便起见许多上下文的访问器和方法直接委托给它们的 `ctx.request`或 `ctx.response` ，不然的话它们是相同的。 例如 `ctx.type` 和 `ctx.length` 委托给 `response` 对象，`ctx.path` 和 `ctx.method` 委托给 `request`。\n\n### API\n\n`Context` 具体方法和访问器.\n\n### ctx.req\n\nNode 的 `request` 对象.\n\n### ctx.res\n\nNode 的 `response` 对象.\n\n绕过 Koa 的 response 处理是 **不被支持的**. 应避免使用以下 node 属性：\n\n- `res.statusCode`\n- `res.writeHead()`\n- `res.write()`\n- `res.end()`\n\n### ctx.request\n\nkoa 的 `Request` 对象.\n\n### ctx.response\n\nkoa 的 `Response` 对象.\n\n### ctx.state\n\n推荐的命名空间，用于通过中间件传递信息和你的前端视图。\n\n```js\nctx.state.user = await User.find(id);\n```\n\n### ctx.app\n\n应用程序实例引用\n\n### ctx.app.emit\n\nKoa 应用扩展了内部 [EventEmitter](https://nodejs.org/dist/latest-v11.x/docs/api/events.html)。`ctx.app.emit` 发出一个类型由第一个参数定义的事件。对于每个事件，您可以连接 \"listeners\"，这是在发出事件时调用的函数。有关更多信息，请参阅[错误处理文档](https://koajs.com/#error-handling)。\n\n### ctx.cookies.get(name, [options])\n\n通过 `options` 获取 cookie `name`:\n\n- `signed` 所请求的cookie应该被签名\n\nkoa 使用 [cookies](https://github.com/pillarjs/cookies) 模块，其中只需传递参数。\n\n### ctx.cookies.set(name, value, [options])\n\n通过 `options` 设置 cookie `name` 的 `value` :\n\n- ```\n  maxAge\n  ```\n\n  : 一个数字, 表示从\n\n  ```\n  Date.now()\n  ```\n\n  得到的毫秒数.\n\n  - `expires`: 一个 `Date` 对象, 表示 cookie 的到期日期 (默认情况下在会话结束时过期).\n  - `path`: 一个字符串, 表示 cookie 的路径 (默认是`/`).\n  - `domain`: 一个字符串, 指示 cookie 的域 (无默认值).\n  - `secure`: 一个布尔值, 表示 cookie 是否仅通过 HTTPS 发送 (HTTP 下默认为 `false`, HTTPS 下默认为 `true`). [阅读有关此参数的更多信息](https://github.com/pillarjs/cookies#secure-cookies).\n  - `httpOnly`: 一个布尔值, 表示 cookie 是否仅通过 HTTP(S) 发送，, 且不提供给客户端 JavaScript (默认为 `true`).\n  - `sameSite`: 一个布尔值或字符串, 表示该 cookie 是否为 \"相同站点\" cookie (默认为 `false`). 可以设置为 `'strict'`, `'lax'`, `'none'`, 或 `true` (映射为 `'strict'`).\n  - `signed`: 一个布尔值, 表示是否要对 cookie 进行签名 (默认为 `false`). 如果为 `true`, 则还会发送另一个后缀为 `.sig` 的同名 cookie, 使用一个 27-byte url-safe base64 SHA1 值来表示针对第一个 [Keygrip](https://www.npmjs.com/package/keygrip) 键的 _cookie-name_=_cookie-value_ 的哈希值. 此签名密钥用于检测下次接收 cookie 时的篡改.\n  - `overwrite`: 一个布尔值, 表示是否覆盖以前设置的同名的 cookie (默认是 `false`). 如果是 true, 在同一个请求中设置相同名称的所有 Cookie（无论路径或域）是否在设置此Cookie 时从 Set-Cookie 消息头中过滤掉.\n\nkoa 使用传递简单参数的 [cookies](https://github.com/pillarjs/cookies) 模块。\n\n### ctx.throw([status], [msg], [properties])\n\n用来抛出一个包含 `.status` 属性错误的帮助方法，其默认值为 `500`。这样 Koa 就可以做出适当地响应。\n\n允许以下组合：\n\n```js\nctx.throw(400);\nctx.throw(400, 'name required');\nctx.throw(400, 'name required', { user: user });\n```\n\n例如 `ctx.throw(400, 'name required')` 等效于:\n\n```js\nconst err = new Error('name required');\nerr.status = 400;\nerr.expose = true;\nthrow err;\n```\n\n请注意，这些是用户级错误，并用 `err.expose` 标记，这意味着消息适用于客户端响应，这通常不是错误消息的内容，因为您不想泄漏故障详细信息。\n\n你可以根据需要将 `properties` 对象传递到错误中，对于装载上传给请求者的机器友好的错误是有用的。这用于修饰其人机友好型错误并向上游的请求者报告非常有用。\n\n```js\nctx.throw(401, 'access_denied', { user: user });\n```\n\nkoa 使用 [http-errors](https://github.com/jshttp/http-errors) 来创建错误。`status` 只应作为第一个参数传递。\n\n### ctx.assert(value, [status], [msg], [properties])\n\n当 `!value` 时抛出一个类似 `.throw` 错误的帮助方法。这与 node 的 [assert()](http://nodejs.org/api/assert.html) 方法类似.\n\n```js\nctx.assert(ctx.state.user, 401, 'User not found. Please login!');\n```\n\nkoa 使用 [http-assert](https://github.com/jshttp/http-assert) 作为断言。\n\n### ctx.respond\n\n为了绕过 Koa 的内置 response 处理，你可以显式设置 `ctx.respond = false;`。 如果您想要写入原始的 `res` 对象而不是让 Koa 处理你的 response，请使用此参数。\n\n请注意，Koa _不_ 支持使用此功能。这可能会破坏 Koa 中间件和 Koa 本身的预期功能。使用这个属性被认为是一个 hack，只是便于那些希望在 Koa 中使用传统的 `fn(req, res)` 功能和中间件的人。\n\n## Request 别名\n\n以下访问器和 [Request](https://koa.bootcss.com/#request) 别名等效：\n\n- `ctx.header`\n- `ctx.headers`\n- `ctx.method`\n- `ctx.method=`\n- `ctx.url`\n- `ctx.url=`\n- `ctx.originalUrl`\n- `ctx.origin`\n- `ctx.href`\n- `ctx.path`\n- `ctx.path=`\n- `ctx.query`\n- `ctx.query=`\n- `ctx.querystring`\n- `ctx.querystring=`\n- `ctx.host`\n- `ctx.hostname`\n- `ctx.fresh`\n- `ctx.stale`\n- `ctx.socket`\n- `ctx.protocol`\n- `ctx.secure`\n- `ctx.ip`\n- `ctx.ips`\n- `ctx.subdomains`\n- `ctx.is()`\n- `ctx.accepts()`\n- `ctx.acceptsEncodings()`\n- `ctx.acceptsCharsets()`\n- `ctx.acceptsLanguages()`\n- `ctx.get()`\n\n### Response 别名\n\n以下访问器和 [Response](https://koa.bootcss.com/#response) 别名等效：\n\n- `ctx.body`\n- `ctx.body=`\n- `ctx.status`\n- `ctx.status=`\n- `ctx.message`\n- `ctx.message=`\n- `ctx.length=`\n- `ctx.length`\n- `ctx.type=`\n- `ctx.type`\n- `ctx.headerSent`\n- `ctx.redirect()`\n- `ctx.attachment()`\n- `ctx.set()`\n- `ctx.append()`\n- `ctx.remove()`\n- `ctx.lastModified=`\n- `ctx.etag=`\n\n## 请求(Request)\n\nKoa `Request` 对象是在 node 的 原生请求对象之上的抽象，提供了诸多对 HTTP 服务器开发有用的功能。\n\n### API\n\n### request.header\n\n请求头对象。这与 node [`http.IncomingMessage`](https://nodejs.org/api/http.html#http_class_http_incomingmessage) 上的 [`headers`](https://nodejs.org/api/http.html#http_message_headers) 字段相同\n\n### request.header=\n\n设置请求头对象。\n\n### request.headers\n\n请求头对象。别名为 `request.header`.\n\n### request.headers=\n\n设置请求头对象。别名为 `request.header=`.\n\n### request.method\n\n请求方法。\n\n### request.method=\n\n设置请求方法，对于实现诸如 `methodOverride()` 的中间件是有用的。\n\n### request.length\n\n返回以数字返回请求的 Content-Length，或 `undefined`。\n\n### request.url\n\n获取请求 URL.\n\n### request.url=\n\n设置请求 URL, 对 url 重写有用。\n\n### request.originalUrl\n\n获取请求原始URL。\n\n### request.origin\n\n获取URL的来源，包括 `protocol` 和 `host`。\n\n```js\nctx.request.origin\n// => http://example.com\n```\n\n### request.href\n\n获取完整的请求URL，包括 `protocol`，`host` 和 `url`。\n\n```js\nctx.request.href;\n// => http://example.com/foo/bar?q=1\n```\n\n### request.path\n\n获取请求路径名。\n\n### request.path=\n\n设置请求路径名，并在存在时保留查询字符串。\n\n### request.querystring\n\n根据 `?` 获取原始查询字符串.\n\n### request.querystring=\n\n设置原始查询字符串。\n\n### request.search\n\n使用 `?` 获取原始查询字符串。\n\n### request.search=\n\n设置原始查询字符串。\n\n### request.host\n\n存在时获取主机（hostname:port）。当 `app.proxy` 是 **true** 时支持 `X-Forwarded-Host`，否则使用 `Host`。\n\n### request.hostname\n\n存在时获取主机名。当 `app.proxy` 是 **true** 时支持 `X-Forwarded-Host`，否则使用 `Host`。\n\n如果主机是 IPv6, Koa 解析到 [WHATWG URL API](https://nodejs.org/dist/latest-v8.x/docs/api/url.html#url_the_whatwg_url_api), _注意_ 这可能会影响性能。\n\n### request.URL\n\n获取 WHATWG 解析的 URL 对象。\n\n### request.type\n\n获取请求 `Content-Type`, 不含 \"charset\" 等参数。\n\n> 译者注: 这里其实是只获取 _mime-type_, 详见[源码及其注释](https://github.com/koajs/koa/blob/eda27608f7d39ede86d7b402aae64b1867ce31c6/lib/request.js#L639)\n\n```js\nconst ct = ctx.request.type;\n// => \"image/png\"\n```\n\n### request.charset\n\n存在时获取请求字符集，或者 `undefined`：\n\n```js\nctx.request.charset;\n// => \"utf-8\"\n```\n\n### request.query\n\n获取解析的查询字符串, 当没有查询字符串时，返回一个空对象。请注意，此 getter _不_ 支持嵌套解析。\n\n例如 \"color=blue&size=small\":\n\n```js\n{\n  color: 'blue',\n  size: 'small'\n}\n```\n\n### request.query=\n\n将查询字符串设置为给定对象。 请注意，此 setter _不_ 支持嵌套对象。\n\n```js\nctx.query = { next: '/login' };\n```\n\n### request.fresh\n\n检查请求缓存是否“新鲜”，也就是内容没有改变。此方法用于 `If-None-Match` / `ETag`, 和 `If-Modified-Since` 和 `Last-Modified` 之间的缓存协商。 在设置一个或多个这些响应头后应该引用它。\n\n```js\n// 新鲜度检查需要状态20x或304\nctx.status = 200;\nctx.set('ETag', '123');\n\n// 缓存是好的\nif (ctx.fresh) {\n  ctx.status = 304;\n  return;\n}\n\n// 缓存是陈旧的\n// 获取新数据\nctx.body = await db.find('something');\n```\n\n### request.stale\n\n与 `request.fresh` 相反.\n\n### request.protocol\n\n返回请求协议，“https” 或 “http”。当 `app.proxy` 是 **true** 时支持 `X-Forwarded-Proto`。\n\n### request.secure\n\n通过 `ctx.protocol == \"https\"` 来检查请求是否通过 TLS 发出。\n\n### request.ip\n\n请求远程地址。 当 `app.proxy` 是 **true** 时支持 `X-Forwarded-Proto`。\n\n### request.ips\n\n当 `X-Forwarded-For` 存在并且 `app.proxy` 被启用时，这些 ips 的数组被返回，从上游 - >下游排序。 禁用时返回一个空数组。\n\n例如，如果值是 \"client, proxy1, proxy2\"，将会得到数组 `[\"client\", \"proxy1\", \"proxy2\"]`。\n\n大多数反向代理（nginx）都通过 `proxy_add_x_forwarded_for` 设置了 x-forwarded-for，这带来了一定的安全风险。恶意攻击者可以通过伪造 `X-Forwarded-For` 请求头来伪造客户端的ip地址。 客户端发送的请求具有 'forged' 的 `X-Forwarded-For` 请求头。 在由反向代理转发之后，`request.ips` 将是 ['forged', 'client', 'proxy1', 'proxy2']。\n\nKoa 提供了两种方式来避免被绕过。\n\n如果您可以控制反向代理，则可以通过调整配置来避免绕过，或者使用 koa 提供的 `app.proxyIpHeader` 来避免读取 `x-forwarded-for` 获取 ips。\n\n```js\nconst app = new Koa({\n  proxy: true,\n  proxyIpHeader: 'X-Real-IP',\n});\n```\n\n如果您确切知道服务器前面有多少个反向代理，则可以通过配置 `app.maxIpsCount` 来避免读取用户的伪造的请求头：\n\n```js\nconst app = new Koa({\n  proxy: true,\n  maxIpsCount: 1, // 服务器前只有一个代理\n});\n\n// request.header['X-Forwarded-For'] === [ '127.0.0.1', '127.0.0.2' ];\n// ctx.ips === [ '127.0.0.2' ];\n```\n\n### request.subdomains\n\n以数组形式返回子域。\n\n子域是应用程序主域之前主机的点分隔部分。默认情况下，应用程序的域名假定为主机的最后两个部分。这可以通过设置 `app.subdomainOffset` 来更改。\n\n例如，如果域名为“tobi.ferrets.example.com”：\n\n如果 `app.subdomainOffset` 未设置, `ctx.subdomains` 是 `[\"ferrets\", \"tobi\"]`. 如果 `app.subdomainOffset` 是 3, `ctx.subdomains` 是 `[\"tobi\"]`.\n\n### request.is(types...)\n\n检查传入请求是否包含 `Content-Type` 消息头字段， 并且包含任意的 mime `type`。 如果没有请求主体，返回 `null`。 如果没有内容类型，或者匹配失败，则返回 `false`。 反之则返回匹配的 content-type。\n\n```js\n// 使用 Content-Type: text/html; charset=utf-8\nctx.is('html'); // => 'html'\nctx.is('text/html'); // => 'text/html'\nctx.is('text/*', 'text/html'); // => 'text/html'\n\n// 当 Content-Type 是 application/json 时\nctx.is('json', 'urlencoded'); // => 'json'\nctx.is('application/json'); // => 'application/json'\nctx.is('html', 'application/*'); // => 'application/json'\n\nctx.is('html'); // => false\n```\n\n例如，如果要确保仅将图像发送到给定路由：\n\n```js\nif (ctx.is('image/*')) {\n  // 处理\n} else {\n  ctx.throw(415, 'images only!');\n}\n```\n\n### 内容协商\n\nKoa 的 `request` 对象包括由 [accepts](http://github.com/expressjs/accepts) 和 [negotiator](https://github.com/federomero/negotiator) 提供的内容协商实用函数。\n\n这些实用函数是：\n\n- `request.accepts(types)`\n- `request.acceptsEncodings(types)`\n- `request.acceptsCharsets(charsets)`\n- `request.acceptsLanguages(langs)`\n\n如果没有提供类型，则返回 **所有** 可接受的类型。\n\n如果提供多种类型，将返回最佳匹配。 如果没有找到匹配项，则返回一个`false`，你应该向客户端发送一个`406 \"Not Acceptable\"` 响应。\n\n如果接收到任何类型的接收头，则会返回第一个类型。 因此，你提供的类型的顺序很重要。\n\n### request.accepts(types)\n\n检查给定的 `type(s)` 是否可以接受，如果 `true`，返回最佳匹配，否则为 `false`。 `type` 值可能是一个或多个 mime 类型的字符串，如 `application/json`，扩展名称如 `json`，或数组 `[\"json\", \"html\", \"text/plain\"]`。\n\n```js\n// Accept: text/html\nctx.accepts('html');\n// => \"html\"\n\n// Accept: text/*, application/json\nctx.accepts('html');\n// => \"html\"\nctx.accepts('text/html');\n// => \"text/html\"\nctx.accepts('json', 'text');\n// => \"json\"\nctx.accepts('application/json');\n// => \"application/json\"\n\n// Accept: text/*, application/json\nctx.accepts('image/png');\nctx.accepts('png');\n// => false\n\n// Accept: text/*;q=.5, application/json\nctx.accepts(['html', 'json']);\nctx.accepts('html', 'json');\n// => \"json\"\n\n// No Accept header\nctx.accepts('html', 'json');\n// => \"html\"\nctx.accepts('json', 'html');\n// => \"json\"\n```\n\n你可以根据需要多次调用 `ctx.accepts()`，或使用 switch：\n\n```js\nswitch (ctx.accepts('json', 'html', 'text')) {\n  case 'json': break;\n  case 'html': break;\n  case 'text': break;\n  default: ctx.throw(406, 'json, html, or text only');\n}\n```\n\n### request.acceptsEncodings(encodings)\n\n检查 `encodings` 是否可以接受，返回最佳匹配为 `true`，否则为 `false`。 请注意，您应该将`identity` 作为编码之一！\n\n```js\n// Accept-Encoding: gzip\nctx.acceptsEncodings('gzip', 'deflate', 'identity');\n// => \"gzip\"\n\nctx.acceptsEncodings(['gzip', 'deflate', 'identity']);\n// => \"gzip\"\n```\n\n当没有给出参数时，所有接受的编码将作为数组返回：\n\n```js\n// Accept-Encoding: gzip, deflate\nctx.acceptsEncodings();\n// => [\"gzip\", \"deflate\", \"identity\"]\n```\n\n请注意，如果客户端显式地发送 `identity;q=0`，那么 `identity` 编码（这意味着没有编码）可能是不可接受的。 虽然这是一个边缘的情况，你仍然应该处理这种方法返回 `false` 的情况。\n\n### request.acceptsCharsets(charsets)\n\n检查 `charsets` 是否可以接受，在 `true` 时返回最佳匹配，否则为 `false`。\n\n```js\n// Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5\nctx.acceptsCharsets('utf-8', 'utf-7');\n// => \"utf-8\"\n\nctx.acceptsCharsets(['utf-7', 'utf-8']);\n// => \"utf-8\"\n```\n\n当没有参数被赋予所有被接受的字符集将作为数组返回：\n\n```js\n// Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5\nctx.acceptsCharsets();\n// => [\"utf-8\", \"utf-7\", \"iso-8859-1\"]\n```\n\n### request.acceptsLanguages(langs)\n\n检查 `langs` 是否可以接受，如果为 `true`，返回最佳匹配，否则为 `false`。\n\n```js\n// Accept-Language: en;q=0.8, es, pt\nctx.acceptsLanguages('es', 'en');\n// => \"es\"\n\nctx.acceptsLanguages(['en', 'es']);\n// => \"es\"\n```\n\n当没有参数被赋予所有接受的语言将作为数组返回：\n\n```js\n// Accept-Language: en;q=0.8, es, pt\nctx.acceptsLanguages();\n// => [\"es\", \"pt\", \"en\"]\n```\n\n### request.idempotent\n\n检查请求是否是幂等的。\n\n### request.socket\n\n返回请求套接字。\n\n### request.get(field)\n\n返回请求头(header), `field` 不区分大小写.\n\n## 响应(Response)\n\nKoa `Response` 对象是在 node 的原生响应对象之上的抽象，提供了诸多对 HTTP 服务器开发有用的功能。\n\n### API\n\n### response.header\n\n响应头对象。\n\n### response.headers\n\n响应头对象。别名是 `response.header`。\n\n### response.socket\n\n响应套接字。 作为 `request.socket` 指向 net.Socket 实例。\n\n### response.status\n\n获取响应状态。默认情况下，`response.status` 设置为 `404` 而不是像 node 的 `res.statusCode` 那样默认为 `200`。\n\n### response.status=\n\n通过数字代码设置响应状态：\n\n- 100 \"continue\"\n- 101 \"switching protocols\"\n- 102 \"processing\"\n- 200 \"ok\"\n- 201 \"created\"\n- 202 \"accepted\"\n- 203 \"non-authoritative information\"\n- 204 \"no content\"\n- 205 \"reset content\"\n- 206 \"partial content\"\n- 207 \"multi-status\"\n- 208 \"already reported\"\n- 226 \"im used\"\n- 300 \"multiple choices\"\n- 301 \"moved permanently\"\n- 302 \"found\"\n- 303 \"see other\"\n- 304 \"not modified\"\n- 305 \"use proxy\"\n- 307 \"temporary redirect\"\n- 308 \"permanent redirect\"\n- 400 \"bad request\"\n- 401 \"unauthorized\"\n- 402 \"payment required\"\n- 403 \"forbidden\"\n- 404 \"not found\"\n- 405 \"method not allowed\"\n- 406 \"not acceptable\"\n- 407 \"proxy authentication required\"\n- 408 \"request timeout\"\n- 409 \"conflict\"\n- 410 \"gone\"\n- 411 \"length required\"\n- 412 \"precondition failed\"\n- 413 \"payload too large\"\n- 414 \"uri too long\"\n- 415 \"unsupported media type\"\n- 416 \"range not satisfiable\"\n- 417 \"expectation failed\"\n- 418 \"I'm a teapot\"\n- 422 \"unprocessable entity\"\n- 423 \"locked\"\n- 424 \"failed dependency\"\n- 426 \"upgrade required\"\n- 428 \"precondition required\"\n- 429 \"too many requests\"\n- 431 \"request header fields too large\"\n- 500 \"internal server error\"\n- 501 \"not implemented\"\n- 502 \"bad gateway\"\n- 503 \"service unavailable\"\n- 504 \"gateway timeout\"\n- 505 \"http version not supported\"\n- 506 \"variant also negotiates\"\n- 507 \"insufficient storage\"\n- 508 \"loop detected\"\n- 510 \"not extended\"\n- 511 \"network authentication required\"\n\n**注意**: 不用太在意记住这些字符串, 如果你写错了,可以查阅这个列表随时更正.\n\n由于 `response.status` 默认设置为 `404`，因此发送没有 body 且状态不同的响应的操作如下：\n\n```js\nctx.response.status = 200;\n\n// 或其他任何状态\nctx.response.status = 204;\n```\n\n### response.message\n\n获取响应的状态消息. 默认情况下, `response.message` 与 `response.status` 关联.\n\n### response.message=\n\n将响应的状态消息设置为给定值。\n\n### response.length=\n\n将响应的 Content-Length 设置为给定值。\n\n### response.length\n\n以数字返回响应的 Content-Length，或者从`ctx.body`推导出来，或者`undefined`。\n\n### response.body\n\n获取响应主体。\n\n### response.body=\n\n将响应体设置为以下之一：\n\n- `string` 写入\n- `Buffer` 写入\n- `Stream` 管道\n- `Object` || `Array` JSON-字符串化\n- `null` 无内容响应\n\n如果 `response.status` 未被设置, Koa 将会自动设置状态为 `200` 或 `204`。\n\nKoa 没有防范作为响应体的所有内容 - 函数没有有意义地序列化，返回布尔值可能会根据您的应用程序而有意义。并且当错误生效时，它可能无法正常工作 错误的属性无法枚举。 我们建议在您的应用中添加中间件，以确定每个应用的正文类型。 示例中间件可能是：\n\n```js\napp.use(async (ctx, next) => {\n  await next()\n\n  ctx.assert.equal('object', typeof ctx, 500, '某些开发错误')\n})\n```\n\n#### String\n\nContent-Type 默认为 `text/html` 或 `text/plain`, 同时默认字符集是 utf-8。Content-Length 字段也是如此。\n\n#### Buffer\n\nContent-Type 默认为 `application/octet-stream`, 并且 Content-Length 字段也是如此。\n\n#### Stream\n\nContent-Type 默认为 `application/octet-stream`。\n\n每当流被设置为响应主体时，`.onerror` 作为侦听器自动添加到 `error` 事件中以捕获任何错误。此外，每当请求关闭（甚至过早）时，流都将被销毁。如果你不想要这两个功能，请勿直接将流设为主体。例如，当将主体设置为代理中的 HTTP 流时，你可能不想要这样做，因为它会破坏底层连接。\n\n参阅: <https://github.com/koajs/koa/pull/612> 获取更多信息。\n\n以下是流错误处理的示例，而不会自动破坏流：\n\n```js\nconst PassThrough = require('stream').PassThrough;\n\napp.use(async ctx => {\n  ctx.body = someHTTPStream.on('error', (err) => ctx.onerror(err)).pipe(PassThrough());\n});\n```\n\n#### Object\n\nContent-Type 默认为 `application/json`. 这包括普通的对象 `{ foo: 'bar' }` 和数组 `['foo', 'bar']`。\n\n### response.get(field)\n\n不区分大小写获取响应头字段值 `field`。\n\n```js\nconst etag = ctx.response.get('ETag');\n```\n\n### response.has(field)\n\n如果当前在响应头中设置了由名称标识的消息头，则返回 `true`. 消息头名称匹配不区分大小写.\n\n```js\nconst rateLimited = ctx.response.has('X-RateLimit-Limit');\n```\n\n### response.set(field, value)\n\n设置响应头 `field` 到 `value`:\n\n```js\nctx.set('Cache-Control', 'no-cache');\n```\n\n### response.append(field, value)\n\n用值 `val` 附加额外的消息头 `field`。\n\n```js\nctx.append('Link', '<http://127.0.0.1/>');\n```\n\n### response.set(fields)\n\n用一个对象设置多个响应头`fields`:\n\n```js\nctx.set({\n  'Etag': '1234',\n  'Last-Modified': date\n});\n```\n\n这将委托给 [setHeader](https://nodejs.org/dist/latest/docs/api/http.html#http_request_setheader_name_value) ，它通过指定的键设置或更新消息头，并且不重置整个消息头。\n\n### response.remove(field)\n\n删除消息头 `field`。\n\n### response.type\n\n获取响应 `Content-Type`, 不含 \"charset\" 等参数。\n\n> 译者注: 这里其实是只获取 _mime-type_, 详见[源码及其注释](https://github.com/koajs/koa/blob/eda27608f7d39ede86d7b402aae64b1867ce31c6/lib/response.js#L371)\n\n```js\nconst ct = ctx.type;\n// => \"image/png\"\n```\n\n### response.type=\n\n设置响应 `Content-Type` 通过 mime 字符串或文件扩展名。\n\n```js\nctx.type = 'text/plain; charset=utf-8';\nctx.type = 'image/png';\nctx.type = '.png';\nctx.type = 'png';\n```\n\n注意: 在适当的情况下为你选择 `charset`, 比如 `response.type = 'html'` 将默认是 \"utf-8\". 如果你想覆盖 `charset`, 使用 `ctx.set('Content-Type', 'text/html')` 将响应头字段设置为直接值。\n\n### response.is(types...)\n\n非常类似 `ctx.request.is()`. 检查响应类型是否是所提供的类型之一。这对于创建操纵响应的中间件特别有用。\n\n例如, 这是一个中间件，可以削减除流之外的所有HTML响应。\n\n```js\nconst minify = require('html-minifier');\n\napp.use(async (ctx, next) => {\n  await next();\n\n  if (!ctx.response.is('html')) return;\n\n  let body = ctx.body;\n  if (!body || body.pipe) return;\n\n  if (Buffer.isBuffer(body)) body = body.toString();\n  ctx.body = minify(body);\n});\n```\n\n### response.redirect(url, [alt])\n\n执行 [302] 重定向到 `url`.\n\n字符串 “back” 是特别提供 Referrer 支持的，当 Referrer 不存在时，使用 `alt` 或 “/”。\n\n```js\nctx.redirect('back');\nctx.redirect('back', '/index.html');\nctx.redirect('/login');\nctx.redirect('http://google.com');\n```\n\n要更改 “302” 的默认状态，只需在该调用之前或之后给 `status` 赋值。要变更主体请在此调用之后:\n\n```js\nctx.status = 301;\nctx.redirect('/cart');\nctx.body = 'Redirecting to shopping cart';\n```\n\n### response.attachment([filename], [options])\n\n将 `Content-Disposition` 设置为 “附件” 以指示客户端提示下载。(可选)指定下载的 `filename` 和部分 [参数](https://github.com/jshttp/content-disposition#options)。\n\n### response.headerSent\n\n检查是否已经发送了一个响应头。 用于查看客户端是否可能会收到错误通知。\n\n### response.lastModified\n\n将 `Last-Modified` 消息头返回为 `Date`, 如果存在。\n\n### response.lastModified=\n\n将 `Last-Modified` 消息头设置为适当的 UTC 字符串。您可以将其设置为 `Date` 或日期字符串。\n\n```js\nctx.response.lastModified = new Date();\n```\n\n### response.etag=\n\n设置包含 `\"` 包裹的 ETag 响应， 请注意，没有相应的 `response.etag` getter。\n\n```js\nctx.response.etag = crypto.createHash('md5').update(ctx.body).digest('hex');\n```\n\n### response.vary(field)\n\n设置 `field` 的 `vary`。\n\n### response.flushHeaders()\n\n刷新任何设置的消息头，然后是主体(body)。\n\n## 参与翻译\n\n如果您希望贡献力量完善本中文文档，请前往 <https://github.com/demopark/koa-docs-Zh-CN.git> 仓库。\n\n## 相关资源\n\nCommunity links to discover third-party middleware for Koa, full runnable examples, thorough guides and more! If you have questions join us in IRC!\n\n- [GitHub repository](https://github.com/koajs/koa)\n- [Examples](https://github.com/koajs/examples)\n- [Middleware](https://github.com/koajs/koa/wiki)\n- [Wiki](https://github.com/koajs/koa/wiki)\n- [G+ Community](https://plus.google.com/communities/101845768320796750641)\n- [Mailing list](https://groups.google.com/forum/#!forum/koajs)\n- [Guide](https://github.com/koajs/koa/blob/master/docs/guide.md)\n- [FAQ](https://github.com/koajs/koa/blob/master/docs/faq.md)\n- **#koajs** on freenode\n","children":[]},{"name":"Nest.md","path":"../guanruihua.github.io/Front-End/Node/中台","data":"# nest\n\n## 前言\n\n> [文档](https://docs.nestjs.cn/8/firststeps)\n> node >= 10.13.0, v13除外\n","children":[]},{"name":"ORM","path":"../guanruihua.github.io/Front-End/Node/中台","data":"","children":[{"name":"typeorm.md","path":"../guanruihua.github.io/Front-End/Node/中台/ORM","data":"# typeorm\n\n## 前言\n\n> [文档](https://typeorm.bootcss.com/)\n","children":[]}]},{"name":"中台.md","path":"../guanruihua.github.io/Front-End/Node/中台","data":"# 中台\n\n> 业务中台\n>\n> 数据中台\n>\n> 算法中台\n>\n> 移动中台\n","children":[]},{"name":"中间件","path":"../guanruihua.github.io/Front-End/Node/中台","data":"","children":[{"name":"multer.md","path":"../guanruihua.github.io/Front-End/Node/中台/中间件","data":"# multer\n\n## 安装\n\n```bash\nnpm install --save multer\n```\n\n## 使用\n\nMulter 会添加一个 `body` 对象 以及 `file` 或 `files` 对象 到 express 的 `request` 对象中。 `body` 对象包含表单的文本域信息，`file` 或 `files` 对象包含对象表单上传的文件信息。\n\n基本使用方法:\n\n```js\nvar express = require('express')\nvar multer  = require('multer')\nvar upload = multer({ dest: 'uploads/' })\n\nvar app = express()\n\napp.post('/profile', upload.single('avatar'), function (req, res, next) {\n  // req.file 是 `avatar` 文件的信息\n  // req.body 将具有文本域数据，如果存在的话\n})\n\napp.post('/photos/upload', upload.array('photos', 12), function (req, res, next) {\n  // req.files 是 `photos` 文件数组的信息\n  // req.body 将具有文本域数据，如果存在的话\n})\n\nvar cpUpload = upload.fields([{ name: 'avatar', maxCount: 1 }, { name: 'gallery', maxCount: 8 }])\napp.post('/cool-profile', cpUpload, function (req, res, next) {\n  // req.files 是一个对象 (String -> Array) 键是文件名，值是文件数组\n  //\n  // 例如：\n  //  req.files['avatar'][0] -> File\n  //  req.files['gallery'] -> Array\n  //\n  // req.body 将具有文本域数据，如果存在的话\n})\n```\n\n如果你需要处理一个只有文本域的表单，你应当使用 `.none()`:\n\n```js\nvar express = require('express')\nvar app = express()\nvar multer  = require('multer')\nvar upload = multer()\n\napp.post('/profile', upload.none(), function (req, res, next) {\n  // req.body 包含文本域\n})\n```\n\n## API\n\n### 文件信息\n\n每个文件具有下面的信息:\n\n| Key            | Description                     | Note            |\n| -------------- | ------------------------------- | --------------- |\n| `fieldname`    | Field name 由表单指定           |                 |\n| `originalname` | 用户计算机上的文件的名称        |                 |\n| `encoding`     | 文件编码                        |                 |\n| `mimetype`     | 文件的 MIME 类型                |                 |\n| `size`         | 文件大小（字节单位）            |                 |\n| `destination`  | 保存路径                        | `DiskStorage`   |\n| `filename`     | 保存在 `destination` 中的文件名 | `DiskStorage`   |\n| `path`         | 已上传文件的完整路径            | `DiskStorage`   |\n| `buffer`       | 一个存放了整个文件的 `Buffer`   | `MemoryStorage` |\n\n### `multer(opts)`\n\nMulter 接受一个 options 对象，其中最基本的是 `dest` 属性，这将告诉 Multer 将上传文件保存在哪。如果你省略 options 对象，这些文件将保存在内存中，永远不会写入磁盘。\n\n为了避免命名冲突，Multer 会修改上传的文件名。这个重命名功能可以根据您的需要定制。\n\n以下是可以传递给 Multer 的选项。\n\n| Key                 | Description                        |\n| ------------------- | ---------------------------------- |\n| `dest` or `storage` | 在哪里存储文件                     |\n| `fileFilter`        | 文件过滤器，控制哪些文件可以被接受 |\n| `limits`            | 限制上传的数据                     |\n| `preservePath`      | 保存包含文件名的完整文件路径       |\n\n通常，一般的网页应用，只需要设置 `dest` 属性，像这样：\n\n```\nvar upload = multer({ dest: 'uploads/' })\n```\n\n如果你想在上传时进行更多的控制，你可以使用 `storage` 选项替代 `dest`。Multer 具有 `DiskStorage` 和 `MemoryStorage` 两个存储引擎；另外还可以从第三方获得更多可用的引擎。\n\n#### `.single(fieldname)`\n\n接受一个以 `fieldname` 命名的文件。这个文件的信息保存在 `req.file`。\n\n#### `.array(fieldname[, maxCount])`\n\n接受一个以 `fieldname` 命名的文件数组。可以配置 `maxCount` 来限制上传的最大数量。这些文件的信息保存在 `req.files`。\n\n#### `.fields(fields)`\n\n接受指定 `fields` 的混合文件。这些文件的信息保存在 `req.files`。\n\n`fields` 应该是一个对象数组，应该具有 `name` 和可选的 `maxCount` 属性。\n\nExample:\n\n```js\n[\n  { name: 'avatar', maxCount: 1 },\n  { name: 'gallery', maxCount: 8 }\n]\n```\n\n#### `.none()`\n\n只接受文本域。如果任何文件上传到这个模式，将发生 \"LIMIT_UNEXPECTED_FILE\" 错误。这和 `upload.fields([])` 的效果一样。\n\n#### `.any()`\n\n接受一切上传的文件。文件数组将保存在 `req.files`。\n\n**警告:** 确保你总是处理了用户的文件上传。 永远不要将 multer 作为全局中间件使用，因为恶意用户可以上传文件到一个你没有预料到的路由，应该只在你需要处理上传文件的路由上使用。\n\n### `storage`\n\n#### 磁盘存储引擎 (`DiskStorage`)\n\n磁盘存储引擎可以让你控制文件的存储。\n\n```js\nvar storage = multer.diskStorage({\n  destination: function (req, file, cb) {\n    cb(null, '/tmp/my-uploads')\n  },\n  filename: function (req, file, cb) {\n    cb(null, file.fieldname + '-' + Date.now())\n  }\n})\n\nvar upload = multer({ storage: storage })\n```\n\n有两个选项可用，`destination` 和 `filename`。他们都是用来确定文件存储位置的函数。\n\n`destination` 是用来确定上传的文件应该存储在哪个文件夹中。也可以提供一个 `string` (例如 `'/tmp/uploads'`)。如果没有设置 `destination`，则使用操作系统默认的临时文件夹。\n\n**注意:** 如果你提供的 `destination` 是一个函数，你需要负责创建文件夹。当提供一个字符串，multer 将确保这个文件夹是你创建的。\n\n`filename` 用于确定文件夹中的文件名的确定。 如果没有设置 `filename`，每个文件将设置为一个随机文件名，并且是没有扩展名的。\n\n**注意:** Multer 不会为你添加任何扩展名，你的程序应该返回一个完整的文件名。\n\n每个函数都传递了请求对象 (`req`) 和一些关于这个文件的信息 (`file`)，有助于你的决定。\n\n注意 `req.body` 可能还没有完全填充，这取决于向客户端发送字段和文件到服务器的顺序。\n\n#### 内存存储引擎 (`MemoryStorage`)\n\n内存存储引擎将文件存储在内存中的 `Buffer` 对象，它没有任何选项。\n\n```\nvar storage = multer.memoryStorage()\nvar upload = multer({ storage: storage })\n```\n\n当使用内存存储引擎，文件信息将包含一个 `buffer` 字段，里面包含了整个文件数据。\n\n**警告**: 当你使用内存存储，上传非常大的文件，或者非常多的小文件，会导致你的应用程序内存溢出。\n\n### `limits`\n\n一个对象，指定一些数据大小的限制。Multer 通过这个对象使用 busboy，详细的特性可以在 [busboy's page](https://github.com/mscdex/busboy#busboy-methods) 找到。\n\n可以使用下面这些:\n\n| Key             | Description                                              | Default   |\n| --------------- | -------------------------------------------------------- | --------- |\n| `fieldNameSize` | field 名字最大长度                                       | 100 bytes |\n| `fieldSize`     | field 值的最大长度                                       | 1MB       |\n| `fields`        | 非文件 field 的最大数量                                  | 无限      |\n| `fileSize`      | 在 multipart 表单中，文件最大长度 (字节单位)             | 无限      |\n| `files`         | 在 multipart 表单中，文件最大数量                        | 无限      |\n| `parts`         | 在 multipart 表单中，part 传输的最大数量(fields + files) | 无限      |\n| `headerPairs`   | 在 multipart 表单中，键值对最大组数                      | 2000      |\n\n设置 limits 可以帮助保护你的站点抵御拒绝服务 (DoS) 攻击。\n\n### `fileFilter`\n\n设置一个函数来控制什么文件可以上传以及什么文件应该跳过，这个函数应该看起来像这样：\n\n```js\nfunction fileFilter (req, file, cb) {\n\n  // 这个函数应该调用 `cb` 用boolean值来\n  // 指示是否应接受该文件\n\n  // 拒绝这个文件，使用`false`，像这样:\n  cb(null, false)\n\n  // 接受这个文件，使用`true`，像这样:\n  cb(null, true)\n\n  // 如果有问题，你可以总是这样发送一个错误:\n  cb(new Error('I don\\'t have a clue!'))\n\n}\n```\n\n## 错误处理机制\n\n当遇到一个错误，multer 将会把错误发送给 express。你可以使用一个比较好的错误展示页 ([express标准方式](http://expressjs.com/guide/error-handling.html))。\n\n如果你想捕捉 multer 发出的错误，你可以自己调用中间件程序。如果你想捕捉 [Multer 错误](https://github.com/expressjs/multer/blob/master/lib/multer-error.js)，你可以使用 `multer` 对象下的 `MulterError` 类 (即 `err instanceof multer.MulterError`)。\n\n```js\nvar multer = require('multer')\nvar upload = multer().single('avatar')\n\napp.post('/profile', function (req, res) {\n  upload(req, res, function (err) {\n    if (err instanceof multer.MulterError) {\n      // 发生错误\n    } else if (err) {\n      // 发生错误\n    }\n\n    // 一切都好\n  })\n})\n```\n\n## 定制存储引擎\n\n> 构建自己的存储引擎，请看 [这里](https://github.com/expressjs/multer/blob/master/StorageEngine.md)\n","children":[]}]}]},{"name":"基础","path":"../guanruihua.github.io/Front-End/Node","data":"","children":[{"name":"fs.md","path":"../guanruihua.github.io/Front-End/Node/基础","data":"# fs模块\r\n\r\n### 前言\r\n\r\nNode.js中赋予了JavaScript很多在浏览器中没有的能力，譬如：文件读写，创建http服务器等等，今天我们就来看看在node中怎样用JavaScript进行文件的读写操作。\r\n\r\n1. 读文件\r\n   1. 我们在data文件夹下新建一个`hello.txt`，并且在里面写入：`hello， node.js!!` ，如图：\r\n\r\n1. 我们在`hello.txt`同级目录下创建一个`hello.js`文件，我们在这个js文件中利用Node提供的文件操作API, 读取`hello.txt`文件中的内容。\r\n\r\n- node中对文件相关的操作需要依赖fs模块，这个是node中内置模块之一，我们需要引入。fs--file system。\r\n\r\n```js\r\n   let fs = require('fs')\r\n   fs.readFile() \r\n   \r\n    // 读文件。 readFile函数接受两个参数：读取文件路径，回调函数（error，data两个参数），\r\n   读取文件成功：data为文件内容，error为null，读取失败：error为错误对象，data为undefined\r\n```\r\n\r\n   最后我们`hello.js`中的代码如下:\r\n\r\n```js\r\nlet fs = require('fs')\r\nfs.readFile('./hello.txt', (error, data) => {\r\n  console.log(data.toString())\r\n})\r\n   \r\n```\r\n\r\n   在这里可以说一下，我们读取回来的默认是二进制的内容，所以需要调用toString()方法进行转换。最后，终端可以看到结果如下：\r\n\r\n  可以看到我们刚才在`hello.txt`中写入的文本`hello, node.js!!`已经打印出来。看到这里是不是觉得很牛叉，JavaScript居然可以用来读取文件内容，完全颠覆了我们以前对JavaScript的理解，然而这一切都得归功于Node.js。\r\n\r\n1. 写文件\r\n\r\n   我们在刚才的`hello.js`中写入下面这行代码：\r\n\r\n   ```js\r\n   fs.writeFile('./hello.md', '你好，node.js!', (error) => {\r\n\r\n         if (!error) {\r\n           console.log('创建成功了。。')\r\n         }\r\n   }) \r\n   // 写文件。writeFile接受三个参数：写入文件路径，写入内容，回调函数。\r\n      ```\r\n\r\n   写入成功时候：error为null，写入失败时候：error为错误对象\r\n\r\n   最后我们看到在同级目录下出现了一个`hello.md`文件，并且里面的内容为`你好，node.js`. 如图：\r\n\r\n### 删除文件\r\n\r\n### 语法\r\n\r\n以下为删除文件的语法格式：\r\n\r\n```\r\nfs.unlink(path, callback)\r\n```\r\n\r\n### 参数\r\n\r\n参数使用说明如下：\r\n\r\n- **path** - 文件路径。\r\n- **callback** - 回调函数，没有参数。\r\n\r\n### 实例\r\n\r\ninput.txt 文件内容为：\r\n\r\n```\r\nsite:www.runoob.com\r\n```\r\n\r\n接下来我们创建 file.js 文件，代码如下所示：\r\n\r\n```\r\nvar fs = require(\"fs\");\r\n\r\nconsole.log(\"准备删除文件！\");\r\nfs.unlink('input.txt', function(err) {\r\n   if (err) {\r\n       return console.error(err);\r\n   }\r\n   console.log(\"文件删除成功！\");\r\n});\r\n```\r\n\r\n以上代码执行结果如下：\r\n\r\n```\r\n$ node file.js \r\n准备删除文件！\r\n文件删除成功！\r\n```\r\n\r\n再去查看 input.txt 文件，发现已经不存在了。\r\n\r\n------\r\n\r\n### 创建目录\r\n\r\n### 语法\r\n\r\n以下为创建目录的语法格式：\r\n\r\n```\r\nfs.mkdir(path[, options], callback)\r\n```\r\n\r\n### 参数\r\n\r\n参数使用说明如下：\r\n\r\n- **path** - 文件路径。\r\n- options 参数可以是：\r\n  - **recursive** - 是否以递归的方式创建目录，默认为 false。\r\n  - **mode** - 设置目录权限，默认为 0777。\r\n- **callback** - 回调函数，没有参数。\r\n\r\n### 实例\r\n\r\n接下来我们创建 file.js 文件，代码如下所示：\r\n\r\n```js\r\nvar fs = require(\"fs\");\r\n// tmp 目录必须存在\r\nconsole.log(\"创建目录 /tmp/test/\");\r\nfs.mkdir(\"/tmp/test/\",function(err){\r\n   if (err) {\r\n       return console.error(err);\r\n   }\r\n   console.log(\"目录创建成功。\");\r\n});\r\n```\r\n\r\n以上代码执行结果如下：\r\n\r\n```\r\n$ node file.js \r\n创建目录 /tmp/test/\r\n目录创建成功。\r\n```\r\n\r\n可以添加 recursive: true 参数，不管创建的目录 /tmp 和 /tmp/a 是否存在：\r\n\r\n```js\r\nfs.mkdir('/tmp/a/apple', { recursive: true }, (err) => {\r\n  if (err) throw err;\r\n});\r\n```\r\n\r\n------\r\n\r\n### 读取目录\r\n\r\n### 语法\r\n\r\n以下为读取目录的语法格式：\r\n\r\n```\r\nfs.readdir(path, callback)\r\n```\r\n\r\n### 参数\r\n\r\n参数使用说明如下：\r\n\r\n- **path** - 文件路径。\r\n- **callback** - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。\r\n\r\n### 实例\r\n\r\n接下来我们创建 file.js 文件，代码如下所示：\r\n\r\n```js\r\nvar fs = require(\"fs\");\r\n\r\nconsole.log(\"查看 /tmp 目录\");\r\nfs.readdir(\"/tmp/\",function(err, files){\r\n   if (err) {\r\n       return console.error(err);\r\n   }\r\n   files.forEach( function (file){\r\n       console.log( file );\r\n   });\r\n});\r\n```\r\n\r\n以上代码执行结果如下：\r\n\r\n```\r\n$ node file.js \r\n查看 /tmp 目录\r\ninput.out\r\noutput.out\r\ntest\r\ntest.txt\r\n```\r\n\r\n------\r\n\r\n### 删除目录\r\n\r\n### 语法\r\n\r\n以下为删除目录的语法格式：\r\n\r\n```\r\nfs.rmdir(path, callback)\r\n```\r\n\r\n### 参数\r\n\r\n参数使用说明如下：\r\n\r\n- **path** - 文件路径。\r\n- **callback** - 回调函数，没有参数。\r\n\r\n### 实例\r\n\r\n接下来我们创建 file.js 文件，代码如下所示：\r\n\r\n```\r\nvar fs = require(\"fs\");\r\n// 执行前创建一个空的 /tmp/test 目录\r\nconsole.log(\"准备删除目录 /tmp/test\");\r\nfs.rmdir(\"/tmp/test\",function(err){\r\n   if (err) {\r\n       return console.error(err);\r\n   }\r\n   console.log(\"读取 /tmp 目录\");\r\n   fs.readdir(\"/tmp/\",function(err, files){\r\n      if (err) {\r\n          return console.error(err);\r\n      }\r\n      files.forEach( function (file){\r\n          console.log( file );\r\n      });\r\n   });\r\n});\r\n```\r\n\r\n输入输出\r\n\r\n```\r\n// 引入readline模块\r\nvar readline = require('readline');\r\n    \r\n//创建readline接口实例\r\nvar  rl = readline.createInterface({\r\n    input:process.stdin,\r\n    output:process.stdout\r\n});\r\n\r\n// question方法\r\nrl.question(\"你的名字是？\",function(answer){\r\n    console.log(\"我的名字是：\"+answer);\r\n    // 不加close，则程序不会结束\r\n    rl.close();\r\n});\r\n\r\n// close事件监听\r\nrl.on(\"close\", function(){\r\n   // 结束程序\r\n    process.exit(0);\r\n})\r\n```\r\n","children":[]},{"name":"node-basis.md","path":"../guanruihua.github.io/Front-End/Node/基础","data":"# node-basis\n\n## 特点\n\n> - 事件驱动\n> - 非阻塞态IO模型(异步)\n> - 轻量,高效\n\n## Node.js Stream(流)\n\nStream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。\n\nNode.js，Stream 有四种流类型：\n\n- **Readable** - 可读操作。\n- **Writable** - 可写操作。\n- **Duplex** - 可读可写操作.\n- **Transform** - 操作被写入数据，然后读出结果。\n\n所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：\n\n- **data** - 当有数据可读时触发。\n- **end** - 没有更多的数据可读时触发。\n- **error** - 在接收和写入过程中发生错误时触发。\n- **finish** - 所有数据已被写入到底层系统时触发。\n\n本教程会为大家介绍常用的流操作。\n\n------\n\n### 从流中读取数据\n\n创建 input.txt 文件，内容如下：\n\n```\nwww.sxt.com\n```\n\n创建 main.js 文件, 代码如下：\n\n```\nvar fs = require(\"fs\");\nvar data = '';\n\n// 创建可读流\nvar readerStream = fs.createReadStream('input.txt');\n\n// 设置编码为 utf8。\nreaderStream.setEncoding('UTF8');\n\n// 处理流事件 --> data, end, and error\nreaderStream.on('data', function(chunk) {\n   data += chunk;\n});\n\nreaderStream.on('end',function(){\n   console.log(data);\n});\n\nreaderStream.on('error', function(err){\n   console.log(err.stack);\n});\n\nconsole.log(\"程序执行完毕\");\n```\n\n以上代码执行结果如下：\n\n```\n程序执行完毕地址：www.sxt.com\n```\n\n------\n\n### 写入流\n\n创建 main.js 文件, 代码如下：\n\n```\nvar fs = require(\"fs\");\nvar data = 'www.sxt.com';\n\n// 创建一个可以写入的流，写入到文件 output.txt 中\nvar writerStream = fs.createWriteStream('output.txt');\n\n// 使用 utf8 编码写入数据\nwriterStream.write(data,'UTF8');\n\n// 标记文件末尾\nwriterStream.end();\n\n// 处理流事件 --> data, end, and error\nwriterStream.on('finish', function() {\n    console.log(\"写入完成。\");\n});\n\nwriterStream.on('error', function(err){\n   console.log(err.stack);\n});\n\nconsole.log(\"程序执行完毕\");\n```\n\n以上程序会将 data 变量的数据写入到 output.txt 文件中。代码执行结果如下：\n\n```\n$ node main.js \n程序执行完毕\n写入完成。\n```\n\n查看 output.txt 文件的内容：\n\n```\n$ cat output.txt \nwww.sxt.com\n```\n\n------\n\n### 管道流\n\n管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。\n\n![img](https://www.sxt.com/wp-content/uploads/2015/09/bVcla61)\n\n如上面的图片所示，我们把文件比作装水的桶，而水就是文件里的内容，我们用一根管子(pipe)连接两个桶使得水从一个桶流入另一个桶，这样就慢慢的实现了大文件的复制过程。\n\n以下实例我们通过读取一个文件内容并将内容写入到另外一个文件中。\n\n设置 input.txt 文件内容如下：\n\n```\n教程官网地址：www.sxt.com\n管道流操作实例\n```\n\n创建 main.js 文件, 代码如下：\n\n```\nvar fs = require(\"fs\");\n\n// 创建一个可读流\nvar readerStream = fs.createReadStream('input.txt');\n\n// 创建一个可写流\nvar writerStream = fs.createWriteStream('output.txt');\n\n// 管道读写操作\n// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中\nreaderStream.pipe(writerStream);\n\nconsole.log(\"程序执行完毕\");\n```\n\n代码执行结果如下：\n\n```\n$ node main.js \n程序执行完毕\n```\n\n查看 output.txt 文件的内容：\n\n```\n$ cat output.txt \n教程官网地址：www.sxt.com\n管道流操作实例\n```\n\n------\n\n### 链式流\n\n链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。\n\n接下来我们就是用管道和链式来压缩和解压文件。\n\n创建 compress.js 文件, 代码如下：\n\n```js\nvar fs = require(\"fs\");\nvar zlib = require('zlib');\n\n// 压缩 input.txt 文件为 input.txt.gz\nfs.createReadStream('input.txt')\n  .pipe(zlib.createGzip())\n  .pipe(fs.createWriteStream('input.txt.gz'));\n  \nconsole.log(\"文件压缩完成。\");\n```\n\n代码执行结果如下：\n\n```\n$ node compress.js \n文件压缩完成。\n```\n\n执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。\n\n接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下：\n\n```\nvar fs = require(\"fs\");\nvar zlib = require('zlib');\n\n// 解压 input.txt.gz 文件为 input.txt\nfs.createReadStream('input.txt.gz')\n  .pipe(zlib.createGunzip())\n  .pipe(fs.createWriteStream('input.txt'));\n  \nconsole.log(\"文件解压完成。\");\n```\n\n代码执行结果如下：\n\n```js\n$ node decompress.js \n文件解压完成。\n```\n\n## Node.js 事件循环\n\nNode.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。\n\nNode.js 几乎每一个 API 都是支持回调函数的。\n\nNode.js 基本上所有的事件机制都是用设计模式中观察者模式实现。\n\nNode.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.\n\n```\n开启进程\n开启线程\n初始化数据，window/document/location...\nwhile(true){\n    \n    初始化事件列表\n    根据事件修改数据\n    根据数据去渲染页面\n    \n    if(count=0){\n        运行js代e\n        btn.onclick = function(){\n            document.body.style.background = \"skyblue\"\n            console.log(123)\n        }\n        console.log(456)\n        count++\n    }\n    \n    \n}\n```\n\n------\n\n### 事件驱动程序\n\nNode.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。\n\n当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。\n\n这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作。（这也称之为非阻塞式IO或者事件驱动IO）\n\n在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。\n\n![img](https://www.sxt.com/wp-content/uploads/2015/09/event_loop.jpg)\n\nNode.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：\n\n```\n// 引入 events 模块\nvar events = require('events');\n// 创建 eventEmitter 对象\nvar eventEmitter = new events.EventEmitter();\n```\n\n以下程序绑定事件处理程序：\n\n```\n// 绑定事件及事件的处理程序\neventEmitter.on('eventName', eventHandler);\n```\n\n我们可以通过程序触发事件：\n\n```\n// 触发事件\neventEmitter.emit('eventName');\n```\n\n### 实例\n\n创建 main.js 文件，代码如下所示：\n\n### 实例\n\n```js\n// 引入 events 模块\nvar events = require('events');\n// 创建 eventEmitter 对象\nvar eventEmitter = new events.EventEmitter();\n \n// 创建事件处理程序\nvar connectHandler = function connected() {\n   console.log('连接成功。');\n  \n   // 触发 data_received 事件 \n   eventEmitter.emit('data_received');\n}\n \n// 绑定 connection 事件处理程序\neventEmitter.on('connection', connectHandler);\n \n// 使用匿名函数绑定 data_received 事件\neventEmitter.on('data_received', function(){\n   console.log('数据接收成功。');\n});\n \n// 触发 connection 事件 \neventEmitter.emit('connection');\n \nconsole.log(\"程序执行完毕。\");\n```\n\n接下来让我们执行以上代码：\n\n```\n$ node main.js\n连接成功。\n数据接收成功。\n程序执行完毕。\n```\n\n------\n\n### Node 应用程序是如何工作的？\n\n在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。\n\n接下来让我们来重新看下前面的实例，创建一个 input.txt ,文件内容如下：\n\n```\n官网地址：www.sxt.com\n```\n\n创建 main.js 文件，代码如下：\n\n```js\nvar fs = require(\"fs\");\n\nfs.readFile('input.txt', function (err, data) {\n   if (err){\n      console.log(err.stack);\n      return;\n   }\n   console.log(data.toString());\n});\nconsole.log(\"程序执行完毕\");\n```\n\n以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。\n\n如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。\n\n执行以上代码，执行结果如下：\n\n```\n程序执行完毕\n官网地址：www.sxt.com\n```\n\n接下来我们删除 input.txt 文件，执行结果如下所示：\n\n```\n程序执行完毕\nError: ENOENT, open 'input.txt'\n```\n\n因为文件 input.txt 不存在，所以输出了错误信息。\n\n### Node.js EventEmitter\n\nNode.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。\n\nNode.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。\n\n------\n\n### EventEmitter 类\n\nevents 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。\n\n你可以通过require(\"events\");来访问该模块。\n\n```js\n// 引入 events 模块\nvar events = require('events');\n// 创建 eventEmitter 对象\nvar eventEmitter = new events.EventEmitter();\n```\n\nEventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。\n\n下面我们用一个简单的例子说明 EventEmitter 的用法：\n\n```js\n//event.js 文件\nvar EventEmitter = require('events').EventEmitter; \nvar event = new EventEmitter(); \nevent.on('some_event', function() { \n    console.log('some_event 事件触发'); \n}); \nsetTimeout(function() { \n    event.emit('some_event'); \n}, 1000); \n```\n\n执行结果如下：\n\n运行这段代码，1 秒后控制台输出了 **'some_event 事件触发'**。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。\n\n```\n$ node event.js \nsome_event 事件触发\n```\n\nEventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。\n\n当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。\n\n让我们以下面的例子解释这个过程：\n\n```\n//event.js 文件\nvar events = require('events'); \nvar emitter = new events.EventEmitter(); \nemitter.on('someEvent', function(arg1, arg2) { \n    console.log('listener1', arg1, arg2); \n}); \nemitter.on('someEvent', function(arg1, arg2) { \n    console.log('listener2', arg1, arg2); \n}); \nemitter.emit('someEvent', 'arg1 参数', 'arg2 参数'); \n```\n\n执行以上代码，运行的结果如下：\n\n```\n$ node event.js \nlistener1 arg1 参数 arg2 参数\nlistener2 arg1 参数 arg2 参数\n```\n\n以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。\n\n运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。\n\nEventEmitter 提供了多个属性，如 **on** 和 **emit**。**on** 函数用于绑定事件函数，**emit** 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。\n\n## http模块\n\n开启一个本地服务器需要Node.js中`http`核心模块\n\n1. http--模块提供了搭建本地服务器的API,首先我们在项目中引入；\n\n```\nlet http = require('http')\n```\n\n引入之后我们利用http.createServer()方法得到一个服务器实例。\n\n```\nlet server = http.createServer() // createServer()方法返回一个server实例，所以我们需要一个变量来接收\n\n```\n\n1. 经过以上两步，我们已经搭建好了一个服务器实例，然后我们给服务器实例绑定接收`request`的事情处理函数，代码如下：\n\n```\nserver.on('request', (req, res) => {\n  console.log(req.url) // 获取到请求的路径（请求路径永远以“/”开头）\n})\n\n// 给服务器绑定接收请求的处理事件，当服务器接收到客户端发送的请求后，会调用后面的处理函数，处理函数接收两个参数：请求信息对象，响应信息对象。\n```\n\n1. 绑定监听端口号，开启服务器。代码如下：\n\n```\nserver.listen(3000, () => {\n  console.log('服务器开启成功，可以通过访问http://127.0.0.1:3000/来获取数据~~')\n})\n\n// server.listen()用来绑定监听的端口号，可以传入第二个参数，当服务器开启成功后，触发后面的回调函数\n\n```\n\n1. 最后看到的效果如下图所示：\n\n![node演示](D:/note/Front-end/node学习图片资源/07.png)\n\n我们看到请求路径被打印在了CMD窗口中。\n\n好了，经过这简单的操作是不是已经完成了一个服务器的简单搭建，接下来我们来实现一个需求：\n\n- 当我们访问“<http://127.0.0.1:3000/login>”, 服务器返回 “login page”\n- 当我们访问“<http://127.0.0.1:3000/register>”, 服务器返回 “register page”\n- 当我们访问“<http://127.0.0.1:3000/>”, 服务器返回 “index page”\n- 当我们访问“<http://127.0.0.1:3000/product>”, 服务器返回 **产品信息列表**\n\n我们实现这个需求，只需要在绑定服务器监听的事件处理函数中获取到用户的请求路径，然后根据不同路径返回不同数据即可，这个也不难。详情代码看下：\n\n```js\nlet http = require('http')\nlet server = http.createServer()\n\nserver.on('request', (req, res) => {\n  let url = req.url //得到请求的路径 （请求的路径永远以‘/’开头）\n  if (url === '/') {\n    res.end('index page')\n  } else if (url === '/login') {\n    res.end('login page')\n  } else if (url === '/register') {\n    res.end('register page')\n  } else if (url === '/product'){\n    let arr = [\n      {\n        name: 'iphone X',\n        price: 8888\n      },\n      {\n        name: 'iphone 7',\n        price: 4320\n      }\n    ]\n    // 响应的数据类型必须是字符串或者二进制数据\n    res.end(JSON.stringify(arr))\n  } else {\n    res.end('404 NOT found')\n  }\n})\n\nserver.listen(3000, () => {\n  console.log('服务器启动成功了，，可以访问http://127.0.0.1:3000/啦')\n})\n```\n\n最后实现的效果图如下：\n\n![node演示](D:/note/Front-end/node学习图片资源/08.gif)\n\n我们看到我们请求不同的路径，服务器给我们返回了不同的内容，并且显示在了网页中。\n\n### 设置状态码和响应头\n\n```\nresponse.writeHead(200, { 'Content-Type': 'text/plain' });\n```\n\n### 设置响应头\n\n```\nresponse.setHeader('Content-Type', 'text/html');\n```\n\n### 写入内容\n\n```\nresponse.write(fileData);\n```\n\n### 结束响应\n\n```\nresponse.end();\n```\n\n### 静态服务器定义\n\n能够根据需要请求的文件，原封不动的将服务器磁盘中的数据直接返回给到浏览器。\n\n1. 根据设定的目录，判断用户是否请求的文件时静态文件\n\n```\n//解析路径\nlet urlObj = path.parse(req.url)\n//判断是否请求静态文件\nurlObj.dir=='/static'\n```\n\n1. 从磁盘读取静态文件并返回\n\n```\n//根据请求的后缀名，返回文件的类型\nres.setHeader(\"content-type\",getContentType(urlObj.ext))\n//从服务器磁盘中读取文件，并输出到响应对象中\nlet rs = fs.createReadStream('./static/'+urlObj.base)\nrs.pipe(res)\n```\n\n1. 如何 根据后缀名返回文件类型\n\n```\nfunction getContentType(extName){\n    switch(extName){\n        case \".jpg\":\n            return \"image/jpeg\";\n        case \".html\":\n            return \"text/html;charset=utf-8\";\n        case \".js\":\n            return \"text/javascript;charset=utf-8\";\n        case \".json\":\n            return \"text/json;charset=utf-8\";\n        case \".gif\":\n            return \"image/gif\";\n        case \".css\":\n            return \"text/css\"\n    }\n}\n```\n\n#### 完整案例\n\n```\n//引入http模块\nlet http = require('http');\n//创建server对象\nlet server = http.createServer()\n//引入path模块\nlet path = require('path')\n//引入文件模块\nlet fs = require('fs')\n//监听客户端发送过来的请求\n//req请求对象包含了请求的相关的信息\n//res对象用于响应内容，可以通过这个对象帮助我们快速实现HTTP响应\nserver.on('request',function(req,res){\n    //解析路径\n    let urlObj = path.parse(req.url)\n    //识别请求的路径\n    //console.log(urlObj)\n    //进入首页，返回首页的内容\n    if(req.url==\"/\"){\n        res.setHeader(\"content-type\",\"text/html;charset=utf-8\")\n        res.end(`<link rel=\"stylesheet\" href=\"./static/style.css\"><h1>首页</h1><img src='./static/cxk.jpg'>`)\n    }else if(urlObj.dir=='/static'){\n        res.setHeader(\"content-type\",getContentType(urlObj.ext))\n        let rs = fs.createReadStream('./static/'+urlObj.base)\n        rs.pipe(res)\n    }else{\n        \n        res.setHeader(\"content-type\",\"text/html;charset=utf-8\")\n        res.end(\"<h1>404页面找不到</h1>\")\n    }\n    \n})\n\n\nfunction getContentType(extName){\n    switch(extName){\n        case \".jpg\":\n            return \"image/jpeg\";\n        case \".html\":\n            return \"text/html;charset=utf-8\";\n        case \".js\":\n            return \"text/javascript;charset=utf-8\";\n        case \".json\":\n            return \"text/json;charset=utf-8\";\n        case \".gif\":\n            return \"image/gif\";\n        case \".css\":\n            return \"text/css\"\n    }\n}\n\n\n\n//启动服务器，监听服务端口\nserver.listen(80,function(){\n    console.log(\"服务已启动：http:127.0.0.1\")\n})\n```\n\n## 模板动态生成页面\n\n1. 根据规则去解析链接，并且获取ID或者时索引值\n\n```js\n//请求路径：http://127.0.0.1/movies/0\nlet index = req.pathObj.base;\n```\n\n2. 根据索引获取数据\n\n```json\nlet movies = [\n         {\n            name:\"雪暴\",\n            brief:\"电影《雪暴》讲述了在一座极北的边陲小镇，一伙穷凶极恶、作案手法老到的悍匪为抢夺黄金，打劫运金车，并借助大雪掩盖了所有犯罪痕迹。为了探求真相，警察王康浩暗地里搜集证据，熟悉地形，终于在一场灾难级的暴雪降临时，与谋财害命的悍匪发生了惊心动魄的正面对决……\",\n            author:\"张震\"\n         },{\n             name:\"少年的你\",\n             brief:\"陈念（周冬雨 饰）是一名即将参加高考的高三学生，同校女生胡晓蝶（张艺凡 饰）的跳楼自杀让她的生活陷入了困顿之中。胡晓蝶死后，陈念遭到了以魏莱（周也 饰）为首的三人组的霸凌，魏莱虽然表面上看来是乖巧的优等生，实际上却心思毒辣，胡晓蝶的死和她有着千丝万缕的联系。\",\n             author:\"周冬雨 \"\n         }\n     ]\nlet pageData = movies[index]\n```\n\n1. 根据模板渲染页面\n\n```js\nres.render( movies[index],'./template/index.html')\n```\n\n1. 底层需要实现渲染函数，通过正则匹配，找到需要修改的地方进行一一的修改。\n\n```js\nfunction render(options,path){\n    fs.readFile(path,{encoding:\"utf-8\",flag:\"r\"},(err,data)=>{\n        if(err){\n            console.log(err)\n        }else{\n            console.log(data)\n            let reg = /\\{\\{(.*?)\\}\\}/igs\n            let result;\n            while(result = reg.exec(data)){\n                //去除2边的空白\n                let strKey = result[1].trim()\n                let strValue = options[strKey]\n                data = data.replace(result[0],strValue)\n            }\n\n            this.end(data)\n        }\n    })\n}\n```\n\n## async_promise\n\n### 写法不同\n\nES5正常写法\n\n```\ngetAjax(url,(res)=>{})\n```\n\nPromise\n\n```\nget(url).then((res)=>{})\n```\n\nasync_await\n\n```\n(async ()=>{ \n    let res = await get(url)\n})()\n```\n\n总结：\n\n- ES5写法和promise写法，主要区别在写法的不同，可以让回调函数，划分出去在.then的函数里去执行，使得代码更加的另外，也可以将两个不同的参数，可以划分开来写。\n- async和promise的区别，不要在于async时promise的语法糖，这种形式的写法在底层编译之后会自动转化成promise的写法\n\n### Promise实现原理\n\npromise需要实现的功能\n\n```\nfunction fn(resolve,reject){\n    setTimeout(()=>{\n        if(true){\n            resolve()\n        }else{\n            reject()\n        }\n    })\n}\nvar p1 = new LcPromise(fn)\n\np1.then(function(res){\n    document.body.style.background = \"greenyellow\"\n    console.log(\"这是成功做的事情\")\n    console.log(res)\n})\n\np1.catch(function(res){\n    document.body.style.background = \"pink\"\n    console.log(\"这是失败做的事情\")\n    console.log(res)\n})\n```\n\np1promise对象发送了异步操作，必然会有1个未来事件，在未来要执行。这个过程由传入的函数对象fn执行。函数fn里必然需要由成功执行和失败执行的函数\n\n1创建类构造对象\n\n```\nclass LcPromise{\n    constructor(fn) {\n        //将成功的事件函数集成在successList数组里\n        this.successList  = [];\n        //这里将所有的失败函数集成到failList里\n        this.failList = []\n        //pending,fullfilled,rejected\n        this.state = \"pending\"\n        //传入的函数对象,(异步操作的函数内容)\n        fn(this.resolveFn.bind(this),this.rejectFn.bind(this))\n    }\n}\n```\n\n构造函数的作用：\n\n- 声明成功函数放置的数组对象\n- 声明失败函数放置的数组对象\n- 定义初始化状态\n- 调用传入进行执行异步内容的函数（在未来有成功的结果时调用传入进去的成功函数，在未来失败时调用传入进行的失败函数）\n\n2.传入成功或者失败时需要调用的函数\n\n```js\nclass LcPromise{\n    constructor(fn) {\n\n        //将成功的事件函数集成在successList数组里\n        this.successList  = [];\n        //这里将所有的失败函数集成到failList里\n        this.failList = []\n        //pending,fullfilled,rejected\n        this.state = \"pending\"\n        //传入的函数对象,(异步操作的函数内容)\n        fn(this.resolveFn.bind(this),this.rejectFn.bind(this))\n    }\n    then(successFn,failFn){\n        if(typeof successFn=='function'){\n            this.successList.push(successFn)\n        }\n        if(typeof failFn=='function'){\n            this.failList.push(failFn)\n        }\n    }\n    catch(failFn){\n        if(typeof failFn=='function'){\n            this.failList.push(failFn)\n        }\n    }\n}\n```\n\n作用：\n\n- 将成功和失败的函数传入值成功和失败的数组里\n\n定义调用成功和失败的函数\n\n```js\n//promise async await proxy Iteratror\nclass LcPromise{\n  constructor(fn) {\n\n    //将成功的事件函数集成在successList数组里\n    this.successList  = [];\n    //这里将所有的失败函数集成到failList里\n    this.failList = []\n    //pending,fullfilled,rejected\n    this.state = \"pending\"\n    //传入的函数对象,(异步操作的函数内容)\n    fn(this.resolveFn.bind(this),this.rejectFn.bind(this))\n  }\n  then(successFn,failFn){\n    if(typeof successFn=='function'){\n      this.successList.push(successFn)\n    }\n    if(typeof failFn=='function'){\n      this.failList.push(failFn)\n    }\n  }\n  catch(failFn){\n    if(typeof failFn=='function'){\n      this.failList.push(failFn)\n    }\n  }\n  resolveFn(res){\n    this.state = \"fullfilled\"\n    this.successList.forEach(function(item,index){\n      //将成功的事件循环调用\n      item(res)\n    })\n  }\n  rejectFn(res){\n    this.state = 'rejected'\n    //注册到的失败所有事件进行调用\n    this.failList.forEach(function(item,index){\n      item(res)\n    })\n\n    throw Error(res);\n  }\n\n}\n```\n\n作用：\n\n- 成功时调用成功数组里所有的函数，失败时调用失败数组里所有的函数。\n\n### 应用\n\n如何将promise与async和await结合使用\n\n典型异步读写的回调操作\n\n```js\nfs.readFile(path,{flag:'r',encoding:\"utf-8\"},function(err,data){\n    if(err){\n        //console.log(err)\n        //失败执行的内容\n        reject(err)\n\n    }else{\n        //console.log(data)\n        //成功执行的内容\n        resolve(data)\n    }\n    //console.log(456)\n})\n\n```\n\n转换成promise对象\n\n```\nnew Promise(function(resolve,reject){\n    fs.readFile(path,{flag:'r',encoding:\"utf-8\"},function(err,data){\n        if(err){\n            reject(err)\n        }else{\n            resolve(data)\n        }\n    })\n})\n```\n\n由于每次使用，都不想写这么多代码，那么就会把这样的写法直接进行函数的封装\n\n```\nfunction fsRead(path){\n    return new Promise(function(resolve,reject){\n        fs.readFile(path,{flag:'r',encoding:\"utf-8\"},function(err,data){\n            if(err){\n                reject(err)\n            }else{\n                resolve(data)\n            }\n        })\n    })\n}\n\n```\n\n使用的时候，就可以使用promise写法\n\n```\np1 = fsRead(path) //就可以得到promise对象\np1.then(function(data){\n    console.log('输出数据:',data)\n})\n```\n\nasycn_await写法\n\n```\n(async ()=>{ \n    let data = await fsRead(path)\n})()\n```\n\n异步async函数调用之后也是一个promise对象\n\n```\n(async ()=>{ \n    async function test(){\n        let data = await fsRead(path)\n        return data;\n    }\n    let p = test()//异步函数调用后，也是一个promise对象\n    p.then(function(data){\n        console.log(data)\n    })\n    let a = await test()//异步函数调用后，也是一个promise对象\n    \n    console.log(123)\n})()\n```\n\n## 梳理框架流程\n\n### 1浏览器发送请求\n\n1. 用户输入网址地址\n\n```\nhttp://127.0.0.1/\n```\n\n1. 浏览器根据请求转变成HTTP的请求包\n\n```\nGET / HTTP/1.1\nHost: 127.0.0.1\nConnection: keep-alive\nPragma: no-cache\nCache-Control: no-cache\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36\nSec-Fetch-Mode: navigate\nSec-Fetch-User: ?1\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\nSec-Fetch-Site: none\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\n```\n\n### 2服务器接受到请求\n\n​ 1. http模块里中实例化的server对象，server对象监听每一次浏览器发送过来的请求，每次的请求都会触发`request`事件\n\n```\nthis.server.on('request',(req,res)=>{})\n```\n\n1. 将HTTP的请求包转化成req的请求对象，并且传入到请求事件触发的函数中。\n2. 会创建生成1个res响应对象，这个对象可以帮助我们快速的实现HTTP的响应\n\n### 3解析请求路径，调用不同的页面渲染函数\n\n1. 正则匹配方式进行对路径的匹配\n2. 以匹配的正则字符串作为KEY，找到需要调用执行的渲染函数\n\n```\n//循环匹配正则路径\nfor(let key in this.reqEvent){\n\n    let regStr = key\n    let reg = new RegExp(regStr,'igs');\n    console.log(regStr,reg)\n    if(reg.test(req.url)){\n        this.reqEvent[key](req,res)\n        resState = true\n        break;\n    }\n}\n```\n\n1. 调用页面的执行函数\n\n```\napp.on('/movies/[01]',(req,res)=>{})//这里的箭头函数即为真正匹配到的页面时执行的函数\n```\n\n1. 调用模板的渲染函数\n\n```\nres.render(movies[index],'./template/index0.html')\n```\n\n1. 执行渲染函数\n\n```\nfunction render(options,path){\n    fs.readFile(path,{encoding:\"utf-8\",flag:\"r\"},(err,data)=>{\n        if(err){\n            console.log(err)\n        }else{\n            //数组变量的替换\n            data = replaceArr(data,options)\n            //单个变量的替换\n            data = replaceVar(data,options)\n            //最终输出渲染出来的HTML\n            this.end(data)\n        }\n    })\n}\n```\n\n1. 数组变量的替换\n\n```\nfunction replaceArr(data,options){\n    //匹配循环的变量，并且替换循环的内容\n    let reg = /\\{\\%for \\{(.*?)\\} \\%\\}(.*?)\\{\\%endfor\\%\\}/igs\n    while(result = reg.exec(data)){\n        let strKey = result[1].trim();//提取变量时，去掉左右两边的空格\n        //通过KEY值获取数组内容\n        let strValueArr = options[strKey]\n        let listStr = \"\"\n        strValueArr.forEach((item,i)=>{\n            //替换每一项内容里的变量\n            listStr = listStr + replaceVar(result[2],{\"item\":item})\n        })\n        data = data.replace(result[0],listStr)\n    }\n    return data;\n}\n```\n\n1. 单个变量的替换\n\n```\nfunction replaceVar(data,options){\n    let reg = /\\{\\{(.*?)\\}\\}/igs\n    let result;\n    console.log(options)\n    while(result = reg.exec(data)){\n        //去除2边的空白\n        let strKey = result[1].trim()\n        \n        console.log(strKey)// item,item.abc\n        //options.item\n        let strValue = eval('options.'+strKey);//执行字符串作为JS表达式，并将计算出来的结果返回\n        data = data.replace(result[0],strValue)\n    }\n    return data\n}\n```\n\n### 4如果是请求静态文件，那么就按照静态文件的形式输出\n\n1. 首先判断是否响应过，如果没有响应过，可以判断是否为静态文件，如果是静态文件就正常的输出\n2. 否则，就输出404\n\n```\nif(!resState){\n    if(pathObj.dir==this.staticDir){\n        res.setHeader(\"content-type\",this.getContentType(pathObj.ext))\n        let rs = fs.createReadStream('./static/'+pathObj.base)\n        rs.pipe(res)\n    }else{\n        res.setHeader(\"content-type\",\"text/html;charset=utf-8\")\n        res.end(\"<h1>404!页面找不到</h1>\")\n    }\n}\n```\n\n### 5RES响应对象将res设置的内容最终转化成http的响应包\n\n```\nHTTP/1.1 200 OK\ncontent-type: text/html;charset=utf-8\nDate: Sat, 30 Nov 2019 07:01:36 GMT\nConnection: keep-alive\nContent-Length: 46\n\n<h1>这是首页</h1><img src='./abc/cxk.jpg'>\n```\n\n### 6浏览器解析响应包，并将html渲染在页面上\n\n## 正则路由的设定\n\n要求：可以根据自己设定的正则匹配路径来执行相对应的函数来响应用户的内容。\n\n### 1.设定正则的匹配路径和响应的执行函数\n\n```\napp.on('^/$',(req,res)=>{\n    res.setHeader(\"content-type\",\"text/html;charset=utf-8\");\n    res.end(\"<h1>这是首页</h1><img src='./abc/cxk.jpg'>\")\n})\n```\n\n### 2. 获取正则路径创建正则对象\n\n```\nlet reg = new RegExp(regStr,'igs');\n```\n\n### 3.匹配路径，并调用相对应的函数\n\n```\nif(reg.test(req.url)){\n    this.reqEvent[key](req,res)\n    resState = true\n    break;\n}\n```\n\n### 4.判断是否正则路径响应过，如果响应过，将不再响应，不能重复响应，会报错\n\n```javascript\nif(!resState){\n    if(pathObj.dir==this.staticDir){\n        res.setHeader(\"content-type\",this.getContentType(pathObj.ext))\n        let rs = fs.createReadStream('./static/'+pathObj.base)\n        rs.pipe(res)\n    }else{\n        res.setHeader(\"content-type\",\"text/html;charset=utf-8\")\n        res.end(\"<h1>404!页面找不到</h1>\")\n    }\n}\n```\n\n## Node总结\n\nNode：一门后端语言（服务器端的程序语言），能够连接数据库存取数据，能够接受和处理网络请求（服务器的响应，发送请求去获取数据），单线程事件驱动，异步执行，不等待，提高IO（input和ouput）的处理速度和效率。\n\n服务器：本质上是一台PC主机（linux系统，windows系统），部署了后端语言的执行环境，并且能够长时间提供网络服务。\n\n### 事件驱动\n\nnode本身提供了事件对象，帮助我们快速订阅者模式，或者观察者模式，或者事件模式。\n\n```js\n//事件的订阅\nevent.on(‘林俊杰演唱会’，()=>{订阅门票})\n//事件的触发\nevent.emit(‘林俊杰演唱会’)\n```\n\n### 读写事件\n\n```js\nfs.readfile('path',读取配置,(err,data)=>{})\nfs.writeFile('path',写入数据，写入配置，()=>{})\n```\n\n### 读写的promise封装\n\n```javascript\nlet fs = require('fs')\nfunction fsRead(path){\n    return new Promise(function(resolve,reject){\n        fs.readFile(path,{flag:'r',encoding:\"utf-8\"},function(err,data){\n            if(err){\n                //console.log(err)\n                //失败执行的内容\n                reject(err)\n\n            }else{\n                //console.log(data)\n                //成功执行的内容\n                resolve(data)\n            }\n            //console.log(456)\n        })\n    })\n}\n\n\nfunction fsWrite(path,content){\n    return new Promise(function(resolve,reject){\n        fs.writeFile(path,content,{flag:\"a\",encoding:\"utf-8\"},function(err){\n            if(err){\n                //console.log(\"写入内容出错\")\n                reject(err)\n            }else{\n                resolve(err)\n                //console.log(\"写入内容成功\")\n            }\n        })\n    })\n}\n\nfunction fsDir(path){\n    return new Promise(function(resolve,reject){\n        fs.mkdir(path,function(err){\n            if(err){\n                reject(err)\n            }else{\n                resolve(\"成功创建目录\")\n            }\n        })\n    })\n}\n\nmodule.exports = {fsRead,fsWrite,fsDir}\n```\n\n#### 使用方式\n\n```\n(async function(){\n let data = await fsRead('path')\n})()\n```\n\n### 网络请求数据\n\nrequest,axios:效率比较高，单局限性比较大\n\npuppeteer:效率低，局限性比较小\n\n重点掌握的是：页面的分析，数据存放的位置，以及响应内容。\n\n### 网络响应数据\n\nhttp.createServer：就可以创建1个服务器去监听某个端口，并且通过请求事件来处理每个发送过来的请求。\n\nserver.on('request',(req,res)=>{\n\n​ req:请求数据都会放在请求对象里\n\n​ res：能够做出响应对象\n\n})\n\n### 路由\n\n根据不同的路径去响应不同的内容\n\n```javascript\n//循环匹配正则路径\nfor(let key in this.reqEvent){\n    res.setHeader(\"content-type\",\"text/html;charset=utf-8\")\n    let regStr = key\n    let reg = new RegExp(regStr,'igs');\n    //console.log(regStr,reg)\n    if(reg.test(req.url)){\n        this.reqEvent[key](req,res)\n        resState = true\n        break;\n    }\n}\n```\n\n### 模板\n\n会有个固定样式和结构的HTML模板，根据请求的数据不同，显示页面内容。例如新闻网站\n\n```javascript\nfunction render(options,path){\n    fs.readFile(path,{encoding:\"utf-8\",flag:\"r\"},(err,data)=>{\n        if(err){\n            console.log(err)\n        }else{\n            try {\n                data = replaceArr(data,options)\n                data = replaceVar(data,options)\n            } catch (error) {\n               console.log(error)     \n            }\n\n            this.end(data)\n        }\n    })\n}\n```\n\n## 回调函数\n\n> - 异步变成的直接体现就是回调\n>\n> - node所有api都支持回调函数\n\n```js\nfunction foo(value, callback1, callback) { }\n```\n\n### 阻塞代码实例\n\ninput.txt\n\n```txt\ngrhgrh\n```\n\nmain.js\n\n```js\nvar fs = require('fs');\nvar data = fs.readFileSync('input.txt');\nconsole.log(data.toString());\nconsole.log(\"程序执行结束!\");\n```\n\n执行代码\n\n```cmd\n$ node main.js\ngrhgrh\n\n程序执行结束!\n```\n\n### 非阻塞态实例\n\ninput.txt\n\n```txt\ngrhgrh\n```\n\nmain.js\n\n```js\nvar fs = require('fs');\nfs.readFile('input.txt', function(err, data){\n  if(err) return console.log(err);\n  consolo.log(data.toString());\n});\nconsole.log(\"程序执行结束!\");\n```\n\n执行代码\n\n```cmd\n$ node main.js\n程序执行结束!\ngrhgrh\n```\n\n## 事件循环\n\n> - node事件机制都是用观察者设计模式来实现的\n> - 单线程进入while(true)的时间循环,知道没有事件观察者退出,每个异步时间都生成一个时间观察者,没有事件发生就调用该回调函数\n\n### 事件驱动程序\n\n> - 当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。\n>\n> - 当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户\n\n<img src=\"https://images.gitee.com/uploads/images/2020/0601/115845_6c7a6287_6545143.png\" style=\"zoom:50%;\" />\n\n```js\n// 引入 events 模块\nvar events = require('events');\n// 创建 eventEmitter 对象\nvar eventEmitter = new events.EventEmitter();\n \n// 创建事件处理程序\nvar connectHandler = function connected() {\n   console.log('连接成功。');\n  \n   // 触发 data_received 事件 \n   eventEmitter.emit('data_received');\n}\n \n// 绑定 connection 事件处理程序\neventEmitter.on('connection', connectHandler);\n \n// 使用匿名函数绑定 data_received 事件\neventEmitter.on('data_received', function(){\n   console.log('数据接收成功。');\n});\n \n// 触发 connection 事件 \neventEmitter.emit('connection');\n \nconsole.log(\"程序执行完毕。\");\n\n执行结果:\n$ node main.js\n连接成功。\n数据接收成功。\n程序执行完毕\n\n```\n\n## EventEmitter\n\n> - Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。\n>\n> - Node.js 里面的许多对象都会分发事件：\n>   - 一个 net.Server 对象会在每次有新连接时触发一个事件，\n>   - 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。\n\n```js\n//event.js 文件\nvar events = require('events'); \nvar emitter = new events.EventEmitter(); \nemitter.on('someEvent', function(arg1, arg2) { \n    console.log('listener1', arg1, arg2); \n}); \nemitter.on('someEvent', function(arg1, arg2) { \n    console.log('listener2', arg1, arg2); \n}); \nemitter.emit('someEvent', 'arg1 参数', 'arg2 参数'); \n\n//执行后\n$ node event.js \nlistener1 arg1 参数 arg2 参数\nlistener2 arg1 参数 arg2 参数\n```\n\n> emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件\n\n### 方法\n\n| 序号 | 方法 & 描述                                                                                                                                                                                                                                                                                                                     |\n| :--- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| 1    | **addListener(event, listener)** 为指定事件添加一个监听器到监听器数组的尾部。                                                                                                                                                                                                                                                   |\n| 2    | **on(event, listener)** 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。`server.on('connection', function (stream) {  console.log('someone connected!'); });`                                                                                                                                                    |\n| 3    | **once(event, listener)** 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。`server.once('connection', function (stream) {  console.log('Ah, we have our first user!'); });`                                                                                                                     |\n| 4    | **removeListener(event, listener)** 移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。`var callback = function(stream) {  console.log('someone connected!'); }; server.on('connection', callback); // ... server.removeListener('connection', callback);` |\n| 5    | **removeAllListeners([event])** 移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。                                                                                                                                                                                                                           |\n| 6    | **setMaxListeners(n)** 默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。                                                                                                                                                                           |\n| 7    | **listeners(event)** 返回指定事件的监听器数组。                                                                                                                                                                                                                                                                                 |\n| 8    | **emit(event, [arg1], [arg2], [...])** 按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。                                                                                                                                                                                                          |\n\n### 事件\n\n| 序号 | 事件 & 描述                                                                                                                                                                    |\n| :--- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 1    | **newListener** **event** - 字符串，事件名称**listener** - 处理事件函数该事件在添加新监听器时被触发。                                                                          |\n| 2    | **removeListener** **event** - 字符串，事件名称**listener** - 处理事件函数从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。 |\n\n### 实例\n\nmain.js\n\n```js\nvar events = require('events');\nvar eventEmitter = new events.EventEmitter();\n\n// 监听器 #1\nvar listener1 = function listener1() {\n   console.log('监听器 listener1 执行。');\n}\n\n// 监听器 #2\nvar listener2 = function listener2() {\n  console.log('监听器 listener2 执行。');\n}\n\n// 绑定 connection 事件，处理函数为 listener1 \neventEmitter.addListener('connection', listener1);\n\n// 绑定 connection 事件，处理函数为 listener2\neventEmitter.on('connection', listener2);\n\nvar eventListeners = eventEmitter.listenerCount('connection');\nconsole.log(eventListeners + \" 个监听器监听连接事件。\");\n\n// 处理 connection 事件 \neventEmitter.emit('connection');\n\n// 移除监绑定的 listener1 函数\neventEmitter.removeListener('connection', listener1);\nconsole.log(\"listener1 不再受监听。\");\n\n// 触发连接事件\neventEmitter.emit('connection');\n\neventListeners = eventEmitter.listenerCount('connection');\nconsole.log(eventListeners + \" 个监听器监听连接事件。\");\n\nconsole.log(\"程序执行完毕。\");\n\n执行结果:\n\n$ node main.js\n  2 个监听器监听连接事件。\n  监听器 listener1 执行。\n  监听器 listener2 执行。\n  listener1 不再受监听。\n  监听器 listener2 执行。\n  1 个监听器监听连接事件。\n  程序执行完毕。\n\n```\n\n------\n\n## Buffer(缓冲区)\n\n> - JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。\n>\n> - 但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。\n>\n> - 在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。\n\n### node支持的字符编码\n\n> - **ascii** - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。\n> - ==**utf8** - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。==\n> - **utf16le** - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。\n> - **ucs2** - **utf16le** 的别名。\n> - **base64** - Base64 编码。\n> - **latin1** - 一种把 **Buffer** 编码成一字节编码的字符串的方式。\n> - **binary** - **latin1** 的别名。\n> - **hex** - 将每个字节编码为两个十六进制字符。\n\neg:\n\n```js\nconst buf = Buffer.from('runoob', 'ascii');\n\n// 输出 72756e6f6f62\nconsole.log(buf.toString('hex'));\n\n// 输出 cnVub29i\nconsole.log(buf.toString('base64'));\n```\n\n### 创建Buffer类\n\n> Buffer 提供了以下 API 来创建 Buffer 类：\n>\n> - **Buffer.alloc(size[, fill[, encoding]])：** 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0\n> - **Buffer.allocUnsafe(size)：** 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据\n> - **Buffer.allocUnsafeSlow(size)**\n> - **Buffer.from(array)：** 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）\n> - **Buffer.from(arrayBuffer[, byteOffset[, length]])：** 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。\n> - **Buffer.from(buffer)：** 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例\n> - **Buffer.from(string[, encoding])：** 返回一个被 string 的值初始化的新的 Buffer 实例\n\n```js\n// 创建一个长度为 10、且用 0 填充的 Buffer。\nconst buf1 = Buffer.alloc(10);\n\n// 创建一个长度为 10、且用 0x1 填充的 Buffer。 \nconst buf2 = Buffer.alloc(10, 1);\n\n// 创建一个长度为 10、且未初始化的 Buffer。\n// 这个方法比调用 Buffer.alloc() 更快，\n// 但返回的 Buffer 实例可能包含旧数据，\n// 因此需要使用 fill() 或 write() 重写。\nconst buf3 = Buffer.allocUnsafe(10);\n\n// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。\nconst buf4 = Buffer.from([1, 2, 3]);\n\n// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。\nconst buf5 = Buffer.from('tést');\n\n// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。\nconst buf6 = Buffer.from('tést', 'latin1');\n```\n\n### 写入缓存区\n\n```js\nbuf.write(string[, offset[, length]][, encoding])\n```\n\n> - **string** - 写入缓冲区的字符串。\n> - **offset** - 缓冲区开始写入的索引值，默认为 0 。\n> - **length** - 写入的字节数，默认为 buffer.length\n> - **encoding** - 使用的编码。默认为 'utf8' 。\n\n```js\nbuf = Buffer.alloc(256);\nlen = buf.write(\"www.ruihuag.com\");\n\nconsole.log(\"写入字节数 : \"+  len);\n```\n\n执行以上代码，输出结果为：\n\n```js\n$node main.js\n写入字节数 : 14\n```\n\n### 从缓存区读取数据\n\n```js\nbuf.toString([encoding[, start[, end]]])\n```\n\n> - **encoding** - 使用的编码。默认为 'utf8' 。\n> - **start** - 指定开始读取的索引位置，默认为 0。\n> - **end** - 结束位置，默认为缓冲区的末尾。\n\n```js\nbuf = Buffer.alloc(26);\nfor (var i = 0 ; i < 26 ; i++) {\n  buf[i] = i + 97;\n}\n\nconsole.log( buf.toString('ascii'));       // 输出: abcdefghijklmnopqrstuvwxyz\nconsole.log( buf.toString('ascii',0,5));   //使用 'ascii' 编码, 并输出: abcde\nconsole.log( buf.toString('utf8',0,5));    // 使用 'utf8' 编码, 并输出: abcde\nconsole.log( buf.toString(undefined,0,5)); // 使用默认的 'utf8' 编码, 并输出: abcde\n\n$ node main.js\nabcdefghijklmnopqrstuvwxyz\nabcde\nabcde\nabcde\n```\n\n### 将Buffer转换为JSON对象\n\n```js\nbuf.toJSON()\n```\n\n> 当字符串化一个 Buffer 实例时，`JSON.stringify()`会隐式地调用该 **toJSON()**。\n\n```js\nconst buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);\nconst json = JSON.stringify(buf);\n\n// 输出: {\"type\":\"Buffer\",\"data\":[1,2,3,4,5]}\nconsole.log(json);\n\nconst copy = JSON.parse(json, (key, value) => {\n  return value && value.type === 'Buffer' ?\n    Buffer.from(value.data) :\n    value;\n});\n\n// 输出: <Buffer 01 02 03 04 05>\nconsole.log(copy);\n\n执行结果\n{\"type\":\"Buffer\",\"data\":[1,2,3,4,5]}\n<Buffer 01 02 03 04 05>\n\n```\n\n### 缓存区合并\n\n```js\nBuffer.concat(list[, totalLength])\n```\n\n> - **list** - 用于合并的 Buffer 对象数组列表。\n> - **totalLength** - 指定合并后Buffer对象的总长度。\n\neg;\n\n```js\nvar buffer1 = Buffer.from(('grh'));\nvar buffer2 = Buffer.from(('www.ruihuag.com'));\nvar buffer3 = Buffer.concat([buffer1,buffer2]);\nconsole.log(\"buffer3 内容: \" + buffer3.toString());\n\n输出:\nbuffer3 内容: grhwww.ruihuag.com\n```\n\n### 缓存区比较\n\n```js\nbuf.compare(otherBuffer);\n```\n\n> **otherBuffer** - 与 **buf** 对象比较的另外一个 Buffer 对象。//返回一个数字\n\neg:\n\n```js\nvar buffer1 = Buffer.from('ABC');\nvar buffer2 = Buffer.from('ABCD');\nvar result = buffer1.compare(buffer2);\n\nif(result < 0) {\n   console.log(buffer1 + \" 在 \" + buffer2 + \"之前\");\n}else if(result == 0){\n   console.log(buffer1 + \" 与 \" + buffer2 + \"相同\");\n}else {\n   console.log(buffer1 + \" 在 \" + buffer2 + \"之后\");\n}\n\n输出\nABC在ABCD之前\n\n```\n\n### 拷贝缓存区\n\n```js\nbuf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])\n```\n\n> - **targetBuffer** - 要拷贝的 Buffer 对象。\n> - **targetStart** - 数字, 可选, 默认: 0\n> - **sourceStart** - 数字, 可选, 默认: 0\n> - **sourceEnd** - 数字, 可选, 默认: buffer.length\n> - 没有返回值\n\neg:\n\n```js\nvar buf1 = Buffer.from('abcdefghijkl');\nvar buf2 = Buffer.from('RUNOOB');\n\n//将 buf2 插入到 buf1 指定位置上\nbuf2.copy(buf1, 2);\n\nconsole.log(buf1.toString());\n\n结果:abRUNOOBijkl\n```\n\n### 缓存区裁剪\n\n```js\nbuf.slice([start[, end]])\n```\n\n> - **start** - 数字, 可选, 默认: 0\n> - **end** - 数字, 可选, 默认: buffer.length\n\n```js\nvar buffer1 = Buffer.from('runoob');\n// 剪切缓冲区\nvar buffer2 = buffer1.slice(0,2);\nconsole.log(\"buffer2 content: \" + buffer2.toString());\n\n结果:buffer2 content: ru\n```\n\n### 缓存区长度 buf.length\n\n### 方法参考手册\n\n| 序号 | 方法 & 描述                                                                                                                                                                                                                                                                                                                                                                                                                          |\n| :--- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 1    | **new Buffer(size)** 分配一个新的 size 大小单位为8位字节的 buffer。 注意, size 必须小于 kMaxLength，否则，将会抛出异常 RangeError。废弃的: 使用 Buffer.alloc() 代替（或 Buffer.allocUnsafe()）。                                                                                                                                                                                                                                     |\n| 2    | **new Buffer(buffer)** 拷贝参数 buffer 的数据到 Buffer 实例。废弃的: 使用 Buffer.from(buffer) 代替。                                                                                                                                                                                                                                                                                                                                 |\n| 3    | **new Buffer(str[, encoding])** 分配一个新的 buffer ，其中包含着传入的 str 字符串。 encoding 编码方式默认为 'utf8'。 废弃的: 使用 Buffer.from(string[, encoding]) 代替。                                                                                                                                                                                                                                                             |\n| 4    | **buf.length** 返回这个 buffer 的 bytes 数。注意这未必是 buffer 里面内容的大小。length 是 buffer 对象所分配的内存数，它不会随着这个 buffer 对象内容的改变而改变。                                                                                                                                                                                                                                                                    |\n| 5    | **`buf.write(string[, offset[, length]][, encoding])`** 根据参数 offset 偏移量和指定的 encoding 编码方式，将参数 string 数据写入buffer。 offset 偏移量默认值是 0, encoding 编码方式默认是 utf8。 length 长度是将要写入的字符串的 bytes 大小。 返回 number 类型，表示写入了多少 8 位字节流。如果 buffer 没有足够的空间来放整个 string，它将只会只写入部分字符串。 length 默认是 buffer.length - offset。 这个方法不会出现写入部分字符。 |\n| 6    | **buf.writeUIntLE(value, offset, byteLength[, noAssert])** 将 value 写入到 buffer 里， 它由 offset 和 byteLength 决定，最高支持 48 位无符号整数，小端对齐，例如： `const buf = Buffer.allocUnsafe(6); buf.writeUIntLE(0x1234567890ab, 0, 6); // 输出:  console.log(buf);`noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。                                                                                   |\n| 7    | **buf.writeUIntBE(value, offset, byteLength[, noAssert])** 将 value 写入到 buffer 里， 它由 offset 和 byteLength 决定，最高支持 48 位无符号整数，大端对齐。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。`const buf = Buffer.allocUnsafe(6); buf.writeUIntBE(0x1234567890ab, 0, 6); // 输出:  console.log(buf);`                                                                                          |\n| 8    | **buf.writeIntLE(value, offset, byteLength[, noAssert])** 将value 写入到 buffer 里， 它由offset 和 byteLength 决定，最高支持48位有符号整数，小端对齐。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。                                                                                                                                                                                                      |\n| 9    | **buf.writeIntBE(value, offset, byteLength[, noAssert])** 将value 写入到 buffer 里， 它由offset 和 byteLength 决定，最高支持48位有符号整数，大端对齐。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。                                                                                                                                                                                                      |\n| 10   | **buf.readUIntLE(offset, byteLength[, noAssert])** 支持读取 48 位以下的无符号数字，小端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。                                                                                                                                                                                                                                                           |\n| 11   | **buf.readUIntBE(offset, byteLength[, noAssert])** 支持读取 48 位以下的无符号数字，大端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。                                                                                                                                                                                                                                                           |\n| 12   | **buf.readIntLE(offset, byteLength[, noAssert])** 支持读取 48 位以下的有符号数字，小端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。                                                                                                                                                                                                                                                            |\n| 13   | **buf.readIntBE(offset, byteLength[, noAssert])** 支持读取 48 位以下的有符号数字，大端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。                                                                                                                                                                                                                                                            |\n| 14   | **buf.toString([encoding[, start[, end]]])** 根据 encoding 参数（默认是 'utf8'）返回一个解码过的 string 类型。还会根据传入的参数 start (默认是 0) 和 end (默认是 buffer.length)作为取值范围。                                                                                                                                                                                                                                        |\n| 15   | **buf.toJSON()** 将 Buffer 实例转换为 JSON 对象。                                                                                                                                                                                                                                                                                                                                                                                    |\n| 16   | **buf[index]** 获取或设置指定的字节。返回值代表一个字节，所以返回值的合法范围是十六进制0x00到0xFF 或者十进制0至 255。                                                                                                                                                                                                                                                                                                                |\n| 17   | **buf.equals(otherBuffer)** 比较两个缓冲区是否相等，如果是返回 true，否则返回 false。                                                                                                                                                                                                                                                                                                                                                |\n| 18   | **buf.compare(otherBuffer)** 比较两个 Buffer 对象，返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。                                                                                                                                                                                                                                                                                                                          |\n| 19   | **buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])** buffer 拷贝，源和目标可以相同。 targetStart 目标开始偏移和 sourceStart 源开始偏移默认都是 0。 sourceEnd 源结束位置偏移默认是源的长度 buffer.length 。                                                                                                                                                                                                          |\n| 20   | **buf.slice([start[, end]])** 剪切 Buffer 对象，根据 start(默认是 0 ) 和 end (默认是 buffer.length ) 偏移和裁剪了索引。 负的索引是从 buffer 尾部开始计算的。                                                                                                                                                                                                                                                                         |\n| 21   | **buf.readUInt8(offset[, noAssert])** 根据指定的偏移量，读取一个无符号 8 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 如果这样 offset 可能会超出buffer 的末尾。默认是 false。                                                                                                                                                                                                                                      |\n| 22   | **buf.readUInt16LE(offset[, noAssert])** 根据指定的偏移量，使用特殊的 endian 字节序格式读取一个无符号 16 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。                                                                                                                                                                                                     |\n| 23   | **buf.readUInt16BE(offset[, noAssert])** 根据指定的偏移量，使用特殊的 endian 字节序格式读取一个无符号 16 位整数，大端对齐。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。                                                                                                                                                                                           |\n| 24   | **buf.readUInt32LE(offset[, noAssert])** 根据指定的偏移量，使用指定的 endian 字节序格式读取一个无符号 32 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。                                                                                                                                                                                           |\n| 25   | **buf.readUInt32BE(offset[, noAssert])** 根据指定的偏移量，使用指定的 endian 字节序格式读取一个无符号 32 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。                                                                                                                                                                                           |\n| 26   | **buf.readInt8(offset[, noAssert])** 根据指定的偏移量，读取一个有符号 8 位整数。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。                                                                                                                                                                                                                                     |\n| 27   | **buf.readInt16LE(offset[, noAssert])** 根据指定的偏移量，使用特殊的 endian 格式读取一个 有符号 16 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。                                                                                                                                                                                                |\n| 28   | **buf.readInt16BE(offset[, noAssert])** 根据指定的偏移量，使用特殊的 endian 格式读取一个 有符号 16 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。                                                                                                                                                                                                |\n| 29   | **buf.readInt32LE(offset[, noAssert])** 根据指定的偏移量，使用指定的 endian 字节序格式读取一个有符号 32 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。                                                                                                                                                                                            |\n| 30   | **buf.readInt32BE(offset[, noAssert])** 根据指定的偏移量，使用指定的 endian 字节序格式读取一个有符号 32 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。                                                                                                                                                                                            |\n| 31   | **buf.readFloatLE(offset[, noAssert])** 根据指定的偏移量，使用指定的 endian 字节序格式读取一个 32 位双浮点数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer的末尾。默认是 false。                                                                                                                                                                                               |\n| 32   | **buf.readFloatBE(offset[, noAssert])** 根据指定的偏移量，使用指定的 endian 字节序格式读取一个 32 位双浮点数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer的末尾。默认是 false。                                                                                                                                                                                               |\n| 33   | **buf.readDoubleLE(offset[, noAssert])** 根据指定的偏移量，使用指定的 endian字节序格式读取一个 64 位双精度数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。                                                                                                                                                                                              |\n| 34   | **buf.readDoubleBE(offset[, noAssert])** 根据指定的偏移量，使用指定的 endian字节序格式读取一个 64 位双精度数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。                                                                                                                                                                                              |\n| 35   | **buf.writeUInt8(value, offset[, noAssert])** 根据传入的 offset 偏移量将 value 写入 buffer。注意：value 必须是一个合法的无符号 8 位整数。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则不要使用。默认是 false。                                                                                       |\n| 36   | **buf.writeUInt16LE(value, offset[, noAssert])** 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的无符号 16 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。                                          |\n| 37   | **buf.writeUInt16BE(value, offset[, noAssert])** 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的无符号 16 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。                                          |\n| 38   | **buf.writeUInt32LE(value, offset[, noAssert])** 根据传入的 offset 偏移量和指定的 endian 格式(LITTLE-ENDIAN:小字节序)将 value 写入buffer。注意：value 必须是一个合法的无符号 32 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着value 可能过大，或者offset可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。                      |\n| 39   | **buf.writeUInt32BE(value, offset[, noAssert])** 根据传入的 offset 偏移量和指定的 endian 格式(Big-Endian:大字节序)将 value 写入buffer。注意：value 必须是一个合法的有符号 32 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者offset可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。                                  |\n| 40   | **buf.writeInt8(value, offset[, noAssert])**                                                                                                                                                                                                                                                                                                                                                                                         |\n| 41   | **buf.writeInt16LE(value, offset[, noAssert])** 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 16 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false 。                                                 |\n| 42   | **buf.writeInt16BE(value, offset[, noAssert])** 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 16 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false 。                                                 |\n| 43   | **buf.writeInt32LE(value, offset[, noAssert])** 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 32 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。                                                  |\n| 44   | **buf.writeInt32BE(value, offset[, noAssert])** 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 32 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。                                                  |\n| 45   | **buf.writeFloatLE(value, offset[, noAssert])** 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer 。注意：当 value 不是一个 32 位浮点数类型的值时，结果将是不确定的。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。                                |\n| 46   | **buf.writeFloatBE(value, offset[, noAssert])** 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer 。注意：当 value 不是一个 32 位浮点数类型的值时，结果将是不确定的。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。                                |\n| 47   | **buf.writeDoubleLE(value, offset[, noAssert])** 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个有效的 64 位double 类型的值。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成value被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。                                               |\n| 48   | **buf.writeDoubleBE(value, offset[, noAssert])** 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个有效的 64 位double 类型的值。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成value被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。                                               |\n| 49   | **`buf.fill(value[, offset][, end])`** 使用指定的 value 来填充这个 buffer。如果没有指定 offset (默认是 0) 并且 end (默认是 buffer.length) ，将会填充整个buffer。                                                                                                                                                                                                                                                                       |\n\n## Stream(流)\n\n> **Stream四种类型**\n>\n> - Readable** - 可读操作。\n> - **Writable** - 可写操作。\n> - **Duplex** - 可读可写操作.\n> - **Transform** - 操作被写入数据，然后读出结果。\n>\n>\n>\n> 所有的 Stream 对象都是 EventEmitter 的实例。\n>\n> 常用的事件有：\n>\n> - **data** - 当有数据可读时触发。\n> - **end** - 没有更多的数据可读时触发。\n> - **error** - 在接收和写入过程中发生错误时触发。\n> - **finish** - 所有数据已被写入到底层系统时触发。\n\n### 从流中读取数据\n\ninput.js\n\n```txt\ngrh\n```\n\nmain.js\n\n```js\nvar fs = require(\"fs\");\nvar data = '';\n\n// 创建可读流\nvar readerStream = fs.createReadStream('input.txt');\n\n// 设置编码为 utf8。\nreaderStream.setEncoding('UTF8');\n\n// 处理流事件 --> data, end, and error\nreaderStream.on('data', function(chunk) {\n   data += chunk;\n});\n\nreaderStream.on('end',function(){\n   console.log(data);\n});\n\nreaderStream.on('error', function(err){\n   console.log(err.stack);\n});\n\nconsole.log(\"程序执行完毕\");\n\n结果:\n\n程序执行完毕\ngrh官网地址：www.runoob.com\n\n```\n\n### 写入流\n\nmain.js\n\n```js\nvar fs = require(\"fs\");\nvar data = 'grh官网地址：www.runoob.com';\n\n// 创建一个可以写入的流，写入到文件 output.txt 中\nvar writerStream = fs.createWriteStream('output.txt');\n\n// 使用 utf8 编码写入数据\nwriterStream.write(data,'UTF8');\n\n// 标记文件末尾\nwriterStream.end();\n\n// 处理流事件 --> data, end, and error\nwriterStream.on('finish', function() {\n    console.log(\"写入完成。\");\n});\n\nwriterStream.on('error', function(err){\n   console.log(err.stack);\n});\n\nconsole.log(\"程序执行完毕\");\n\n结果\n\n程序执行完毕\n写入完成\n\n```\n\n### 管道流\n\n> - 一个输出流流到流入的机制\n> - 我们用于从一个流中获取数据并将数据传递到另一个流中\n>   - 可以慢慢的实现大文件的复制过程\n\n```js\nvar fs = require(\"fs\");\n\n// 创建一个可读流\nvar readerStream = fs.createReadStream('input.txt');\n\n// 创建一个可写流\nvar writerStream = fs.createWriteStream('output.txt');\n\n// 管道读写操作\n// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中\nreaderStream.pipe(writerStream);\n\nconsole.log(\"程序执行完毕\");\n```\n\n### 链式流\n\n> - 一般用于管道操作\n> - 通过连接输出流到另外一个流并创建多个流操作链的机制\n\n```js\n//compress.js 压缩文件\n\nvar fs = require(\"fs\");\nvar zlib = require('zlib');\n\n// 压缩 input.txt 文件为 input.txt.gz\nfs.createReadStream('input.txt')\n  .pipe(zlib.createGzip())\n  .pipe(fs.createWriteStream('input.txt.gz'));\n  \nconsole.log(\"文件压缩完成。\");\n```\n\n```js\n//decompress.js 解压文件\n\nvar fs = require(\"fs\");\nvar zlib = require('zlib');\n\n// 解压 input.txt.gz 文件为 input.txt\nfs.createReadStream('input.txt.gz')\n  .pipe(zlib.createGunzip())\n  .pipe(fs.createWriteStream('input.txt'));\n  \nconsole.log(\"文件解压完成。\");\n```\n\n## 模块系统\n\n> **exports 和 module.exports 的使用**\n>\n> - 如果要对外暴露属性或方法，就用 **exports** 就行，要暴露对象(类似class，包含了很多属性和方法)，就用 **module.exports**。\n> - 不用同时使用两个\n\n### 创建模块\n\n自封装一个对象\n\n```js\nmodule.exports = function() {\n  // ...\n}\n\n//hello.js \nfunction Hello() { \n    var name; \n    this.setName = function(thyName) { \n        name = thyName; \n    }; \n    this.sayHello = function() { \n        console.log('Hello ' + name); \n    }; \n}; \nmodule.exports = Hello;\n\n//main.js \nvar Hello = require('./hello'); \nhello = new Hello(); \nhello.setName('BYVoid'); \nhello.sayHello(); \n```\n\nhello.js\n\n```js\nexports.world = function() {\n  console.log('Hello World');\n}\n```\n\nmain.js\n\n```js\nvar hello = require('./hello');\nhello.world();\n```\n\n### 服务器的模块\n\n```js\nvar http = require(\"http\");\n\n...\n\nhttp.createServer(...);\n```\n\n#### require方法执行过程\n\n<img src=\"https://images.gitee.com/uploads/images/2020/0601/215608_19475bd4_6545143.png\" style=\"zoom:50%;\" />\n\n## 函数\n\n> 函数中传输参数的地方可以直接定义函数\n>\n> ```js\n> function say(word) {\n> console.log(word);\n> }\n> \n> function execute(someFunction, value) {\n> someFunction(value);\n> }\n> \n> execute(say, \"Hello\");\n> ```\n>\n>\n\n### 匿名函数\n\n> 我们可以把一个函数作为变量传递。\n>\n> 但是我们不一定要绕这个\"==先定义，再传递==\"的圈子，\n>\n> 我们可以直接在另一个函数的括号中定义和传递这个函数：\n\n```js\nfunction execute(someFunction, value) {\n  someFunction(value);\n}\n\nexecute(function(word){ console.log(word) }, \"Hello\");\n```\n\n### 函数传递是如何让HTTP服务器工作的\n\n```js\nvar http = require(\"http\");\n\nhttp.createServer(function(request, response) {\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"Hello World\");\n  response.end();\n}).listen(8888);\n```\n\n```js\nvar http = require(\"http\");\n\nfunction onRequest(request, response) {\n  response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n  response.write(\"Hello World\");\n  response.end();\n}\n\nhttp.createServer(onRequest).listen(8888);\n```\n\n### 路由\n\n<img src=\"https://images.gitee.com/uploads/images/2020/0601/223037_4fbde394_6545143.png\" style=\"zoom:50%;\" />\n\nserver.js\n\n```js\nvar http = require(\"http\");\nvar url = require(\"url\");\n \nfunction start() {\n  function onRequest(request, response) {\n    var pathname = url.parse(request.url).pathname;\n    console.log(\"Request for \" + pathname + \" received.\");\n    response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n    response.write(\"Hello World\");\n    response.end();\n  }\n \n  http.createServer(onRequest).listen(8888);\n  console.log(\"Server has started.\");\n}\n \nexports.start = start;\n```\n\nrouter.js\n\n```js\nfunction route(pathname) {\n  console.log(\"About to route a request for \" + pathname);\n}\n \nexports.route = route;\n```\n\nindex.js\n\n```js\nvar server = require(\"./server\");\nvar router = require(\"./router\");\n \nserver.start(router.route);\n```\n\n启动\n\n```shell\n$ node index.js\nServer has started.\n```\n\n浏览器访问 **<http://127.0.0.1:8888/>**\n\n## 全局对象\n\n> - 在程序的任何地方都可以访问,即全局变量\n>\n> - 通常window是全局对象,node中的全局对象是global\n> - 按照ECMAScript定义,全局变量的条件:\n>   - 在最外层定义的变量\n>   - 全局对象的属性\n>   - 隐式定义的变量(未定义直接赋值的变量)\n>   - 不要使用var定义变量,全局变量会污染命名空间\n\n### __filename\n\n> - 表示当前正在执行的脚本的文件名\n> - 输出文件说在位置的绝对路径\n> - 如果是在模块中,返回的值是模块文件的路径\n\nmain.js\n\n```js\n// 输出全局变量 __filename 的值\nconsole.log( __filename );\n\n执行:\n$ node main.js\n/web/com/runoob/nodejs/main.js\n```\n\n### __dirname\n\n> 表示当前执行脚本说在的目录\n\nmain.js\n\n```js\n// 输出全局变量 __dirname 的值\nconsole.log( __dirname );\n执行 main.js 文件，代码如下所示:\n\n\n输出:\n$ node main.js\n/web/com/runoob/nodejs\n```\n\n### clearTimeout(t)\n\n> - 全局函数用于停止一个之前通过 setTimeout() 创建的定时器。\n>\n> - 参数 **t** 是通过 setTimeout() 函数创建的定时器。\n\n```js\nfunction printHello(){\n   console.log( \"Hello, World!\");\n}\n// 两秒后执行以上函数\nvar t = setTimeout(printHello, 2000);\n\n// 清除定时器\nclearTimeout(t);\n```\n\n### setInterval(cb, ms)\n\n> - 指定在每ms数执行\n> - 直到clearInterval()被调用或窗口关闭\n\n```js\nfunction printHello(){\n   console.log( \"Hello, World!\");\n}\n// 两秒后执行以上函数\nsetInterval(printHello, 2000);\n```\n\n### console\n\n> console 用于提供控制台标准输出，它是由 Internet Explorer 的 JScript 引擎提供的调试工具，后来逐渐成为浏览器的实施标准。\n>\n> Node.js 沿用了这个标准，提供与习惯行为一致的 console 对象，用于向标准输出流（stdout）或标准错误流（stderr）输出字符。\n\n| 序号 | 方法 & 描述                                                                                                                                                                                           |\n| :--- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 1    | **`console.log([data][, ...])`** 向标准输出流打印字符并以换行符结束。该方法接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。   |\n| 2    | **`console.info([data][, ...])`** 该命令的作用是返回信息性消息，这个命令与console.log差别并不大，除了在chrome中只会输出文字外，其余的会显示一个蓝色的惊叹号。                                           |\n| 3    | **`console.error([data][, ...])`** 输出错误消息的。控制台在出现错误时会显示是红色的叉子。                                                                                                               |\n| 4    | **`console.warn([data][, ...])`** 输出警告消息。控制台出现有黄色的惊叹号。                                                                                                                              |\n| 5    | **console.dir(obj[, options])** 用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。                                                                                                     |\n| 6    | **console.time(label)** 输出时间，表示计时开始。                                                                                                                                                      |\n| 7    | **console.timeEnd(label)** 结束时间，表示计时结束。                                                                                                                                                   |\n| 8    | **console.trace(message[, ...])** 当前执行的代码在堆栈中的调用路径，这个测试函数运行很有帮助，只要给想测试的函数里面加入 console.trace 就行了。                                                       |\n| 9    | **`console.assert(value[, message][, ...])`** 用于判断某个表达式或变量是否为真，接收两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。 |\n\n#### console.log()\n\n```js\nconsole.log('Hello world'); \nconsole.log('byvoid%diovyb'); \nconsole.log('byvoid%diovyb', 1991); \n运行结果:\nHello world \nbyvoid%diovyb \nbyvoid1991iovyb\n```\n\n#### console.error()\n\n> 与console.log() 用法相同，只是向标准错误流输出。\n\n#### console.trace()\n\n> 向标准流输出当前的调用栈\n\n```js\nconsole.trace()\n\nTrace:\nat Object.<anonymous> (/home/byvoid/consoletrace.js:1:71) \nat Module._compile (module.js:441:26) \nat Object..js (module.js:459:10) \nat Module.load (module.js:348:31) \nat Function._load (module.js:308:12) \nat Array.0 (module.js:479:10) \nat EventEmitter._tickCallback (node.js:192:40)\n```\n\neg:\n\n```js\nconsole.info(\"程序开始执行：\");\nvar counter = 10;\nconsole.log(\"计数: %d\", counter);\nconsole.time(\"获取数据\");\n//\n// 执行一些代码\n// \nconsole.timeEnd('获取数据');\nconsole.info(\"程序执行完毕。\")\n\n\n$ node main.js\n程序开始执行：\n计数: 10\n获取数据: 0ms\n程序执行完毕\n```\n\n### process\n\n> - 全局变量,即global对象属性\n\n| 序号 | 事件 & 描述                                                                                                                                                                 |\n| :--- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 1    | **exit** 当进程准备退出时触发。                                                                                                                                             |\n| 2    | **beforeExit** 当 node 清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时 node 退出，但是 'beforeExit' 的监听器可以异步调用，这样 node 就会继续执行。 |\n| 3    | **uncaughtException** 当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监视器，默认的操作（打印堆栈跟踪信息并退出）就不会发生。                                    |\n| 4    | **Signal 事件** 当进程接收到信号时就触发。信号列表详见标准的 POSIX 信号名，如 SIGINT、SIGUSR1 等。                                                                          |\n\n```js\nprocess.on('exit', function(code) {\n\n  // 以下代码永远不会执行\n  setTimeout(function() {\n    console.log(\"该代码不会执行\");\n  }, 0);\n  \n  console.log('退出码为:', code);\n});\nconsole.log(\"程序执行结束\")\n\n$ node main.js\n程序执行结束\n退出码为: 0\n\n```\n\n#### 退出状态码\n\n| 状态码 | 名称 & 描述                                                                                                                                                                        |\n| :----- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 1      | **Uncaught Fatal Exception** 有未捕获异常，并且没有被域或 uncaughtException 处理函数处理。                                                                                         |\n| 2      | **Unused** 保留                                                                                                                                                                    |\n| 3      | **Internal JavaScript Parse Error** JavaScript的源码启动 Node 进程时引起解析错误。非常罕见，仅会在开发 Node 时才会有。                                                             |\n| 4      | **Internal JavaScript Evaluation Failure** JavaScript 的源码启动 Node 进程，评估时返回函数失败。非常罕见，仅会在开发 Node 时才会有。                                               |\n| 5      | **Fatal Error** V8 里致命的不可恢复的错误。通常会打印到 stderr ，内容为： FATAL ERROR                                                                                              |\n| 6      | **Non-function Internal Exception Handler** 未捕获异常，内部异常处理函数不知为何设置为on-function，并且不能被调用。                                                                |\n| 7      | **Internal Exception Handler Run-Time Failure** 未捕获的异常， 并且异常处理函数处理时自己抛出了异常。例如，如果 process.on('uncaughtException') 或 domain.on('error') 抛出了异常。 |\n| 8      | **Unused** 保留                                                                                                                                                                    |\n| 9      | **Invalid Argument** 可能是给了未知的参数，或者给的参数没有值。                                                                                                                    |\n| 10     | **Internal JavaScript Run-Time Failure** JavaScript的源码启动 Node 进程时抛出错误，非常罕见，仅会在开发 Node 时才会有。                                                            |\n| 12     | **Invalid Debug Argument** 设置了参数--debug 和/或 --debug-brk，但是选择了错误端口。                                                                                               |\n| 128    | **Signal Exits** 如果 Node 接收到致命信号，比如SIGKILL 或 SIGHUP，那么退出代码就是128 加信号代码。这是标准的 Unix 做法，退出信号代码放在高位。                                     |\n\n#### Process属性\n\n| 序号. | 属性 & 描述                                                                                                                                    |\n| :---- | :--------------------------------------------------------------------------------------------------------------------------------------------- |\n| 1     | **stdout** 标准输出流。                                                                                                                        |\n| 2     | **stderr** 标准错误流。                                                                                                                        |\n| 3     | **stdin** 标准输入流。                                                                                                                         |\n| 4     | **argv** argv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。   |\n| 5     | **execPath** 返回执行当前脚本的 Node 二进制文件的绝对路径。                                                                                    |\n| 6     | **execArgv** 返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。                                              |\n| 7     | **env** 返回一个对象，成员为当前 shell 的环境变量                                                                                              |\n| 8     | **exitCode** 进程退出时的代码，如果进程优通过 process.exit() 退出，不需要指定退出码。                                                          |\n| 9     | **version** Node 的版本，比如v0.10.18。                                                                                                        |\n| 10    | **versions** 一个属性，包含了 node 的版本和依赖.                                                                                               |\n| 11    | **config** 一个包含用来编译当前 node 执行文件的 javascript 配置选项的对象。它与运行 ./configure 脚本生成的 \"config.gypi\" 文件相同。            |\n| 12    | **pid** 当前进程的进程号。                                                                                                                     |\n| 13    | **title** 进程名，默认值为\"node\"，可以自定义该值。                                                                                             |\n| 14    | **arch** 当前 CPU 的架构：'arm'、'ia32' 或者 'x64'。                                                                                           |\n| 15    | **platform** 运行程序所在的平台系统 'darwin', 'freebsd', 'linux', 'sunos' 或 'win32'                                                           |\n| 16    | **mainModule** require.main 的备选方法。不同点，如果主模块在运行时改变，require.main可能会继续返回老的模块。可以认为，这两者引用了同一个模块。 |\n\n```js\n// 输出到终端\nprocess.stdout.write(\"Hello World!\" + \"\\n\");\n// 通过参数读取\nprocess.argv.forEach(function(val, index, array) {\n   console.log(index + ': ' + val);\n});\n// 获取执行路径\nconsole.log(process.execPath);\n// 平台信息\nconsole.log(process.platform);\n\n\n$ node main.js\nHello World!\n0: node\n1: /web/www/node/main.js\n/usr/local/node/0.10.36/bin/node\ndarwin\n```\n\n#### 方法参考手册\n\n| 序号 | 方法 & 描述                                                                                                                                                                                                                                                                                       |\n| :--- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| 1    | **abort()** 这将导致 node 触发 abort 事件。会让 node 退出并生成一个核心文件。                                                                                                                                                                                                                     |\n| 2    | **chdir(directory)** 改变当前工作进程的目录，如果操作失败抛出异常。                                                                                                                                                                                                                               |\n| 3    | **cwd()** 返回当前进程的工作目录                                                                                                                                                                                                                                                                  |\n| 4    | **exit([code])** 使用指定的 code 结束进程。如果忽略，将会使用 code 0。                                                                                                                                                                                                                            |\n| 5    | **getgid()** 获取进程的群组标识（参见 getgid(2)）。获取到得时群组的数字 id，而不是名字。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。                                                                                                                                        |\n| 6    | **setgid(id)** 设置进程的群组标识（参见 setgid(2)）。可以接收数字 ID 或者群组名。如果指定了群组名，会阻塞等待解析为数字 ID 。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。                                                                                                   |\n| 7    | **getuid()** 获取进程的用户标识(参见 getuid(2))。这是数字的用户 id，不是用户名。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。                                                                                                                                                |\n| 8    | **setuid(id)** 设置进程的用户标识（参见setuid(2)）。接收数字 ID或字符串名字。果指定了群组名，会阻塞等待解析为数字 ID 。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。                                                                                                         |\n| 9    | **getgroups()** 返回进程的群组 iD 数组。POSIX 系统没有保证一定有，但是 node.js 保证有。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。                                                                                                                                         |\n| 10   | **setgroups(groups)** 设置进程的群组 ID。这是授权操作，所以你需要有 root 权限，或者有 CAP_SETGID 能力。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。                                                                                                                         |\n| 11   | **initgroups(user, extra_group)** 读取 /etc/group ，并初始化群组访问列表，使用成员所在的所有群组。这是授权操作，所以你需要有 root 权限，或者有 CAP_SETGID 能力。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。                                                                |\n| 12   | **kill(pid[, signal])** 发送信号给进程. pid 是进程id，并且 signal 是发送的信号的字符串描述。信号名是字符串，比如 'SIGINT' 或 'SIGHUP'。如果忽略，信号会是 'SIGTERM'。                                                                                                                             |\n| 13   | **memoryUsage()** 返回一个对象，描述了 Node 进程所用的内存状况，单位为字节。                                                                                                                                                                                                                      |\n| 14   | **nextTick(callback)** 一旦当前事件循环结束，调用回调函数。                                                                                                                                                                                                                                       |\n| 15   | **umask([mask])** 设置或读取进程文件的掩码。子进程从父进程继承掩码。如果mask 参数有效，返回旧的掩码。否则，返回当前掩码。                                                                                                                                                                         |\n| 16   | **uptime()** 返回 Node 已经运行的秒数。                                                                                                                                                                                                                                                           |\n| 17   | **hrtime()** 返回当前进程的高分辨时间，形式为 [seconds, nanoseconds]数组。它是相对于过去的任意事件。该值与日期无关，因此不受时钟漂移的影响。主要用途是可以通过精确的时间间隔，来衡量程序的性能。 你可以将之前的结果传递给当前的 process.hrtime() ，会返回两者间的时间差，用来基准和测量时间间隔。 |\n\n```js\n// 输出当前目录\nconsole.log('当前目录: ' + process.cwd());\n\n// 输出当前版本\nconsole.log('当前版本: ' + process.version);\n\n// 输出内存使用情况\nconsole.log(process.memoryUsage());\n\n$ node main.js\n当前目录: /web/com/runoob/nodejs\n当前版本: v0.10.36\n{ rss: 12541952, heapTotal: 4083456, heapUsed: 2157056 }\n```\n\n## 常用工具\n\n### util\n\n`const uril = require('util')`\n\n#### util.callbackify\n\n> util.callbackify(orginal)将async异步函数(或者一个返回值为Promise的函数)转换为遵循`异常优先回调风格`的函数,例如将(err,value)=>...回调作为最后一个参数. 在回答函数中,第一个参数为拒绝的原因(如果Promise解决,则为null), 第二个参数则是解决的值.\n\n```js\nconst util =require('util');\n async function fn(){\n   return 'hello world';\n }\n\nconst callbackFunction = util.callbackify(fn);\n\ncallbackFunction((err,ret)=>{\n  if(err) throw err;\n  console.log(ret);\n})\n\n执行结果:\nhello world\n```\n\n> - 回调函数是异步执行的，并且有异常堆栈错误追踪。 如果回调函数抛出一个异常，进程会触发一个 'uncaughtException' 异常，如果没有被捕获，进程将会退出。\n>\n> - null 在回调函数中作为一个参数有其特殊的意义，如果回调函数的首个参数为 Promise 拒绝的原因且带有返回值，且值可以转换成布尔值 false，这个值会被封装在 Error 对象里，可以通过属性 reason 获取\n\n```js\nfunction fn() {\n  return Promise.reject(null);\n}\nconst callbackFunction = util.callbackify(fn);\n\ncallbackFunction((err, ret) => {\n  // 当 Promise 被以 `null` 拒绝时，它被包装为 Error 并且原始值存储在 `reason` 中。\n  err && err.hasOwnProperty('reason') && err.reason === null;  // true\n});\n```\n\n> original 为async异步函数,改函数返回传统回调函数\n\n#### util.inherits\n\n> - util.inherits(constructor, superConstructor) 是一个实现对象间原型继承的函数\n>\n> - javaScript的面向对象特性是基于原型的,与常见的基于类的不同.\n> - JavaScript没有提供对象继承的语言级别特性,而是通过原型复制来实现的.\n\n```js\nvar util = require('util');\nfunciton Base(){\n this.name = 'base';\n  this.base = '1999';\n  this.sayHello = function(){\n    console.log('Hello'+ this.name);\n  };\n}\n\nBase.prototype.showName = function(){\n  console.log(this.name);\n}\n\nfunction Sub(){\n  this.name = 'sub';\n}\n\nutil.inherits(Sub, Base);//这里实现了sub继承了Base\n\nvar objBase = new Base();\nobjBase.showname();\nobjBase.sayHello();\nconsole.log(objBase);\n\nvar objSub = new Sub();\nobjSub.showName();\n//objSub.sayHello();\nconsole.log(objSub);\n```\n\n> - 定义一个基础对象Base和一个继承自Base的Sub,Base有三个构造函数类定义的属性和一个原型中定义的函数,\n> - 通过util.inherits实现继承\n\n```js\n执行结果\nbase\nHello base\n{ name: 'base', base :1999, sayHello:[Funciton] }\nsub\n{ name: 'sub' }\n```\n\n> - sub仅仅继承了Base在原型中定义的函数\n> - 而构造函数内部创造函数内部创造的base属性和sayHello函数都没有被Sub继承\n> - ==在原型定义的属性不会被console.log作为对象的属性输出==\n> - 可以继承原型方法\n\n#### util.inspect\n\n> - `util.inspect(object, [showHidden], [depth], [colors])`\n> - 将任意对象转换为字符串的方法, 通常用于挑食和错误输出\n> - 至少接受一个参数object,即要转换的对象\n> - showHidden:可选,如果为true,会输出更多隐藏信息\n> - depth表示最大的层次,\n>   - 如果对象很复杂,你可以指定成熟以控制输出信息的多少.\n>   - 如果不指定depth,默认会递归2层,\n>   - 指定为null表示不递归成熟完成遍历对象\n> - colors值true,输出格式将会ANSI编码,通常用于在终端显示更加漂亮的效果\n\n```js\nvar util = require('util'); \nfunction Person() { \n    this.name = 'byvoid'; \n    this.toString = function() { \n    return this.name; \n    }; \n} \nvar obj = new Person(); \nconsole.log(util.inspect(obj)); \nconsole.log(util.inspect(obj, true)); \n\n运行结果:\nPerson { name: 'byvoid', toString: [Function] }\nPerson {\n  name: 'byvoid',\n  toString: \n   { [Function]\n     [length]: 0,\n     [name]: '',\n     [arguments]: null,\n     [caller]: null,\n     [prototype]: { [constructor]: [Circular] } } }\n```\n\n| 方法                  | 描述           |\n| --------------------- | -------------- |\n| util.isArray(object)  | 是数组返回true |\n| util.isRegExp(object) | 是正则返回true |\n| util.isDate(object)   | 是日期返回true |\n\n## 文件系统\n\n> - `var fs  = require(\"fs\")`\n> - node有异步[fs.readFile()]和同步[fs.readFileSync()]两个版本\n> - 异步方法函数最后一个参数为回调函数,会带函数的第一个参数包含错误信息(error)\n> - 建议使用异步\n\nfile.js\n\n```js\nvar fs = require(\"fs\")\n//异步读取\nfs.readFIle('input.txt', function(err, data){\n  if(err){\n    return console.error(err);\n  }\n  console.log(\"异步读取:\"+ data.toString());\n});\n\n//同步读取\nvar data = fs.readFileSync('input.txt');\nconsole.log(\"同步读取:\" + data.toString());\nconsole.log(\"程序执行完毕\");\n```\n\n### 打开文件\n\n> 异步模式打开文件的语法:`fs.open(path, flags[, model], callback)`\n>\n> - flags:文件的打开行为\n> - mode: 设置文件模式(权限), 文件创建默认权限为0666(可读可写)\n> - callback: 回调函数, 带有两个参数:callback(err,fd)\n\nflags参数\n\n| Flag | 描述                                                 |\n| :--- | :--------------------------------------------------- |\n| r    | 以读取模式打开文件。如果文件不存在抛出异常。         |\n| r+   | 以读写模式打开文件。如果文件不存在抛出异常。         |\n| rs   | 以同步的方式读取文件。                               |\n| rs+  | 以同步的方式读取和写入文件。                         |\n| w    | 以写入模式打开文件，如果文件不存在则创建。           |\n| wx   | 类似 'w'，但是如果文件路径存在，则文件写入失败。     |\n| w+   | 以读写模式打开文件，如果文件不存在则创建。           |\n| wx+  | 类似 'w+'， 但是如果文件路径存在，则文件读写失败。   |\n| a    | 以追加模式打开文件，如果文件不存在则创建。           |\n| ax   | 类似 'a'， 但是如果文件路径存在，则文件追加失败。    |\n| a+   | 以读取追加模式打开文件，如果文件不存在则创建。       |\n| ax+  | 类似 'a+'， 但是如果文件路径存在，则文件读取追加失败 |\n\n```js\nvar fs = require(\"fs\");\n\n// 异步打开文件\nconsole.log(\"准备打开文件！\");\nfs.open('input.txt', 'r+', function(err, fd) {\n   if (err) {\n       return console.error(err);\n   }\n  console.log(\"文件打开成功！\");     \n});\n```\n\n### 获取文件信息\n\n> - `fs.stat(path,callback)`\n> - callback: 回调函数,带有两个参数(err,stats), stats是fs.Stats对象\n\n```js\n//fs.stat(path)执行后，会将stats类的实例返回给其回调函数。可以通过stats类中的提供方法判断文件的相关属性。例如判断是否为文件：\nvar fs = require('fs');\n\nfs.stat('/Users/liuht/code/itbilu/demo/fs.js', function (err, stats) {\n    console.log(stats.isFile());         //true\n})\n```\n\nstats类中的方法\n\n| 方法                      | 描述                                                                         |\n| :------------------------ | :--------------------------------------------------------------------------- |\n| stats.isFile()            | 如果是文件返回 true，否则返回 false。                                        |\n| stats.isDirectory()       | 如果是目录返回 true，否则返回 false。                                        |\n| stats.isBlockDevice()     | 如果是块设备返回 true，否则返回 false。                                      |\n| stats.isCharacterDevice() | 如果是字符设备返回 true，否则返回 false。                                    |\n| stats.isSymbolicLink()    | 如果是软链接返回 true，否则返回 false。                                      |\n| stats.isFIFO()            | 如果是FIFO，返回true，否则返回 false。FIFO是UNIX中的一种特殊类型的命令管道。 |\n| stats.isSocket()          | 如果是 Socket 返回 true，否则返回 false。                                    |\n\n```js\nvar fs = require(\"fs\");\n\nconsole.log(\"准备打开文件！\");\nfs.stat('input.txt', function (err, stats) {\n   if (err) {\n       return console.error(err);\n   }\n   console.log(stats);\n   console.log(\"读取文件信息成功！\");\n   \n   // 检测文件类型\n   console.log(\"是否为文件(isFile) ? \" + stats.isFile());\n   console.log(\"是否为目录(isDirectory) ? \" + stats.isDirectory());    \n});\n\n运行结果:\n\n$ node file.js \n准备打开文件！\n{ dev: 16777220,\n  mode: 33188,\n  nlink: 1,\n  uid: 501,\n  gid: 20,\n  rdev: 0,\n  blksize: 4096,\n  ino: 40333161,\n  size: 61,\n  blocks: 8,\n  atime: Mon Sep 07 2015 17:43:55 GMT+0800 (CST),\n  mtime: Mon Sep 07 2015 17:22:35 GMT+0800 (CST),\n  ctime: Mon Sep 07 2015 17:22:35 GMT+0800 (CST) }\n读取文件信息成功！\n是否为文件(isFile) ? true\n是否为目录(isDirectory) ? false\n```\n\n### 写入文件\n\n> - `fs.writeFile(file, data[, options], callback)`\n> - 打开方式默认w模式(文件存在写入内容会覆盖)\n> - **file** - 文件名或文件描述符。\n> - **data** - 要写入文件的数据，可以是 String(字符串) 或 Buffer(缓冲) 对象。\n> - **options** - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为 utf8, 模式为 0666 ， flag 为 'w'\n> - **callback** - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。\n\n```js\nvar fs = require(\"fs\");\n\nconsole.log(\"准备写入文件\");\nfs.writeFile('input.txt', '我是通 过fs.writeFile 写入文件的内容',  function(err) {\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"数据写入成功！\");\n   console.log(\"--------我是分割线-------------\")\n   console.log(\"读取写入的数据！\");\n   fs.readFile('input.txt', function (err, data) {\n      if (err) {\n         return console.error(err);\n      }\n      console.log(\"异步读取文件数据: \" + data.toString());\n   });\n});\n\n执行结果如下：\n\n$ node file.js \n准备写入文件\n数据写入成功！\n--------我是分割线-------------\n读取写入的数据！\n异步读取文件数据: 我是通 过fs.writeFile 写入文件的内容\n```\n\n### 读取文件\n\n> - ```js\n>   fs.read(fd, buffer, offset, length, position, callback)\n>   ```\n>\n> - **fd** - 通过 fs.open() 方法返回的文件描述符。\n>\n> - **buffer** - 数据写入的缓冲区。\n>\n> - **offset** - 缓冲区写入的写入偏移量。\n>\n> - **length** - 要从文件中读取的字节数。\n>\n> - **position** - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。\n>\n> - **callback** - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。\n\n```js\nvar fs = require(\"fs\");\nvar buf = new Buffer.alloc(1024);\n\nconsole.log(\"准备打开已存在的文件！\");\nfs.open('input.txt', 'r+', function(err, fd) {\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"文件打开成功！\");\n   console.log(\"准备读取文件：\");\n   fs.read(fd, buf, 0, buf.length, 0, function(err, bytes){\n      if (err){\n         console.log(err);\n      }\n      console.log(bytes + \"  字节被读取\");\n      \n      // 仅输出读取的字节\n      if(bytes > 0){\n         console.log(buf.slice(0, bytes).toString());\n      }\n   });\n});\n\n以上代码执行结果如下：\n\n$ node file.js \n准备打开已存在的文件！\n文件打开成功！\n准备读取文件：\n42  字节被读取\ngrh官网地址：www.runoob.com\n```\n\n### 关闭文件\n\n> ```\n> fs.close(fd, callback)\n> ```\n>\n> - **fd** - 通过 fs.open() 方法返回的文件描述符。\n> - **callback** - 回调函数，没有参数。\n\n```js\nvar fs = require(\"fs\");\nvar buf = new Buffer.alloc(1024);\n\nconsole.log(\"准备打开文件！\");\nfs.open('input.txt', 'r+', function(err, fd) {\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"文件打开成功！\");\n   console.log(\"准备读取文件！\");\n   fs.read(fd, buf, 0, buf.length, 0, function(err, bytes){\n      if (err){\n         console.log(err);\n      }\n\n      // 仅输出读取的字节\n      if(bytes > 0){\n         console.log(buf.slice(0, bytes).toString());\n      }\n\n      // 关闭文件\n      fs.close(fd, function(err){\n         if (err){\n            console.log(err);\n         } \n         console.log(\"文件关闭成功\");\n      });\n   });\n});\n\n以上代码执行结果如下：\n\n$ node file.js \n准备打开文件！\n文件打开成功！\n准备读取文件！\ngrh官网地址：www.runoob.com\n文件关闭成功\n```\n\n### 截取文件\n\n```\nfs.ftruncate(fd, len, callback)\n```\n\n参数使用说明如下：\n\n- **fd** - 通过 fs.open() 方法返回的文件描述符。\n- **len** - 文件内容截取的长度。\n- **callback** - 回调函数，没有参数。\n\ninput.txt 文件内容为：\n\n```\nsite:www.runoob.com\n```\n\n接下来我们创建 file.js 文件，代码如下所示：\n\n```js\nvar fs = require(\"fs\");\nvar buf = new Buffer.alloc(1024);\n\nconsole.log(\"准备打开文件！\");\nfs.open('input.txt', 'r+', function(err, fd) {\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"文件打开成功！\");\n   console.log(\"截取10字节内的文件内容，超出部分将被去除。\");\n   \n   // 截取文件\n   fs.ftruncate(fd, 10, function(err){\n      if (err){\n         console.log(err);\n      } \n      console.log(\"文件截取成功。\");\n      console.log(\"读取相同的文件\"); \n      fs.read(fd, buf, 0, buf.length, 0, function(err, bytes){\n         if (err){\n            console.log(err);\n         }\n\n         // 仅输出读取的字节\n         if(bytes > 0){\n            console.log(buf.slice(0, bytes).toString());\n         }\n\n         // 关闭文件\n         fs.close(fd, function(err){\n            if (err){\n               console.log(err);\n            } \n            console.log(\"文件关闭成功！\");\n         });\n      });\n   });\n});\n```\n\n以上代码执行结果如下：\n\n```js\n$ node file.js \n准备打开文件！\n文件打开成功！\n截取10字节内的文件内容，超出部分将被去除。\n文件截取成功。\n读取相同的文件\nsite:www.r\n文件关闭成功\n```\n\n### 删除文件\n\n```\nfs.unlink(path, callback)\n```\n\n参数使用说明如下：\n\n- **path** - 文件路径。\n- **callback** - 回调函数，没有参数。\n\ninput.txt 文件内容为：\n\n```\nsite:www.runoob.com\n```\n\n接下来我们创建 file.js 文件，代码如下所示：\n\n```js\nvar fs = require(\"fs\");\n\nconsole.log(\"准备删除文件！\");\nfs.unlink('input.txt', function(err) {\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"文件删除成功！\");\n});\n```\n\n以上代码执行结果如下：\n\n```\n$ node file.js \n准备删除文件！\n文件删除成功！\n```\n\n### 创建目录\n\n```\nfs.mkdir(path[, options], callback)\n```\n\n参数使用说明如下：\n\n- **path** - 文件路径。\n- options 参数可以是：\n  - **recursive** - 是否以递归的方式创建目录，默认为 false。\n  - **mode** - 设置目录权限，默认为 0777。\n- **callback** - 回调函数，没有参数。\n\n接下来我们创建 file.js 文件，代码如下所示：\n\n```\nvar fs = require(\"fs\");\n// tmp 目录必须存在\nconsole.log(\"创建目录 /tmp/test/\");\nfs.mkdir(\"/tmp/test/\",function(err){\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"目录创建成功。\");\n});\n```\n\n以上代码执行结果如下：\n\n```\n$ node file.js \n创建目录 /tmp/test/\n目录创建成功。\n```\n\n可以添加 recursive: true 参数，不管创建的目录 /tmp 和 /tmp/a 是否存在：\n\n```\nfs.mkdir('/tmp/a/apple', { recursive: true }, (err) => {\n  if (err) throw err;\n});\n```\n\n------\n\n### 读取目录\n\n```\nfs.readdir(path, callback)\n```\n\n参数使用说明如下：\n\n- **path** - 文件路径。\n- **callback** - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。\n\n接下来我们创建 file.js 文件，代码如下所示：\n\n```js\nvar fs = require(\"fs\");\n\nconsole.log(\"查看 /tmp 目录\");\nfs.readdir(\"/tmp/\",function(err, files){\n   if (err) {\n       return console.error(err);\n   }\n   files.forEach( function (file){\n       console.log( file );\n   });\n});\n```\n\n以上代码执行结果如下：\n\n```js\n$ node file.js \n查看 /tmp 目录\ninput.out\noutput.out\ntest\ntest.txt\n```\n\n### 读取目录\n\n```\nfs.readdir(path, callback)\n```\n\n- **path** - 文件路径。\n- **callback** - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。\n\n接下来我们创建 file.js 文件，代码如下所示：\n\n```\nvar fs = require(\"fs\");\n\nconsole.log(\"查看 /tmp 目录\");\nfs.readdir(\"/tmp/\",function(err, files){\n   if (err) {\n       return console.error(err);\n   }\n   files.forEach( function (file){\n       console.log( file );\n   });\n});\n```\n\n以上代码执行结果如下：\n\n```\n$ node file.js \n查看 /tmp 目录\ninput.out\noutput.out\ntest\ntest.txt\n```\n\n### 删除目录\n\n> - fs.rmdir(path, callback)\n>\n> - path - 文件路径。\n>\n> - callback - 回调函数，没有参数。\n\n```js\nvar fs = require(\"fs\");\n// 执行前创建一个空的 /tmp/test 目录\nconsole.log(\"准备删除目录 /tmp/test\");\nfs.rmdir(\"/tmp/test\",function(err){\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"读取 /tmp 目录\");\n   fs.readdir(\"/tmp/\",function(err, files){\n      if (err) {\n          return console.error(err);\n      }\n      files.forEach( function (file){\n          console.log( file );\n      });\n   });\n});\n以上代码执行结果如下：\n\n$ node file.js \n准备删除目录 /tmp/test\n读取 /tmp 目录\n……\n```\n\n### 文件模块方法参考手册\n\n| 序号 | 方法 & 描述                                                                                                                                                              |\n| :--- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 1    | **fs.rename(oldPath, newPath, callback)** 异步 rename().回调函数没有参数，但可能抛出异常。                                                                               |\n| 2    | **fs.ftruncate(fd, len, callback)** 异步 ftruncate().回调函数没有参数，但可能抛出异常。                                                                                  |\n| 3    | **fs.ftruncateSync(fd, len)** 同步 ftruncate()                                                                                                                           |\n| 4    | **fs.truncate(path, len, callback)** 异步 truncate().回调函数没有参数，但可能抛出异常。                                                                                  |\n| 5    | **fs.truncateSync(path, len)** 同步 truncate()                                                                                                                           |\n| 6    | **fs.chown(path, uid, gid, callback)** 异步 chown().回调函数没有参数，但可能抛出异常。                                                                                   |\n| 7    | **fs.chownSync(path, uid, gid)** 同步 chown()                                                                                                                            |\n| 8    | **fs.fchown(fd, uid, gid, callback)** 异步 fchown().回调函数没有参数，但可能抛出异常。                                                                                   |\n| 9    | **fs.fchownSync(fd, uid, gid)** 同步 fchown()                                                                                                                            |\n| 10   | **fs.lchown(path, uid, gid, callback)** 异步 lchown().回调函数没有参数，但可能抛出异常。                                                                                 |\n| 11   | **fs.lchownSync(path, uid, gid)** 同步 lchown()                                                                                                                          |\n| 12   | **fs.chmod(path, mode, callback)** 异步 chmod().回调函数没有参数，但可能抛出异常。                                                                                       |\n| 13   | **fs.chmodSync(path, mode)** 同步 chmod().                                                                                                                               |\n| 14   | **fs.fchmod(fd, mode, callback)** 异步 fchmod().回调函数没有参数，但可能抛出异常。                                                                                       |\n| 15   | **fs.fchmodSync(fd, mode)** 同步 fchmod().                                                                                                                               |\n| 16   | **fs.lchmod(path, mode, callback)** 异步 lchmod().回调函数没有参数，但可能抛出异常。Only available on Mac OS X.                                                          |\n| 17   | **fs.lchmodSync(path, mode)** 同步 lchmod().                                                                                                                             |\n| 18   | **fs.stat(path, callback)** 异步 stat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。                                                                         |\n| 19   | **fs.lstat(path, callback)** 异步 lstat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。                                                                       |\n| 20   | **fs.fstat(fd, callback)** 异步 fstat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。                                                                         |\n| 21   | **fs.statSync(path)** 同步 stat(). 返回 fs.Stats 的实例。                                                                                                                |\n| 22   | **fs.lstatSync(path)** 同步 lstat(). 返回 fs.Stats 的实例。                                                                                                              |\n| 23   | **fs.fstatSync(fd)** 同步 fstat(). 返回 fs.Stats 的实例。                                                                                                                |\n| 24   | **fs.link(srcpath, dstpath, callback)** 异步 link().回调函数没有参数，但可能抛出异常。                                                                                   |\n| 25   | **fs.linkSync(srcpath, dstpath)** 同步 link().                                                                                                                           |\n| 26   | **fs.symlink(srcpath, dstpath[, type], callback)** 异步 symlink().回调函数没有参数，但可能抛出异常。 type 参数可以设置为 'dir', 'file', 或 'junction' (默认为 'file') 。 |\n| 27   | **fs.symlinkSync(srcpath, dstpath[, type])** 同步 symlink().                                                                                                             |\n| 28   | **fs.readlink(path, callback)** 异步 readlink(). 回调函数有两个参数 err, linkString。                                                                                    |\n| 29   | **fs.realpath(path[, cache], callback)** 异步 realpath(). 回调函数有两个参数 err, resolvedPath。                                                                         |\n| 30   | **fs.realpathSync(path[, cache])** 同步 realpath()。返回绝对路径。                                                                                                       |\n| 31   | **fs.unlink(path, callback)** 异步 unlink().回调函数没有参数，但可能抛出异常。                                                                                           |\n| 32   | **fs.unlinkSync(path)** 同步 unlink().                                                                                                                                   |\n| 33   | **fs.rmdir(path, callback)** 异步 rmdir().回调函数没有参数，但可能抛出异常。                                                                                             |\n| 34   | **fs.rmdirSync(path)** 同步 rmdir().                                                                                                                                     |\n| 35   | **fs.mkdir(path[, mode], callback)** S异步 mkdir(2).回调函数没有参数，但可能抛出异常。 访问权限默认为 0777。                                                             |\n| 36   | **fs.mkdirSync(path[, mode])** 同步 mkdir().                                                                                                                             |\n| 37   | **fs.readdir(path, callback)** 异步 readdir(3). 读取目录的内容。                                                                                                         |\n| 38   | **fs.readdirSync(path)** 同步 readdir().返回文件数组列表。                                                                                                               |\n| 39   | **fs.close(fd, callback)** 异步 close().回调函数没有参数，但可能抛出异常。                                                                                               |\n| 40   | **fs.closeSync(fd)** 同步 close().                                                                                                                                       |\n| 41   | **fs.open(path, flags[, mode], callback)** 异步打开文件。                                                                                                                |\n| 42   | **fs.openSync(path, flags[, mode])** 同步 version of fs.open().                                                                                                          |\n| 43   | **fs.utimes(path, atime, mtime, callback)**                                                                                                                              |\n| 44   | **fs.utimesSync(path, atime, mtime)** 修改文件时间戳，文件通过指定的文件路径。                                                                                           |\n| 45   | **fs.futimes(fd, atime, mtime, callback)**                                                                                                                               |\n| 46   | **fs.futimesSync(fd, atime, mtime)** 修改文件时间戳，通过文件描述符指定。                                                                                                |\n| 47   | **fs.fsync(fd, callback)** 异步 fsync.回调函数没有参数，但可能抛出异常。                                                                                                 |\n| 48   | **fs.fsyncSync(fd)** 同步 fsync.                                                                                                                                         |\n| 49   | **fs.write(fd, buffer, offset, length[, position], callback)** 将缓冲区内容写入到通过文件描述符指定的文件。                                                              |\n| 50   | **fs.write(fd, data[, position[, encoding]], callback)** 通过文件描述符 fd 写入文件内容。                                                                                |\n| 51   | **fs.writeSync(fd, buffer, offset, length[, position])** 同步版的 fs.write()。                                                                                           |\n| 52   | **fs.writeSync(fd, data[, position[, encoding]])** 同步版的 fs.write().                                                                                                  |\n| 53   | **fs.read(fd, buffer, offset, length, position, callback)** 通过文件描述符 fd 读取文件内容。                                                                             |\n| 54   | **fs.readSync(fd, buffer, offset, length, position)** 同步版的 fs.read.                                                                                                  |\n| 55   | **fs.readFile(filename[, options], callback)** 异步读取文件内容。                                                                                                        |\n| 56   | **fs.readFileSync(filename[, options])**                                                                                                                                 |\n| 57   | **fs.writeFile(filename, data[, options], callback)** 异步写入文件内容。                                                                                                 |\n| 58   | **fs.writeFileSync(filename, data[, options])** 同步版的 fs.writeFile。                                                                                                  |\n| 59   | **fs.appendFile(filename, data[, options], callback)** 异步追加文件内容。                                                                                                |\n| 60   | **fs.appendFileSync(filename, data[, options])** The 同步 version of fs.appendFile.                                                                                      |\n| 61   | **fs.watchFile(filename[, options], listener)** 查看文件的修改。                                                                                                         |\n| 62   | **fs.unwatchFile(filename[, listener])** 停止查看 filename 的修改。                                                                                                      |\n| 63   | **`fs.watch(filename[, options][, listener])`** 查看 filename 的修改，filename 可以是文件或目录。返回 fs.FSWatcher 对象。                                                  |\n| 64   | **fs.exists(path, callback)** 检测给定的路径是否存在。                                                                                                                   |\n| 65   | **fs.existsSync(path)** 同步版的 fs.exists.                                                                                                                              |\n| 66   | **fs.access(path[, mode], callback)** 测试指定路径用户权限。                                                                                                             |\n| 67   | **fs.accessSync(path[, mode])** 同步版的 fs.access。                                                                                                                     |\n| 68   | **fs.createReadStream(path[, options])** 返回ReadStream 对象。                                                                                                           |\n| 69   | **fs.createWriteStream(path[, options])** 返回 WriteStream 对象。                                                                                                        |\n| 70   | **fs.symlink(srcpath, dstpath[, type], callback)** 异步 symlink().回调函数没有参数，但可能抛出异常。                                                                     |\n\n## GET/POST请求\n\n### 获取GET请求内容\n\n```js\nvar http = require('http');\nvar url = require('url');\nvar util = require('util');\n \nhttp.createServer(function(req, res){\n    res.writeHead(200, {'Content-Type': 'text/plain; charset=utf-8'});\n    res.end(util.inspect(url.parse(req.url, true)));\n}).listen(3000);\n\n//获取url参数\nhttp.createServer(function(req, res){\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n \n    // 解析 url 参数\n    var params = url.parse(req.url, true).query;\n    res.write(\"网站名：\" + params.name);\n    res.write(\"\\n\");\n    res.write(\"网站 URL：\" + params.url);\n    res.end();\n\n}).listen(3000);\n```\n\n<img src=\"https://images.gitee.com/uploads/images/2020/0602/182627_1b8e7ecd_6545143.png\" style=\"zoom:67%;\" />\n\n### 获取post请求内容\n\n```js\nvar http = require('http');\nvar querystring = require('querystring');\nvar util = require('util');\n \nhttp.createServer(function(req, res){\n    // 定义了一个post变量，用于暂存请求体的信息\n    var post = '';     \n \n    // 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中\n    req.on('data', function(chunk){    \n        post += chunk;\n    });\n \n    // 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。\n    req.on('end', function(){    \n        post = querystring.parse(post);\n        res.end(util.inspect(post));\n    });\n```\n\n```js\nvar http = require('http');\nvar querystring = require('querystring');\n \nvar postHTML = \n  '<html><head><meta charset=\"utf-8\"><title>grh Node.js 实例</title></head>' +\n  '<body>' +\n  '<form method=\"post\">' +\n  '网站名： <input name=\"name\"><br>' +\n  '网站 URL： <input name=\"url\"><br>' +\n  '<input type=\"submit\">' +\n  '</form>' +\n  '</body></html>';\n \nhttp.createServer(function (req, res) {\n  var body = \"\";\n  req.on('data', function (chunk) {\n    body += chunk;\n  });\n  req.on('end', function () {\n    // 解析参数\n    body = querystring.parse(body);\n    // 设置响应头部信息及编码\n    res.writeHead(200, {'Content-Type': 'text/html; charset=utf8'});\n \n    if(body.name && body.url) { // 输出提交的数据\n        res.write(\"网站名：\" + body.name);\n        res.write(\"<br>\");\n        res.write(\"网站 URL：\" + body.url);\n    } else {  // 输出表单\n        res.write(postHTML);\n    }\n    res.end();\n  });\n}).listen(3000);\n```\n","children":[]},{"name":"node-demo.md","path":"../guanruihua.github.io/Front-End/Node/基础","data":"# express\n\n## 简单使用\n\n`npm i`\n\nnpm i express\n\n`npm i nodemon`\n\n```js\n//server.js\nvar express = require('express');\nvar app = express();\n\napp.get('/',function(req, res){\n    res.send('this is the homepage');\n})\n\napp.listen(3000);\n```\n\n运行 `nodemon server.js`\n\n浏览器打开`http://localhost:3000/`\n\n## id的使用\n\n```js\nvar express = require('express');\nvar app = express();\napp.get('/user/:id/and/:name',function(req,res){\n    console.log(req.params);\n    res.send(req.params.id+\"  \"+req.params.name);\n  //可以输出id和name的值\n})\napp.listen(3000);\n```\n\n## url中使用正则\n\n```js\nvar express = require('express');\nvar app = express();\n//这里的?就是正则表达式\napp.get('/user/ab?cd',function(req,res){\n    console.log(req.params);\n    res.send(\"匹配成功\");\n})\napp.listen(3000);\n//输入http://localhost:3000/acd也可以匹配成功\n```\n\n## 查询字符串\n\n```js\n//server.js\nvar express = require('express');\nvar app = express();\n\napp.get('/',function(req, res){\n   console.log(req.query);\n    res.send('this is a epage'+ req.query.user);\n   //req.query.user可以拿到值\n})\napp.listen(3000);\n```\n\n> `http://localhost:3000/?user=grh` req.query可以返回{user:'grh'}\n\n## 使用body-parser中间件\n\n> `npm install body-parser --save`\n>\n> [官网](https://www.expressjs.com.cn/en/resources/middleware/body-parser.html)\n\n### Express/Connect top-level generic\n\n> 这个示例演示了添加一个通用的JSON和URL编码的解析器作为顶级中间件，它将解析所有传入请求的主体。 这是最简单的设置。\n\n```javascript\nvar express = require('express')\nvar bodyParser = require('body-parser')\n\nvar app = express()\n\n// parse application/x-www-form-urlencoded\napp.use(bodyParser.urlencoded({ extended: false }))\n\n// parse application/json\napp.use(bodyParser.json())\n\napp.use(function (req, res) {\n  res.setHeader('Content-Type', 'text/plain')\n  res.write('you posted:\\n')\n  res.end(JSON.stringify(req.body, null, 2))\n})\n```\n\n### Express route-specific\n\n> 此示例演示了将主体解析器专门添加到需要它们的路由。通常，这是与Express结合使用body解析器的最推荐方法。\n\n```javascript\nvar express = require('express')\nvar bodyParser = require('body-parser')\n\nvar app = express()\n\n// create application/json parser\nvar jsonParser = bodyParser.json()\n\n// create application/x-www-form-urlencoded parser\nvar urlencodedParser = bodyParser.urlencoded({ extended: false })\n\n// POST /login gets urlencoded bodies\napp.post('/login', urlencodedParser, function (req, res) {\n  res.send('welcome, ' + req.body.username)\n})\n\n// POST /api/users gets JSON bodies\napp.post('/api/users', jsonParser, function (req, res) {\n  // create user in req.body\n})\n```\n\n### Change accepted type for parsers\n\n> 所有解析器都接受一个“类型”选项，该选项允许您更改中间件将解析的“内容类型”。\n\n```javascript\nvar express = require('express')\nvar bodyParser = require('body-parser')\n\nvar app = express()\n\n// parse various different custom JSON types as JSON\napp.use(bodyParser.json({ type: 'application/*+json' }))\n\n// parse some custom thing into a Buffer\napp.use(bodyParser.raw({ type: 'application/vnd.custom-type' }))\n\n// parse an HTML body into a string\napp.use(bodyParser.text({ type: 'text/html' }))\n```\n\n## HTML 5 `<form>` enctype 属性\n\n| 值                                | 描述                                                         |\n| :-------------------------------- | :----------------------------------------------------------- |\n| application/x-www-form-urlencoded | 在发送前对所有字符进行编码（默认）。                         |\n| multipart/form-data               | 不对字符编码。当使用有==文件上传==控件的表单时，该值是必需的。 |\n| text/plain                        | 将空格转换为 \"+\" 符号，但不编码特殊字符。                    |\n\n## req.params,req.query,req.body的差别\n\n|                   | 对应的url                              |\n| ----------------- | -------------------------------------- |\n| `req.params`      | `http://localhost:3000/10`             |\n| `req.query[\"id\"]` | `http://localhost:3000/?id=10`         |\n| `req.body.id`     | `http://localhost:3000`一般不在url显示 |\n\n## 上传文件使用multer\n\nMulter 是一个 node.js 中间件，用于处理 `multipart/form-data` 类型的表单数据，它主要用于上传文件。它是写在 [busboy](https://github.com/mscdex/busboy) 之上非常高效。\n\n**注意**: Multer 不会处理任何非 `multipart/form-data` 类型的表单数据。\n\nserver.js\n\n```javascript\nvar express = require('express');\nvar app = express();\n\n//上传文件\napp.post('/form_file', upload.single('logo') , function(req,res,next){\n    // var form = fs.readFileSync('./form.html', { encoding: \"utf8\"});\n    // res.send(form);\n    console.log(req.file);\n    res.send({'ret_code': 0 });\n})\n\n// 通过http://localhost:3000/form 打开formhtml\napp.get('/form', function(req,res){\n    // 方法一\n    // var form = fs.readFileSync('./form.html', {encoding:\"utf8\"});\n    // res.send(form);\n    // 方法二\n    res.sendFile(__dirname + '/form.html');\n})\n\napp.listen(3000);\n```\n\nform.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Comptatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<body>\n   <!--这里的action填/form_file也是可以的-->\n    <form action=\"http://localhost:3000/form_file\" method=\"post\" enctype=\"multipart/form-data\">\n        <h2>单图上传</h2>\n        <input type=\"file\" name=\"logo\">\n        <input type=\"submit\" value=\"提交\">\n    </form>\n</body>\n</html>\n```\n\n## 使用模板引擎ejs\n\n### 安装`npm install ejs --save`\n\n```js\nvar express = require('express');\nvar app = express();\n\napp.set('view engine', 'ejs');\napp.get('/ejs/:name',function(req,res){\n    var myname = req.params.name;\n  //这里也可以传输对象等数据类型\n    res.render('ejs_text',{pn: myname });\n})//这里的ejs_text是指向iview的文件\n\napp.listen(3000);\n```\n\nejs_text.ejs\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <h1>\n        <%= pn %>\n    </h1>\n</body>\n</html>\n```\n\n> 通过`localhost:3000/ejs/grh`访问\n\n## 中间件\n\nserver.js\n\n```javaScript\nvar express = require('express');\nvar app = express();\n\napp.use(function(req, res, next){\n  console.log('first middleware');\n  next();//可以接着运行下一个\n})\n\napp.use(function(req, res, next){\n  console.log('second middleware');\n  res.send('ok');\n})\n\napp.listen(3000);\n```\n\n## Express托管静态文件\n\n`express.static(root, [options])`\n\n```javascript\napp.use(express.static('public'))\n```\n\n现在，你就可以访问 `public` 目录中的所有文件了：\n\n```plain-text\nhttp://localhost:3000/images/kitten.jpg\nhttp://localhost:3000/css/style.css\nhttp://localhost:3000/js/app.js\nhttp://localhost:3000/images/bg.png\nhttp://localhost:3000/hello.html\n```\n\n`app.use('/aset',express.static('public'))`\n\n通过`http://localhost:3000/aset/images/kitten.jpg`来访问\n\n## 路由中间件\n\n### 原server.js\n\n```javascript\nvar express = require('express')\nvar app = express();\napp.get('/home', function(req, res, next){\n  res.send('home');\n})\n\napp.get('/users', function(req, res, next){\n  res.send('users');\n})\n\napp.get('/', function(req, res, next){\n  res.send('root');\n})\napp.listen(3000);\n```\n\n### 使用路由中间件后\n\n> 1. 先新建routes文件夹\n>\n> 2. 然后再在这文件夹下,建立模块index.js,users,js\n> 3. 再在server.js引入这两个路由\n\nindex.js\n\n```javascript\nvar express = require('express');\nvar router =  express.Router();\nrouter.get('/', function(req, res, next){\n  res.send('root');\n})\n\nmodule.exports = router;\n```\n\nusers.js\n\n```javascript\nvar express = require('express');\nvar router =  express.Router();\nrouter.get('/', function(req, res, next){\n  res.send('users');\n})\n\nmodule.exports = router;\n```\n\nserver.js\n\n```javascript\nvar express =  require('express')\nvar app  = express();\nvar indexRouter = require('./routes/index')\nvar userRouter = require('./route/users')\n\napp.use('/', indexRouter);\napp.use('/users', usersRouter);\n\n\napp.listen(3000);\n```\n","children":[]},{"name":"node-expand.md","path":"../guanruihua.github.io/Front-End/Node/基础","data":"# node-expand\n\n## nodejs使用fetch\n\nnode 中没有实现 fetch，你可以使用 [node-fetch](https://github.com/bitinn/node-fetch)，使得在 node 中也可以使用 fetch.\n\n安装 node-fetch:\n\n```\nnpm install node-fetch\n```\n\n使用 fetch 之前先加载：\n\n```\nconst fetch = require('node-fetch')\n```\n\n简单使用方法：\n\n```\nfetch('https://api.github.com/users/github')\n    .then(res => res.json())\n    .then(json => console.log(json));\n```\n\n关于 fetch 的使用介绍 <https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch>\n\n## Nodemon自动重启项目\n\n1. 安装：`npm install -g nodemon`\n2. 使用`nodemon`运行项目，取代之前的`node app.js`。\n\n```\nnodemon  [your app.js]\n```\n\n项目运行之后，`nodemon`会自动监听代码的改动，并且重新启动服务，大大增加我们开发效率。\n\n1. `nodemon`常见配置\n\n- 在命令行指定应用的端口号：`nodemon ./server.js localhost 8080`\n- 查看帮助，帮助里面有很多选项都是一目了然：`nodemon -h 或者 nodemon --help`\n- 运行 debug 模式：`nodemon --debug ./server.js 80`\n- 手动重启项目： `Nodemon` 命令运行的终端 窗口中输入 `rs` 两个字符，然后再按下回车键，就能手动重启 `Nodemon`了。\n\n## 爬虫\n\n### 1.爬虫介绍\n\n通过模拟浏览器的请求，服务器就会根据我们的请求返回我们想要的数据，将数据解析出来，并且进行保存。\n\n### 2.爬虫流程\n\n#### 1-目标：确定你想要获取的数据\n\n1. 确定想要的数据在什么页面上（一般详细的数据会在详情页）\n2. 确定在哪些页面可以链接到这些页面（一般分类列表页面会有详情页的链接数据）\n3. 寻找页面之间和数据之间的规律\n\n#### 2-分析页面\n\n1. 获取数据的方式（正则，cherrio）\n2. 分析数据是通过ajax请求的数据，还是html里自带的数据\n3. 如果是通过AJAX请求的数据，那么需要获取ajax请求的链接，一般请求到的数据都为JSON格式数据，那么就会比较容易解析。\n4. 如何数据在HTML里面，那么就用cherrio通过选择器将内容选中\n\n#### 3-编写单个数据获取的案例\n\n1. 解析出分类页的链接地址\n2. 解析出列表页的链接地址\n3. 解析出详情页的链接地址\n4. 解析详情页里面想要获取的数据\n5. 将数据进行保存到本地或者是数据库\n\n#### 4-如果遇到阻碍进行反爬虫对抗\n\n1. User-Agent是否是正常浏览器的信息\n2. 将请求头设置成跟浏览器一样的内容\n3. 因为爬虫的爬取速度过快，会导致封号。1那么可以降低速度进行解决，2可以使用代理进行解决\n4. 如果设置需要凭证，那么可以采用无界浏览器真实模拟。\n\n### 2.请求数据的库\n\nrequest，axios：通过库，帮助我们快速实现HTTP请求包的打包\n\n```\nrequest.get('请求地址', {\n  '请求头字段': '请求头的value值'\n},(res)=>{处理返回的内容});\n```\n\naxios优势会更明显，前后端通杀，前后端调用的方式一致。\n\n```js\naxios.get('请求地址',参数对象).then(function (response) {\n    console.log(response);\n})\n```\n\naxios获取图片\n\n```js\naxios({\n  method:'get',\n  url:'http://bit.ly/2mTM3nY',\n  responseType:'stream'\n})\n.then(function(response) {\n  response.data.pipe(fs.createWriteStream('ada_lovelace.jpg'))\n});\n```\n\npuppeteer:完全模拟浏览器\n\n打开浏览器\n\n```js\nlet options = {\n    headless:true,//是否是无界面浏览器\n    slowMo:250,//调试时可以减慢操作速度\n    defaultViewport:{\n        width:1200,//设置视窗的宽高\n        height:800\n    },\n    timeout:3000，//默认超时3秒\n}\nlet browser =await puppeteer.launch(options);\n```\n\n打开新标签页\n\n```js\nlet page = await browser.newPage()\n```\n\n获取所有浏览器中的页面\n\n```js\nlet pages = await browser.pages()\n```\n\n关闭浏览器\n\n```js\nbrowser.close()\n```\n\n将页面跳转至\n\n```\nawait page.goto(url)\n```\n\n获取页面的对象,并进行操作\n\n```\nlet btn = await page.$(selector)\nlet input = await page.$(selector)\n//点击按钮\nbtn.click()\n//聚焦到输入框\ninput.forcus()\n```\n\n在页面上写入内容或者键盘按键\n\n```\nawait page.keyboard.type('Hello World!');\nawait page.keyboard.press('ArrowLeft');\nawait page.keyboard.down('Shift');\n```\n\n设置鼠标的移动\n\n```\nawait page.mouse.move(0, 0);\nawait page.mouse.down();\nawait page.mouse.move(0, 100);\nawait page.mouse.move(100, 100);\nawait page.mouse.move(100, 0);\nawait page.mouse.move(0, 0);\nawait page.mouse.up();\n```\n\n截获页面请求\n\n```\nawait page.setRequestInterception(true);\npage.on('request', request => {\n    request.url()//可以获取请求的网址，request，包含了所有的请求信息\n    if(你想要的条件){\n        request.continue()\n    }else{\n        request.abort([errorCode])\n    }\n});\n```\n\n获取浏览器的信息和内容\n\n```\npage.$eval(selector,(item)=>{return item})\npage.$$eval(selectors,(items)=>{return items})\n```\n\n## 静态服务器\n\n## 网络通信原理\n\n**1、协议及协议栈的基本概念**\n\n**1.1、什么是协议**\n\n协议是网络中计算机或设备之间进行通信的一系列规则的集合。常用协议有IP、TCP、HTTP、POP3、SMTP等。\n\n**1.2、什么是协议栈**\n\n在网络中，为了完成通信，必须使用多层上的多种协议。这些协议按照层次顺序组合在一起，构成了协议栈(Protocol Stack)，也称为协议族(Protocol Suite)。\n\n**1.3、协议的作用**\n\n一个网络协议的作用主要有两个：一是建立对等层之间的虚拟通信，二是实现层次之间的无关性。\n\n**1.4、层次间的无关性**\n\n所谓层次间无关性，就是指较高层次和相邻的相低层次进行通信时，只是利用较低层次提供的接口和服务，而不需了解底层实现该功能所采用的算法和协议的细节；较低层次也仅是使用从高层系统传送来的参数和控制信息，这就是层次间的无关性。\n\n**2、网络协议族/栈组成**\n\n网络通信协议的作用是负责在网络上建立通信通道和控制通过通道的信息流的规则。为了进行网络通信，通信双方必须遵守通信协议\n\n<img src=\"https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=482594737,1881689515&amp;fm=173&amp;app=49&amp;f=JPEG?w=640&amp;h=506&amp;s=5986BE1A490E44CA5A4104EB03005032\" alt=\"img\" style=\"zoom:50%;\" />\n\n说明：网络协议与标准是基于OSI七层模型，每一层都有其对应的协议。\n\n**3、常见的网络协议**\n\nTCP/IP：工业标准、开放式协议，Internet网络的标准\n\nIPX/SPX：Novell开发的Netware操作系统使用的协议，IPX为网际数据包交换协议，工作在网络层，SPX为序列数据包交换协议，工作在传输层。\n\nNetBIOS/NetBEUI：较小的协议栈，应用于IBM和早期的Windows系统，现在Windows仍然支持。\n\nAppleTalk：Apple公司的Mac OS中所采用的网络协议。\n\n**（1）TCP/IP协议**\n\nTCP/IP是分层协议，如层次图所示：从底层到应用层，分别是物理层，链路层，网络层，传输层，应用层。数据是层层封装，封装的方式一般都是在原有数据的前面加一个数据控制头。\n\n![img](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2298966842,1075106660&fm=173&app=49&f=JPEG?w=640&h=388&s=C018C53889DF40C85EED91460300A0F1)\n\n**（2）Telnet协议**\n\nTelnet是TCP/IP中的一种应用协议，可以为终端仿真提供支持。可使用户连接到主机上，使主机响应起来就像它直接连接在终端上一样。Telnet在发送端和接收端使用TCP的23号端口以进行专用的通信。\n\nIPV4\n\nIP:1.1.1.1   ---   255.255.255.255  \n\nIPV6\n\n10亿  10亿 10亿 10亿\n\n**（3）FTP协议**\n\nFTP协议使用TCP20号和21号端口，20号端口用于数据交换，21号端口用于建立连接，允许目录和文件访问，上传下载，不能远程执行文件。\n\nTFTP是简单文件传输协议（Trivial File Transfer Protocol，TFTP），TFTP是无连接的，使用UDP的69号端口，用于当数据传输错误无关紧要而且无须安全性时的小型文件的传输。\n\n**（4）SMTP协议**\n\nSMTP是简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）是为网络系统间的电子邮件交换而设计的。使用 25 端口。SMTP只需要在接收端的一个电子邮件地址即可发送邮件。POP3 协议用来接收邮件.使用110端口\n\n**（5）DNS服务**\n\nDNS是域名解析服务（Domain Name Service, DNS），作用是将域名转换为IP地址，或将IP地址转换为域名，用于解析完全合格域名（FQDN）。使用53号端口。\n\n**（6）DHCP服务**\n\nDHCP是动态主机配置协议(DHCP)，服务器可以提供的信息有:\n\n1、IP地址\n\n2、子网掩码(subnet mask)\n\n3、域名(domain name)\n\n4、默认网关(default gateway)\n\n5、DNS\n\n## HTTP协议\n\nHTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。\n\nHTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。\n\nHTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。\n\nHTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。\n\n### HTTP协议的主要特点\n\n1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。\n\n2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。\n\n3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n\n4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 5、支持B/S及C/S模式\n\n### HTTP协议与URL的关系\n\nHTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息。\n\nURL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：\n\n```\nhttp://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name\n```\n\n##### 从上面的URL可以看出，一个完整的URL包括以下几部分\n\n1.协议部分：该URL的协议部分为“http”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在\"HTTP\"后面的“//”为分隔符。\n\n2.域名部分：该URL的域名部分为“[www.aspxfans.com](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.aspxfans.com)”。一个URL中，也可以使用IP地址作为域名使用。\n\n3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口。\n\n4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”。\n\n5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名。\n\n6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分。\n\n7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。\n\n\\#\n\n### URI和URL的区别\n\n##### URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源\n\nWeb上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的 URI一般由三部组成： ①访问资源的命名机制 ②存放资源的主机名 ③资源自身的名称，由路径表示，着重强调于资源。\n\n##### URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源\n\nURL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。 采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成： ①协议(或称为服务方式) ②存有该资源的主机IP地址(有时也包括端口号) ③主机资源的具体地址。如目录和文件名等\n\n##### URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如[mailto:java-net@java.sun.com](https://links.jianshu.com/go?to=mailto%3Ajava-net%40java.sun.com)\n\nURI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。\n\n在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。 在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。 相反的是，URL类可以打开一个到达资源的流。\n\n> HTTP之请求消息Request\n\n客户端发送一个HTTP请求到服务器的请求消息包括以下格式：\n\n##### 请求行（request line）、请求头部（header）、空行和请求数据四个部分组成\n\n![img](https:////upload-images.jianshu.io/upload_images/2964446-fdfb1a8fce8de946.png?imageMogr2/auto-orient/strip|imageView2/2/w/466/format/webp)\n\nimage\n\n- 请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。\n\n##### Get请求例子，使用Charles抓取的request\n\n\\#\n\n```\nGET /562f25980001b1b106000338.jpg HTTP/1.1\nHost    img.mukewang.com\nUser-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36\nAccept    image/webp,image/*,*/*;q=0.8\nReferer    http://www.imooc.com/\nAccept-Encoding    gzip, deflate, sdch\nAccept-Language    zh-CN,zh;q=0.8\n```\n\n##### 第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本\n\nGET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。\n\n##### 第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息\n\n从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等\n\n##### 第三部分：空行，请求头部后面的空行是必须的\n\n即使第四部分的请求数据为空，也必须有空行。\n\n##### 第四部分：请求数据也叫主体，可以添加任意的其他数据\n\n这个例子的请求数据为空。\n\n##### POST请求例子，使用Charles抓取的request\n\n\\#\n\n```\nPOST / HTTP1.1\nHost:www.wrox.com\nUser-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)\nContent-Type:application/x-www-form-urlencoded\nContent-Length:40\nConnection: Keep-Alive\n\nname=Professional%20Ajax&publisher=Wiley\n```\n\n第一部分：请求行，第一行明了是post请求，以及http1.1版本。 第二部分：请求头部，第二行至第六行。 第三部分：空行，第七行的空行。 第四部分：请求数据，第八行。\n\n> HTTP之响应消息Response\n\n一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。\n\n##### HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文\n\n![img](https:////upload-images.jianshu.io/upload_images/2964446-1c4cab46f270d8ee.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/683/format/webp)\n\nimage\n\n##### 例子\n\n```\nHTTP/1.1 200 OK\nDate: Fri, 22 May 2009 06:07:21 GMT\nContent-Type: text/html; charset=UTF-8\n\n<html>\n      <head></head>\n      <body>\n            <!--body goes here-->\n      </body>\n</html>\n```\n\n##### 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成\n\n第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）\n\n##### 第二部分：消息报头，用来说明客户端要使用的一些附加信息\n\n第二行和第三行为消息报头， Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8\n\n##### 第三部分：空行，消息报头后面的空行是必须的\n\n##### 第四部分：响应正文，服务器返回给客户端的文本信息\n\n空行后面的html部分为响应正文。\n\n> HTTP协议之状态码\n\n状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:\n\n###### 1xx：指示信息--表示请求已接收，继续处理\n\n###### 2xx：成功--表示请求已被成功接收、理解、接受\n\n###### 3xx：重定向--要完成请求必须进行更进一步的操作\n\n###### 4xx：客户端错误--请求有语法错误或请求无法实现\n\n###### 5xx：服务器端错误--服务器未能实现合法的请求\n\n常见状态码：\n\n200 OK                        //客户端请求成功\n\n400 Bad Request               //客户端请求有语法错误，不能被服务器所理解\n\n401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用\n\n403 Forbidden                 //服务器收到请求，但是拒绝提供服务\n\n404 Not Found                 //请求资源不存在，eg：输入了错误的URL\n\n500 Internal Server Error     //服务器发生不可预期的错误\n\n503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常\n\n### HTTP请求方法\n\n根据HTTP标准，HTTP请求可以使用多种请求方法。 HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\n\nGET     请求指定的页面信息，并返回实体主体。\n\nHEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头\n\nPOST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。\n\nPUT     从客户端向服务器传送的数据取代指定的文档的内容。\n\nDELETE      请求服务器删除指定的页面。\n\nCONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n\nOPTIONS     允许客户端查看服务器的性能。 TRACE     回显服务器收到的请求，主要用于测试或诊断。`\n\n> HTTP工作原理\n\nHTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。\n\n以下是 HTTP 请求/响应的步骤：\n\n###### 1、客户端连接到Web服务器\n\n一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，[http://www.oakcms.cn。](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.oakcms.cn.%2F)\n\n###### 2、发送HTTP请求\n\n通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。\n\n###### 3、服务器接受请求并返回HTTP响应\n\nWeb服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。\n\n###### 4、释放连接[TCP连接](https://www.jianshu.com/p/ef892323e68f)\n\n若connection 模式为close，则服务器主动关闭[TCP连接](https://www.jianshu.com/p/ef892323e68f)，客户端被动关闭连接，释放[TCP连接](https://www.jianshu.com/p/ef892323e68f);若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;\n\n###### 5、客户端浏览器解析HTML内容\n\n客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。\n\n例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：\n\n1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;\n\n2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立[TCP连接](https://www.jianshu.com/p/ef892323e68f);\n\n3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 [TCP 三次握手](https://www.jianshu.com/p/ef892323e68f)的第三个报文的数据发送给服务器;\n\n4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;\n\n5、释放 [TCP连接](https://www.jianshu.com/p/ef892323e68f);\n\n6、浏览器将该 html 文本并显示内容;\n\n> GET和POST请求的区别\n\n###### GET请求\n\n```\nGET /books/?sex=man&name=Professional HTTP/1.1 Host: www.wrox.com User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6) Gecko/20050225 Firefox/1.0.1 Connection: Keep-Alive\n```\n\n注意最后一行是空行\n\n###### POST请求\n\n```\n`POST / HTTP/1.1 Host: www.wrox.com User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6) Gecko/20050225 Firefox/1.0.1 Content-Type: application/x-www-form-urlencoded Content-Length: 40 Connection: Keep-Alive\n```\n\nname=Professional%20Ajax&publisher=Wiley`\n\n1、GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&连接；例 如：login.action?name=hyddd&password=idontknow&verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。\n\nPOST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据\n\n###### 因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变\n\n2、传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。\n\n而在实际开发中存在的限制主要有：\n\n**GET**:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。\n\n因此对于GET提交时，传输数据就会受到URL长度的 限制。\n\n**POST**:由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。\n\n3、安全性\n\nPOST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击\n\n4、Http get,post,soap协议都是在http上运行的\n\n（1）get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的 查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全\n\n（2）post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。 但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。\n\n（3）soap：是http post的一个专用版本，遵循一种特殊的xml消息格式 Content-type设置为: text/xml 任何数据都可以xml化。\n\nHttp协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.\n\n我们看看GET和POST的区别\n\n1. GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456. POST方法是把提交的数据放在HTTP包的Body中.\n2. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.\n3. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。\n4. GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.\n\n## 工具模块\n\n| 序号 | 模块名 & 描述                                                |\n| :--- | :----------------------------------------------------------- |\n| 1    | **OS 模块** 提供基本的系统操作函数。                         |\n| 2    | **Path 模块** 提供了处理和转换文件路径的工具。               |\n| 3    | **Net 模块** 用于底层的网络通信。提供了服务端和客户端的的操作。 |\n| 4    | **DNS 模块** 用于解析域名。                                  |\n| 5    | **Domain 模块** 简化异步代码的异常处理，可以捕捉处理try catch无法捕捉的。 |\n\n## web模块\n\n<img src=\"https://images.gitee.com/uploads/images/2020/0602/183736_ca5004eb_6545143.png\" style=\"zoom: 87%;\" />\n\n> - **Client** - 客户端，一般指浏览器，浏览器可以通过 HTTP 协议向服务器请求数据。\n> - **Server** - 服务端，一般指 Web 服务器，可以接收客户端请求，并向客户端发送响应数据。\n> - **Business** - 业务层， 通过 Web 服务器处理应用程序，如与数据库交互，逻辑运算，调用外部程序等。\n> - **Data** - 数据层，一般由数据库组成。\n\n### Node 创建 Web 服务器\n\nserver.js\n\n```js\nvar http = require('http');\nvar fs = require('fs');\nvar url = require('url');\n \n \n// 创建服务器\nhttp.createServer( function (request, response) {  \n   // 解析请求，包括文件名\n   var pathname = url.parse(request.url).pathname;\n   \n   // 输出请求的文件名\n   console.log(\"Request for \" + pathname + \" received.\");\n   \n   // 从文件系统中读取请求的文件内容\n   fs.readFile(pathname.substr(1), function (err, data) {\n      if (err) {\n         console.log(err);\n         // HTTP 状态码: 404 : NOT FOUND\n         // Content Type: text/html\n         response.writeHead(404, {'Content-Type': 'text/html'});\n      }else{             \n         // HTTP 状态码: 200 : OK\n         // Content Type: text/html\n         response.writeHead(200, {'Content-Type': 'text/html'});    \n         \n         // 响应文件内容\n         response.write(data.toString());        \n      }\n      //  发送响应数据\n      response.end();\n   });   \n}).listen(8080);\n \n// 控制台会输出以下信息\nconsole.log('Server running at http://127.0.0.1:8080/');\n```\n\nindex.html\n\n```js\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>grh(grh.com)</title>\n</head>\n<body>\n    <h1>我的第一个标题</h1>\n    <p>我的第一个段落。</p>\n</body>\n</html>\n```\n\n### Node创建Web客户端\n\nclient.js\n\n```js\nvar http = require('http');\n \n// 用于请求的选项\nvar options = {\n   host: 'localhost',\n   port: '8080',\n   path: '/index.html'  \n};\n \n// 处理响应的回调函数\nvar callback = function(response){\n   // 不断更新数据\n   var body = '';\n   response.on('data', function(data) {\n      body += data;\n   });\n   \n   response.on('end', function() {\n      // 数据接收完成\n      console.log(body);\n   });\n}\n// 向服务端发送请求\nvar req = http.request(options, callback);\nreq.end();\n```\n\n## Express框架\n\n> Express 框架核心特性：\n>\n> - 可以设置中间件来响应 HTTP 请求。\n> - 定义了路由表用于执行不同的 HTTP 请求动作。\n> - 可以通过向模板传递参数来动态渲染 HTML 页面。\n\n### 安装\n\n`$ npm install express --save`\n\n> 会安装到node_modules目录中\n\n几个重要的模块\n\n> - **body-parser** - node.js 中间件，用于处理 JSON, Raw, Text 和 URL 编码的数据。\n> - **cookie-parser** - 这就是一个解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象。\n> - **multer** - node.js 中间件，用于处理 enctype=\"multipart/form-data\"（设置表单的MIME编码）的表单数据。\n\n```\ncnpm install body-parser --save\ncnpm install cookie-parser --save\ncnpm install multer --save\n```\n\n### Express实例\n\n```js\n//express_demo.js 文件\nvar express = require('express');\nvar app = express();\n \napp.get('/', function (req, res) {\n   res.send('Hello World');\n})\n \nvar server = app.listen(8081, function () {\n \n  var host = server.address().address\n  var port = server.address().port\n \n  console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)\n \n})\n```\n\n```shell\n$ node express_demo.js \n应用实例，访问地址为 http://0.0.0.0:8081\n```\n\n### 请求和响应\n\n> Express 应用使用回调函数的参数： **request** 和 **response** 对象来处理请求和响应的数据。\n\n```js\napp.get('/', function (req, res) {\n   // --\n})\n```\n\n#### **Request 对象**\n\n> - request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有：\n>\n> 1. req.app：当callback为外部文件时，用req.app访问express的实例\n> 2. req.baseUrl：获取路由当前安装的URL路径\n> 3. req.body / req.cookies：获得「请求主体」/ Cookies\n> 4. req.fresh / req.stale：判断请求是否还「新鲜」\n> 5. req.hostname / req.ip：获取主机名和IP地址\n> 6. req.originalUrl：获取原始请求URL\n> 7. req.params：获取路由的parameters\n> 8. req.path：获取请求路径\n> 9. req.protocol：获取协议类型\n> 10. req.query：获取URL的查询参数串\n> 11. req.route：获取当前匹配的路由\n> 12. req.subdomains：获取子域名\n> 13. req.accepts()：检查可接受的请求的文档类型\n> 14. req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages：返回指定字符集的第一个可接受字符编码\n> 15. req.get()：获取指定的HTTP请求头\n> 16. req.is()：判断请求头Content-Type的MIME类型\n\n#### **Response 对象**\n\n> - response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有：\n>\n> 1. res.app：同req.app一样\n> 2. res.append()：追加指定HTTP头\n> 3. res.set()在res.append()后将重置之前设置的头\n> 4. res.cookie(name，value [，option])：设置Cookie\n> 5. opition: domain / expires / httpOnly / maxAge / path / secure / signed\n> 6. res.clearCookie()：清除Cookie\n> 7. res.download()：传送指定路径的文件\n> 8. res.get()：返回指定的HTTP头\n> 9. res.json()：传送JSON响应\n> 10. res.jsonp()：传送JSONP响应\n> 11. res.location()：只设置响应的Location HTTP头，不设置状态码或者close response\n> 12. res.redirect()：设置响应的Location HTTP头，并且设置状态码302\n> 13. res.render(view,[locals],callback)：渲染一个view，同时向callback传递渲染后的字符串，如果在渲染过程中有错误发生next(err)将会被自动调用。callback将会被传入一个可能发生的错误以及渲染后的页面，这样就不会自动输出了。\n> 14. res.send()：传送HTTP响应\n> 15. res.sendFile(path [，options] [，fn])：传送指定路径的文件 -会自动根据文件extension设定Content-Type\n> 16. res.set()：设置HTTP头，传入object可以一次设置多个头\n> 17. res.status()：设置HTTP状态码\n> 18. res.type()：设置Content-Type的MIME类型\n\n### 路由\n\n> 路由决定了由谁(指定脚本)去响应客户端请求。\n\n```js\nvar express = require('express');\nvar app = express();\n \n//  主页输出 \"Hello World\"\napp.get('/', function (req, res) {\n   console.log(\"主页 GET 请求\");\n   res.send('Hello GET');\n})\n \n \n//  POST 请求\napp.post('/', function (req, res) {\n   console.log(\"主页 POST 请求\");\n   res.send('Hello POST');\n})\n \n//  /del_user 页面响应\napp.get('/del_user', function (req, res) {\n   console.log(\"/del_user 响应 DELETE 请求\");\n   res.send('删除页面');\n})\n \n//  /list_user 页面 GET 请求\napp.get('/list_user', function (req, res) {\n   console.log(\"/list_user GET 请求\");\n   res.send('用户列表页面');\n})\n \n// 对页面 abcd, abxcd, ab123cd, 等响应 GET 请求\napp.get('/ab*cd', function(req, res) {   \n   console.log(\"/ab*cd GET 请求\");\n   res.send('正则匹配');\n})\n \n \nvar server = app.listen(8081, function () {\n \n  var host = server.address().address\n  var port = server.address().port\n \n  console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)\n \n})\n```\n\n### 静态文件\n\n> - Express 提供了内置的中间件 **express.static** 来设置静态文件如：图片， CSS, JavaScript 等。\n>\n> - 使用 **express.static** 中间件来设置静态文件路径。\n>   - 例如，如果你将图片， CSS, JavaScript 文件放在 public 目录下\n\n```js\nvar express = require('express');\nvar app = express();\n \napp.use('/public', express.static('public'));\n/*\nnode_modules\nserver.js\npublic/\npublic/images\npublic/images/logo.png\n*/\n \napp.get('/', function (req, res) {\n   res.send('Hello World');\n})\n \nvar server = app.listen(8081, function () {\n \n  var host = server.address().address\n  var port = server.address().port\n \n  console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)\n \n})\n```\n\n`http://127.0.0.1:8081/public/images/logo.png`可以访问到图片\n\n### 文件上传\n\n```js\n<html>\n<head>\n<title>文件上传表单</title>\n</head>\n<body>\n<h3>文件上传：</h3>\n选择一个文件上传: <br />\n<form action=\"/file_upload\" method=\"post\" enctype=\"multipart/form-data\">\n  <input type=\"file\" name=\"image\" size=\"50\" />\n  <br />\n  <input type=\"submit\" value=\"上传文件\" />\n</form>\n</body>\n</html>\n```\n\n```js\nvar express = require('express');\nvar app = express();\nvar fs = require(\"fs\");\n \nvar bodyParser = require('body-parser');\nvar multer  = require('multer');\n \napp.use('/public', express.static('public'));\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(multer({ dest: '/tmp/'}).array('image'));\n \napp.get('/index.html', function (req, res) {\n   res.sendFile( __dirname + \"/\" + \"index.html\" );\n})\n \napp.post('/file_upload', function (req, res) {\n \n   console.log(req.files[0]);  // 上传的文件信息\n  \n   var des_file = __dirname + \"/\" + req.files[0].originalname;\n   fs.readFile( req.files[0].path, function (err, data) {\n        fs.writeFile(des_file, data, function (err) {\n         if( err ){\n              console.log( err );\n         }else{\n               response = {\n                   message:'File uploaded successfully', \n                   filename:req.files[0].originalname\n              };\n          }\n          console.log( response );\n          res.end( JSON.stringify( response ) );\n       });\n   });\n})\n \nvar server = app.listen(8081, function () {\n \n  var host = server.address().address\n  var port = server.address().port\n \n  console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)\n \n})\n```\n\n### Cookie管理\n\n```js\n// express_cookie.js 文件\nvar express = require('express')\nvar cookieParser = require('cookie-parser')\nvar util = require('util');\n \nvar app = express()\napp.use(cookieParser())\n \napp.get('/', function(req, res) {\n    console.log(\"Cookies: \" + util.inspect(req.cookies));\n})\n \napp.listen(8081)\n```\n\n## 多进程\n\n> - node是单线程的模式运行的\n> - 使用事件驱动来处理并发,有助于我们在多核cpu的系统上创建多个子进程,从而太高性能\n> - 每个子进程有三个对象\n>   - child.stdin\n>   - child.stdout\n>   - child.stder\n>   - 可能会共享父进程的stdio流,或者是独立的被导流的流对象\n> - Node提供child_process模块来创建子进程\n>   - exec - child_process.exec 使用值进程执行命令,缓存子进程的输出,并将子进程的输出以回调函数参数的形式返回\n>   - spawn - child_process.spawn 使用指定命令参数创建新进程\n>   - fork - child_process.fork 是spawn()的特殊形式,用于在子进程的模块,如fork('./json.js') 相当于spawn('node',['./son.js'].\n>     - 和spwan()方法不同,fork会在父进程与子进程自己拿,建立一个通信管道,用于进程中之间的通信\n\n### exec() 方法\n\nchild_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。\n\n语法如下所示：\n\n```\nchild_process.exec(command[, options], callback)\n```\n\n#### 参数\n\n参数说明如下：\n\n**command：** 字符串， 将要运行的命令，参数使用空格隔开\n\n**options ：对象，可以是：**\n\n- cwd ，字符串，子进程的当前工作目录\n- env，对象 环境变量键值对\n- encoding ，字符串，字符编码（默认： 'utf8'）\n- shell ，字符串，将要执行命令的 Shell（默认: 在 UNIX 中为`/bin/sh`， 在 Windows 中为`cmd.exe`， Shell 应当能识别 `-c`开关在 UNIX 中，或 `/s /c` 在 Windows 中。 在Windows 中，命令行解析应当能兼容`cmd.exe`）\n- timeout，数字，超时时间（默认： 0）\n- maxBuffer，数字， 在 stdout 或 stderr 中允许存在的最大缓冲（二进制），如果超出那么子进程将会被杀死 （默认: 200*1024）\n- killSignal ，字符串，结束信号（默认：'SIGTERM'）\n- uid，数字，设置用户进程的 ID\n- gid，数字，设置进程组的 ID\n\n**callback ：**回调函数，包含三个参数error, stdout 和 stderr。\n\n**exec() 方法返回最大的缓冲区，并等待进程结束，一次性返回缓冲区的内容。**\n\n#### 实例\n\n#### support.js 文件代码\n\n`console.log(\"进程 \" + process.argv[2] + \" 执行。\" );`\n\n#### master.js 文件代码\n\n```js\nconst fs = require('fs');\nconst child_process = require('child_process');\n \nfor(var i=0; i<3; i++) {\n    var workerProcess = child_process.exec('node support.js '+i, function (error, stdout, stderr) {\n        if (error) {\n            console.log(error.stack);\n            console.log('Error code: '+error.code);\n            console.log('Signal received: '+error.signal);\n        }\n        console.log('stdout: ' + stdout);\n        console.log('stderr: ' + stderr);\n    });\n \n    workerProcess.on('exit', function (code) {\n        console.log('子进程已退出，退出码 '+code);\n    });\n}\n```\n\n执行以上代码，输出结果为：\n\n```\n$ node master.js \n子进程已退出，退出码 0\nstdout: 进程 1 执行。\n\nstderr: \n子进程已退出，退出码 0\nstdout: 进程 0 执行。\n\nstderr: \n子进程已退出，退出码 0\nstdout: 进程 2 执行。\n\nstderr: \n```\n\n### spawn()方法\n\nchild_process.spawn 使用指定的命令行参数创建新进程，语法格式如下：\n\n```\nchild_process.spawn(command[, args][, options])\n```\n\n参数说明如下：\n\n**command：** 将要运行的命令\n\n**args：** Array 字符串参数数组\n\n**options Object**\n\n- cwd String 子进程的当前工作目录\n- env Object 环境变量键值对\n- stdio Array|String 子进程的 stdio 配置\n- detached Boolean 这个子进程将会变成进程组的领导\n- uid Number 设置用户进程的 ID\n- gid Number 设置进程组的 ID\n\nspawn() 方法返回流 (stdout & stderr)，在进程返回大量数据时使用。进程一旦开始执行时 spawn() 就开始接收响应。\n\n#### 实例\n\n让我们创建两个 js 文件 support.js 和 master.js。\n\n#### support.js 文件代码\n\n`console.log(\"进程 \" + process.argv[2] + \" 执行。\" );`\n\n#### master.js 文件代码\n\n```js\nconst fs = require('fs');\nconst child_process = require('child_process');\n \nfor(var i=0; i<3; i++) {\n   var workerProcess = child_process.spawn('node', ['support.js', i]);\n \n   workerProcess.stdout.on('data', function (data) {\n      console.log('stdout: ' + data);\n   });\n \n   workerProcess.stderr.on('data', function (data) {\n      console.log('stderr: ' + data);\n   });\n \n   workerProcess.on('close', function (code) {\n      console.log('子进程已退出，退出码 '+code);\n   });\n}\n```\n\n执行以上代码，输出结果为：\n\n```\n$ node master.js stdout: 进程 0 执行。\n\n子进程已退出，退出码 0\nstdout: 进程 1 执行。\n\n子进程已退出，退出码 0\nstdout: 进程 2 执行。\n\n子进程已退出，退出码 0\n```\n\n### fork 方法\n\nchild_process.fork 是 spawn() 方法的特殊形式，用于创建进程，语法格式如下：\n\n```\nchild_process.fork(modulePath[, args][, options])\n```\n\n参数说明如下：\n\n**modulePath**： String，将要在子进程中运行的模块\n\n**args**： Array 字符串参数数组\n\n**options**：Object\n\n- cwd String 子进程的当前工作目录\n- env Object 环境变量键值对\n- execPath String 创建子进程的可执行文件\n- execArgv Array 子进程的可执行文件的字符串参数数组（默认： process.execArgv）\n- silent Boolean 如果为`true`，子进程的`stdin`，`stdout`和`stderr`将会被关联至父进程，否则，它们将会从父进程中继承。（默认为：`false`）\n- uid Number 设置用户进程的 ID\n- gid Number 设置进程组的 ID\n\n返回的对象除了拥有ChildProcess实例的所有方法，还有一个内建的通信信道。\n\n#### 实例\n\n让我们创建两个 js 文件 support.js 和 master.js。\n\n#### support.js 文件代码\n\n`console.log(\"进程 \" + process.argv[2] + \" 执行。\" );`\n\n#### master.js 文件代码\n\n```js\nconst fs = require('fs');\nconst child_process = require('child_process');\n \nfor(var i=0; i<3; i++) {\n   var worker_process = child_process.fork(\"support.js\", [i]);    \n \n   worker_process.on('close', function (code) {\n      console.log('子进程已退出，退出码 ' + code);\n   });\n}\n```\n\n执行以上代码，输出结果为：\n\n```\n$ node master.js \n进程 0 执行。\n子进程已退出，退出码 0\n进程 1 执行。\n子进程已退出，退出码 0\n进程 2 执行。\n子进程已退出，退出码 0\n```\n\n## Node 连接 mongoDB\n\n### 安装驱动\n\n```\ncnpm install mongodb\n```\n\n------\n\n### 创建数据库\n\n> 要在 MongoDB 中创建一个数据库，首先我们需要创建一个 MongoClient 对象，然后配置好指定的 URL 和 端口号。\n>\n> 如果数据库不存在，MongoDB 将创建数据库并建立连接。\n\n### 创建连接\n\n```js\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/grh\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n  if (err) throw err;\n  console.log(\"数据库已创建!\");\n  db.close();\n})\n```\n\n------\n\n### 创建集合\n\n我们可以使用 createCollection() 方法来创建集合：\n\n```js\nvar MongoClient = require('mongodb').MongoClient;\nvar url = 'mongodb://localhost:27017/grh';\nMongoClient.connect(url, { useNewUrlParser: true }, function (err, db) {\n    if (err) throw err;\n    console.log('数据库已创建');\n    var dbase = db.db(\"grh\");\n    dbase.createCollection('site', function (err, res) {\n        if (err) throw err;\n        console.log(\"创建集合!\");\n        db.close();\n    });\n});\n```\n\n------\n\n### 数据库操作( CURD )\n\n#### 插入一条数据insertOne()\n\n```js\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"grh\");\n    var myobj = { name: \"grh\", url: \"www.grh\" };\n    dbo.collection(\"site\").insertOne(myobj, function(err, res) {\n        if (err) throw err;\n        console.log(\"文档插入成功\");\n        db.close();\n    });\n});\n```\n\n执行以下命令输出就结果为：\n\n```\n$ node test.js\n文档插入成功\n```\n\n从输出结果来看，数据已插入成功。\n\n我们也可以打开 MongoDB 的客户端查看数据，如：\n\n```\n> show dbs\ngrh  0.000GB          # 自动创建了 grh 数据库\n> show tables\nsite                     # 自动创建了 site 集合（数据表）\n> db.site.find()\n{ \"_id\" : ObjectId(\"5a794e36763eb821b24db854\"), \"name\" : \"grh\", \"url\" : \"www.grh\" }\n> \n```\n\n#### 插入多条数据 **insertMany()**\n\n```js\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"grh\");\n    var myobj =  [\n        { name: '菜鸟工具', url: 'https://c.grh.com', type: 'cn'},\n        { name: 'Google', url: 'https://www.google.com', type: 'en'},\n        { name: 'Facebook', url: 'https://www.google.com', type: 'en'}\n       ];\n    dbo.collection(\"site\").insertMany(myobj, function(err, res) {\n        if (err) throw err;\n        console.log(\"插入的文档数量为: \" + res.insertedCount);\n        db.close();\n    });\n});\n```\n\nres.insertedCount 为插入的条数。\n\n#### 查询数据 find()\n\n```js\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"grh\");\n    dbo.collection(\"site\"). find({}).toArray(function(err, result) { // 返回集合中所有数据\n        if (err) throw err;\n        console.log(result);\n        db.close();\n    });\n});\n```\n\n#### 查询指定条件的数据\n\n> 以下实例检索 name 为 \"grh\" 的实例：\n\n```js\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"grh\");\n     var whereStr = {\"name\":'grh'};  // 查询条件\n    dbo.collection(\"site\").find(whereStr).toArray(function(err, result) {\n        if (err) throw err;\n        console.log(result);\n        db.close();\n    });\n});\n```\n\n执行以下命令输出就结果为：\n\n```json\n[ { _id: 5a794e36763eb821b24db854,\n    name: 'grh',\n    url: 'www.grh.com' } ]\n```\n\n#### 更新一条数据\n\n> 将 name 为 \"grh\" 的 url 改为`https://www.grh.com`：\n\n```js\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"grh\");\n    var whereStr = {\"name\":'grh'};  // 查询条件\n    var updateStr = {$set: { \"url\" : \"https://www.grh.com\" }};\n    dbo.collection(\"site\").updateOne(whereStr, updateStr, function(err, res) {\n        if (err) throw err;\n        console.log(\"文档更新成功\");\n        db.close();\n    });\n});\n```\n\n执行成功后，进入 mongo 管理工具查看数据已修改：\n\n```\n> db.site.find().pretty()\n{\n    \"_id\" : ObjectId(\"5a794e36763eb821b24db854\"),\n    \"name\" : \"grh\",\n    \"url\" : \"https://www.grh.com\"     // 已修改为 https\n}\n```\n\n如果要更新所有符合条的文档数据可以使用 **updateMany()**：\n\n#### 更新多条数据\n\n```js\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"grh\");\n    var whereStr = {\"type\":'en'};  // 查询条件\n    var updateStr = {$set: { \"url\" : \"https://www.grh.com\" }};\n    dbo.collection(\"site\").updateMany(whereStr, updateStr, function(err, res) {\n        if (err) throw err;\n         console.log(res.result.nModified + \" 条文档被更新\");\n        db.close();\n    });\n});\n```\n\nresult.nModified 为更新的条数。\n\n------\n\n#### 删除一条数据\n\n> 将 name 为 \"grh\" 的数据删除 :\n\n```js\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"grh\");\n    var whereStr = {\"name\":'grh'};  // 查询条件\n    dbo.collection(\"site\").deleteOne(whereStr, function(err, obj) {\n        if (err) throw err;\n        console.log(\"文档删除成功\");\n        db.close();\n    });\n});\n```\n\n执行成功后，进入 mongo 管理工具查看数据已删除：\n\n```\n> db.site.find()\n>\n```\n\n------\n\n#### 删除多条数据\n\n> 将 type 为 en 的所有数据删除 :\n>\n> 删除多条语句可以使用 **deleteMany()** 方法\n\n```js\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"grh\");\n    var whereStr = { type: \"en\" };  // 查询条件\n    dbo.collection(\"site\").deleteMany(whereStr, function(err, obj) {\n        if (err) throw err;\n        console.log(obj.result.n + \" 条文档被删除\");\n        db.close();\n    });\n});\n```\n\nobj.result.n 删除的条数。\n\n#### 排序\n\n排序 使用 sort() 方法，该方法接受一个参数，规定是升序(1)还是降序(-1)。\n\n```\n{ type: 1 }  // 按 type 字段升序\n{ type: -1 } // 按 type 字段降序\n```\n\n按 type 升序排列:\n\n```js\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"grh\");\n    var mysort = { type: 1 };\n    dbo.collection(\"site\").find().sort(mysort).toArray(function(err, result) {\n        if (err) throw err;\n        console.log(result);\n        db.close();\n    });\n});\n```\n\n#### 查询分页\n\n如果要设置指定的返回条数可以使用 **limit()** 方法，该方法只接受一个参数，指定了返回的条数。\n\n##### limit()：读取两条数据\n\n```js\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"grh\");\n    dbo.collection(\"site\").find().limit(2).toArray(function(err, result) {\n        if (err) throw err;\n        console.log(result);\n        db.close();\n  });\n});\n```\n\n如果要指定跳过的条数，可以使用 **skip()** 方法。\n\n##### skip(): 跳过前面两条数据，读取两条数据\n\n```js\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"grh\");\n    dbo.collection(\"site\").find().skip(2).limit(2).toArray(function(err, result) {\n        if (err) throw err;\n        console.log(result);\n        db.close();\n  });\n});\n```\n\n#### 连接操作\n\nmongoDB 不是一个关系型数据库，但我们可以使用 **$lookup** 来实现左连接。\n\n例如我们有两个集合数据分别为：\n\n集合1：orders\n\n```\n[\n  { _id: 1, product_id: 154, status: 1 }\n]\n```\n\n集合2：products\n\n```\n[\n  { _id: 154, name: '笔记本电脑' },\n  { _id: 155, name: '耳机' },\n  { _id: 156, name: '台式电脑' }\n]\n```\n\n#### $lookup 实现左连接\n\n```js\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://127.0.0.1:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n  if (err) throw err;\n  var dbo = db.db(\"grh\");\n  dbo.collection('orders').aggregate([\n    { $lookup:\n       {\n         from: 'products',            // 右集合\n         localField: 'product_id',    // 左集合 join 字段\n         foreignField: '_id',         // 右集合 join 字段\n         as: 'orderdetails'           // 新生成字段（类型array）\n       }\n     }\n    ]).toArray(function(err, res) {\n    if (err) throw err;\n    console.log(JSON.stringify(res));\n    db.close();\n  });\n});\n```\n\n#### 删除集合 drop()\n\n```js\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n \nMongoClient.connect(url, { useNewUrlParser: true }, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"grh\");\n    // 删除 test 集合\n    dbo.collection(\"test\").drop(function(err, delOK) {  // 执行成功 delOK 返回 true，否则返回 false\n        if (err) throw err;\n        if (delOK) console.log(\"集合已删除\");\n        db.close();\n    });\n});\n```\n","children":[]},{"name":"node-mysql.md","path":"../guanruihua.github.io/Front-End/Node/基础","data":"# Node.js 连接 MySQL\n\n介绍如何使用 Node.js 来连接 MySQL，并对数据库进行操作。\n\n### 安装驱动\n\n```\ncnpm install mysql\n```\n\n### 连接数据库\n\n在以下实例中根据你的实际配置修改数据库用户名、及密码及数据库名：\n\n## test.js 文件代码\n\n```javascript\nvar mysql      = require('mysql');\nvar connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'root',\n  password : '123456',\n  database : 'test'\n});\n \nconnection.connect();\n \nconnection.query('SELECT 1 + 1 AS solution', function (error, results, fields) {\n  if (error) throw error;\n  console.log('The solution is: ', results[0].solution);\n});\n```\n\n执行以下命令输出结果为：\n\n> $ node test.js\n> The solution is: 2\n\n## 数据库操作( CURD )\n\n### 查询数据\n\n将上面我们提供的 SQL 文件导入数据库后，执行以下代码即可查询出数据：\n\n## 查询数据\n\n```javascript\nvar mysql  = require('mysql');  \n \nvar connection = mysql.createConnection({     \n  host     : 'localhost',       \n  user     : 'root',              \n  password : '123456',       \n  port: '3306',                   \n  database: 'test' \n}); \n \nconnection.connect();\n \nvar  sql = 'SELECT * FROM websites';\n//查\nconnection.query(sql,function (err, result) {\n        if(err){\n          console.log('[SELECT ERROR] - ',err.message);\n          return;\n        }\n \n       console.log('------SELECT------');\n       console.log(result);\n       console.log('------------------');  \n});\n \nconnection.end();\n```\n\n执行以下命令输出就结果为：\n\n```shell\n$ node test.js\n--------------------------SELECT----------------------------\n[ RowDataPacket {\n    id: 1,\n    name: 'Google',\n    url: 'https://www.google.cm/',\n    alexa: 1,\n    country: 'USA' },\n  RowDataPacket {\n    id: 2,\n    name: '淘宝',\n    url: 'https://www.taobao.com/',\n    alexa: 13,\n    country: 'CN' }\n]\n------------------------------------------------------------\n```\n\n### 插入数据\n\n我们可以向数据表 websties 插入数据：\n\n## 插入数据\n\n```javascript\nvar mysql  = require('mysql');  \n \nvar connection = mysql.createConnection({     \n  host     : 'localhost',       \n  user     : 'root',              \n  password : '123456',       \n  port: '3306',                   \n  database: 'test' \n}); \n \nconnection.connect();\n \nvar  addSql = 'INSERT INTO websites(Id,name,url,alexa,country) VALUES(0,?,?,?,?)';\nvar  addSqlParams = ['工具', 'https://c.sxb.com','23453', 'CN'];\n//增\nconnection.query(addSql,addSqlParams,function (err, result) {\n  if(err){\n    console.log('[INSERT ERROR] - ',err.message);\n    return;\n  }        \n\n  console.log('------INSERT------');\n  //console.log('INSERT ID:',result.insertId);        \n  console.log('INSERT ID:',result);        \n  console.log('--------------\\n\\n');  \n});\n \nconnection.end();\n```\n\n执行以下命令输出就结果为：\n\n```\n$ node test.js\n--------------------------INSERT----------------------------\nINSERT ID: OkPacket {\n  fieldCount: 0,\n  affectedRows: 1,\n  insertId: 6,\n  serverStatus: 2,\n  warningCount: 0,\n  message: '',\n  protocol41: true,\n  changedRows: 0 }\n-----------------------------------------------------------------\n```\n\n执行成功后，查看数据表，即可以看到添加的数据\n\n### 更新数据\n\n我们也可以对数据库的数据进行修改：\n\n## 更新数据\n\n```javascript\nvar mysql  = require('mysql');  \n \nvar connection = mysql.createConnection({     \n  host     : 'localhost',       \n  user     : 'root',              \n  password : '123456',       \n  port: '3306',                   \n  database: 'test' \n}); \n \nconnection.connect();\n \nvar modSql = 'UPDATE websites SET name = ?,url = ? WHERE Id = ?';\nvar modSqlParams = ['移动站', 'https://m.sxt.com',6];\n//改\nconnection.query(modSql,modSqlParams,function (err, result) {\n   if(err){\n         console.log('[UPDATE ERROR] - ',err.message);\n         return;\n   }        \n  console.log('--------UPDATE--------');\n  console.log('UPDATE affectedRows',result.affectedRows);\n  console.log('----------\\n\\n');\n});\n \nconnection.end();\n```\n\n执行以下命令输出就结果为：\n\n```shell\n--------------------------UPDATE----------------------------\nUPDATE affectedRows 1\n-----------------------------------------------------------------\n```\n\n执行成功后，查看数据表\n\n### 删除数据\n\n我们可以使用以下代码来删除 id 为 6 的数据:\n\n## 删除数据\n\n```javascript\nvar mysql  = require('mysql');  \n \nvar connection = mysql.createConnection({     \n  host     : 'localhost',       \n  user     : 'root',              \n  password : '123456',       \n  port: '3306',                   \n  database: 'test' \n}); \n \nconnection.connect();\n \nvar delSql = 'DELETE FROM websites where id=6';\n//删\nconnection.query(delSql,function (err, result) {\n  if(err){\n    console.log('[DELETE ERROR] - ',err.message);\n    return;\n  }        \n\n  console.log('-----DELETE-------');\n  console.log('DELETE affectedRows',result.affectedRows);\n  console.log('----------------\\n\\n');  \n});\n \nconnection.end();\n```\n\n执行以下命令输出就结果为：\n\n```\n--------------------------DELETE----------------------------\nDELETE affectedRows 1\n-----------------------------------------------------------------\n```\n\n执行成功后，查看数据表\n","children":[]},{"name":"接收参数.md","path":"../guanruihua.github.io/Front-End/Node/基础","data":"# Node接收参数\n\n> 利用 node 内置对象  `process`\n\n## 命令行接收参数\n\n```js\nprocess.argv.forEach((val, index) => {\n console.log({ index, val });\n})\n\nnode index.js a=1 b c\n\n{ index: 0, val: 'node程序的路径' }\n{ index: 1, val: '当前执行文件的路径' }\n{ index: 2, val: 'a=1' }\n{ index: 3, val: 'b'}\n{ index: 4, val: 'c'}\n```\n\n## 命令行接收输入\n\n```js\nconst readline = require('readline').createInterface({\n input: process.stdin,\n output: process.stdout\n})\n\nreadline.question(`你叫什么名字?`, name => {\n console.log(`你好 ${name}!`)\n readline.close()\n})\n\n你叫什么名字?guanruihua\n你好 guanruihua!\n```\n\n如果需要密码，则最好不要回显密码，而是显示 `*` 符号。\n\n最简单的方式是使用 [`readline-sync` 软件包](https://www.npmjs.com/package/readline-sync)，其在 API 方面非常相似。\n\n[Inquirer.js 软件包](https://github.com/SBoudrias/Inquirer.js)则提供了更完整、更抽象的解决方案。\n\n可以使用 `npm install inquirer` 进行安装，然后复用上面的代码如下：\n\n```js\nJScopyconst inquirer = require('inquirer')\nvar questions = [  {    type: 'input',    name: 'name',    message: \"你叫什么名字?\"  }]\ninquirer.prompt(questions).then(answers => {  console.log(`你好 ${answers['name']}!`)})\n```\n\nInquirer.js 可以执行许多操作，例如询问多项选择、展示单选按钮、确认等。\n\n所有的可选方案都值得了解，尤其是 Node.js 提供的内置方案，但是如果打算将 CLI 输入提升到更高的水平，则 Inquirer.js 是更优的选择。\n","children":[]},{"name":"模块化.md","path":"../guanruihua.github.io/Front-End/Node/基础","data":"# 模块化\r\n\r\n- Node.js采用的是CommonJs规范，在NodeJS中，一般将代码合理拆分到不同的JS文件中，每一个文件就是一个模块，而文件路径就是模块名。\r\n- 在编写每个模块时，都有require、exports、module三个预先定义好的变量可供使用。\r\n- Node.js中模块的分类：\r\n\r\n  - 核心模块（已经封装好的内置模块）\r\n  - 自己定义的模块\r\n  - 第三方的模块（npm下载下来的）\r\n\r\n## require\r\n\r\n- `require`函数用来在一个模块中引入另外一个模块。传入一个模块名，返回一个模块导出对象。\r\n- 用法：`const cc = require(\"模块名\")` ，其中模块名可以用绝对路径也可以用相对路径,模块的后缀名.js可以省略。例如：\r\n\r\n```js\r\nconst cc1 = require('./main.js')\r\nconst cc2 = require('home/src/main.js')\r\nconst cc3 = require('./main')\r\n```\r\n\r\nrequire()函数用两个作用：\r\n\r\n- 执行导入的模块中的代码；\r\n- 返回导入模块中的接口对象；\r\n\r\n## exports\r\n\r\n`exports`对象用来导出当前模块的公共方法或属性，别的模块通过`require`函数使用当前模块时得到的就是当前模块的`exports`对象。用法：`exports.name`,name为导出的对象名。例子：\r\n\r\n```js\r\nexports.add = function () {\r\n  let i = 0\r\n  console.log(++i)\r\n}\r\n\r\n// 导出一个add方法供其他模块使用\r\n```\r\n\r\n- 其实exports类似于ES6中的export的用法，用来导出一个指定名字的对象。\r\n\r\n## module.exports\r\n\r\n`module.exports`用来导出一个默认对象，没有指定对象名，常见于修改模块的原始导出对象。比如原本模块导出的是一个对象，我们可以通过module.exports修改为导出一个函数。如下：\r\n\r\n```js\r\nmodule.exports = function () {\r\n  console.log('hello world！')\r\n}\r\n```\r\n\r\n1. 模块的初始化\r\n\r\n一个模块中的JS代码仅在模块**第一次被使用时**执行一次，并且在使用的过程中进行*初始化*，之后缓存起来便于后续继续使用。\r\n\r\n1. 主模块\r\n\r\n通过命令行参数传递给NodeJS以启动程序的模块被称为主模块。主模块负责调度组成整个程序的其它模块完成工作。例如通过以下命令启动程序时，main.js就是主模块。\r\n\r\n```sh\r\nnode main.js // 运行main.js启动程序，main.js称为主模块\r\n```\r\n\r\n完整实例：\r\n\r\n在项目中我们有个`hello.js`文件，里面定义了一个求和的函数\r\n\r\n```js\r\nvar a = 1;\r\n\r\nfunction add () {\r\n  return ++a;\r\n}\r\n\r\nexports.add = add\r\n```\r\n\r\n我们在项目的主模块 `main.js`中引入`hello.js`\r\n\r\n```js\r\nvar add1 = require('./hello')\r\nvar add2 = require('./hello')\r\n\r\nconsole.log(add1.add())\r\nconsole.log(add2.add())\r\n```\r\n\r\n该程序运行的结果如下：\r\n\r\n```shell\r\n$ node main.js\r\n2\r\n3\r\n```\r\n\r\n我们可以看到`hello.js`并没有别引入两次而初始化两次，说明模块只会在执行的过程中被初始化一次。\r\n\r\n## module.exports和exports的区别\r\n\r\n### 前言\r\n\r\n- Node中，每个模块都有一个`exports`接口对象，我们需要把公共的方法或者字符串挂载在这个接口对象中，其他的模块才可以使用。\r\n\r\n- Node.js中只有模块作用域，默认两个模块之间的变量，方法互不冲突，互不影响，这样就导致一个问题，我们怎样使用加载进来的模块中的方法呢？这就需要在另外一个模块`exports`接口对象中挂载模块中公共的方法。\r\n\r\n1. exports\r\n\r\n我们在`a.js`中有以下代码：\r\n\r\n```js\r\nlet foo = 'hello'\r\nfunction add (x, y) {\r\n  return x+y\r\n}\r\nexports.add = add // 在接口对象中挂载公共的add方法\r\nexports.foo = foo // 在接口对象中挂载foo属性\r\n```\r\n\r\n此时，在`b.js`中如果需要使用`add`方法,只需引入`a.js`即可。`b.js`代码如下：\r\n\r\n```js\r\nlet a = require('./a.js')  // a.js和b.js在同级目录下，注意：同级目录必须加“./”\r\nconsole.log(a.add(20,30)) // 使用a.js中的add方法\r\n```\r\n\r\n相反，如果我们没有在`a.js`exports接口对象中挂载add方法，那么这里就得不到结果。\r\n\r\n1. module.exports\r\n\r\n对于1中的例子，我们同样可以利用`module.exports`来写，只需把暴露的方式改成如下：\r\n\r\n```js\r\nmodule.exports.add = add\r\nmodule.exports.foo = foo\r\n```\r\n\r\n### 总结\r\n\r\n1. Node中每个模块都有一个`module`对象，`module`对象中的有一个`exports`属性为一个接口对象，我们需要把模块之间公共的方法或属性挂载在这个接口对象中，方便其他的模块使用这些公共的方法或属性。\r\n2. Node中每个模块的最后，都会`return: module.exports`。\r\n3. Node中每个模块都会把`module.exports`指向的对象赋值给一个变量`exports`，也就是说：`exports = module.exports`。\r\n4. `module.exports = XXX`，表示当前模块导出一个单一成员，结果就是XXX。\r\n5. 如果需要导出多个成员时必须使用`exports.add = XXX; exports.foo = XXX;`或者使用`module.exports.add = XXX; module.export.foo = XXX;`。\r\n\r\n## require加载第三方包的规则\r\n\r\nNode.js中使用`CommonJs`模块化机制，通过`npm`下载的第三方包，我们在项目中引入第三方包都是：`let xx = require('第三方包名')`，究竟`require`方法加载第三方包的原理机制是什么，今天我们来探讨下。\r\n\r\n1. `require('第三方包名')`优先在加载该包的模块的同级目录`node_modules`中查找第三方包。\r\n\r\n```js\r\nlet template = require('art-template') //加载第三方包\r\n```\r\n\r\n1. 找到该第三方包中的`package.json`文件，并且找到里面的`main`属性对应的入口模块，该入口模块即为加载的第三方模块。\r\n\r\n2. 如果在要加载的第三方包中没有找到`package.json`文件或者是`package.json`文件中没有`main`属性，则默认加载第三方包中的`index.js`文件。\r\n\r\n3. 如果在加载第三方模块的文件的同级目录没有找到`node_modules`文件夹，或者以上所有情况都没有找到，则会向上一级父级目录下查找`node_modules`文件夹，查找规则如上一致。\r\n\r\n4. 如果一直找到该模块的磁盘根路径都没有找到，则会报错：`can not find module xxx`。\r\n","children":[]}]},{"name":"读取git信息.md","path":"../guanruihua.github.io/Front-End/Node","data":"# [读取git信息](https://blog.csdn.net/wang1006008051/article/details/103699669)\r\n","children":[]}]},{"name":"Package","path":"../guanruihua.github.io/Front-End","data":"","children":[{"name":"dumi","path":"../guanruihua.github.io/Front-End/Package","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Front-End/Package/dumi","data":"# [dumi](https://d.umijs.org)\r\n\r\n> 资源路径问题, 目前不打算使用\r\n\r\n## 初始化\r\n\r\n环境准备\r\n确保正确安装 Node.js 且版本为 14+ 即可。\r\n\r\n```shell\r\n$ node -v\r\nv14.19.1\r\n```\r\n\r\n## 脚手架\r\n\r\n```shell\r\n\r\n# 先找个地方建个空目录\r\n\r\n$ mkdir myapp && cd myapp\r\n\r\n# 通过官方工具创建项目，选择你需要的模板\r\n\r\n$ npx create-dumi\r\n\r\n# 安装依赖后启动项目\r\n\r\n$ npm start\r\n```\r\n\r\n## 目录结构\r\n\r\n一个普通的、使用 dumi 做研发的组件库目录结构大致如下：\r\n\r\n```\r\n.\r\n├── docs               # 组件库文档目录\r\n│   ├── index.md       # 组件库文档首页\r\n│   ├── guide          # 组件库其他文档路由表（示意）\r\n│   │   ├── index.md\r\n│   │   └── help.md\r\n├── src                # 组件库源码目录\r\n│   ├── Button         # 单个组件\r\n│   │   ├── `index.tsx`  # 组件源码\r\n│   │   ├── `index.less` # 组件样式\r\n│   │   └── index.md   # 组件文档\r\n│   └── index.ts       # 组件库入口文件\r\n├── `.dumirc.ts`         # dumi 配置文件\r\n└── `.fatherrc.ts`       # father-build 的配置文件，用于组件库打包\r\n```\r\n\r\n如果是单纯的文档站点、不包含组件源码，忽略上面的 src 目录结构即可。\r\n\r\n> 注意，此处仅对目录结构做说明，如果要初始化一个 dumi 项目，建议直接使用 create-dumi 的脚手架进行创建。\r\n\r\n### 约定式路由\r\n\r\n为了使得路由生成更容易理解、更易于控制，dumi 对 `Markdown` 文档的目录解析做了『文档路由』及『资产路由』的概念拆分。\r\n\r\n默认情况下，docs 目录下的 `Markdown` 文档及`.dumi/pages` 下的 `React` 组件会根据目录结构解析为文档路由，src 目录下第一层级的 `Markdown` 文档会被解析为 `/components` 下的资产路由，我们可以通过配置项 `resolve.atomDirs` 对资产路由前缀及解析目录进行更改。\r\n\r\n举几个例子方便理解：\r\n\r\n| 磁盘路径| 解析结果 |\r\n|:----|:----|\r\n| `/path/to/.dumi/pages/hello.tsx`  | - 导航：Hello <br/> - 页面路由：/hello |\r\n| `/path/to/docs/hello.md` | - 导航：Hello<br/> - 页面路由：/hello|\r\n| `/path/to/docs/hello/index.md` | - 导航：Hello <br/> - 页面路由：/hello |\r\n| `/path/to/docs/hello/world/dumi.md` | - 导航：Hello <br/> - 页面路由：`/hello/world/dumi` |\r\n| `/path/to/src/hello.md` | - 导航：`Components` <br/> - 页面路由：`/components/hello` |\r\n| `/path/to/src/hello/index.md` | - 导航：`Components` <br/> - 页面路由：`/components/hello` |\r\n| `/path/to/src/hello/world.md` | 不识别 |\r\n| `/path/to/src/hello/another/world.md` | 不识别 |\r\n\r\n除此之外，以下内容也不会被识别：\r\n\r\n- 以 . 开头的目录及文档\r\n- 以 _ 开头的目录及文档\r\n\r\n### 自定义导航、分组和标题\r\n\r\n> 如果希望控制导航/分组/页面标题的生成，可以通过在 Markdown 文件顶部编写 `FrontMatter`\r\n\r\n实现：\r\n\r\n```md\r\n---\r\ntitle: 自定义页面名称\r\nnav:\r\n  title: 自定义导航名称\r\n  order: 控制导航顺序，数字越小越靠前，默认以路径长度和字典序排序\r\ngroup:\r\n  title: 自定义分组名称\r\n  order: 控制分组顺序，数字越小越靠前，默认以路径长度和字典序排序\r\n---\r\n\r\n<!-- 其他 Markdown 内容 -->\r\n```\r\n","children":[]}]},{"name":"dva","path":"../guanruihua.github.io/Front-End/Package","data":"","children":[{"name":"问题.md","path":"../guanruihua.github.io/Front-End/Package/dva","data":"# dva 问题\r\n\r\n## 项目打包后,要刷新才正常\r\n\r\n- data: 2022-11-16 10:28:11\r\n\r\n> 有问题浏览器:\r\n>\r\n> - Chrome(Version 109.0.5410.0 (Official Build) dev (64-bit))\r\n> - Chrome(Version 107.0.5304.107 (Official Build) (64-bit))\r\n> - edge(版本 107.0.1418.42 (正式版本) (64 位))\r\n>\r\n> 正常浏览器: 火狐\r\n>\r\n> - 强制清理缓存, 重复多次, 也有概率复现\r\n\r\n![](./__assets__/问题-2022-11-16-10-27-35.png)\r\n\r\n## react+dva+antd打包运行，项目时常出现报错：Loading chunk n failed.——求解决\r\n\r\n> 表现的形式:页面空白，控制栏报错如下：除非强制刷新页面才可以正常展示。不是每个页面都会出现，偶尔出现\r\n![](./__assets__/问题-2022-11-16-10-32-23.png)\r\n","children":[]}]},{"name":"hexo.md","path":"../guanruihua.github.io/Front-End/Package","data":"# **hexo**\n\n> - [官网](https://hexo.io/zh-cn/docs/)\n\n## hexo常用指令\n\n| 指令               | 指令                      |\n| ------------------ | ------------------------- |\n| 清理缓存           | `hexo clean`              |\n| 生成静态文件       | `hexo generate | hexo g`  |\n| 部署到git 上       | `hexo deploy  |  hexo d`  |\n| 执行上面三条指令   | `hexo generate  --deploy` |\n| 写作               | `hexo new noteName`       |\n| 本地服务器打开运行 | `hexo server`             |\n\n## 注意点\n\n> 写笔记尽量不要少写链接, 可能会出现错误\n\n## 新建blog\n\n```basic\nhexo init <folder>\ncd <folder>\nnpm install // 安装依赖包\nhexo server // 运行\n```\n\n## 问题\n\n1. 部署到码云上没有样式\n\n   修改配置文件_config.yml\n\n   ```yml\n   # URL\n   ## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n   url: http://grh-gitee.gitee.io/grh/\n   root: /grh/\n   permalink: :year/:month/:day/:title/\n   permalink_defaults:\n   ```\n\n2. hexo 推送到多个平台\n\n```shell\n   deploy:\n  type: git\n  repo: \n       github: git@github.com:AshinWang/AshinWang.github.io.git\n       coding: git@git.coding.net:AshinWang/AshinWang.coding.me.git\n       gitee: git@gitee.com:AshinWang/AshinWang.git\n  branch: master\n```\n\n## 修改主题默认样式\n\n### 1. 问题: li和p默认居中显示\n\n修改source/css/_partial/aricle.styl\n\n```stylus\nul\n  li\n    text-align: left\np\n  text-align: left\n```\n\n### 2.关闭tags的渲染,但是不关闭tag cloud\n\n修改themes\\landscape\\layout\\_partial\\sidebar.ejs\n\n```ejs\n<aside id=\"sidebar\"<% if (theme.sidebar === 'bottom'){ %> class=\"outer\"<% } %>>\n  <% theme.widgets.forEach(function(widget){ %>\n    <% if(widget!='tag') { %>\n    <%- partial('_widget/' + widget) %>\n    <% } %>\n  <% }) %>\n</aside>\n```\n\n## 从零开始制作hexo主题\n\n> config变量 : 包含站点配置(即_config.yml中的配置)\n>\n> page.posts : 获取单篇文章的数据, 并获取文章的标题, 内容等数据填充到模板中\n>\n> 无需刷新加载插件 [jquery-pjax]([http://bsify.admui.com/jquery-pjax/?id=%e6%94%b9%e5%8f%98%e6%b5%8f%e8%a7%88%e5%99%a8url](http://bsify.admui.com/jquery-pjax/?id=改变浏览器url))\n>\n> 代码高亮插件 [highlight](https://highlightjs.org/download/)\n>\n> [图标和字体](https://highlightjs.org/download/)\n>\n> [开发参考](https://www.cnblogs.com/yyhh/p/11058985.html)\n\n```ejs\n  <% page.posts.each(function(post){ %>\n        <% console.log(post)  %>\n      <% }) %>\n```\n\n```\n  <% site.posts.forEach(function(post){ %>\n        <%- post.path %>\n        <br />\n        <%- post.slug %>// 笔记文件相对路径\n        <br />\n        <%- post._id %>\n        <br />\n        <%- post.title %>\n        <br />\n        <%- post.date %>\n        <br />\n        <a href=\"/<%- post.path %>\"><%- post.title %></a>\n    <% }) %>\n<% console.log(site.posts) %>\n这里是 layout.ejs\n<%- include('index') %>\n<%- include('post') %>\n```\n\n引入高亮插件问题\n\n```js\nlocalhost/:1拒绝从“http://localhost:4000/lib/ lighligh/styles /agate”应用样式。因为它的MIME类型('text/html')不是一个受支持的样式表MIME类型，并且启用了严格的MIME检查。\n```\n\n```html\n// 换成该方法\n<link rel=\"stylesheet\" type=\"text/html\" href=\"../source/lib/highlight/styles/dark.css\">\n```\n\n## 更换主题\n","children":[]},{"name":"http-server..md","path":"../guanruihua.github.io/Front-End/Package","data":"# http-server\n\n> - http-server是一个简单的零配置命令行静态 HTTP 服务器\n> - 它足够强大，可以用于生产用途，但它足够简单且易于破解，可用于测试，本地开发和学习\n\n## 安装\n\n`npm install --global http-server`\n\n## 运行\n\n`npx http-server [path] [options]`\n\n## 用法\n\n`http-server [path] [options]`\n\n> [path]如果文件夹存在，则默认为，否则。./public./\n>\n> 现在，您可以访问 <http://localhost:8080> 查看您的服务器\n> 注意：默认情况下，缓存处于打开状态。添加为禁用缓存的选项。-c-1\n\n可用选项：\n\n|      命令       |                                                                              描述                                                                              |   默认   |\n| :-------------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------: | :------: |\n|   -p或--port    |                                      要使用的端口。用于查找从 8080 开始的开放端口。它还将从 中读取。-p 0process.env.PORT                                       |   8080   |\n|       -a        |                                                                          要使用的地址                                                                          | 0.0.0.0  |\n|       -d        |                                                                          显示目录列表                                                                          |   true   |\n|       -i        |                                                                          显示自动索引                                                                          |   true   |\n|   -g或--gzip    | 启用后，它将代替文件的 gzip 版本存在并且请求接受 gzip 编码时使用。如果还启用了 brotli，它将尝试先提供 brotli。`./public/some-file.js.gz./public/some-file.js`  |  false   |\n|  -b或--brotli   | 启用后，它将代替文件的 brotli 压缩版本存在并且请求接受编码的情况。如果 gzip 也启用了，它将尝试先提供 brotli。`./public/some-file.js.br./public/some-file.jsbr` |  false   |\n|    -e或--ext    |                                                                  默认文件扩展名（如果未提供）                                                                  |   html   |\n|  -s或--silent   |                                                                    禁止显示输出中的日志消息                                                                    |\n|     --cors      |                                                          通过标头启用 CORSAccess-Control-Allow-Origin                                                          |\n|    -o [path]    |                                        启动服务器后打开浏览器窗口。（可选）提供要打开的 URL 路径。例如： -o /other/dir/                                        |\n|       -c        |                               为缓存控制最大期限标头设置缓存时间（以秒为单位），例如 持续 10 秒钟。要禁用缓存，请使用 。-c10-c-1                               |   3600   |\n|    -U或--utc    |                                                                在日志消息中使用 UTC 时间格式。                                                                 |\n|    --log-ip     |                                                                  启用客户端 IP 地址的日志记录                                                                  |  false   |\n|   -P或--proxy   |                                           将所有无法在本地解析的请求代理到给定的 URL。例如：-P <http://someurl.com>                                            |\n| --proxy-options |                                                 使用嵌套的虚线对象传递代理选项。例如： --proxy-options.secure                                                  |  false   |\n|   --username    |                                                                    用于基本身份验证的用户名                                                                    |\n|   --password    |                                                                       基本身份验证的密码                                                                       |\n| -S或--tls--ssl  |                                                          启用使用 TLS/SSL （HTTPS） 提供安全请求服务                                                           |  false   |\n| -C或--cert SSL  |                                                                         证书文件的路径                                                                         | cert.pem |\n|  -K或--key SSL  |                                                                         密钥文件的路径                                                                         | key.pem  |\n|  -r或--robots   |                                                 自动提供 /robots.txt（其内容默认为User-agent: *\\nDisallow: /)                                                  |  false   |\n|  --no-dotfiles  |                                                                          不显示点文件                                                                          |\n|   --mimetypes   |                                                          用于自定义 mimetype 定义的 .types 文件的路径                                                          |\n|   -h或--help    |                                                                        打印此列表并退出                                                                        |\n|  -v或--version  |                                                                         打印版本并退出                                                                         |\n\n### 魔术文件\n\n> index.html将作为任何目录请求的默认文件。\n> 404.html如果未找到文件，将送达。这可用于单页应用 （SPA） 托管以服务入口页面。\n\n### 捕获所有重定向\n\n> 要实现无限别名重定向，请使用索引页本身作为代理，并执行以下操作：\n> `http-server --proxy <http://localhost:8080>?`\n> 请注意代理 URL 末尾的\n\n### 断续器/域名解析\n\n> 首先，您需要确保 openssl 已正确安装，并且您拥有 和 文件。您可以使用以下命令生成它们：key.pemcert.pem\n>\n> `openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem`\n> 输入命令后，系统将提示您几个问题。如果您希望能够在操作系统的根证书存储或浏览器中安装证书，以便它受信任， 则将其用作 值。127.0.0.1Common name\n>\n> 这将生成一个证书密钥对，有效期为 3650 天（约 10 年）\n> 然后，您需要运行用于启用 SSL 和证书文件的服务器。-S-C\n`http-server -S -C cert.pem`\n> 如果您希望对私钥使用密码，则可以通过 -passout 参数（使用 foobar 的密码）在 openssl 命令中包含一个密码短语\n> 例如openssl req -newkey rsa:2048 -passout pass:foobar -keyout key.pem -x509 -days 365 -out cert.pem\n> 出于安全原因，密码短语将仅从环境变量中读取。NODE_HTTP_SERVER_SSL_PASSPHRASE\n如果成功，应输出以下内容：\n\n```js\nStarting up http-server, serving ./ through https\n\nhttp-server settings:\nCORS: disabled\nCache: 3600 seconds\nConnection Timeout: 120 seconds\nDirectory Listings: visible\nAutoIndex: visible\nServe GZIP Files: false\nServe Brotli Files: false\nDefault File Extension: none\n\nAvailable on:\n  <https://127.0.0.1:8080>\n  <https://192.168.1.101:8080>\n  <https://192.168.1.104:8080>\nHit CTRL-C to stop the server\n```\n","children":[]},{"name":"Quagga.md","path":"../guanruihua.github.io/Front-End/Package","data":"# Quagga\n\n> 实现扫码功能\n","children":[]},{"name":"roadhog.md","path":"../guanruihua.github.io/Front-End/Package","data":"# roadhog\r\n\r\n> cli工具\r\n\r\n## 命令\r\n\r\n### server\r\n\r\n> 本地开发: `roadhog server`\r\n\r\n### build\r\n\r\n> 打包发布: `roadhog server`\r\n\r\n### test\r\n\r\n> 测试: `roadhog server`\r\n\r\n## 环境变量\r\n\r\n可环境变量临时配置一些参数，包括：\r\n\r\nPORT，端口号，默认8000\r\nHOST，默认localhost\r\nHTTPS，是否开启https，默认关闭\r\nBROWSER，设为none 时，不自动打开浏览器\r\nCLEAR_CONSOLE，设为none时清屏\r\n\r\n```shell\r\n\r\n//OS X, Linux\r\n$ PORT=3000 roadhog server\r\n\r\n//Windows\r\n$ set PORT=3000&&roadhog server\r\n```\r\n","children":[]},{"name":"全屏","path":"../guanruihua.github.io/Front-End/Package","data":"","children":[{"name":"react-flip-toolkit.md","path":"../guanruihua.github.io/Front-End/Package/全屏","data":"# [react-flip-toolkit](https://codesandbox.io/s/74q85nq1qq?file=/src/index.js:109-127)\r\n\r\n> 全屏最大化\r\n","children":[]}]},{"name":"兼容性.md","path":"../guanruihua.github.io/Front-End/Package","data":"# 兼容性\n\n## 标签兼容性\n\n> 1. [caniuse](https://caniuse.com/)\n>\n> 2. 安装使用caniuse-cmd\n>    1. 安装 `npm install -g caniuse-cmd`\n>    2. 使用 `caniuse+<element name>[标签名]`\n","children":[]},{"name":"可视化","path":"../guanruihua.github.io/Front-End/Package","data":"","children":[{"name":"cesium.md","path":"../guanruihua.github.io/Front-End/Package/可视化","data":"# Cesium\r\n\r\n> [官网](<https://cesium.com/platform/cesiumjs/>)\r\n> 3d 可视化\r\n","children":[]},{"name":"D3.md","path":"../guanruihua.github.io/Front-End/Package/可视化","data":"# D3\n\n> [d3-brush | D3js: Data-Driven Documents](https://d3js.org.cn/document/d3-brush/#api-reference)\n>\n> [D3.js - Axis API_学习D3JS|WIKI教程 (iowiki.com)](https://iowiki.com/d3js/d3js_axis_api.html)\n>\n> - 操作真实DOM的框架, 和JQuery类似\n> - 实现效果类似echart或highChart\n\n\n\n[d3-scale-chromatic | D3js: Data-Driven Documents](https://d3js.org.cn/document/d3-scale-chromatic/#api-reference)\n\n[React + D3.js之图表制作——柱状图 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/85862899)\n\n[柱状图 - CodeSandbox](https://codesandbox.io/embed/zhuzhuangtu-ukfzt)\n\n[d3/d3: Bring data to life with SVG, Canvas and HTML. (github.com)](https://github.com/d3/d3)","children":[]},{"name":"echart","path":"../guanruihua.github.io/Front-End/Package/可视化","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Front-End/Package/可视化/echart","data":"# [`EChart`](https://echarts.apache.org/zh/index.html)\r\n\r\n## 地图\r\n>\r\n> - [yanivam/react-svg-worldmap: A simple, compact and free React SVG world map.](https://github.com/yanivam/react-svg-worldmap)\r\n> - [react、echarts和地图的结合](https://www.jianshu.com/p/29b346e282ac)\r\n","children":[]}]},{"name":"HighEchart.md","path":"../guanruihua.github.io/Front-End/Package/可视化","data":"# HighEChart\n\n> [Highcharts API 文档 | Highcharts](https://api.highcharts.com.cn/highcharts)\n> [demo](https://jshare.com.cn/highcharts/hhhh7r)\n\n### react 使用\n\n### package.js\n\n```json\n{\n  \"dependencies\": {\n    \"highcharts-drilldown\": \"^0.1.7\",\n    \"react-highcharts\": \"^11.5.0\",\n  },\n}\n```\n\n### react文件\n\n> `grouped-categories.js` : 坐标轴分组\n>\n> `https://blacklabel.github.io/grouped_categories/grouped-categories.js`\n\n```js\nimport React from 'react'\nimport Highcharts from 'highcharts'\nimport ReactHighcharts from 'react-highcharts'\nimport Grouped from '../../assets/js/grouped-categories'\nGrouped(Highcharts) // 启用第三方包\n// 定义配置文件\nconst config = {\n chart: {\n  renderTo: \"container\",\n  type: \"column\"\n },\n title: {\n  useHTML: true,\n  x: -10,\n  y: 8,\n  text: '<span class=\"chart-title\"> Grouped categories </span>'\n },\n series: [{\n  data: [4, 14, 18, 5, 6, 5, 14, 15, 18]\n }],\n xAxis: {\n  categories: [{\n   name: \"Fruit\",\n   categories: [\"Apple\", \"Banana\", \"Orange\"]\n  }, {\n   name: \"Vegetable\",\n   categories: [\"Carrot\", \"Potato\", \"Tomato\"]\n  }, {\n   name: \"Fish\",\n   categories: [\"Cod\", \"Salmon\", \"Tuna\"]\n  }]\n }\n}\n\n// 渲染出来\n<ReactHighcharts config={config}></ReactHighcharts>\n```\n\n## 配置\n\n### 去掉highcharts的logo\n\n```js\ncredits: { \n  enabled: false //不显示LOGO \n},\n```\n\n### 改变柱状图宽度\n\n```js\nplotOptions: {\n  series: {\n     pointPadding: 0, //数据点之间的距离值\n     groupPadding: 0, //分组之间的距离值\n     borderWidth: 0,\n     shadow: false,\n     pointWidth:5 //柱子之间的距离值\n  }\n}\n//统一柱状图的颜色\n\ncolor:'#ffc77f',\n```\n\n### 改变y轴的刻度\n\n```json\nyAxis: {\n  tickPositions: [0, 50000, 100000, 150000,200000,250000,300000] // 指定竖轴坐标点的值\n},\n```\n\n### 改变背景颜色,改变环形图文字颜色\n\n```json\n chart: {\n   plotBackgroundColor: null,\n   plotBorderWidth: null,\n   backgroundColor:'#fff',//改变背景颜色\n   plotShadow: false, \n   spacing : [100, 0 , 40, 0]\n },\ntitle: {\n  floating:true,\n  text: '前十大投资人',\n  style: {\n    color: \"#000\"//改变环形图文字颜色\n  }\n},\n```\n\n### 去掉图例\n\n   legend: {\n            enabled: false\n        }\n\n### highcharts改变y轴刻度的单位\n\n```json\nlabels: {\n  formatter:function(){\n    return this.value+\"%\";\n  }\n} \n```\n\n### 提示框的背景色\n\n```json\ntooltip: {\n  backgroundColor: '#ff6600',\n  pointFormat: '平台交易: <b>{point.y:.1f} 万元</b><br>交易笔数：<b>{point.y:.1f} 万笔</b>',\n  animation: true  \n},\n```\n\n### 重新绘制\n\n```json\n$(\"#container1\").highcharts().reflow();\n```\n\n### 雷达图刻度\n\n```json\nplotOptions: {\n  line: {\n    dataLabels: {\n      enabled: true          // 开启数据标签\n    },\n    enableMouseTracking: false // 关闭鼠标跟踪，对应的提示框、点击事件会失效\n  }\n},\n```\n\n## 第三方包\n\n### grouped-categories.js\n\n```js\n/* global Highcharts module window:true */\n(function (factory) {\n if (typeof module === 'object' && module.exports) {\n  module.exports = factory;\n } else {\n  factory(Highcharts);\n }\n}(function (HC) {\n 'use strict';\n /**\n  * Grouped Categories v1.1.6 (2020-06-19)\n  *\n  * (c) 2012-2020 Black Label\n  *\n  * License: Creative Commons Attribution (CC)\n  */\n\n /* jshint expr:true, boss:true */\n var UNDEFINED = void 0,\n  mathRound = Math.round,\n  mathMin = Math.min,\n  mathMax = Math.max,\n  merge = HC.merge,\n  pick = HC.pick,\n  each = HC.each,\n\n  // cache prototypes\n  axisProto = HC.Axis.prototype,\n  tickProto = HC.Tick.prototype,\n\n  // cache original methods\n  protoAxisInit = axisProto.init,\n  protoAxisRender = axisProto.render,\n  protoAxisSetCategories = axisProto.setCategories,\n  protoTickGetLabelSize = tickProto.getLabelSize,\n  protoTickAddLabel = tickProto.addLabel,\n  protoTickDestroy = tickProto.destroy,\n  protoTickRender = tickProto.render;\n\n function deepClone(thing) {\n  return JSON.parse(JSON.stringify(thing));\n }\n\n function Category(obj, parent) {\n  this.userOptions = deepClone(obj);\n  this.name = obj.name || obj;\n  this.parent = parent;\n\n  return this;\n }\n\n Category.prototype.toString = function () {\n  var parts = [],\n   cat = this;\n\n  while (cat) {\n   parts.push(cat.name);\n   cat = cat.parent;\n  }\n\n  return parts.join(', ');\n };\n\n // returns sum of an array\n function sum(arr) {\n  var l = arr.length,\n   x = 0;\n\n  while (l--) {\n   x += arr[l];\n  }\n\n  return x;\n }\n\n // Adds category leaf to array\n function addLeaf(out, cat, parent) {\n  out.unshift(new Category(cat, parent));\n\n  while (parent) {\n   parent.leaves = parent.leaves ? (parent.leaves + 1) : 1;\n   parent = parent.parent;\n  }\n }\n\n // Builds reverse category tree\n function buildTree(cats, out, options, parent, depth) {\n  var len = cats.length,\n   cat;\n\n  depth = depth ? depth : 0;\n  options.depth = options.depth ? options.depth : 0;\n\n  while (len--) {\n   cat = cats[len];\n   \n   if (cat.categories) {\n    if (parent) {\n     cat.parent = parent;\n    }\n    buildTree(cat.categories, out, options, cat, depth + 1);\n   } else {\n    addLeaf(out, cat, parent);\n   }\n  }\n  options.depth = mathMax(options.depth, depth);\n }\n\n // Pushes part of grid to path\n function addGridPart(path, d, width) {\n  // Based on crispLine from HC (#65)\n  if (d[0] === d[2]) {\n   d[0] = d[2] = mathRound(d[0]) - (width % 2 / 2);\n  }\n  if (d[1] === d[3]) {\n   d[1] = d[3] = mathRound(d[1]) + (width % 2 / 2);\n  }\n\n  path.push(\n   'M',\n   d[0], d[1],\n   'L',\n   d[2], d[3]\n  );\n }\n\n // Returns tick position\n function tickPosition(tick, pos) {\n  return tick.getPosition(tick.axis.horiz, pos, tick.axis.tickmarkOffset);\n }\n\n function walk(arr, key, fn) {\n  var l = arr.length,\n   children;\n\n  while (l--) {\n   children = arr[l][key];\n\n   if (children) {\n    walk(children, key, fn);\n   }\n   fn(arr[l]);\n  }\n }\n\n //\n // Axis prototype\n //\n\n axisProto.init = function (chart, options) {\n  // default behaviour\n  protoAxisInit.call(this, chart, options);\n\n  if (typeof options === 'object' && options.categories) {\n   this.setupGroups(options);\n  }\n };\n\n // setup required axis options\n axisProto.setupGroups = function (options) {\n  var categories = deepClone(options.categories),\n   reverseTree = [],\n   stats = {},\n   labelOptions = this.options.labels,\n   userAttr = labelOptions.groupedOptions,\n   css = labelOptions.style;\n\n  // build categories tree\n  buildTree(categories, reverseTree, stats);\n\n  // set axis properties\n  this.categoriesTree = categories;\n  this.categories = reverseTree;\n  this.isGrouped = stats.depth !== 0;\n  this.labelsDepth = stats.depth;\n  this.labelsSizes = [];\n  this.labelsGridPath = [];\n  this.tickLength = options.tickLength || this.tickLength || null;\n  // #66: tickWidth for x axis defaults to 1, for y to 0\n  this.tickWidth = pick(options.tickWidth, this.isXAxis ? 1 : 0);\n  this.directionFactor = [-1, 1, 1, -1][this.side];\n  this.options.lineWidth = pick(options.lineWidth, 1);\n  // #85: align labels vertically\n  this.groupFontHeights = [];\n  for (var i = 0; i <= stats.depth; i++) {\n   var hasOptions = userAttr && userAttr[i - 1],\n    mergedCSS = hasOptions && userAttr[i - 1].style ? merge(css, userAttr[i - 1].style) : css;\n   this.groupFontHeights[i] = Math.round(this.chart.renderer.fontMetrics(mergedCSS ? mergedCSS.fontSize : 0).b * 0.3);\n  }\n };\n\n\n axisProto.render = function () {\n  // clear grid path\n  if (this.isGrouped) {\n   this.labelsGridPath = [];\n  }\n\n  // cache original tick length\n  if (this.originalTickLength === UNDEFINED) {\n   this.originalTickLength = this.options.tickLength;\n  }\n\n  // use default tickLength for not-grouped axis\n  // and generate grid on grouped axes,\n  // use tiny number to force highcharts to hide tick\n  this.options.tickLength = this.isGrouped ? 0.001 : this.originalTickLength;\n\n  protoAxisRender.call(this);\n\n  if (!this.isGrouped) {\n   if (this.labelsGrid) {\n    this.labelsGrid.attr({\n     visibility: 'hidden'\n    });\n   }\n   return false;\n  }\n\n  var axis = this,\n   options = axis.options,\n   top = axis.top,\n   left = axis.left,\n   right = left + axis.width,\n   bottom = top + axis.height,\n   visible = axis.hasVisibleSeries || axis.hasData,\n   depth = axis.labelsDepth,\n   grid = axis.labelsGrid,\n   horiz = axis.horiz,\n   d = axis.labelsGridPath,\n   i = options.drawHorizontalBorders === false ? (depth + 1) : 0,\n   offset = axis.opposite ? (horiz ? top : right) : (horiz ? bottom : left),\n   tickWidth = axis.tickWidth,\n   part;\n\n  if (axis.userTickLength) {\n   depth -= 1;\n  }\n\n  // render grid path for the first time\n  if (!grid) {\n   grid = axis.labelsGrid = axis.chart.renderer.path()\n   .attr({\n    // #58: use tickWidth/tickColor instead of lineWidth/lineColor:\n    strokeWidth: tickWidth, // < 4.0.3\n    'stroke-width': tickWidth, // 4.0.3+ #30\n    stroke: options.tickColor || '' // for styled mode (tickColor === undefined)\n   })\n   .add(axis.axisGroup);\n   // for styled mode - add class\n   if (!options.tickColor) {\n    grid.addClass('highcharts-tick');\n   }\n  }\n\n  // go through every level and draw horizontal grid line\n  while (i <= depth) {\n   offset += axis.groupSize(i);\n\n   part = horiz ?\n    [left, offset, right, offset] :\n    [offset, top, offset, bottom];\n\n   addGridPart(d, part, tickWidth);\n   i++;\n  }\n\n  // draw grid path\n  grid.attr({\n   d: d,\n   visibility: visible ? 'visible' : 'hidden'\n  });\n\n  axis.labelGroup.attr({\n   visibility: visible ? 'visible' : 'hidden'\n  });\n\n\n  walk(axis.categoriesTree, 'categories', function (group) {\n   var tick = group.tick;\n\n   if (!tick) {\n    return false;\n   }\n   if (tick.startAt + tick.leaves - 1 < axis.min || tick.startAt > axis.max) {\n    tick.label.hide();\n    tick.destroyed = 0;\n   } else {\n    tick.label.attr({\n     visibility: visible ? 'visible' : 'hidden'\n    });\n   }\n   return true;\n  });\n  return true;\n };\n\n axisProto.setCategories = function (newCategories, doRedraw) {\n  if (this.categories) {\n   this.cleanGroups();\n  }\n  this.setupGroups({\n   categories: newCategories\n  });\n  this.categories = this.userOptions.categories = newCategories;\n  protoAxisSetCategories.call(this, this.categories, doRedraw);\n };\n\n // cleans old categories\n axisProto.cleanGroups = function () {\n  var ticks = this.ticks,\n   n;\n\n  for (n in ticks) {\n   if (ticks[n].parent) {\n    delete ticks[n].parent;\n   }\n  }\n  walk(this.categoriesTree, 'categories', function (group) {\n   var tick = group.tick;\n   \n   if (!tick) {\n    return false;\n   }\n   tick.label.destroy();\n   \n   each(tick, function (v, i) {\n    delete tick[i];\n   });\n   delete group.tick;\n   \n   return true;\n  });\n  this.labelsGrid = null;\n };\n\n // keeps size of each categories level\n axisProto.groupSize = function (level, position) {\n  var positions = this.labelsSizes,\n   direction = this.directionFactor,\n   groupedOptions = this.options.labels.groupedOptions ? this.options.labels.groupedOptions[level - 1] : false,\n   userXY = 0;\n\n  if (groupedOptions) {\n   if (direction === -1) {\n    userXY = groupedOptions.x ? groupedOptions.x : 0;\n   } else {\n    userXY = groupedOptions.y ? groupedOptions.y : 0;\n   }\n  }\n\n  if (position !== UNDEFINED) {\n   positions[level] = mathMax(positions[level] || 0, position + 10 + Math.abs(userXY));\n  }\n\n  if (level === true) {\n   return sum(positions) * direction;\n  } else if (positions[level]) {\n   return positions[level] * direction;\n  }\n\n  return 0;\n };\n\n //\n // Tick prototype\n //\n\n // Override methods prototypes\n tickProto.addLabel = function () {\n  var tick = this,\n   axis = tick.axis,\n   category;\n  \n  protoTickAddLabel.call(tick);\n  \n  if (!axis.categories || !(category = axis.categories[tick.pos])) {\n   return false;\n  }\n  \n  // set label text - but applied after formatter #46\n  if (tick.label) {\n   tick.label.attr('text', tick.axis.labelFormatter.call({\n    axis: axis,\n    chart: axis.chart,\n    isFirst: tick.isFirst,\n    isLast: tick.isLast,\n    value: category.name,\n    pos: tick.pos\n   }));\n  }\n  \n  // create elements for parent categories\n  if (axis.isGrouped && axis.options.labels.enabled) {\n   tick.addGroupedLabels(category);\n  }\n  return true;\n };\n\n // render ancestor label\n tickProto.addGroupedLabels = function (category) {\n  var tick = this,\n   axis = this.axis,\n   chart = axis.chart,\n   options = axis.options.labels,\n   useHTML = options.useHTML,\n   css = options.style,\n   userAttr = options.groupedOptions,\n   attr = {\n    align: 'center',\n    rotation: options.rotation,\n    x: 0,\n    y: 0\n   },\n   size = axis.horiz ? 'height' : 'width',\n   depth = 0,\n   label;\n\n\n  while (tick) {\n   if (depth > 0 && !category.tick) {\n    // render label element\n    this.value = category.name;\n    var name = options.formatter ? options.formatter.call(this, category) : category.name,\n     hasOptions = userAttr && userAttr[depth - 1],\n     mergedAttrs = hasOptions ? merge(attr, userAttr[depth - 1]) : attr,\n     mergedCSS = hasOptions && userAttr[depth - 1].style ? merge(css, userAttr[depth - 1].style) : css;\n\n    // #63: style is passed in CSS and not as an attribute\n    delete mergedAttrs.style;\n\n    label = chart.renderer.text(name, 0, 0, useHTML)\n     .attr(mergedAttrs)\n     .css(mergedCSS)\n     .add(axis.labelGroup);\n\n    // tick properties\n    tick.startAt = this.pos;\n    tick.childCount = category.categories.length;\n    tick.leaves = category.leaves;\n    tick.visible = this.childCount;\n    tick.label = label;\n    tick.labelOffsets = {\n     x: mergedAttrs.x,\n     y: mergedAttrs.y\n    };\n\n    // link tick with category\n    category.tick = tick;\n   }\n\n   // set level size, #93\n   if (tick && tick.label) {\n    axis.groupSize(depth, tick.label.getBBox()[size]);\n   }\n\n   // go up to the parent category\n   category = category.parent;\n\n   if (category) {\n    tick = tick.parent = category.tick || {};\n   } else {\n    tick = null;\n   }\n\n   depth++;\n  }\n };\n\n // set labels position & render categories grid\n tickProto.render = function (index, old, opacity) {\n  protoTickRender.call(this, index, old, opacity);\n\n  var treeCat = this.axis.categories[this.pos];\n\n  if (!this.axis.isGrouped || !treeCat || this.pos > this.axis.max) {\n   return;\n  }\n\n  var tick = this,\n   group = tick,\n   axis = tick.axis,\n   tickPos = tick.pos,\n   isFirst = tick.isFirst,\n   max = axis.max,\n   min = axis.min,\n   horiz = axis.horiz,\n   grid = axis.labelsGridPath,\n   size = axis.groupSize(0),\n   tickWidth = axis.tickWidth,\n   xy = tickPosition(tick, tickPos),\n   start = horiz ? xy.y : xy.x,\n   baseLine = axis.chart.renderer.fontMetrics(axis.options.labels.style ? axis.options.labels.style.fontSize : 0).b,\n   depth = 1,\n   reverseCrisp = ((horiz && xy.x === axis.pos + axis.len) || (!horiz && xy.y === axis.pos)) ? -1 : 0, // adjust grid lines for edges\n   gridAttrs,\n   lvlSize,\n   minPos,\n   maxPos,\n   attrs,\n   bBox;\n\n  // render grid for \"normal\" categories (first-level), render left grid line only for the first category\n  if (isFirst) {\n   gridAttrs = horiz ?\n    [axis.left, xy.y, axis.left, xy.y + axis.groupSize(true)] : axis.isXAxis ?\n     [xy.x, axis.top, xy.x + axis.groupSize(true), axis.top] : [xy.x, axis.top + axis.len, xy.x + axis.groupSize(true), axis.top + axis.len];\n\n   addGridPart(grid, gridAttrs, tickWidth);\n  }\n\n  if (horiz && axis.left < xy.x) {\n   addGridPart(grid, [xy.x - reverseCrisp, xy.y, xy.x - reverseCrisp, xy.y + size], tickWidth);\n  } else if (!horiz && axis.top <= xy.y) {\n   addGridPart(grid, [xy.x, xy.y + reverseCrisp, xy.x + size, xy.y + reverseCrisp], tickWidth);\n  }\n\n  size = start + size;\n\n  function fixOffset(tCat) {\n   var ret = 0;\n   if (isFirst) {\n    ret = tCat.parent.categories.indexOf(tCat.name);\n    ret = ret < 0 ? 0 : ret;\n    return ret;\n   }\n   return ret;\n  }\n\n\n  while (group.parent) {\n   group = group.parent;\n   \n   var fix = fixOffset(treeCat),\n    userX = group.labelOffsets.x,\n    userY = group.labelOffsets.y;\n   \n   minPos = tickPosition(tick, mathMax(group.startAt - 1, min - 1));\n   maxPos = tickPosition(tick, mathMin(group.startAt + group.leaves - 1 - fix, max));\n   bBox = group.label.getBBox(true);\n   lvlSize = axis.groupSize(depth);\n   // check if on the edge to adjust\n   reverseCrisp = ((horiz && maxPos.x === axis.pos + axis.len) || (!horiz && maxPos.y === axis.pos)) ? -1 : 0;\n   \n   attrs = horiz ? {\n    x: (minPos.x + maxPos.x) / 2 + userX,\n    y: size + axis.groupFontHeights[depth] + lvlSize / 2 + userY / 2\n   } : {\n    x: size + lvlSize / 2 + userX,\n    y: (minPos.y + maxPos.y - bBox.height) / 2 + baseLine + userY\n   };\n   \n   if (!isNaN(attrs.x) && !isNaN(attrs.y)) {\n    group.label.attr(attrs);\n\n    if (grid) {\n     if (horiz && axis.left < maxPos.x) {\n      addGridPart(grid, [maxPos.x - reverseCrisp, size, maxPos.x - reverseCrisp, size + lvlSize], tickWidth);\n     } else if (!horiz && axis.top <= maxPos.y) {\n      addGridPart(grid, [size, maxPos.y + reverseCrisp, size + lvlSize, maxPos.y + reverseCrisp], tickWidth);\n     }\n    }\n   }\n\n   size += lvlSize;\n   depth++;\n  }\n };\n\n tickProto.destroy = function () {\n  var group = this.parent;\n\n  while (group) {\n   group.destroyed = group.destroyed ? (group.destroyed + 1) : 1;\n   group = group.parent;\n  }\n\n  protoTickDestroy.call(this);\n };\n\n // return size of the label (height for horizontal, width for vertical axes)\n tickProto.getLabelSize = function () {\n  if (this.axis.isGrouped === true) {\n   // #72, getBBox might need recalculating when chart is tall\n   var size = protoTickGetLabelSize.call(this) + 10,\n    topLabelSize = this.axis.labelsSizes[0];\n   if (topLabelSize < size) {\n    this.axis.labelsSizes[0] = size;\n   }\n   return sum(this.axis.labelsSizes);\n  }\n  return protoTickGetLabelSize.call(this);\n };\n \n // Since datasorting is not supported by the plugin,\n // override replaceMovedLabel method, #146.\n HC.wrap(HC.Tick.prototype, 'replaceMovedLabel', function (proceed) {\n  if (!this.axis.isGrouped) {\n   proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n  }\n });\n\n}));\n```\n","children":[]},{"name":"threejs","path":"../guanruihua.github.io/Front-End/Package/可视化","data":"","children":[{"name":"API","path":"../guanruihua.github.io/Front-End/Package/可视化/threejs","data":"","children":[{"name":"PerspectiveCamera.md","path":"../guanruihua.github.io/Front-End/Package/可视化/threejs/API","data":"\n# 透视相机（PerspectiveCamera）\n\n这一摄像机使用[perspective projection](https://en.wikipedia.org/wiki/Perspective_(graphical))（透视投影）来进行投影。\n\n这一投影模式被用来模拟人眼所看到的景象，它是3D场景的渲染中使用得最普遍的投影模式。\n\n## 代码示例\n\n```js\nconst camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 ); \nscene.add( camera );\n```\n\n## 例子\n\n[animation / skinning / blending](https://threejs.org/examples/#webgl_animation_skinning_blending)\n[animation / skinning / blending](https://threejs.org/examples/#webgl_animation_skinning_morph)\n[effects / stereo](https://threejs.org/examples/#webgl_effects_stereo)\n[interactive / cubes](https://threejs.org/examples/#webgl_interactive_cubes)\n[loader / collada / skinning](https://threejs.org/examples/#webgl_loader_collada_skinning)\n\n## 构造器\n\n### PerspectiveCamera( fov : Number, aspect : Number, near : Number, far : Number )\n\n> - fov — 摄像机视锥体垂直视野角度\n> - aspect — 摄像机视锥体长宽比\n> - near — 摄像机视锥体近端面\n> - far — 摄像机视锥体远端面\n\n这些参数一起定义了摄像机的[viewing frustum](https://en.wikipedia.org/wiki/Viewing_frustum)（视锥体）。\n\n## 属性\n\n> 共有属性请参见其基类 Camera\n> 请注意，在大多数属性发生改变之后，你将需要调用.updateProjectionMatrix来使得这些改变生效。\n\n### .aspect : Float\n\n> 摄像机视锥体的长宽比，通常是使用画布的宽/画布的高。默认值是**1**（正方形画布）。\n\n### .far : Float\n\n> 摄像机的远端面，默认值是**2000**。\n>\n> 该值必须大于near plane（摄像机视锥体近端面）的值。\n\n### .filmGauge : Float\n\n> 胶片尺寸，其默认值为35（毫米）。 这个参数不会影响摄像机的投影矩阵，除非.filmOffset被设置为了一个非零的值。\n\n### .filmOffset : Float\n\n> 水平偏离中心偏移量，和.filmGauge单位相同。默认值为**0**。\n\n### .focus : Float\n\n> 用于立体视觉和景深效果的物体的距离。 这个参数不会影响摄像机的投影矩阵，除非使用了StereoCamera。 默认值是**10**。\n\n### .fov : Float\n\n> 摄像机视锥体垂直视野角度，从视图的底部到顶部，以角度来表示。默认值是**50**。\n\n### .near : Float\n\n> 摄像机的近端面，默认值是**0.1**。\n>\n> 其有效值范围是0到当前摄像机far plane（远端面）的值之间。 请注意，和OrthographicCamera不同，**0**对于PerspectiveCamera的近端面来说*不是*一个有效值。\n\n### .view : Object\n\n> Frustum window specification or null. 这个值使用.setViewOffset方法来进行设置，使用.clearViewOffset方法来进行清除。\n\n### .zoom : number\n\n> 获取或者设置摄像机的缩放倍数，其默认值为**1**。\n\n## 方法\n\n> 共有方法请参见其基类Camera。\n\n### .clearViewOffset () : undefined\n\n> 清除任何由.setViewOffset设置的偏移量。\n\n### .getEffectiveFOV () : Float\n\n> 结合.zoom（缩放倍数），以角度返回当前垂直视野角度。\n\n### .getFilmHeight () : Float\n\n> 返回当前胶片上图像的高，如果.aspect小于或等于1（肖像格式、纵向构图），则结果等于.filmGauge。\n\n### .getFilmWidth () : Float\n\n> 返回当前胶片上图像的宽，如果.aspect大于或等于1（景观格式、横向构图），则结果等于.filmGauge。\n\n### .getFocalLength () : Float\n\n> 返回当前.fov（视野角度）相对于.filmGauge（胶片尺寸）的焦距。\n\n### .setFocalLength ( focalLength : Float ) : undefined\n\n> 通过相对于当前.filmGauge的焦距，设置FOV。\n>\n> 默认情况下，焦距是为35mm（全画幅）摄像机而指定的。\n\n### .setViewOffset ( fullWidth : Float, fullHeight : Float, x : Float, y : Float, width : Float, height : Float ) : undefined\n\nfullWidth — 多视图的全宽设置\nfullHeight — 多视图的全高设置\nx — 副摄像机的水平偏移\ny — 副摄像机的垂直偏移\nwidth — 副摄像机的宽度\nheight — 副摄像机的高度\n\n在较大的viewing frustum（视锥体）中设置偏移量，对于多窗口或者多显示器的设置是很有用的。\n\n例如，如果你有一个3x2的显示器阵列，每个显示器分辨率都是1920x1080，且这些显示器排列成像这样的网格：\n\n```txt\n+---+---+---+\n| A | B | C |\n+---+---+---+\n| D | E | F |\n+---+---+---+\n```\n\n那对于每个显示器，你可以这样来设置、调用：\n\n```js\nconst w = 1920; \nconst h = 1080; \nconst fullWidth = w * 3; \nconst fullHeight = h * 2; \n// A \ncamera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h ); \n// B \ncamera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h ); \n// C \ncamera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h ); \n// D \ncamera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h ); \n// E \ncamera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h ); \n// F \ncamera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n```\n\n请注意，显示器的不必具有相同的大小，或者不必在网格中。\n\n### .updateProjectionMatrix () : undefined\n\n更新摄像机投影矩阵。在任何参数被改变以后必须被调用。\n\n### .toJSON (meta : Object) : Object\n\nmeta -- 包含有元数据的对象，例如对象后代中的纹理或图像\n将摄像机转换为 three.js [JSON Object/Scene format](https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4)（three.js JSON 物体/场景格式）。\n\n## 源代码\n\n[src/cameras/PerspectiveCamera.js](https://github.com/mrdoob/three.js/blob/master/src/cameras/PerspectiveCamera.js)\n","children":[]},{"name":"WebGLRenderer.md","path":"../guanruihua.github.io/Front-End/Package/可视化/threejs/API","data":"# WebGLRenderer\n\nWebGL Render 用[WebGL](https://en.wikipedia.org/wiki/WebGL)渲染出你精心制作的场景。\n\n## 构造器\n\n### WebGLRenderer( parameters : Object )\n\nparameters - (可选) 该对象的属性定义了渲染器的行为。也可以完全不传参数。在所有情况下，当缺少参数时，它将采用合理的默认值。 以下是合法参数：\n\n> - canvas - 一个供渲染器绘制其输出的[canvas](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas) 它和下面的domElement属性对应。 如果没有传这个参数，会创建一个新canvas\n> - context - 可用于将渲染器附加到已有的渲染环境([RenderingContext](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext))中。默认值是null\n> - precision - 着色器精度. 可以是 **\"highp\"**, **\"mediump\"** 或者 **\"lowp\"**. 如果设备支持，默认为**\"highp\"** . 点击[here](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices) 查看\"应该避免的事\"\n> - alpha - canvas是否包含alpha (透明度)。默认为 **false**\n> - premultipliedAlpha - renderer是否假设颜色有 [premultiplied alpha](https://en.wikipedia.org/wiki/Glossary_of_computer_graphics#Premultiplied_alpha). 默认为**true**\n> - antialias - 是否执行抗锯齿。默认为**false**.\n> - stencil - 绘图缓存是否有一个至少8位的模板缓存([stencil buffer](https://en.wikipedia.org/wiki/Stencil_buffer))。默认为**true**\n> - preserveDrawingBuffer -是否保留缓直到手动清除或被覆盖。 默认**false**.\n> - powerPreference - 提示用户代理怎样的配置更适用于当前WebGL环境。 可能是**\"high-performance\"**, **\"low-power\"** 或 **\"default\"**。默认是**\"default\"**. 详见[WebGL spec](https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.12)\n> - failIfMajorPerformanceCaveat - whether the renderer creation will fail upon low perfomance is detected. Default is **false**. See [WebGL spec](https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.12) for details.\n> - depth - 绘图缓存是否有一个至少6位的深度缓存([depth buffer](https://en.wikipedia.org/wiki/Z-buffering) )。 默认是**true**.\n> - logarithmicDepthBuffer - 是否使用对数深度缓存。如果要在单个场景中处理巨大的比例差异，就有必要使用。 Note that this setting uses gl_FragDepth if available which disables the [Early Fragment Test](https://www.khronos.org/opengl/wiki/Early_Fragment_Test) optimization and can cause a decrease in performance. 默认是**false**。 示例：camera / logarithmicdepthbuffer\n\n## 属性\n\n### .autoClear : Boolean\n\n> 定义渲染器是否在渲染每一帧之前自动清除其输出。\n\n### .autoClearColor : Boolean\n\n> 如果autoClear为true, 定义renderer是否清除颜色缓存。 默认是**true**\n\n### .autoClearDepth : Boolean\n\n> 如果autoClear是true, 定义renderer是否清除深度缓存。 默认是**true**\n\n### .autoClearStencil : Boolean\n\n> 如果autoClear是true, 定义renderer是否清除模板缓存. 默认是**true**\n\n### .debug.checkShaderErrors : Boolean\n\n> 如果checkShaderErrors为true，定义是否检查材质着色器程序 编译和链接过程中的错误。 禁用此检查生产以获得性能增益可能很有用。 强烈建议在开发期间保持启用这些检查。 如果着色器没有编译和链接 - 它将无法工作，并且相关材料将不会呈现。 默认是**true**\n\n### .capabilities : Object\n\n> 一个包含当前渲染环境([RenderingContext](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext))的功能细节的对象。\n>\n> - floatFragmentTextures: 环境是否支持[OES_texture_float](https://developer.mozilla.org/en-US/docs/Web/API/OES_texture_float)扩展\n> - floatVertexTextures: 如果floatFragmentTextures和vertexTextures都是true， 则此值为**true**\n> - getMaxAnisotropy(): 返回最大可用各向异性。\n> - getMaxPrecision(): 返回顶点着色器和片元着色器的最大可用精度。\n> - isWebGL2: **true** if the context in use is a WebGL2RenderingContext object.\n> - logarithmicDepthBuffer: 如果logarithmicDepthBuffer在构造器中被设为true且 环境支持[EXT_frag_depth](https://developer.mozilla.org/en-US/docs/Web/API/EXT_frag_depth)扩展，则此值为**true**\n> - maxAttributes: **gl.MAX_VERTEX_ATTRIBS**的值\n> - maxCubemapSize: **gl.MAX_CUBE_MAP_TEXTURE_SIZE** 的值，着色器可使用的立方体贴图纹理的最大宽度*高度\n> - maxFragmentUniforms: **gl.MAX_FRAGMENT_UNIFORM_VECTORS**的值，片元着色器可使用的全局变量(uniforms)数量\n> - maxTextureSize: **gl.MAX_TEXTURE_SIZE**的值，着色器可使用纹理的最大宽度*高度\n> - maxTextures: *gl.MAX_TEXTURE_IMAGE_UNITS的值，着色器可使用的纹理数量\n> - maxVaryings: **gl.MAX_VARYING_VECTORS**的值，着色器可使用矢量的数量\n> - maxVertexTextures: **gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS**的值，顶点着色器可使用的纹理数量。\n> - maxVertexUniforms: **gl.MAX_VERTEX_UNIFORM_VECTORS**的值，顶点着色器可使用的全局变量(uniforms)数量\n> - precision: 渲染器当前使用的着色器的精度\n> - vertexTextures: 如果 .maxVertexTextures : Integer大于0，此值为**true** (即可以使用顶点纹理)\n\n### .clippingPlanes : Array\n\n> 用户自定义的剪裁平面，在世界空间中被指定为THREE.Plane对象。 这些平面全局使用。空间中与该平面点积为负的点将被切掉。 默认值是`[]`\n\n### .domElement : DOMElement\n\n> 一个[canvas](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas)，渲染器在其上绘制输出。\n渲染器的构造函数会自动创建(如果没有传入canvas参数);你需要做的仅仅是像下面这样将它加页面里去:\n`document.body.appendChild( renderer.domElement );`\n\n### .extensions : Object\n\n.extensions.get方法的包装, 用于检查是否支持各种WebGL扩展\n\n### .outputEncoding : number\n\n定义渲染器的输出编码。默认为THREE.LinearEncoding\n\n如果渲染目标已经使用 .setRenderTarget、之后将直接使用renderTarget.texture.encoding\n\n查看texture constants页面以获取其他格式细节\n\n### .info : Object\n\n一个对象，包含有关图形板内存和渲染过程的一系列统计信息。这些信息可用于调试或仅仅满足下好奇心。改对象包含以下字段:\n\n- memory:\n  - geometries\n  - textures\n- render:\n  - calls\n  - triangles\n  - points\n  - lines\n  - frame\n- programs\n\nBy default these data are reset at each render call but when having multiple render passes per frame (e.g. when using post processing) it can be preferred to reset with a custom pattern. First, set **autoReset** to **false**.`renderer.info.autoReset = false;`Call **reset()** whenever you have finished to render a single frame.`renderer.info.reset();`\n\n### .localClippingEnabled : Boolean\n\n定义渲染器是否考虑对象级剪切平面。 默认为**false**.\n\n### .physicallyCorrectLights : Boolean\n\n是否使用物理上正确的光照模式。 默认是**false**。 示例：[lights / physical](https://threejs.org/examples/#webgl_lights_physical)\n\n### .properties : Object\n\n渲染器内部使用，以跟踪各种子对象属性。\n\n### .renderLists : WebGLRenderLists\n\n在内部用于处理场景渲染对象的排序。\n\n### .shadowMap : WebGLShadowMap\n\n如果使用，它包含阴影贴图的引用。\n\n### .shadowMap.enabled : Boolean\n\n如果设置开启，允许在场景中使用阴影贴图。默认是 **false**。\n\n### .shadowMap.autoUpdate : Boolean\n\n启用场景中的阴影自动更新。默认是**true**\n\n如果不需要动态光照/阴影, 则可以在实例化渲染器时将之设为false\n\n### .shadowMap.needsUpdate : Boolean\n\n当被设为**true**, 场景中的阴影贴图会在下次**render**调用时刷新。默认是**false**\n\n如果你已经禁用了阴影贴图的自动更新(**shadowMap.autoUpdate = false**), 那么想要在下一次渲染时更新阴影的话就需要将此值设为**true**\n\n### .shadowMap.type : Integer\n\n定义阴影贴图类型 (未过滤, 关闭部分过滤, 关闭部分双线性过滤)\n\n可选值有THREE.BasicShadowMap, THREE.PCFShadowMap (默认), THREE.PCFSoftShadowMap 和 THREE.VSMShadowMap。详见Renderer constants\n\n### .sortObjects : Boolean\n\n定义渲染器是否应对对象进行排序。默认是**true**.\n\n说明: 排序用于尝试正确渲染出具有一定透明度的对象。根据定义，排序可能不总是有用。根据应用的需求，可能需要关闭排序并使其他方法来处理透明度的渲染，例如， 手动确定每个对象的显然顺序。\n\n### .state : Object\n\n包含设置WebGLRenderer.context状态的各种属性的函数。\n\n### .toneMapping : Constant\n\n默认是NoToneMapping。查看Renderer constants以获取其它备选项\n\n### .toneMappingExposure : Number\n\n色调映射的曝光级别。默认是**1**\n\n### .xr : WebXRManager\n\nProvides access to the WebXR related interface of the renderer.\n\n## 方法\n\n### .clear ( color : Boolean, depth : Boolean, stencil : Boolean ) : undefined\n\n告诉渲染器清除颜色、深度或模板缓存. 此方法将颜色缓存初始化为当前颜色。参数们默认都是**true**\n\n### .clearColor ( ) : undefined\n\n清除颜色缓存。 相当于调用.clear( true, false, false )\n\n### .clearDepth ( ) : undefined\n\n清除深度缓存。相当于调用.clear( false, true, false )\n\n### .clearStencil ( ) : undefined\n\n清除模板缓存。相当于调用.clear( false, false, true )\n\n### .clearTarget (renderTarget : WebGLRenderTarget, color : Boolean, depth : Boolean, stencil : Boolean) : undefined\n\nrenderTarget -- 需要被清除的renderTarget\ncolor -- 如果设置, 颜色会被清除\ndepth -- 如果设置, 深度缓存会被清除\nstencil -- 如果设置, 模板缓存会被清除\n\n该方法清楚了一个rendertarget。为此它会激活此endertarget\n\n### .compile ( scene : Object3D, camera : Camera ) : undefined\n\n使用相机编译场景中的所有材质。这对于在首次渲染之前预编译着色器很有用。\n\n### .copyFramebufferToTexture ( position : Vector2, texture : FramebufferTexture, level : Number ) : undefined\n\n将当前WebGLFramebuffer中的像素复制到2D纹理中。可访问[WebGLRenderingContext.copyTexImage2D](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/copyTexImage2D).\n\n### .copyTextureToTexture ( position : Vector2, srcTexture : Texture, dstTexture : Texture, level : Number ) : undefined\n\n将纹理的所有像素复制到一个已有的从给定位置开始的纹理中。可访问[WebGLRenderingContext.texSubImage2D](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texSubImage2D).\n\n### .dispose ( ) : undefined\n\n处理当前的渲染环境\n\n### .extensions.get ( extensionName : String ) : Object\n\n用于检查是否支持各种扩展，并返回一个对象，其中包含扩展的详细信息。 该方法检查以下扩展：\n\n\\- **WEBGL_depth_texture**\n\\- **EXT_texture_filter_anisotropic**\n\\- **WEBGL_compressed_texture_s3tc**\n\\- **WEBGL_compressed_texture_pvrtc**\n\\- **WEBGL_compressed_texture_etc1**\n\n### .forceContextLoss () : undefined\n\n模拟WebGL环境的丢失。需要支持 [WEBGL_lose_context](https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_lose_context) 扩展才能用。\n\n### .forceContextRestore ( ) : undefined\n\n模拟WebGL环境的恢复。需要支持 [WEBGL_lose_context](https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_lose_context) 扩展才能用。\n\n### .getClearAlpha () : Float\n\n返回一个表示当前alpha值的float，范围0到1\n\n### .getClearColor ( target : Color ) : Color\n\n返回一个表示当前颜色值的THREE.Color实例\n\n### .getContext () : WebGLRenderingContext\n\n返回当前WebGL环境\n\n### .getContextAttributes () : WebGLContextAttributes\n\n返回一个对象，这个对象中存有在WebGL环境在创建的时候所设置的属性\n\n### .getActiveCubeFace () : Integer\n\nReturns the current active cube face.\n\n### .getActiveMipmapLevel () : Integer\n\nReturns the current active mipmap level.\n\n### .getRenderTarget () : RenderTarget\n\n如果当前存在RenderTarget，则返回该值；否则返回**null**。\n\n### .getCurrentViewport () : RenderTarget\n\n返回当前视口\n\n### .getDrawingBufferSize () : Object\n\n返回一个包含渲染器绘图缓存宽度和高度(单位像素)的对象。\n\n### .getPixelRatio () : number\n\n返回当前使用设备像素比\n\n### .getSize () : Object\n\n返回包含渲染器输出canvas的宽度和高度(单位像素)的对象。\n\n### .initTexture ( texture : Texture ) : undefined\n\nInitializes the given texture. Useful for preloading a texture rather than waiting until first render (which can cause noticeable lags due to decode and GPU upload overhead).\n\n### .resetGLState ( ) : undefined\n\n将GL状态重置为默认值。WebGL环境丢失时会内部调用\n\n### .readRenderTargetPixels ( renderTarget : WebGLRenderTarget, x : Float, y : Float, width : Float, height : Float, buffer : TypedArray, activeCubeFaceIndex : Integer ) : undefined\n\nbuffer - Uint8Array is the only destination type supported in all cases, other types are renderTarget and platform dependent. See [WebGL spec](https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.12) for details.\n\n将enderTarget中的像素数据读取到传入的缓冲区中。这是[WebGLRenderingContext.readPixels](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/readPixels)()的包装器\n示例：[interactive / cubes / gpu](https://threejs.org/examples/#webgl_interactive_cubes_gpu)\n\nFor reading out a WebGLCubeRenderTarget use the optional parameter activeCubeFaceIndex to determine which face should be read.\n\n### .render ( scene : Object3D, camera : Camera ) : undefined\n\n用相机(camera)渲染一个场景(scene)或是其它类型的object。\n渲染一般是在canvas上完成的，或者是renderTarget(如果有指定)\n如果forceClear值是**true**，那么颜色、深度及模板缓存将会在渲染之前清除，即使渲染器的autoClear属性值是false\n即便forceClear设为true, 也可以通过将autoClearColor、autoClearStencil或autoClearDepth属性的值设为false来阻止对应缓存被清除。\n\n### .resetState () : undefined\n\nCan be used to reset the internal WebGL state. This method is mostly relevant for applications which share a single WebGL context across multiple WebGL libraries.\n\n### .setAnimationLoop ( callback : Function ) : undefined\n\ncallback — 每个可用帧都会调用的函数。 如果传入‘null’,所有正在进行的动画都会停止。\n\n可用来代替[requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)的内置函数. 对于WebXR项目，必须使用此函数。\n\n### .setClearAlpha ( alpha : Float ) : undefined\n\n设置alpha。合法参数是一个**0.0**到 **1.0**之间的浮点数\n\n### .setClearColor ( color : Color, alpha : Float ) : undefined\n\n设置颜色及其透明度\n\n### .setPixelRatio ( value : number ) : undefined\n\n设置设备像素比。通常用于避免HiDPI设备上绘图模糊\n\n### .setRenderTarget ( renderTarget : WebGLRenderTarget, activeCubeFace : Integer, activeMipmapLevel : Integer ) : undefined\n\nrenderTarget -- 需要被激活的renderTarget(可选)。若此参数为空，则将canvas设置成活跃render target。\nactiveCubeFace -- Specifies the active cube side (PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5) of WebGLCubeRenderTarget (optional).\nactiveMipmapLevel -- Specifies the active mipmap level (optional).\n\n该方法设置活跃rendertarget。\n\n### .setScissor ( x : Integer, y : Integer, width : Integer, height : Integer ) : undefined\n\n将剪裁区域设为(x, y)到(x + width, y + height) Sets the scissor area from\n\n### .setScissorTest ( boolean : Boolean ) : undefined\n\n启用或禁用剪裁检测. 若启用，则只有在所定义的裁剪区域内的像素才会受之后的渲染器影响。\n\n### .setSize ( width : Integer, height : Integer, updateStyle : Boolean ) : undefined\n\n将输出canvas的大小调整为(width, height)并考虑设备像素比，且将视口从(0, 0)开始调整到适合大小 将updateStyle设置为false以阻止对canvas的样式做任何改变。\n\n### .setViewport ( x : Integer, y : Integer, width : Integer, height : Integer ) : undefined\n\n将视口大小设置为(x, y)到 (x + width, y + height).\n\n## 源码\n\n[src/renderers/WebGLRenderer.js](https://github.com/mrdoob/three.js/blob/master/src/renderers/WebGLRenderer.js)\n","children":[]},{"name":"几何体","path":"../guanruihua.github.io/Front-End/Package/可视化/threejs/API","data":"","children":[{"name":"BoxGeometry.md","path":"../guanruihua.github.io/Front-End/Package/可视化/threejs/API/几何体","data":"# 立方缓冲几何体（BoxGeometry）\n\nBoxGeometry是四边形的原始几何类，它通常使用构造函数所提供的“width”、“height”、“depth”参数来创建立方体或者不规则四边形。\n\n<iframe id=\"scene\" src=\"https://threejs.org/docs/scenes/geometry-browser.html#BoxGeometry\" style=\"width: 880px; height: 420px; border: 0px; color: rgb(187, 187, 187); font-family: Inter, sans-serif; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"></iframe>\n\n## 代码示例\n\n```js\nconst geometry = new THREE.BoxGeometry( 1, 1, 1 ); \nconst material = new THREE.MeshBasicMaterial( {color: 0x00ff00} ); \nconst cube = new THREE.Mesh( geometry, material ); scene.add( cube );\n```\n\n## 构造器\n\n### BoxGeometry(width : Float, height : Float, depth : Float, widthSegments : Integer, heightSegments : Integer, depthSegments : Integer)\n\n> - width — X轴上面的宽度，默认值为1。\n> - height — Y轴上面的高度，默认值为1。\n> - depth — Z轴上面的深度，默认值为1。\n> - widthSegments — （可选）宽度的分段数，默认值是1。\n> - heightSegments — （可选）高度的分段数，默认值是1。\n> - depthSegments — （可选）深度的分段数，默认值是1。\n\n## 属性\n\n共有属性请参见其基类BufferGeometry。\n\n### .parameters : Object\n\n一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。\n\n使用上面的示例代码来作为基础：\n\n```js\ngeometry.parameters; // outputs an object {width: 1, height: 1, depth: 1, widthSegments: undefined, heightSegments: undefined}  \ncube.geometry.parameters; // as above  \ncube.geometry.parameters.width; // === 1  \ncube.geometry.parameters.widthSegments // === undefined.\n```\n\n## 方法(Methods)\n\n共有方法请参见其基类BufferGeometry。\n\n## 源代码\n\n[src/geometries/BoxGeometry.js](https://github.com/mrdoob/three.js/blob/master/src/geometries/BoxGeometry.js)\n\n![img](https://threejs.org/files/ic_mode_edit_black_24dp.svg)\n","children":[]},{"name":"CircleGeometry.md","path":"../guanruihua.github.io/Front-End/Package/可视化/threejs/API/几何体","data":"\n# 圆形缓冲几何体（CircleGeometry）\n\nCircleGeometry是欧式几何的一个简单形状，它由围绕着一个中心点的三角分段的数量所构造，由给定的半径来延展。 同时它也可以用于创建规则多边形，其分段数量取决于该规则多边形的边数。\n\n<iframe id=\"scene\" src=\"https://threejs.org/docs/scenes/geometry-browser.html#CircleGeometry\" style=\"width: 880px; height: 420px; border: 0px; color: rgb(187, 187, 187); font-family: Inter, sans-serif; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"></iframe>\n\n## 代码示例\n\n```js\nconst geometry = new THREE.CircleGeometry( 5, 32 ); \nconst material = new THREE.MeshBasicMaterial( { color: 0xffff00 } ); \nconst circle = new THREE.Mesh( geometry, material ); scene.add( circle );\n```\n\n## 构造器\n\n### CircleGeometry(radius : Float, segments : Integer, thetaStart : Float, thetaLength : Float)\n\nradius — 圆形的半径，默认值为1\nsegments — 分段（三角面）的数量，最小值为3，默认值为8。\nthetaStart — 第一个分段的起始角度，默认为0。（three o'clock position）\nthetaLength — 圆形扇区的中心角，通常被称为“θ”（西塔）。默认值是2*Pi，这使其成为一个完整的圆。\n\n## 属性\n\n共有属性请参见其基类BufferGeometry。\n\n### .parameters : Object\n\n一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。\n\n## 方法(Methods)\n\n共有方法请参见其基类BufferGeometry。\n\n## 源代码\n\n[src/geometries/CircleGeometry.js](https://github.com/mrdoob/three.js/blob/master/src/geometries/CircleGeometry.js)\n","children":[]},{"name":"DodecahedronGeometry.md","path":"../guanruihua.github.io/Front-End/Package/可视化/threejs/API/几何体","data":"# 十二面缓冲几何体（DodecahedronGeometry）\n\n一个用于创建十二面几何体的类。\n\n<iframe id=\"scene\" src=\"https://threejs.org/docs/scenes/geometry-browser.html#DodecahedronGeometry\" style=\"width: 880px; height: 420px; border: 0px; color: rgb(187, 187, 187); font-family: Inter, sans-serif; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"></iframe>\n\n\n\n## 构造器\n\n### DodecahedronGeometry(radius : Float, detail : Integer)\n\nradius — 十二面体的半径，默认值为1。\ndetail — 默认值为0。将这个值设为一个大于0的数将会为它增加一些顶点，使其不再是一个十二面体。\n\n## 属性\n\n共有属性请参见其基类PolyhedronGeometry。\n\n### .parameters : Object\n\n一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。\n\n## 方法(Methods)\n\n共有方法请参见其基类PolyhedronGeometry。\n\n## 源代码\n\n[src/geometries/DodecahedronGeometry.js](https://github.com/mrdoob/three.js/blob/master/src/geometries/DodecahedronGeometry.js)","children":[]}]},{"name":"材质","path":"../guanruihua.github.io/Front-End/Package/可视化/threejs/API","data":"","children":[{"name":"LineBasicMaterial.md","path":"../guanruihua.github.io/Front-End/Package/可视化/threejs/API/材质","data":"\n\n# 基础线条材质（LineBasicMaterial）\n\n一种用于绘制线框样式几何体的材质。\n\n## 代码示例\n\n```js\nconst material = new THREE.LineBasicMaterial( {\n  color: 0xffffff,\n  linewidth: 1,\n  linecap: 'round', //ignored by WebGLRenderer \n\tlinejoin:  'round' //ignored by WebGLRenderer \n} );\n```\n\n## 例子\n\n[WebGL / buffergeometry / drawrange](https://threejs.org/examples/#webgl_buffergeometry_drawrange)\n[WebGL / buffergeometry / lines](https://threejs.org/examples/#webgl_buffergeometry_lines)\n[WebGL / buffergeometry / lines / indexed](https://threejs.org/examples/#webgl_buffergeometry_lines_indexed)\n[WebGL / decals](https://threejs.org/examples/#webgl_decals)\n[WebGL / geometry / nurbs](https://threejs.org/examples/#webgl_geometry_nurbs)\n[WebGL / geometry / shapes](https://threejs.org/examples/#webgl_geometry_shapes)\n[WebGL / geometry / spline / editor](https://threejs.org/examples/#webgl_geometry_spline_editor)\n[WebGL / interactive / buffergeometry](https://threejs.org/examples/#webgl_interactive_buffergeometry)\n[WebGL / interactive / voxelpainter](https://threejs.org/examples/#webgl_interactive_voxelpainter)\n[WebGL / lines / colors](https://threejs.org/examples/#webgl_lines_colors)\n[WebGL / lines / dashed](https://threejs.org/examples/#webgl_lines_dashed)\n[WebGL / lines / sphere](https://threejs.org/examples/#webgl_lines_sphere)\n[WebGL / materials](https://threejs.org/examples/#webgl_materials)\n[physics / ammo / rope](https://threejs.org/examples/#physics_ammo_rope)\n\n## 构造函数(Constructor)\n\n### LineBasicMaterial( parameters : Object )\n\nparameters - (可选)用于定义材质外观的对象，具有一个或多个属性。材质的任何属性都可以从此处传入(包括从Material继承的任何属性)。\n\n属性color例外，其可以作为十六进制字符串传递，默认情况下为 **0xffffff**（白色），内部调用Color.set(color)。\n\n## 属性(Properties)\n\n共有属性请参见其基类Material。\n\n### .color : Color\n\n材质的颜色(Color)，默认值为白色 (0xffffff)。\n\n### .linewidth : Float\n\n控制线宽。默认值为 **1**。\n\n由于[OpenGL Core Profile](https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf)与 大多数平台上WebGL渲染器的限制，无论如何设置该值，线宽始终为1。\n\n### .linecap : String\n\n定义线两端的样式。可选值为 'butt', 'round' 和 'square'。默认值为 'round'。\n\n该属性对应[2D Canvas lineCap](https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/lineCap)属性， 并且会被WebGL渲染器忽略。\n\n### .linejoin : String\n\n定义线连接节点的样式。可选值为 'round', 'bevel' 和 'miter'。默认值为 'round'。\n\n该属性对应[2D Canvas lineJoin](https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/lineJoin)属性， 并且会被WebGL渲染器忽略。\n\n## 方法(Methods)\n\n共有方法请参见其基类Material。\n\n## 源码(Source)\n\n[src/materials/LineBasicMaterial.js](https://github.com/mrdoob/three.js/blob/master/src/materials/LineBasicMaterial.js)\n\n","children":[]},{"name":"LineDashedMaterial.md","path":"../guanruihua.github.io/Front-End/Package/可视化/threejs/API/材质","data":"\n\n# 虚线材质(LineDashedMaterial)\n\n一种用于绘制虚线样式几何体的材质。\n\n## 代码示例\n\n```js\nconst material = new THREE.LineDashedMaterial( { \n\tcolor: 0xffffff,\n\tlinewidth: 1, \n\tscale: 1, \n\tdashSize: 3, \n\tgapSize: 1, \n} );\n```\n\n## 例子\n\n[WebGL / lines / dashed](https://threejs.org/examples/#webgl_lines_dashed)\n\n## 构造函数(Constructor)\n\n### LineDashedMaterial( parameters : Object )\n\nparameters - (可选)用于定义材质外观的对象，具有一个或多个属性。材质的任何属性都可以从此处传入(包括从LineBasicMaterial继承的任何属性)。\n\n## 属性(Properties)\n\n共有属性请参见其基类LineBasicMaterial。\n\n### .dashSize : number\n\n虚线的大小，是指破折号和间隙之和。默认值为 **3**。\n\n### .gapSize : number\n\n间隙的大小，默认值为 **1**。\n\n### .scale : number\n\n线条中虚线部分的占比。默认值为 **1**。\n\n## 方法(Methods)\n\n共有方法请参见其基类LineBasicMaterial。\n\n## 源码(Source)\n\n[src/materials/LineDashedMaterial.js](https://github.com/mrdoob/three.js/blob/master/src/materials/LineDashedMaterial.js)","children":[]},{"name":"MeshMatcapMaterial.md","path":"../guanruihua.github.io/Front-End/Package/可视化/threejs/API/材质","data":"\n\n# MeshMatcapMaterial\n\nMeshMatcapMaterial 由一个材质捕捉（MatCap，或光照球（Lit Sphere））纹理所定义，其编码了材质的颜色与明暗。\n\n由于mapcap图像文件编码了烘焙过的光照，因此MeshMatcapMaterial 不对灯光作出反应。 它将会投射阴影到一个接受阴影的物体上(and shadow clipping works)，但不会产生自身阴影或是接受阴影。\n\n<iframe id=\"scene\" src=\"https://threejs.org/docs/scenes/material-browser.html#MeshMatcapMaterial\" style=\"width: 880px; height: 420px; border: 0px; color: rgb(187, 187, 187); font-family: Inter, sans-serif; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"></iframe>\n\n\n\n## 构造函数(Constructor)\n\n### MeshMatcapMaterial( parameters : Object )\n\nparameters - (可选)用于定义材质外观的对象，具有一个或多个属性。 材质的任何属性都可以从此处传入(包括从Material继承的任何属性)。\n\n属性color例外，其可以作为十六进制字符串传递，默认情况下为 **0xffffff**（白色），内部调用Color.set(color)。\n\n## 属性(Properties)\n\n共有属性请参见其基类Material。\n\n### .alphaMap : Texture\n\nalpha贴图是一张灰度纹理，用于控制整个表面的不透明度。（黑色：完全透明；白色：完全不透明）。 默认值为null。\n\n仅使用纹理的颜色，忽略alpha通道（如果存在）。 对于RGB和RGBA纹理，WebGL渲染器在采样此纹理时将使用绿色通道， 因为在DXT压缩和未压缩RGB 565格式中为绿色提供了额外的精度。 Luminance-only以及luminance/alpha纹理也仍然有效。\n\n### .bumpMap : Texture\n\n用于创建凹凸贴图的纹理。黑色和白色值映射到与光照相关的感知深度。凹凸实际上不会影响对象的几何形状，只影响光照。如果定义了法线贴图，则将忽略该贴图。\n\n### .bumpScale : Float\n\n凹凸贴图会对材质产生多大影响。典型范围是0-1。默认值为1。\n\n### .color : Color\n\n材质的颜色(Color)，默认值为白色 (0xffffff)。\n\n### .displacementMap : Texture\n\n位移贴图会影响网格顶点的位置，与仅影响材质的光照和阴影的其他贴图不同，移位的顶点可以投射阴影，阻挡其他对象， 以及充当真实的几何体。位移纹理是指：网格的所有顶点被映射为图像中每个像素的值（白色是最高的），并且被重定位。\n\n### .displacementScale : Float\n\n位移贴图对网格的影响程度（黑色是无位移，白色是最大位移）。如果没有设置位移贴图，则不会应用此值。默认值为1。\n\n### .displacementBias : Float\n\n位移贴图在网格顶点上的偏移量。如果没有设置位移贴图，则不会应用此值。默认值为0。\n\n### .flatShading : Boolean\n\n定义材质是否使用平面着色进行渲染。默认值为false。\n\n### .map : Texture\n\n颜色贴图。默认为null。纹理贴图颜色由漫反射颜色.color调节。\n\n### .matcap : Texture\n\nmatcap贴图，默认为null。\n\n### .normalMap : Texture\n\n用于创建法线贴图的纹理。RGB值会影响每个像素片段的曲面法线，并更改颜色照亮的方式。法线贴图不会改变曲面的实际形状，只会改变光照。 In case the material has a normal map authored using the left handed convention, the y component of normalScale should be negated to compensate for the different handedness.\n\n### .normalMapType : Integer\n\n法线贴图的类型。\n\n选项为THREE.TangentSpaceNormalMap（默认）和THREE.ObjectSpaceNormalMap。\n\n### .normalScale : Vector2\n\n法线贴图对材质的影响程度。典型范围是0-1。默认值是Vector2设置为（1,1）。\n\n## 方法(Methods)\n\n共有方法请参见其基类Material。\n\n## 源码(Source)\n\n[src/materials/MeshMatcapMaterial.js](https://github.com/mrdoob/three.js/blob/master/src/materials/MeshMatcapMaterial.js)","children":[]}]},{"name":"渲染器","path":"../guanruihua.github.io/Front-End/Package/可视化/threejs/API","data":"","children":[{"name":"CSS3DRenderer.md","path":"../guanruihua.github.io/Front-End/Package/可视化/threejs/API/渲染器","data":"# CSS 3D渲染器（CSS3DRenderer）\n\nCSS3DRenderer用于通过CSS3的[transform](https://www.w3schools.com/cssref/css3_pr_transform.asp)属性， 将层级的3D变换应用到DOM元素上。 如果你希望不借助基于canvas的渲染来在你的网站上应用3D变换，那么这一渲染器十分有趣。 同时，它也可以将DOM元素与WebGL的内容相结合。\n\n然而，这一渲染器也有一些十分重要的限制：\n\n- 它不可能使用**three.js**中的材质系统。\n- 同时也不可能使用几何体。\n\n因此，CSS3DRenderer仅仅关注普通的DOM元素，这些元素被包含到了特殊的对象中（**CSS3DObject**或者**CSS3DSprite**），然后被加入到场景图中。\n\n\n\n## 例子\n\n[molecules](https://threejs.org/examples/#css3d_molecules)\n[orthographic camera](https://threejs.org/examples/#css3d_orthographic)\n[periodictable](https://threejs.org/examples/#css3d_periodictable)\n[sprites](https://threejs.org/examples/#css3d_sprites)\n\n## 构造函数\n\n### CSS3DRenderer()\n\n## 方法\n\n### .getSize () : Object\n\n返回一个包含有渲染器宽和高的对象。\n\n### .render ( scene : Scene, camera : PerspectiveCamera ) : undefined\n\n使用perspective camera渲染scene。\n\n### .setSize (width : Number, height : Number) : undefined\n\n将渲染器尺寸重新调整为(width, height)。\n\n## 源代码\n\n[examples/jsm/renderers/CSS3DRenderer.js](https://github.com/mrdoob/three.js/blob/master/examples/jsm/renderers/CSS3DRenderer.js)","children":[]}]}]},{"name":"three.md","path":"../guanruihua.github.io/Front-End/Package/可视化/threejs","data":"# threejs\n\n> [three.js](https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene)\n","children":[]},{"name":"threejs.md","path":"../guanruihua.github.io/Front-End/Package/可视化/threejs","data":"# Three\n\n> <https://threejs.org/docs/>\n>\n\n## React 使用\n\n```js\nimport React from 'react'\nimport * as THREE from 'three'\n\nclass Index extends React.Component {\n  mdom: any = React.createRef()\n  componentDidMount() {\n    const scene = new THREE.Scene()\n    const camera = new THREE.PerspectiveCamera(\n      50,\n      window.innerWidth / window.innerHeight,\n      0.1,\n      1000\n    )\n\n    const renderer = new THREE.WebGLRenderer()\n    renderer.setSize(window.innerWidth-100, window.innerHeight-100)\n    this.mdom.current.appendChild(renderer.domElement)\n\n    // document.body.appendChild(renderer.domElement)\n\n    const geometry = new THREE.BoxGeometry()\n    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 })\n    const cube = new THREE.Mesh(geometry, material)\n    scene.add(cube)\n\n    camera.position.z = 5\n\n    function animate() {\n      requestAnimationFrame(animate)\n\n      cube.rotation.x += 0.01\n      cube.rotation.y += 0.01\n\n      renderer.render(scene, camera)\n    }\n\n    animate()\n  }\n\n  render(): React.ReactNode {\n    // return <></>\n    return <div ref={this.mdom} id='WebGL-output'></div>\n  }\n}\n\nexport default Index\n\n```\n","children":[]}]}]},{"name":"国际化.md","path":"../guanruihua.github.io/Front-End/Package","data":"# 国际化\n\n> [React项目国际化介绍（react-i18next、react-intl)](https://www.jianshu.com/p/2f8d6e0b4adb)\n>\n> [React项目多语言国际化：react-i18next插件实现——本地数据篇 - SegmentFault 思否](https://segmentfault.com/a/1190000040477248)\n","children":[]},{"name":"工具包","path":"../guanruihua.github.io/Front-End/Package","data":"","children":[{"name":"jquery","path":"../guanruihua.github.io/Front-End/Package/工具包","data":"","children":[{"name":"jquery-demo.md","path":"../guanruihua.github.io/Front-End/Package/工具包/jquery","data":"# jquery-demo\n\n## 鼠标悬停时, 弹出下拉菜单[重要]\n\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <style type=\"text/css\">\n        * {\n            margin: 0;\n            padding: 0;\n        }\n\n        ul {\n            list-style: none;\n        }\n\n        .wrap {\n            width: 330px;\n            height: 30px;\n            margin: 100px auto 0;\n            padding-left: 10px;\n            background-color: pink;\n        }\n\n        .wrap li {\n            background-color: yellowgreen;\n        }\n\n        .wrap > ul > li {\n            float: left;\n            margin-right: 10px;\n            position: relative;\n        }\n\n        .wrap a {\n            display: block;\n            height: 30px;\n            width: 100px;\n            text-decoration: none;\n            color: #000;\n            line-height: 30px;\n            text-align: center;\n        }\n\n        .wrap li ul {\n            position: absolute;\n            top: 30px;\n            display: none;\n        }\n    </style>\n   \n\n</head>\n<body>\n<div class=\"wrap\">\n    <ul>\n        <li>\n            <a href=\"javascript:void(0);\">一级菜单1</a>\n            <ul>\n                <li><a href=\"javascript:void(0);\">二级菜单1</a></li>\n                <li><a href=\"javascript:void(0);\">二级菜单2</a></li>\n                <li><a href=\"javascript:void(0);\">二级菜单3</a></li>\n            </ul>\n        </li>\n        <li>\n            <a href=\"javascript:void(0);\">一级菜单1</a>\n            <ul>\n                <li><a href=\"javascript:void(0);\">二级菜单1</a></li>\n                <li><a href=\"javascript:void(0);\">二级菜单2</a></li>\n                <li><a href=\"javascript:void(0);\">二级菜单3</a></li>\n            </ul>\n        </li>\n        <li>\n            <a href=\"javascript:void(0);\">一级菜单1</a>\n            <ul>\n                <li><a href=\"javascript:void(0);\">二级菜单1</a></li>\n                <li><a href=\"javascript:void(0);\">二级菜单2</a></li>\n                <li><a href=\"javascript:void(0);\">二级菜单3</a></li>\n            </ul>\n        </li>\n    </ul>\n</div>\n<script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/1.10.0/jquery.min.js\"></script>\n<script>\n    //入口函数\n    $(document).ready(function () {\n        //需求：鼠标放入一级li中，让他里面的ul显示。移开隐藏。\n        var jqli = $(\".wrap>ul>li\");\n\n        //绑定事件\n        jqli.mouseenter(function () {\n            //这个位置用到了this.\n            // console.log(this);  \n            //打印结果是js中的dom对象。注意：jquery对象绑定的事件中，this指js中的dom对象。【重要】\n            //让this中的ul显示出来。\n          //原生 js 的做法是：this.children[1].style.display = \"block\";\n            //把js的dom对象包装为jquery对象，然后用jquery方法操作\n            $(this).children(\"ul\").show();\n        });\n\n        //绑定事件：鼠标移开时，隐藏下拉菜单\n        jqli.mouseleave(function () {\n            $(this).children(\"ul\").hide();\n        });\n    });\n</script>\n</body>\n</html>\n```\n\n![img](http://img.smyhvae.com/20180205_1030.gif)\n\n## 突出显示\n\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <style type=\"text/css\">\n        * {\n            margin: 0;\n            padding: 0;\n        }\n\n        ul {\n            list-style: none;\n        }\n\n        body {\n            background: #000;\n        }\n\n        .wrap {\n            margin: 100px auto 0;\n            width: 630px;\n            height: 394px;\n            padding: 10px 0 0 10px;\n            background: #000;\n            overflow: hidden;\n            border: 1px solid #fff;\n        }\n\n        .wrap li {\n            float: left;\n            margin: 0 10px 10px 0;\n\n        }\n\n        .wrap img {\n            display: block;\n            border: 0;\n        }\n    </style>\n    <script src=\"jquery-1.11.1.js\"></script>\n    <script>\n        jQuery(window).ready(function () {\n            //需求：鼠标放入li中，其他的li半透明，当前盒子的opacity值为1\n            $(\".wrap\").find(\"li\").mouseenter(function () {\n                //链式编程\n                $(this).css(\"opacity\", 1).siblings(\"li\").css(\"opacity\", 0.4);\n            });\n\n            //离开wrap的时候所有的li的全部opacity值为1；\n            $(\".wrap\").mouseleave(function () {\n                $(this).children().children(\"li\").css(\"opacity\", 1);\n//                $(\".wrap li\").css(\"opacity\",1);\n            });\n        });\n    </script>\n</head>\n<body>\n<div class=\"wrap\">\n    <ul>\n        <li><a href=\"#\"><img src=\"images/01.jpg\" alt=\"\"/></a></li>\n        <li><a href=\"#\"><img src=\"images/02.jpg\" alt=\"\"/></a></li>\n        <li><a href=\"#\"><img src=\"images/03.jpg\" alt=\"\"/></a></li>\n        <li><a href=\"#\"><img src=\"images/04.jpg\" alt=\"\"/></a></li>\n        <li><a href=\"#\"><img src=\"images/05.jpg\" alt=\"\"/></a></li>\n        <li><a href=\"#\"><img src=\"images/06.jpg\" alt=\"\"/></a></li>\n    </ul>\n</div>\n</body>\n</html>\n```\n\n![img](http://img.smyhvae.com/20180205_1118_2.gif)\n\n## 淘宝精品服饰广告\n\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <style type=\"text/css\">\n        * {\n            margin: 0;\n            padding: 0;\n            font-size: 12px;\n        }\n\n        ul {\n            list-style: none;\n        }\n\n        a {\n            text-decoration: none;\n        }\n\n        .wrapper {\n            width: 298px;\n            height: 248px;\n            margin: 100px auto 0;\n            border: 1px solid pink;\n            overflow: hidden;\n        }\n\n        #left, #center, #right {\n            float: left;\n        }\n\n        #left li, #right li {\n            background: url(images/lili.jpg) repeat-x;\n        }\n\n        #left li a, #right li a {\n            display: block;\n            width: 48px;\n            height: 27px;\n            border-bottom: 1px solid pink;\n            line-height: 27px;\n            text-align: center;\n            color: black;\n        }\n\n        #left li a:hover, #right li a:hover {\n            background-image: url(images/abg.gif);\n        }\n\n        #center {\n            border-left: 1px solid pink;\n            border-right: 1px solid pink;\n        }\n    </style>\n    <script src=\"jquery-1.11.1.js\"></script>\n    <script>\n        jQuery(function () {\n            //需求：鼠标放入两侧的li中，让中间的ul中对应索引值的li显示出来，其他的隐藏。（右侧的li要+9）\n            //左侧先绑。获取绑mouseenter\n            $(\"#left li\").mouseenter(function () {\n                //显示对应索引值的中间的li\n                //alert($(this).index());  获取索引值\n                $(\"#center li\").eq($(this).index()).show().siblings(\"li\").hide();\n            });\n\n            //右侧\n            $(\"#right li\").mouseenter(function () {\n                //显示对应索引值的中间的li\n                //alert($(this).index());  获取索引值\n                $(\"#center li:eq(\" + ($(this).index() + 9) + \")\").show().siblings(\"li\").hide();\n            });\n        });\n    </script>\n</head>\n<body>\n<div class=\"wrapper\">\n\n    <ul id=\"left\">\n        <li><a href=\"#\">女靴</a></li>\n        <li><a href=\"#\">雪地靴</a></li>\n        <li><a href=\"#\">冬裙</a></li>\n        <li><a href=\"#\">呢大衣</a></li>\n        <li><a href=\"#\">毛衣</a></li>\n        <li><a href=\"#\">棉服</a></li>\n        <li><a href=\"#\">女裤</a></li>\n        <li><a href=\"#\">羽绒服</a></li>\n        <li><a href=\"#\">牛仔裤</a></li>\n    </ul>\n    <ul id=\"center\">\n        <li><a href=\"#\"><img src=\"images/女靴.jpg\" width=\"200\" height=\"250\"/></a></li>\n        <li><a href=\"#\"><img src=\"images/雪地靴.jpg\" width=\"200\" height=\"250\"/></a></li>\n        <li><a href=\"#\"><img src=\"images/冬裙.jpg\" width=\"200\" height=\"250\"/></a></li>\n        <li><a href=\"#\"><img src=\"images/呢大衣.jpg\" width=\"200\" height=\"250\"/></a></li>\n        <li><a href=\"#\"><img src=\"images/毛衣.jpg\" width=\"200\" height=\"250\"/></a></li>\n        <li><a href=\"#\"><img src=\"images/棉服.jpg\" width=\"200\" height=\"250\"/></a></li>\n        <li><a href=\"#\"><img src=\"images/女裤.jpg\" width=\"200\" height=\"250\"/></a></li>\n        <li><a href=\"#\"><img src=\"images/羽绒服.jpg\" width=\"200\" height=\"250\"/></a></li>\n        <li><a href=\"#\"><img src=\"images/牛仔裤.jpg\" width=\"200\" height=\"250\"/></a></li>\n        <li><a href=\"#\"><img src=\"images/女包.jpg\" width=\"200\" height=\"250\"/></a></li>\n        <li><a href=\"#\"><img src=\"images/男包.jpg\" width=\"200\" height=\"250\"/></a></li>\n        <li><a href=\"#\"><img src=\"images/登山鞋.jpg\" width=\"200\" height=\"250\"/></a></li>\n        <li><a href=\"#\"><img src=\"images/皮带.jpg\" width=\"200\" height=\"250\"/></a></li>\n        <li><a href=\"#\"><img src=\"images/围巾.jpg\" width=\"200\" height=\"250\"/></a></li>\n        <li><a href=\"#\"><img src=\"images/皮衣.jpg\" width=\"200\" height=\"250\"/></a></li>\n        <li><a href=\"#\"><img src=\"images/男毛衣.jpg\" width=\"200\" height=\"250\"/></a></li>\n        <li><a href=\"#\"><img src=\"images/男棉服.jpg\" width=\"200\" height=\"250\"/></a></li>\n        <li><a href=\"#\"><img src=\"images/男靴.jpg\" width=\"200\" height=\"250\"/></a></li>\n    </ul>\n    <ul id=\"right\">\n        <li><a href=\"#\">女包</a></li>\n        <li><a href=\"#\">男包</a></li>\n        <li><a href=\"#\">登山鞋</a></li>\n        <li><a href=\"#\">皮带</a></li>\n        <li><a href=\"#\">围巾</a></li>\n        <li><a href=\"#\">皮衣</a></li>\n        <li><a href=\"#\">男毛衣</a></li>\n        <li><a href=\"#\">男棉服</a></li>\n        <li><a href=\"#\">男靴</a></li>\n    </ul>\n</div>\n</body>\n</html>\n```\n\n![img](http://img.smyhvae.com/20180205_1135.gif)\n\n## 手风琴效果\n\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <style type=\"text/css\">\n        * {padding: 0;margin: 0;}\n        ul { list-style-type: none;}\n\n        .parentWrap {\n            width: 200px;\n            text-align:center;\n        }\n\n        .menuGroup {\n            border:1px solid #999;\n            background-color:#e0ecff;\n        }\n\n        .groupTitle {\n            display:block;\n            height:20px;\n            line-height:20px;\n            font-size: 16px;\n            border-bottom:1px solid #ccc;\n            cursor:pointer;\n        }\n\n        .menuGroup > div {\n            height: 200px;\n            background-color:#fff;\n            display:none;\n        }\n\n    </style>\n</head>\n<body>\n  <ul class=\"parentWrap\">\n      <li class=\"menuGroup\">\n          <span class=\"groupTitle\">标题1</span>\n          <div>我是弹出来的div1</div>\n      </li>\n      <li class=\"menuGroup\">\n          <span class=\"groupTitle\">标题2</span>\n          <div>我是弹出来的div2</div>\n      </li>\n      <li class=\"menuGroup\">\n          <span class=\"groupTitle\">标题3</span>\n          <div>我是弹出来的div3</div>\n      </li>\n      <li class=\"menuGroup\">\n          <span class=\"groupTitle\">标题4</span>\n          <div>我是弹出来的div4</div>\n      </li>\n  </ul>\n  <script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/1.10.0/jquery.js\"></script>\n    <script>\n        $(function () {\n            //需求：鼠标点击span，让他下面的div显示出来。让其他的div隐藏。\n            $(\".parentWrap span\").click(function () {\n              //$(this).next().show();\n              //让其他的隐藏\n              //点击的span的父亲li，的所有的兄弟元素li，的孩子元素div全部隐藏。\n              //$(this).parent(\"li\").siblings(\"li\").children(\"div\").hide();\n              //连式编程\n              $(this).next().show().parent(\"li\").siblings(\"li\").find(\"div\").hide();\n            });\n        })\n    </script>\n</body>\n</html>\n```\n\n![img](http://img.smyhvae.com/20180205_1120.gif)\n","children":[]},{"name":"jquery.md","path":"../guanruihua.github.io/Front-End/Package/工具包/jquery","data":"# jQuery\n\n> - 官网：<http://jquery.com/>\n> - 官网API文档：<http://api.jquery.com/>\n> - 中文汉化API文档：<http://www.css88.com/jqapi-1.9/>\n> - [jQuery 3.3.1) (html.cn)](https://www.html.cn/jqapi-1.9/category/utilities/)\n\n在用 js 写代码时，会遇到一些问题：\n\n- window.onload 事件有事件覆盖的问题，因此只能写一个事件。\n- 代码容错性差。\n- 浏览器兼容性问题。\n- 书写很繁琐，代码量多。\n- 代码很乱，各个页面到处都是。\n- 动画效果很难实现。\n\n![img](jquery.assets/20180204_1710.png)\n\n```js\nstyle.\n div{\n    display: none;\n  }\n\nhtml\n button | 显示五个div盒子和设置内容\n - for(var i=0; i< 5; i++)\n  div\n\n\n<script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/1.10.0/jquery.min.js\"></script>\n<script>\n  $(document).ready(function() {\n  var btn = $('button')\n  var div = $('div')\n  btn.click(function() {\n    div.show(1000);\n    div.html('tomorrow!');\n    div.show(3000).html(1111);\n  })\n})\n</script>\n```\n\n## jquery两大特点\n\n1. **链式编程**: 比如`.show()`和`.html()`可以连写成`.show().html()`\n\n   > 链式编程原理: return this\n\n2. **隐式迭代**: 在方法的内部会匹配到所有元素进行循环遍历, 执行响应的方法; 而不用我们在进行循环, 简化操作\n\n   > 多元素的值, 大部分情况会返回第一个元素的值\n\n## jquery版本\n\n> jquery-1.11.1.js: 未压缩版\n>\n> jquery-1.11.1.min.js:压缩版( 项目上线时候使用)\n\n## jquery入口函数\n\n| 写法                                     | 描述                                                   |\n| ---------------------------------------- | ------------------------------------------------------ |\n| `$(document).ready(function () { ... })` | 文档加载完毕，**图片不加载**的时候，就可以执行         |\n| `$(function (){ ... })`                  | 文档加载完成后, **图片不加载**的时候就执行             |\n| `$(window).ready(function(){ ... })`     | 文档加载完毕, **图片也加载完毕**的时候, 在执行这个函数 |\n\n**jQuery入口函数与js入口函数的区别**：\n\n区别一：书写个数不同：\n\n- Js 的入口函数只能出现一次，出现多次会存在事件覆盖的问题。\n- jQuery 的入口函数，可以出现任意多次，并不存在事件覆盖问题。\n\n区别二：执行时机不同：\n\n- Js的入口函数是在**所有的文件资源加载**完成后，才执行。这些**文件资源**包括：页面文档、外部的js文件、外部的css文件、图片等。\n- jQuery的入口函数，是在文档加载完成后，就执行。文档加载完成指的是：DOM树加载完成后，就可以操作DOM了，不用等到所有的**外部资源**都加载完成。\n\n文档加载的顺序：从上往下，边解析边执行。\n\n## jquery基础\n\n> $===jQuery\n>\n> jQuery对象转换为DOM对象: `jqbox = $(mybox)`\n>\n> ```js\n> $(); // 调用上面我们自定义的函数$\n> $(document）.ready(function(){}); // 调用入口函数\n> $(function(){}); // 调用入口函数\n> $(“#btnShow”) // 获取id属性为btnShow的元素\n> $(“div”) // 获取所有的div标签元素\n> ```\n>\n>\n\n## 选择器\n\n### jquery基本选择器\n\n![img](jquery.assets/20180204_2125.png)\n\n### 层级选择器\n\n![img](jquery.assets/20180204_2138.png)\n\n### 基本过滤选择器\n\n![img](http://img.smyhvae.com/20180204_2150.png)\n\n> `:not(selector)`  : 除了selector都要选择$(\":not(selector)\")\n>\n> `:header`: 选择标题元素(就是h标签)$(\":header\")\n\n### 属性选择器\n\n![img](jquery.assets/20180204_2155.png)\n\n## 过滤器\n\n### 子元素过滤器\n\n```js\n:first-child\n:last-child\n:nth-child():选择第n个子元素\n:nth-last-child():选择倒数第n个子元素\n:only-child选择唯一的子元素\n```\n\n### 内容过滤器\n\n```js\n:contains(str):选择内容含有str的元素\n:empty:选择元素内容为空的\n:parent:选择拥有子节点的\n:has():选择包含指定选择器\n```\n\n### 可见过滤器\n\n> :hidden   不可见元素\n>\n> :visible 可见元素\n\n### 筛选选择器\n\n![img](jquery.assets/20180204_2200.png)\n\n## 事件\n\n### **常用事件**\n\n```js\n$(selector).action(function(){.......});\n```\n\n### 常见文档/窗口事件\n\n```js\nready()就绪\n\nload()加载\n\nunload()卸载(跳到其他页面)\n```\n\n### 键盘事件\n\n```js\nkeydown()按下\n\nkeypress()按下并快速释放\n\nkeyup()释放\n```\n\n### 鼠标事件\n\n```js\nclick()\n\ndbclick()\n\nhover()\n\nmousedown()\n\nmouseenter()鼠标刚进入被选中元素\n\nmouseleave()鼠标刚离开被选中元素\n\nmousemove()鼠标移动事件\n\nmouseout()离开(离开子元素也会触发)\n\nmouseover()穿过\n\nmouseup()鼠标按键被释放事件\n\ntoggle()一次绑定多个函数,指定元素被点击依次执行其中一个函数\n\n$(selector).toggle(function(){},function(){},function(){}....);\n```\n\n### **JQuery事件绑定 解除**\n\n#### 事件绑定\n\n> bind()可以给指定元素绑定一个或多个事件\n\n```js\n//绑定一个事件\n$(selector).bind(event(事件名称),[data,] function(){})  \n//可以绑定多个事件 \n$(selector).bind(event1(事件名称) event2(事件名称) event3(事件名称),[data,] function(){})  \n//可以绑定多个事件和方法\n$(selector).bind({\n    event1(事件名称),[data,] function(){},     \n    event2(事件名称),[data,] function(){},    \n    event3(事件名称),[data,] function(){}}\n  )\n```\n\ndelegate():给指定元素的**子元素**绑定一个或多个事件\n\n```js\n$(selector).delegate(childSelector, event, [data,] function)\n```\n\n==on():给指定元素或子元素绑定一个或多个事件(包含前两个的用法)==\n\n```js\n$(selector).on(event,[childSelector,] [data,] function)\n```\n\n#### 事件解除\n\n```js\n//unbind()\n\n$(selector).unbind([event] [,function]) \n\n//undelegate\n\n$(selector).undelegate([childSelector] [,event] [,function]) \n\n//off()\n\n$(selector).off(event, [childSelector,] [data,] function)\n```\n\n### **jQuery特效**\n\n#### **隐藏和显示**\n\n```js\nhide()\n\nshow()\n\ntoggle()用来切换hide和show\n```\n\n#### **淡入和淡出**\n\n> 【duration可以选择slow，fast】\n\n```js\nfadeIn():淡入\n\nfadeOut():淡出直到隐藏\n\nfadeToggle():切换淡入和淡出\n\nfadeTo():用于将元素变成指定通明度\n\n$(selector).fadeTo(duration(持续时间), opacity(通明度) [, callback])\n```\n\n#### **滑动**\n\n```js\nslideDown():向下滑动\n\nslideUp():向上滑动\n\nslideToggle():切换向上向下滑动\n```\n\n#### **动画**\n\n> animate({params} [,duration], [,callback])\n>\n> > params是形成动画的css属性(可以设置多个)\n> >\n> > duration:表示规定的效果时长\n> >\n> > callback:动画结束后执行的函数\n\n#### **方法链接**\n\n```js\n$(selector).action1(),action2().action3()...;\n```\n\n#### **停止动画**\n\n```js\n$(selector).stop([stopAll] [, gotoEnd]);//这两个都是布尔值\n```\n\n## **jQuery HTML DOM**\n\n### jQuery获取和设置\n\n#### 获取和设置常用的方法\n\n```js\ntext():文本内容\n\nhtml():包括html标签本身\n\nval():表单字段的值\n\nattr():指定元素的属性值\n\ncss():指定元素的css值\n```\n\n#### jQuery添加\n\n```js\nappend():在指定元素内部的结尾插入内容\n\nprepend():在只当以元素的内部的开头插入内容\n\nafter():在指定元素之后添加内容\n\nbefore():在指定元素之前添加内容\n```\n\n#### 删除remove()\n\n```js\n$(\"p\").remove(\".style01\");//删除class=\"style01\"所有的p标签\n```\n\n#### 清空empty()\n\n#### 清空removeAttr()\n\n> 删除元素的指定属性\n\n#### 类属性\n\n```js\naddClass()//添加class\nremoveClass()\ntoggleClass()\n```\n\n#### 尺寸\n\n```js\nwidth:\nheight\ninnerWidth包括内边距\ninnerHeight\nouterWidth包括内边距和边框\nouterHeight\n```\n\n### **jQuery遍历**\n\n**后代遍历**\n\n```js\n$(selector).children([selector2] [\".style1\"])\n$(selector).find(selector2)//查找后代全部元素\n$(selector).filter(selector2)//过滤器,只会选择符合selector2的元素\n```\n\n**同胞遍历(具有相同的父元素)**\n\n```js\nsiblings:所有兄弟节点\nnext:指定的下一个\nnextAll:指定元素后全部\nnextUntil(selector,selector):指定元素后的指定范围\nprev:指定的前一个\nprevAll:指定前全部\nprevUntil(selector,selector):指定元素前的指定范围\n```\n\n**祖先遍历(父,祖父,曾祖父等)**\n\n```js\nparent():指定元素的直接父元素\nparents():指定元素的全部祖先元素\nparentsUntil():指定元素向上指定范围的所有祖先元素\n```\n\n## **AJAX技术**\n\n### **load()方法**\n\n> $(selector).load(URL [, data] [, callback])\n>\n> - URL规定获取数据的URL地址,可以是文本,XML,JSON\n>\n> - data:用于规定与请求一起发送给服务器的字符串(该字符串以键/值对合集)\n>\n> - callback:load()完成后执行的函数\n\n```js\n$(\"#demo\").load(\"test.txt\")\n\n$(\"#demo\").load(\"test.txt div.style01\")\n\n$(selector).load(URL [, data] ,function(response, status,xhr){    \n  //回调函数代码    \n  //response:调用成功时的结果内容    \n  //status:调用状态,eg:success 和 error    \n  //xhr:表示XMLHttpRequest对象 \n})\n```\n\n### **get()方法**\n\n> $.get(URL  [, data] [, success] [, dataType]);\n>\n> ​ dataType规定从服务器端获取的数据类型,eg:XML,JSON,HTML等\n\n### **post()方法**\n\n> $.post(URL [, data] [, success] [, dataType]);\n\n### **ajax()方法**\n\n```js\n$.ajax({    \n  url: \"demo.php\",    \n  method:\"POST\",    \n  data:{username:\"admin\", password:\"123\"},    \n  dataType: \"json\",    \n  success:function(){alert(\"请求成功\");},    \n  error: function(){alert(\"请求失败\");} \n});\n```\n","children":[]}]},{"name":"lodash.md","path":"../guanruihua.github.io/Front-End/Package/工具包","data":"# Lodash\n\n## 前言\n\n> Lodash 是一个一致性, 模块化, 高性能的javascript使用工具库\n>\n> [官网](https://www.lodashjs.com/)\n>\n> [Lodash Documentation](https://lodash.com/docs/4.17.15)\n\n### 安装\n\n```html\n<script src = \"lodash.js\"></script>\n```\n\n```shell\nnpm i loadash --save\n```\n\n```js\n// Load the full build.\nvar _ = require('lodash');\n// Load the core build.\nvar _ = require('lodash/core');\n// Load the FP build for immutable auto-curried iteratee-first data-last methods.\nvar fp = require('lodash/fp');\n \n// Load method categories.\nvar array = require('lodash/array');\nvar object = require('lodash/fp/object');\n \n// Cherry-pick methods for smaller browserify/rollup/webpack bundles.\nvar at = require('lodash/at');\nvar curryN = require('lodash/fp/curryN');\n```\n\n## 数组\n\n## 集合\n\n## 函数\n\n## 对象\n\n### pick\n\n```js\nvar object = { 'a': 1, 'b': '2', 'c': 3 };\n \n_.pick(object, ['a', 'c']);\n// => { 'a': 1, 'c': 3 }\n```\n\n### pickBy\n\n> 第二参数, 就是过滤出只要获取的值类型\n\n```js\nvar object = { 'a': 1, 'b': '2', 'c': 3 };\n \n\n_.pickBy(object, _.isNumber);\n// => { 'a': 1, 'c': 3 }\n```\n\n### omit\n\n```js\nvar object = { 'a': 1, 'b': '2', 'c': 3 };\n \n_.omit(object, ['a', 'c']);\n// => { 'b': '2' }\n```\n\n## 字符串\n\n## Seq\n\n## number\n\n>- clamp : 限制数据的输出范围\n>- inRange : 判断范围\n>- random ： 生成随机树\n\n```js\nlet _ = require('lodash')\n\nlet runArray = [\n  () => [\n      // 后两个参数 分别是上限和下限\n    _.clamp( -10, -5, 5),\n    _.clamp( 10, -5, 5),\n  ],\n  () => [\n      // 判断第一个值是否在后两个参数定义的范围中\n      // 若 总共只有两个参数 第二参数 为上限 下限为 0 , 若第二个参数为负数, 上限为0 , 下限为该参数\n      _.inRange(3, 2, 4),\n      _.inRange(3, 4),\n      _.inRange(3, -4),\n      _.inRange(-2, -4),\n  ],\n  () => [\n      // 三个参数分别为: 上限[0], 下限[1], 是否为浮点数\n      _.random(5), // 改范围为0 - 5\n      _.random(1, 5),\n      _.random(1, 5, true),\n      _.random(1.1, 5.1),// 前两个参数为浮点型, 就会认为是浮点型\n  ]\n]\n\nrunArray[runArray.length - 1]().map(item => console.log(item)) \n```\n\n## lang\n\n> - castArray : 强制转换为数组\n> - clone :  浅拷贝\n> - deepDeep : 深拷贝\n\n```js\nlet _ = require('lodash')\n\nlet runArray = [\n  () => [\n    // 强制转换为数组\n    _.castArray(1),\n    // => [1]\n    _.castArray({ 'a': 1 }),\n    // => [{ 'a': 1 }]\n    _.castArray('abc'),\n    // => ['abc']\n    _.castArray(null),\n    // => [null]\n    _.castArray(undefined),\n    // => [undefined]\n    _.castArray(),\n    // => []\n  ],\n  () => [\n    (()=>{\n      // 浅拷贝\n      let objects = [{ 'a': 1 }, { 'b': 2 }];\n      let shallow = _.clone(objects);\n      console.log(shallow[0] === objects[0]);\n      // => true\n\n    })(),\n    (()=>{\n      // 深拷贝\n      let objects = [{ 'a': 1 }, { 'b': 2 }];\n      let deep = _.cloneDeep(objects);\n      console.log(objects[0] === deep[0]);\n      console.log( deep );\n      console.log( objects[0]['a'] === deep[0]['a']);\n      // => false\n    })(),\n  ]\n\n]\n\nrunArray[runArray.length - 1]().map(item => console.log(item)) \n```\n","children":[]},{"name":"mock.md","path":"../guanruihua.github.io/Front-End/Package/工具包","data":"# mock\n\n> [官网](http://mockjs.com/)\n>\n> [示例](http://mockjs.com/examples.html)\n>\n> [文档](https://github.com/nuysoft/Mock/wiki)\n>\n> 用于生成随机数据, 帮助前端可以提前工作\n\n## 安装\n\n```bash\nnpm install mockjs\nnpm install mockjs -g # 全局安装\n\n$ random url \n# => http://rmcpx.org/funzwc\n$ random -h #帮助\n```\n\n```js\n// 使用 Mock\nvar Mock = require('mockjs')\nvar data = Mock.mock({\n    // 属性 list 的值是一个数组，其中含有 1 到 10 个元素\n    'list|1-10': [{\n        // 属性 id 是一个自增数，起始值为 1，每次增 1\n        'id|+1': 1\n    }]\n})\n// 输出结果\nconsole.log(JSON.stringify(data, null, 4))\n```\n\n## 语法规范\n\n> 1. 数据模板定义规范\n> 2. 数据占位定义规范\n\n### 数据模板定义规范\n\n```bash\n// 属性名   name\n// 生成规则 rule\n// 属性值   value\n'name|rule': value\n```\n\n> 七种格式\n>\n> 1. 'name|min-max': value\n> 2. 'name|count': value\n> 3. 'name|min-max.dmin-dmax': value\n> 4. 'name|min-max.dcount': value\n> 5. 'name|count.dmin-dmax': value\n> 6. 'name|count.dcount': value\n> 7. 'name|+step': value\n\n## Mock.mock()\n\n### Mock.mock( rurl?, rtype?, template|function( options ) )\n\n> 根据数据模板生成模拟数据。\n\n#### Mock.mock( template )\n\n> 根据数据模板生成模拟数据。\n\n#### Mock.mock( rurl, template )\n\n> 记录数据模板。当拦截到匹配 `rurl` 的 Ajax 请求时，将根据数据模板 `template` 生成模拟数据，并作为响应数据返回。\n\n#### Mock.mock( rurl, function( options ) )\n\n> 记录用于生成响应数据的函数。当拦截到匹配 `rurl` 的 Ajax 请求时，函数 `function(options)` 将被执行，并把执行结果作为响应数据返回。\n\n#### Mock.mock( rurl, rtype, template )\n\n> 记录数据模板。当拦截到匹配 `rurl` 和 `rtype` 的 Ajax 请求时，将根据数据模板 `template` 生成模拟数据，并作为响应数据返回。\n\n#### Mock.mock( rurl, rtype, function( options ) )\n\n> 记录用于生成响应数据的函数。当拦截到匹配 `rurl` 和 `rtype` 的 Ajax 请求时，函数 `function(options)` 将被执行，并把执行结果作为响应数据返回。\n\n#### rurl\n\n> 可选。\n>\n> 表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。例如 `/\\/domain\\/list\\.json/`、`'/domian/list.json'`。\n\n#### rtype\n\n> 可选。\n>\n> 表示需要拦截的 Ajax 请求类型。例如 `GET`、`POST`、`PUT`、`DELETE` 等。\n\n#### template\n\n> 可选。\n> 表示数据模板，可以是对象或字符串。例如 `{ 'data|1-10':[{}] }`、`'@EMAIL'`。\n\n#### function(options)\n\n> 可选。\n>\n> 表示用于生成响应数据的函数。\n\n##### options\n\n指向本次请求的 Ajax 选项集，含有 `url`、`type` 和 `body` 三个属性，参见 [XMLHttpRequest 规范](https://xhr.spec.whatwg.org/)。\n\n> 从 1.0 开始，Mock.js 通过覆盖和模拟原生 XMLHttpRequest 的行为来拦截 Ajax 请求，不再依赖于第三方 Ajax 工具库（例如 jQuery、Zepto 等）。\n\n## Mock.setup( settings )\n\n- Mock.setup( settings )\n\n配置拦截 Ajax 请求时的行为。支持的配置项有：`timeout`。\n\n### settings\n\n必选。\n\n配置项集合。\n\n#### timeout\n\n可选。\n\n指定被拦截的 Ajax 请求的响应时间，单位是毫秒。值可以是正整数，例如 `400`，表示 400 毫秒 后才会返回响应内容；也可以是横杠 `'-'` 风格的字符串，例如 `'200-600'`，表示响应时间介于 200 和 600 毫秒之间。默认值是`'10-100'`。\n\n```\nMock.setup({\n    timeout: 400\n})\nMock.setup({\n    timeout: '200-600'\n})\n```\n\n> 目前，接口 `Mock.setup( settings )` 仅用于配置 Ajax 请求，将来可能用于配置 Mock 的其他行为。\n\n## Mock.Random\n\nMock.Random 是一个工具类，用于生成各种随机数据。\n\n**Mock.Random 的方法在数据模板中称为『占位符』，书写格式为 `@占位符(参数 [, 参数])` 。**\n\n```js\nvar Random = Mock.Random\nRandom.email()\n// => \"n.clark@miller.io\"\nMock.mock('@email')\n// => \"y.lee@lewis.org\"\nMock.mock( { email: '@email' } )\n// => { email: \"v.lewis@hall.gov\" }\n```\n\n**注意**\n\n### 方法\n\nMock.Random 提供的完整方法（占位符）如下：\n\n| Type          | Method                                                       |\n| ------------- | ------------------------------------------------------------ |\n| Basic         | boolean, natural, integer, float, character, string, range, date, time, datetime, now |\n| Image         | image, dataImage                                             |\n| Color         | color                                                        |\n| Text          | paragraph, sentence, word, title, cparagraph, csentence, cword, ctitle |\n| Name          | first, last, name, cfirst, clast, cname                      |\n| Web           | url, domain, email, ip, tld                                  |\n| Address       | region, province, city, county, zip                          |\n| Helper        | capitalize, upper, lower, pick, shuffle                      |\n| Miscellaneous | guid, id                                                     |\n\n### 扩展\n\nMock.Random 中的方法与数据模板的 `@占位符` 一一对应，在需要时还可以为 Mock.Random 扩展方法，然后在数据模板中通过 `@扩展方法` 引用。例如：\n\n```js\nRandom.extend({\n    constellation: function(date) {\n        var constellations = ['白羊座', '金牛座', '双子座', '巨蟹座', '狮子座', '处女座', '天秤座', '天蝎座', '射手座', '摩羯座', '水瓶座', '双鱼座']\n        return this.pick(constellations)\n    }\n})\nRandom.constellation()\n// => \"水瓶座\"\nMock.mock('@CONSTELLATION')\n// => \"天蝎座\"\nMock.mock({\n    constellation: '@CONSTELLATION'\n})\n// => { constellation: \"射手座\" }\n```\n\n## Mock.valid()\n\n### Mock.valid( template, data )\n\n- Mock.valid( template, data )\n\n校验真实数据 `data` 是否与数据模板 `template` 匹配。\n\n#### template\n\n必选。\n\n表示数据模板，可以是对象或字符串。例如 `{ 'list|1-10':[{}] }`、`'@EMAIL'`。\n\n#### data\n\n必选。\n\n表示真实数据。\n\n```js\nvar template = {\n    name: 'value1'\n}\nvar data = {\n    name: 'value2'\n}\nMock.valid(template, data)\n// =>\n[\n    {\n        \"path\": [\n            \"data\",\n            \"name\"\n        ],\n        \"type\": \"value\",\n        \"actual\": \"value2\",\n        \"expected\": \"value1\",\n        \"action\": \"equal to\",\n        \"message\": \"[VALUE] Expect ROOT.name'value is equal to value1, but is value2\"\n    }\n]\n```\n\n## Mock.toJSONSchema()\n\n### Mock.toJSONSchema( template )\n\n- Mock.toJSONSchema( template )\n\n把 Mock.js 风格的数据模板 `template` 转换成 [JSON Schema](http://json-schema.org/)。\n\n#### template\n\n必选。\n\n表示数据模板，可以是对象或字符串。例如 `{ 'list|1-10':[{}] }`、`'@EMAIL'`。\n\n```js\nvar template = {\n    'key|1-10': '★'\n}\nMock.toJSONSchema(template)\n// =>\n{\n    \"name\": undefined,\n    \"path\": [\n        \"ROOT\"\n    ],\n    \"type\": \"object\",\n    \"template\": {\n        \"key|1-10\": \"★\"\n    },\n    \"rule\": {},\n    \"properties\": [{\n        \"name\": \"key\",\n        \"path\": [\n            \"ROOT\",\n            \"key\"\n        ],\n        \"type\": \"string\",\n        \"template\": \"★\",\n        \"rule\": {\n            \"parameters\": [\"key|1-10\", \"key\", null, \"1-10\", null],\n            \"range\": [\"1-10\", \"1\", \"10\"],\n            \"min\": 1,\n            \"max\": 10,\n            \"count\": 3,\n            \"decimal\": undefined,\n            \"dmin\": undefined,\n            \"dmax\": undefined,\n            \"dcount\": undefined\n        }\n    }]\n}\nvar template = {\n    'list|1-10': [{}]\n}\nMock.toJSONSchema(template)\n// =>\n{\n    \"name\": undefined,\n    \"path\": [\"ROOT\"],\n    \"type\": \"object\",\n    \"template\": {\n        \"list|1-10\": [{}]\n    },\n    \"rule\": {},\n    \"properties\": [{\n        \"name\": \"list\",\n        \"path\": [\"ROOT\", \"list\"],\n        \"type\": \"array\",\n        \"template\": [{}],\n        \"rule\": {\n            \"parameters\": [\"list|1-10\", \"list\", null, \"1-10\", null],\n            \"range\": [\"1-10\", \"1\", \"10\"],\n            \"min\": 1,\n            \"max\": 10,\n            \"count\": 6,\n            \"decimal\": undefined,\n            \"dmin\": undefined,\n            \"dmax\": undefined,\n            \"dcount\": undefined\n        },\n        \"items\": [{\n            \"name\": 0,\n            \"path\": [\"data\", \"list\", 0],\n            \"type\": \"object\",\n            \"template\": {},\n            \"rule\": {},\n            \"properties\": []\n        }]\n    }]\n}\n```\n","children":[]},{"name":"Monaco Editor.md","path":"../guanruihua.github.io/Front-End/Package/工具包","data":"# Monaco Editor\n\n> [Monaco Editor](https://github.com/microsoft/monaco-editor) 是微软开发的一款开源在线代码编辑器。它是 [VSCode](https://code.visualstudio.com/) 的浏览器版本， 随着近年 VSCode 大热，Monaco Editor 也逐渐走红。目前虽未登上 Online Editor 领域的宝座，却也隐燃有超越几位老前辈之势。\n>\n> [闲谈Monaco Editor-基本使用 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/47746336)\n\n","children":[]},{"name":"RxJS.md","path":"../guanruihua.github.io/Front-End/Package/工具包","data":"# RxJs\n\n> [概览 | RxJS 中文文档](https://cn.rx.js.org/manual/overview.html#-)\n\n","children":[]},{"name":"自定义片段.md","path":"../guanruihua.github.io/Front-End/Package/工具包","data":"# 自定义片段\n\n## 1. 获取文件后缀名\n\n使用场景：上传文件判断后缀名\n\n```js\n/**\n * 获取文件后缀名\n * @param {String} filename\n */\nexport function getExt(filename) {\n    if (typeof filename == 'string') {\n        // 如果文件没有后缀名，返回null\n        if(!filename.includes('.')){return null}\n        return filename\n            .split('.')\n            .pop()\n            .toLowerCase()\n    } else {\n        throw new Error('filename must be a string type')\n    }\n}\n\n```\n\n使用方式\n\n```js\ngetExt(\"1.mp4\") //->mp4\n\n```\n\n## 2. 复制内容到剪贴板\n\n```js\nexport function copyToBoard(value) {\n    const element = document.createElement('textarea')\n    document.body.appendChild(element)\n    element.value = value\n    element.select()\n    if (document.execCommand('copy')) {\n        document.execCommand('copy')\n        document.body.removeChild(element)\n        return true\n    }\n    document.body.removeChild(element)\n    return false\n}\n```\n\n使用方式:\n\n```js\n//如果复制成功返回true\ncopyToBoard('lalallala')\n\n```\n\n原理：\n\n1. 创建一个textare元素并调用select()方法选中\n2. document.execCommand('copy')方法，拷贝当前选中内容到剪贴板。\n\n## 3. 休眠多少毫秒\n\n```js\n/**\n * 休眠xxxms\n * @param {Number} milliseconds\n */\nexport function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms))\n}\n\n//使用方式\nconst fetchData=async()=>{\n\tawait sleep(1000)\n}\n\n```\n\n## 4. 生成随机字符串\n\n```js\n/**\n * 生成随机id\n * @param {*} length\n * @param {*} chars\n */\nexport function uuid(length=8, chars='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') {\n    let result = ''\n    for (let i = length; i > 0; --i)\n        result += chars[Math.floor(Math.random() * chars.length)]\n    return result\n}\n\n```\n\n使用方式\n\n```js\n//第一个参数指定位数，第二个字符串指定字符，都是可选参数，如果都不传，默认生成8位\nuuid()  \n\n```\n\n使用场景：用于前端生成随机的ID,毕竟现在的Vue和React都需要绑定key\n\n## 5. 简单的深拷贝\n\n```js\n/**\n *深拷贝\n * @export\n * @param {*} obj\n * @returns\n */\nexport function deepCopy(obj) {\n    if (typeof obj != 'object') {\n        return obj\n    }\n    if (obj == null) {\n        return obj\n    }\n    return JSON.parse(JSON.stringify(obj))\n}\n\n```\n\n缺陷：只拷贝对象、数组以及对象数组，对于大部分场景已经足够\n\n```js\nconst person={name:'xiaoming',child:{name:'Jack'}}\ndeepCopy(person) //new person\n\n```\n\n## 6. 数组去重\n\n```js\n/**\n * 数组去重\n * @param {*} arr\n */\nexport function uniqueArray(arr) {\n    if (!Array.isArray(arr)) {\n        throw new Error('The first parameter must be an array')\n    }\n    if (arr.length == 1) {\n        return arr\n    }\n  // 若不支持set, 可以 使用 arr.filter((item, i ) => arr.indexOf(item) === i)\n    return [...new Set(arr)]\n}\n\n```\n\n原理是利用Set中不能出现重复元素的特性\n\n```js\nuniqueArray([1,1,1,1,1])//[1]\n\n```\n\n## 7. 对象转化为FormData对象\n\n```js\n/**\n * 对象转化为formdata\n * @param {Object} object\n */\n\n export function getFormData(object) {\n    const formData = new FormData()\n    Object.keys(object).forEach(key => {\n        const value = object[key]\n        if (Array.isArray(value)) {\n            value.forEach((subValue, i) =>\n                formData.append(key + `[${i}]`, subValue)\n            )\n        } else {\n            formData.append(key, object[key])\n        }\n    })\n    return formData\n}\n\n```\n\n使用场景：上传文件时我们要新建一个FormData对象，然后有多少个参数就append多少次，使用该函数可以简化逻辑\n\n使用方式：\n\n```js\nlet req={\n    file:xxx,\n    userId:1,\n    phone:'15198763636',\n    //...\n}\nfetch(getFormData(req))\n\n```\n\n## 8.保留到小数点以后n位\n\n```js\n// 保留小数点以后几位，默认2位\nexport function cutNumber(number, no = 2) {\n    if (typeof number != 'number') {\n        number = Number(number)\n    }\n    return Number(number.toFixed(no))\n}\n\n```\n\n使用场景：JS的浮点数超长，有时候页面显示时需要保留2位小数","children":[]}]},{"name":"拖拽","path":"../guanruihua.github.io/Front-End/Package","data":"","children":[{"name":"react-beautiful-dnd.md","path":"../guanruihua.github.io/Front-End/Package/拖拽","data":"# [React-beautiful-dnd]()\r\n\r\n## [源码](https://github.dev/atlassian/react-beautiful-dnd)\r\n\r\n## Examples\r\n\r\n<https://codesandbox.io/examples/package/react-beautiful-dnd-grid>\r\n","children":[]},{"name":"react-dnd.md","path":"../guanruihua.github.io/Front-End/Package/拖拽","data":"# [react-dnd](https://react-dnd.github.io/react-dnd/examples/sortable/cancel-on-drop-outside)\r\n\r\n## [React DND -在鼠标移动时获取拖动元素的坐标](https://cloud.tencent.com/developer/ask/sof/854392)\r\n\r\n## [Multi Backend](https://github.com/louisbrunner/dnd-multi-backend/tree/main/packages/react-dnd-multi-backend#migrating-from-2xx)\r\n\r\n<https://github.com/LouisBrunner/dnd-multi-backend/tree/main/packages/react-dnd-multi-backend>\r\n\r\n## demo\r\n\r\n<https://github.dev/pinkqq/react-antd/blob/main/src/pages/dndPro/index.js>\r\n<https://codesandbox.io/s/6v7l7z68jk?file=/src/components/DragItem.js:3388-3398>\r\n<https://github.com/LouisBrunner/dnd-multi-backend/tree/main/packages/react-dnd-multi-backend/examples>\r\n\r\n<https://codesandbox.io/s/github/react-dnd/react-dnd/tree/gh-pages/examples_ts/03-nesting/drag-sources?from-embed=&file=/src/TargetBox.tsx>\r\n","children":[]}]},{"name":"模板引擎","path":"../guanruihua.github.io/Front-End/Package","data":"","children":[{"name":"ejs.md","path":"../guanruihua.github.io/Front-End/Package/模板引擎","data":"# EJS\n\n## 特性\n\n> - 快速编译与绘制输出\n> - 简洁的模板标签：<% %>\n> - 自定义分割符（例如：用 <? ?> 替换 <% %>）\n> - 引入模板片段\n> - 同时支持服务器端和浏览器 JS 环境\n> - JavaScript 中间结果静态缓存\n> - 模板静态缓存\n> - 兼容 [Express](http://expressjs.com/) 视图系统\n>\n\n## 入门\n\n### 安装\n\n```bash\nnpm install ejs\n```\n\n### 用法\n\n将模板字符串和一些数据作为参数传递给 EJS，Duang，HTML 出来了。\n\n```javascript\nlet ejs = require('ejs'),\n    people = ['geddy', 'neil', 'alex'],\n    html = ejs.render('<%= people.join(\", \"); %>', {people: people});\n```\n\n### 浏览器支持\n\n从这里下载 [最新的浏览器版本](https://github.com/mde/ejs/releases/latest)，然后引入页面即可。\n\n```markup\n<script src=\"ejs.js\"></script>\n<script>\n  let people = ['geddy', 'neil', 'alex'],\n      html = ejs.render('<%= people.join(\", \"); %>', {people: people});\n</script>\n```\n\n## 文档\n\n### 实例\n\n```markup\n<% if (user) { %>\n  <h2><%= user.name %></h2>\n<% } %>\n```\n\n### 用法\n\n```javascript\nlet template = ejs.compile(str, options);\ntemplate(data);\n// => 输出渲染后的 HTML 字符串\n\nejs.render(str, data, options);\n// => 输出渲染后的 HTML 字符串\n\nejs.renderFile(filename, data, options, function(err, str){\n    // str => 输出渲染后的 HTML 字符串\n});\n```\n\n### 参数\n\n- `cache` 缓存编译后的函数，需要指定 `filename`\n- `filename` 被 `cache` 参数用做键值，同时也用于 include 语句\n- `context` 函数执行时的上下文环境\n- `compileDebug` 当值为 `false` 时不编译调试语句\n- `client` 返回独立的编译后的函数\n- `delimiter` 放在角括号中的字符，用于标记标签的开与闭\n- `debug` 将生成的函数体输出\n- `_with` 是否使用 `with() {}` 结构。如果值为 `false`，所有局部数据将存储在 `locals` 对象上。\n- `localsName` 如果不使用 `with` ，localsName 将作为存储局部变量的对象的名称。默认名称是 `locals`\n- `rmWhitespace` 删除所有可安全删除的空白字符，包括开始与结尾处的空格。对于所有标签来说，它提供了一个更安全版本的 `-%>` 标签（在一行的中间并不会剔除标签后面的换行符)。\n- `escape` 为 `<%=` 结构设置对应的转义（escape）函数。它被用于输出结果以及在生成的客户端函数中通过 `.toString()` 输出。(默认转义 XML)。\n- `outputFunctionName` 设置为代表函数名的字符串（例如 `'echo'` 或 `'print'`）时，将输出脚本标签之间应该输出的内容。\n- `async` 当值为 `true` 时，EJS 将使用异步函数进行渲染。（依赖于 JS 运行环境对 async/await 是否支持）\n\n### 标签含义\n\n- `<%` '脚本' 标签，用于流程控制，无输出。\n- `<%_` 删除其前面的空格符\n- `<%=` 输出数据到模板（输出是转义 HTML 标签）\n- `<%-` 输出非转义的数据到模板\n- `<%#` 注释标签，不执行、不输出内容\n- `<%%` 输出字符串 '<%'\n- `%>` 一般结束标签\n- `-%>` 删除紧随其后的换行符\n- `_%>` 将结束标签后面的空格符删除\n\n### 包含（include）\n\n通过 `include` 指令将相对于模板路径中的模板片段包含进来。(需要提供 'filename' 参数。) 例如，如果存在 \"./views/users.ejs\" 和 \"./views/user/show.ejs\" 两个模板文件，你可以通过 `<%- include('user/show'); %>` 代码包含后者。\n\n你可能需要能够输出原始内容的标签 (`<%-`) 用于 include 指令，避免对输出的 HTML 代码做转义处理。\n\n```markup\n<ul>\n  <% users.forEach(function(user){ %>\n    <%- include('user/show', {user: user}); %>\n  <% }); %>\n</ul>\n```\n\n### 自定义分隔符\n\n可针对单个模板或全局使用自定义分隔符：\n\n```javascript\nlet ejs = require('ejs'),\n    users = ['geddy', 'neil', 'alex'];\n\n// 单个模板文件\nejs.render('<?= users.join(\" | \"); ?>', {users: users},\n    {delimiter: '?'});\n// => 'geddy | neil | alex'\n\n// 全局\nejs.delimiter = '$';\nejs.render('<$= users.join(\" | \"); $>', {users: users});\n// => 'geddy | neil | alex'\n```\n\n### 缓存\n\nEJS 附带了一个基本的进程内缓存，用于缓在渲染模板过程中所生成的临时 JavaScript 函数。 通过 Node 的 `lru-cache` 库可以很容易地加入 LRU 缓存：\n\n```javascript\nlet ejs = require('ejs'),\n    LRU = require('lru-cache');\nejs.cache = LRU(100); // 具有 100 条内容限制的 LRU 缓存\n```\n\n如果要清除 EJS 缓存，调用 `ejs.clearCache` 即可。如果你正在使用的是 LRU 缓存并且需要设置不同的限额，则只需要将 `ejs.cache` 重置为 一个新的 LRU 实例即可。\n\n### 自定义文件加载器\n\n默认的文件加载器是 `fs.readFileSync`，如果你想要的自定义它, 设置`ejs.fileLoader` 即可。\n\n```javascript\nlet ejs = require('ejs');\nlet myFileLoader = function (filePath) {\n  return 'myFileLoader: ' + fs.readFileSync(filePath);\n};\n\nejs.fileLoader = myFileLoad;\n```\n\n使用此功能，您可以在读取模板之前对其进行预处理。\n\n### 布局（Layouts）\n\nEJS 并未对块（blocks）提供专门的支持，但是可以通过 包含页眉和页脚来实现布局，如下所示：\n\n```javascript\n<%- include('header'); -%>\n<h1>\n  Title\n</h1>\n<p>\n  My page\n</p>\n<%- include('footer'); -%>\n```\n\n### 客户端支持\n\n从[latest release](https://github.com/mde/ejs/releases/latest) 链接下载 `./ejs.js` 或 `./ejs.min.js` 文件。或者，你可以 clone 这个仓库并 通过执行 `jake build` 自己编译（或者执行 `$(npm bin)/jake build`，如果 jake 不是安装在全局环境的话）。\n\n在页面中包含上面的任意一个文件，然后 `ejs` 就全局可用了\n\n#### 示例\n\n```javascript\n<div id=\"output\"></div>\n<script src=\"ejs.min.js\"></script>\n<script>\n  let people = ['geddy', 'neil', 'alex'],\n      html = ejs.render('<%= people.join(\", \"); %>', {people: people});\n  // With jQuery:\n  $('#output').html(html);\n  // Vanilla JS:\n  document.getElementById('output').innerHTML = html;\n</script>\n```\n\n#### 注意事项\n\n大多数情况下，EJS 将会按照我们的预期运行; 但是, 仍然需要注意：\n\n1. 显然, 如果你没有文件系统的访问权限, `ejs.renderFile` 将无法正常工作。\n2. 相同的原因, 除非为 include 设置一个回调函数，否则 include 无法正常工作。如下所示：\n\n```javascript\nlet str = \"Hello <%= include('file', {person: 'John'}); %>\",\n      fn = ejs.compile(str, {client: true});\n\nfn(data, null, function(path, d){ // include callback\n  // path -> 'file'\n  // d -> {person: 'John'}\n  // Put your code here\n  // Return the contents of file as a string\n}); // returns rendered string\n```\n\n### 在 Express 中使用 EJS\n\n```javascript\nlet express = require('express');\nlet app = express();\n\napp.set('view engine', 'ejs');\n// 配置选项\napp.set('view options', {delimiter: '?'});\n\n\napp.get('/', (req, res) => {\n  res.render('index', {foo: 'FOO'});\n});\n\napp.listen(4000, () => console.log('Example app listening on port 4000!'));\n```\n\n#### 自定义渲染功能\n\n```js\nlet ejsOptions = {delimiter: '?'};\napp.engine('ejs', (path, data, cb) => {\n  ejs.renderFile(path, data, ejsOptions, cb);\n});\n```\n\n#### 应用程序局部变量\n\n设置的任何属性都将混合到传递到视图引擎的呈现调用的对象中，并且名称匹配已知选择属性的属性将作为选择传递给 EJS：`app.locals``data`\n\n```\napp.locals.delimiter = '?'\n```\n\n这允许您在一个位置设置 EJS 选项，但无法用于不安全的选项，如 。`root`\n\n#### 使用数据传递选择\n\n调用中具有名称匹配已知选择属性的数据对象中的任何属性都将作为选择传递给 EJS：`render`\n\n```js\napp.get('/', (req, res) => {\n  res.render('index', {foo: 'FOO', delimiter: '?'});\n});\n```\n\n此方法意味着您必须在每个渲染调用中传递 EJS 选项，并且不能使用不安全的选项，如 。`root`\n\n```js\napp.get(\"/\", function(request, response){\n   response.render(\"index.ejs\", {list: \"lists\"});\n});\n```\n","children":[]},{"name":"Pug.md","path":"../guanruihua.github.io/Front-End/Package/模板引擎","data":"# Pug\n\n> - 安装 `npm install pug`\n> - 全局安装pug命令行工具 `npm isstall pug-cli -g`\n> - 执行编译 `index.pug` : `pug index.pug`(默认是压缩版)\n>   - `pug index.pug -P`:标准版的html\n>   - `pug index.pug -o a` 将index.html输入到a目录下\n>   - 批量编译: `pug 文件夹名`: 会编译当前文件夹下全部pug文件\n> - 概要: `pug.compile()`会把Pug代码编译成一个js函数, 该函数可以传入数据(局部变量, locals);\n>   - 传入响应的数据, 会返回数据渲染的HTML字符串\n> - [pug官方文档](https://www.pugjs.cn/api/express.html)\n\n```js\n// template.pug\np #{name}的 Pug 代码!\n\n// js代码\nconst pug = require('pug');\n// 编译这份代码\nconst compiledFunction = pug.compileFile('template.pug');\n// 渲染一组数据\nconsole.log(compiledFunction({\n  name: '李莉'\n}));\n// \"<p>李莉的 Pug 代码！</p>\"\n// 渲染另外一组数据\nconsole.log(compiledFunction({\n  name: '张伟'\n}));\n// \"<p>张伟的 Pug 代码！</p>\"\n\n// 编译并使用一组数据渲染 template.pug\nconsole.log(pug.renderFile('template.pug', {\n  name: 'Timothy'\n}));\n// \"<p>Timothy 的 Pug 代码！</p>\"\n```\n\n## 基础语法\n\n### 属性Attribute\n\n| Pug代码                                                      | html                                                         | 描述                  |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------- |\n| a(href='baidu.com') 百度                                     | `<a href=\"baidu.com\">百度</a>`                               |                       |\n| a(class='button' href='baidu.com') 百度                      | `<a class=\"button\" href=\"baidu.com\">百度</a>`                |                       |\n| a(class='button', href='baidu.com') 百度                     | `<a class=\"button\" href=\"baidu.com\">百度</a>`                | 可以加入,号作为分隔符 |\n| a(style={color:'red'})                                       | `<a style=\"color: red;\"></a>`                                |                       |\n| - var authenticated = true<br/>body(class=authenticated ? 'authed' : 'anon') | `<body class=\"authed\"></body>`                               |                       |\n| input(<br/>  type='checkbox'<br/>  name='agreement'<br/>  checked<br/>) | `<input type=\"checkbox\" name=\"agreement\" checked=\"checked\" />` | 多行属性              |\n| div(class='div-class', (click)='play()')<br/>div(class='div-class' '(click)'='play()') | `<div class=\"div-class\" (click)=\"play()\"></div>`<br/>`<div class=\"div-class\" (click)=\"play()\"></div>` | 特殊字符              |\n| div(escaped=\"<code>\">)<br>div(unescaped!=\"<code>\")           | `<div escaped=\"&lt;code&gt;\"></div>`<br>`<div unescaped=\"<code>\"></div>` | 转义属性优先使用!=    |\n\n### 类和ID\n\n```pug\na.button\n.content\n=\"\\n\"\na#main-link\n#content\n```\n\n```html\n<a class=\"button\"></a>\n<div class=\"content\"></div>\n<a id=\"main\"></a>\n<div id=\"content\"></div>\n```\n\n### 结构语法\n\n#### 树状\n\n```pug\nul\n li Item A\n li Item B\n li Item C\n```\n\n```html\n<ul>\n  <li>Item A</li>\n  <li>Item B</li>\n  <li>Item C</li>\n</ul>\n```\n\n#### 内联\n\n> - pug: `a:img`\n> - html: `<a><img/></a>`\n\n#### 自闭合\n\n```js\nimg\ninput\nimg/\ninput/\n```\n\n```html\n<img/>\n<input/><img/>\n<input/>\n```\n\n### 标签\n\n#### DOCTYPE\n\n| PUG                                                   | HTML                                                       |\n| ----------------------------------------------------- | ---------------------------------------------------------- |\n| doctype html                                          | `<!DOCTYPE html>`                                          |\n| doctype html PUBLIC \"-//W3C//DTD XHTML Basic 1.1//EN\" | `<!DOCTYPE HTML PUBLIC \"-//W3C//DTD XHTML Basic 1.1//EN\">` |\n\n#### 标签嵌入\n\n> - 写法`#[标签名(标签属性) 标签内容]`\n\n```pug\np.\n  这是一个很长很长而且还很无聊的段落，还没有结束，是的，非常非常地长。\n  突然出现了一个 #[strong 充满力量感的单词]，这确实让人难以 #[em 忽视]。\n```\n\n```html\n<p>\n   这是一个很长很长而且还很无聊的段落，还没有结束，是的，非常非常地长。\n  突然出现了一个 <strong> 充满力量感的单词</strong>，这确实让人难以 <em> 忽视</em>。\n</p>\n```\n\n### 内容\n\n#### 管道文本\n\n> - 每行前面添加`|`字符\n\n```pug\n| 纯文本当然也可以包括 <strong>HTML</strong> 内容。\np\n  | 但它必须单独起一行。\n```\n\n```html\n纯文本当然也可以包括 <strong>HTML</strong> 内容。\n<p>但它必须单独起一行。</p>\n```\n\n#### 标签内文本\n\n> - 一个空格\n>\n> - ```pug\n>   p 纯文本当然也可以包括 <strong>HTML</strong> 内容。\n>   ```\n>\n> - ```html\n>   <p>纯文本当然也可以包括 <strong>HTML</strong> 内容。</p>\n>   ```\n\n#### 嵌入大文本\n\n> - 标签后接一个`.`\n> - 日常嵌入脚本或样式\n\n```pug\nscript.\n   console.log('using Pug')\n```\n\n```html\n<script>\n  console.log('using Pug')\n</script>\n```\n\n### 注释\n\n#### 单行注释\n\n```pug\n// 注释\n```\n\n#### 不输出注释\n\n```pug\n//- 不输出的代码\n```\n\n#### 块注释\n\n```pug\nbody\n //\n  块状注释\n```\n\n#### 条件注释\n\n```pug\n<!--[if IE 8]>\n<html lang=\"en\" class=\"lt-ie9\">\n<![endif]-->\n<!--[if gt IE 8]><!-->\n<html lang=\"en\">\n<!--<![endif]-->\n```\n\n```html\n<!--[if IE 8]>\n<html lang=\"en\" class=\"lt-ie9\">\n<![endif]-->\n<!--[if gt IE 8]><!-->\n<html lang=\"en\">\n<!--<![endif]-->\n```\n\n## 逻辑语法\n\n```pug\n- for (var x=0;x<3:x++)\n li item\n```\n\n```html\n <li>item</li>\n <li>item</li>\n <li>item</li>\n```\n\n### 变量\n\n### 内容变量\n\n```pug\n- var title = \"On Dogs: Man's Best Friend\";\n- var author = \"enlore\";\n- var theGreat = \"<span>转义!</span>\";\n- var msg = \"not my inside voice\";\n- var url = 'pug-test.html';\n- var btnType = 'info'\n- var btnSize = 'lg'\n\nbutton(type='button' class='btn btn-' + btnType + ' btn-' + btnSize)\n= '\\n'\nbutton(type='button' class=`btn btn-${btnType} btn-${btnSize}`)//模板字符串\na(href='/' + url) 链接\np This is #{msg.toUpperCase()}\nh1= title\np #{author} 笔下源于真情的创作。\np 这是安全的：#{theGreat}\n\ndiv#foo(data-bar=\"foo\")&attributes({'data-foo': 'bar'}) //<div id=\"foo\" data-bar=\"foo\" data-foo=\"bar\"></div>\n```\n\n### 条件\n\n#### if-else\n\n```pug\n- var user = { description: 'foo bar baz' }\n- var authorised = false\n#user\n  if user.description\n    h2.green 描述\n    p.description= user.description\n  else if authorised\n    h2.blue 描述\n    p.description.\n      用户没有添加描述。\n      不写点什么吗……\n  else\n    h2.red 描述\n    p.description 用户没有描述\n```\n\n```html\n<div id=\"user\">\n  <h2 class=\"green\">描述</h2>\n  <p class=\"description\">foo bar baz</p>\n</div>\n```\n\n#### switch\n\n```pug\n- var friends = 10\ncase friends\n  when 0\n    p break\n  when 1\n    p 您有一个朋友\n  default\n    p 您有 #{friends} 个朋友\n```\n\n### 循环\n\n> - 目前支持each 和while\n>\n#### each\n\n```pug\nul\n each val,index in [1, 2, 3, 4, 5]\n  li= val +  ':' + index\n  \nul\n  each val, index in {1:'一',2:'二',3:'三'}\n    li= index + ': ' + val\n\n- var values = [];\nul\n  each val in values.length ? values : ['没有内容']\n    li= val\n\n\n//当values为空时, 就会执行else\n- var values = [];\nul\n  each val in values\n    li= val\n  else\n    li 没有内容\n```\n\n#### while\n\n```pug\n- var n = 0;\nul\n  while n < 4\n    li= n++\n```\n\n### 混入mixin\n\n> - `+link(class='btn')`  等价于 `+link()(class=\"btn')`\n\n```\n//- 定义\nmixin list(name)\n  ul\n    li= name\n    li foo\n    li bar\n    li baz\n//- 使用\n+list\n+list\n p 这是文章\n+list('grh')\n\n//生成两个ul列表\n```\n\n## 文件包含\n\n> - include\n\n```pug\n//- index.pug\ndoctype html\nhtml\n  head\n    style\n      include style.css\n  body\n    h1 我的网站\n    p 欢迎来到我这简陋得不能再简陋的网站。\n    script\n      include script.js\n```\n\n## 文件继承\n\n> - block , extends\n\nlayout.pug\n\n```pug\nhtml\n  head\n　　 meta(charset=\"UTF-8\")\n    title 我的站点 - #{title}\n    block scripts\n      script(src='/jquery.js')\n  body\n    block content\n    block foot\n      #footer\n        p 一些页脚的内容\n```\n\npet.pug\n\n```pug\np= petName\n```\n\npage-a.pug\n\n```pug\nextends layout.pug\n\nblock scripts\n  script(src='/jquery.js')\n  script(src='/pets.js')\n\nblock content\n  h1= title\n  - var pets = ['猫', '狗']\n  each petName in pets\n    include pet.pug\n```\n\n### 继承拓展\n\n> - prepend 在前面添加head\n> - append 在后面添加footer\n> - block关键词可以省略\n\npage-b.pug\n\n```pug\nextends layout.pug\n\nblock prepend head\n  script(src='/vendor/three.js')\n\nblock append footer\n  script(src='/game.js')\n```\n\n## 模板\n\nindex.pug\n\n```pug\ndoctype html\nhtml\n    head\n        meta(charset=\"UTF-8\")\n        title= documentTitle\n        each val in srcStyles\n            link(href= baseStyle +'/' + val)\n    body\n        header.hd\n            nav.hd-navbar.m-navbar.m-navbar_primary\n                .hd-navbar-tel 联系方式: #{tel}\n            ul.hd-navbar-nav\n                each val in mainNavItem\n                    li.Hnn-item.m-btn.m-btn_info\n                        a(href=\"#\")= val\n\n        section.main\n            h1.main-title 我的文档\n            p.main-content.\n                这是一个很长很长而且还很无聊的段落，还没有结束，是的，非常非常地长。\n                突然出现了一个 #[strong 充满力量感的单词]，这确实让人难以 #[em 忽视]。\n\n        footer.ft\n            p Copyright (c) 小火柴的蓝色理想\n\n        each val in srcScripts\n            script(src=baseScript + '/' + val)\n```\n\n```json\n//- data.json\n{\n    \"documentTitle\":\"测试文档\",\n    \"tel\":\"400-888-8888\",\n    \"mainNavItem\":['登录','注册','关于','帮助'],\n    \"baseStyle\":'style',\n    \"srcStyles\":['bootstrap.css','main.css'],\n    \"baseScript\":'/js',\n    \"srcScripts\":['jquery.js','app.js']\n}\n```\n\n执行`pug index.pug -P -w -O data.json`\n","children":[]}]},{"name":"测试","path":"../guanruihua.github.io/Front-End/Package","data":"","children":[{"name":"jest","path":"../guanruihua.github.io/Front-End/Package/测试","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Front-End/Package/测试/jest","data":"# JEST\r\n\r\n> Jest是Facebook开源的一套JavaScript测试框架， 它集成了断言、JSDom、覆盖率报告等开发者所需要的所有测试工具。\r\n>\r\n> 官方简介：一个令人愉快的javascript测试框架\r\n\r\n## 使用\r\n\r\n```shell\r\nnpm init -y\r\nnpm add --dev jest\r\n\r\n# 全局安装\r\nnpm i -g jest\r\n```\r\n","children":[]},{"name":"js.md","path":"../guanruihua.github.io/Front-End/Package/测试/jest","data":"# hello world(jest)\r\n\r\n> 编写以下两个js文件，控制台输入命令jest --no-cache --verbose(全局安装)，或者npx jest --no-cache --verbose（项目依赖安装），jest会搜索项目下所有测试脚本并执行输出测试结果。\r\n\r\n```js\r\n\r\n// hello.js\r\nmodule.exports = function(){\r\n    return \"hello world\";\r\n}\r\n// hello.test.js\r\nconst hello = require('../hello');\r\n\r\nit('should ', () => {\r\n    expect(hello()).toBe('hello world');\r\n});\r\n```\r\n\r\n# 基础测试知识\r\n\r\n## jest文件和目录命名规范\r\n\r\n> 待测试文件: hello.js 测试脚本文件取名：hello.test.jsorhello.spec.js 测试目录:testsor__tests__\r\n\r\n## 测试函数\r\n\r\n```js\r\n\r\ntest(\"测试用列描述信息\",()=>{\r\n\r\n})\r\n// or\r\nit(\"测试用例描述信息\",()=>{\r\n\r\n})\r\n```\r\n\r\n## 断言函数\r\n\r\n测试即运行结果是否与我们预期结果一致 断言函数用来验证结果是否正确.\r\n\r\n```js\r\nexpect(运行结果).toBe(期望的结果);\r\n//常见断言方法\r\nexpect({a:1}).toBe({a:1})//判断两个对象是否相等\r\nexpect(1).not.toBe(2)//判断不等\r\nexpect({ a: 1, foo: { b: 2 } }).toEqual({ a: 1, foo: { b: 2 } })\r\nexpect(n).toBeNull(); //判断是否为null\r\nexpect(n).toBeUndefined(); //判断是否为undefined\r\nexpect(n).toBeDefined(); //判断结果与toBeUndefined相反\r\nexpect(n).toBeTruthy(); //判断结果为true\r\nexpect(n).toBeFalsy(); //判断结果为false\r\nexpect(value).toBeGreaterThan(3); //大于3\r\nexpect(value).toBeGreaterThanOrEqual(3.5); //大于等于3.5\r\nexpect(value).toBeLessThan(5); //小于5\r\nexpect(value).toBeLessThanOrEqual(4.5); //小于等于4.5\r\nexpect(value).toBeCloseTo(0.3); // 浮点数判断相等\r\nexpect('Christoph').toMatch(/stop/); //正则表达式判断\r\nexpect(['one','two']).toContain('one'); //不解释\r\n```\r\n\r\n## 分组函数\r\n\r\n```js\r\ndescribe(\"关于每个功能或某个组件的单元测试\",()=>{\r\n    // 不同用例的单元测试\r\n})\r\n```\r\n\r\n## 常见命令\r\n\r\n```js\r\n{\r\n  \"nocache\": \"jest --no-cache\", //清除缓存\r\n  \"watch\": \"jest --watchAll\", //实时监听\r\n  \"coverage\": \"jest --coverage\",  //生成覆盖测试文档\r\n  \"verbose\": \"npx jest --verbose\" //显示测试描述\r\n}\r\n```\r\n\r\n## 基础测试\r\n\r\n### 对象等值测试\r\n\r\n```js\r\ndescribe('对象测试', () => {\r\n\r\n    it(\"是否同一个对象\", () => {\r\n        const foo = { a: 1 }\r\n        expect(foo).toBe(foo)\r\n    })\r\n\r\n    it(\"对象值是否相等\", () => {\r\n        expect({ a: 1, foo: { b: 2 } }).toEqual({ a: 1, foo: { b: 2 } })\r\n    })\r\n\r\n    test('对象赋值', () => {\r\n        const data = { one: 1 };\r\n        data['two'] = 2;\r\n        expect(data).toEqual({ one: 1, two: 2 });\r\n    });\r\n\r\n});\r\n```\r\n\r\n### 异步测试\r\n\r\n> 异步测试脚本执行完，单元测试就结束了，如果需要延时才能断言的结果，单元测试函数需要设置done形参，在定时回调函数中调用，显示的通过单元测试已完成。\r\n\r\n```js\r\ndescribe('异步操作测试',  () => {\r\n    function foo(callback) {\r\n        console.log('foo...')\r\n        setTimeout(() => {\r\n            callback && callback();\r\n        }, 1000)\r\n    }\r\n    it('异步测试', (done) => {\r\n        function bar() {\r\n            console.log('bar..')\r\n            done();\r\n        }\r\n        foo(bar);\r\n    });\r\n});\r\n```\r\n\r\n### 定时器测试（异步测试）及断言\r\n\r\n> 基于jest提供的两个方法jest.useFakeTimers和jest.runAllTimers可以更优雅的对延时功能的测试。\r\n\r\n```js\r\n\r\ndescribe('定时器相关测试', () => {\r\n    // 开启定时函数模拟\r\n    jest.useFakeTimers();\r\n\r\n    function foo(callback) {\r\n        console.log('foo...')\r\n        setTimeout(() => {\r\n            callback && callback();\r\n        }, 1000)\r\n    }\r\n    it('断言异步测试', () => {\r\n        //创建mock函数，用于断言函数被执行或是执行次数的判断\r\n        const callback = jest.fn();\r\n        foo(callback);\r\n        expect(callback).not.toBeCalled();\r\n        //快进，使所有定时器回调\r\n        jest.runAllTimers();\r\n        expect(callback).toBeCalled();\r\n    })\r\n});\r\n```\r\n\r\n### Dom测试\r\n\r\n> 实现dom渲染测试，以及点击事件等交互功能测试。\r\n\r\n```js\r\n\r\ndescribe('Dom测试', () => {\r\n    it('测试按钮是否被渲染 ', () => {\r\n        document.body.innerHTML = `\r\n    <div>\r\n        <button id='btn'>小按钮</button>\r\n    </div> `\r\n        console.log(document.getElementById('btn'), document.getElementById('btn').toString())\r\n        expect(document.getElementById('btn')).not.toBeNull();\r\n        expect(document.getElementById('btn').toString()).toBe(\"[object HTMLButtonElement]\");\r\n    });\r\n\r\n    it('测试点击事件', () => {\r\n        const onclick = jest.fn();\r\n        document.body.innerHTML = `\r\n        <div>\r\n            <button id='btn'>小按钮</button>\r\n        </div> `\r\n        const btn = document.getElementById('btn');\r\n        expect(onclick).not.toBeCalled();\r\n        btn.onclick = onclick;\r\n        btn.click();\r\n        expect(onclick).toBeCalled();\r\n        expect(onclick).toHaveBeenCalledTimes(1);\r\n        btn.click();\r\n        btn.click();\r\n        expect(onclick).toHaveBeenCalledTimes(3);\r\n    });\r\n});\r\n```\r\n\r\n## Vue测试\r\n\r\n### 5.1 安装unit-jest\r\n\r\n> 如果你创建的项目没有安装unit-jest依赖包，可以通过vue add @vue/unit-jest命令添加。否则通过脚手架手动模式创建一个包含unit-jest的项目。\r\n\r\n### 基础知识\r\n\r\n> mount和shallowMount的区别 - shallowMount只挂载指定组件，不挂载子组件 - mount挂载所有组件\r\n\r\n> Vue的渲染机制 默认情况下 Vue 会异步地批量执行更新 (在下一轮 tick)，以避免不必要的 DOM 重绘或者是观察者计算\r\n\r\n> 异步测试需要在nextTick()之后执行\r\n\r\n### hello Jest Vue\r\n\r\n> vue组件渲染测试\r\n\r\n```js\r\nit('挂载countBtn组件', () => {\r\n        const wraper = shallowMount(CountBtn);\r\n        const btn = wraper.find(\"button\");\r\n        expect(wraper.html()).toBe(`<button>点击次数0</button>`);\r\n    });\r\n```\r\n\r\n### 事件测试\r\n\r\n> vue组件点击事件测试\r\n\r\n```js\r\n\r\nit('测试countBtn组件点击', (done) => {\r\n    const wraper = shallowMount(CountBtn);\r\n    const btn = wraper.find(\"button\");\r\n    expect(wraper.html()).toBe(`<button>点击次数0</button>`);\r\n    btn.trigger('click');\r\n    setTimeout(() => {\r\n        expect(wraper.html()).toBe(`<button>点击次数1</button>`);\r\n        done();\r\n    }, 1000);\r\n});\r\n\r\nit('优雅的测试点击事件', async () => {\r\n    const wraper = shallowMount(CountBtn);\r\n    const btn = wraper.find(\"button\");\r\n    expect(wraper.html()).toBe(`<button>点击次数0</button>`);\r\n    btn.trigger('click');\r\n    await wraper.vm.$nextTick();\r\n    expect(wraper.html()).toBe(`<button>点击次数1</button>`);\r\n});\r\n```\r\n\r\n### axios异步请示测试\r\n\r\n> 模拟异步请示，测试渲染结果是否一致\r\n\r\n```vue\r\n\r\n<!-- User.vue -->\r\n<template>\r\n<table>\r\n    <tr v-for=\"item in list\" :key=\"item.id\">\r\n        <td>{{item.id}}</td>\r\n        <td>{{item.name}}</td>\r\n        <td>{{item.age}}</td>\r\n    </tr>\r\n</table>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    data() {\r\n        return {\r\n            list: []\r\n        }\r\n    },\r\n    created() {\r\n        this.$http.get('/user').then(({\r\n            data\r\n        }) => {\r\n            this.list = data\r\n        })\r\n    }\r\n}\r\n</script>\r\n```\r\n\r\n```js\r\n// User.spec.js\r\nimport { mount } from '@vue/test-utils';\r\nimport User from '@/components/User';\r\n\r\nit('测试用户组件', async() => {\r\n    const wrapper = mount(User,{\r\n        mocks:{\r\n            $http:{\r\n                get: url=>Promise.resolve({data:[{id:1,name:'xxxx',age:18},{id:2,name:'yyyy',age:19}]})\r\n            }\r\n        }\r\n    })\r\n    console.log(wrapper.html())\r\n    // 渲染前\r\n    expect(wrapper.html()).toBe('<table></table>');\r\n    await wrapper.vm.$nextTick();\r\n    // 渲染后\r\n    // console.log(wrapper.html())\r\n    // console.log(wrapper.find('tr'))\r\n    expect(wrapper.findAll('tr').length).toBe(2)\r\n    expect(wrapper.findAll('td').at(2).html()).toBe('<td>18</td>')\r\n\r\n});\r\n\r\n```\r\n","children":[]},{"name":"ts.md","path":"../guanruihua.github.io/Front-End/Package/测试/jest","data":"# ts-jest\r\n\r\n## 安装\r\n\r\n```shell\r\nnpm i -D jest typescript ts-jest @types/jest\r\n```\r\n","children":[]}]}]},{"name":"虚拟列表","path":"../guanruihua.github.io/Front-End/Package","data":"","children":[{"name":"react-window.md","path":"../guanruihua.github.io/Front-End/Package/虚拟列表","data":"# [react-window]()\r\n\r\n> [源码](https://github.com/bvaughn/react-window)\r\n> [api](https://react-window.vercel.app/#/examples/list/fixed-size)\r\n\r\n1、不用全部加载出所有的DOM节点。默认只渲染可视区域及可视区域外的一个节点，此属性可自定义设置。\r\n2、可用于处理大型数据列表。当使用在大型数据列表中，可避免因为数据的更新而导致大量的重新渲染。\r\n\r\n## FixedSizeList（固定尺寸的列表）\r\n\r\n```js\r\n\r\nimport { FixedSizeList } from 'react-window';\r\n/**\r\n    * 每个列表项的组件\r\n    * @param index：列表项的下标；style：列表项的样式（此参数必须传入列表项的组件中，否则会出现滚动到下方出现空白的情况）\r\n    **/\r\nconst Row = ({ index, style }) => (\r\n  <div style={style}>Row {index}</div>\r\n);\r\n\r\nconst Example = () => (\r\n  <FixedSizeList\r\n    height={150} // 列表可视区域的高度\r\n    itemCount={1000} // 列表数据长度\r\n    itemSize={35} // 列表行高\r\n    width={300} //列表可视区域的宽度\r\n  >\r\n    {Row}\r\n  </FixedSizeList>\r\n);\r\n```\r\n\r\n## VariableSizeList （可变尺寸列表）\r\n\r\n```jsx\r\n\r\nimport { VariableSizeList } from 'react-window';\r\n\r\nconst rowHeights = new Array(1000)\r\n  .fill(true)\r\n  .map(() => 25 + Math.round(Math.random() * 50));\r\n\r\nconst getItemSize = index => rowHeights[index]; // 此处采用随机数作为每个列表项的高度\r\n /**\r\n    * 每个列表项的组件\r\n    * @param index：列表项的下标；style：列表项的样式（此参数必须传入列表项的组件中，否则会出现滚动到下方出现空白的情况）\r\n    **/\r\nconst Row = ({ index, style }) => (\r\n  <div style={style}>Row {index}</div>\r\n);\r\n\r\nconst Example = () => (\r\n  <VariableSizeList\r\n    height={150} // 列表可视区域的高度\r\n    itemCount={1000} // 列表数据长度\r\n    itemSize={getItemSize} // 设置列表项的高度\r\n    layout= \"vertical\" // （vertical/horizontal） 默认为vertical，此为设置列表的方向\r\n    width={300}\r\n  >\r\n    {Row}\r\n  <VariableSizeList>\r\n);\r\n````\r\n\r\n## 结合`react-virtualized-auto-sizer`使列表自适应当前页面的宽高\r\n\r\n> 使用AutoSizer可是列表宽高为当前父组件的100%\r\n\r\nimport { FixedSizeList } from \"react-window\";\r\nimport AutoSizer from \"react-virtualized-auto-sizer\";\r\nconst Example = () => (\r\n  <AutoSizer>\r\n    {({ height, width }) => (\r\n      <FixedSizeList\r\n        className=\"List\"\r\n        height={height}\r\n        itemCount={1000}\r\n        itemSize={35}\r\n        width={width}\r\n      >\r\n        {Row}\r\n      </FixedSizeList>\r\n    )}\r\n  </AutoSizer>\r\n);\r\n\r\n## 常见问题\r\n\r\n> 在使用VariableSizeList 会遇到列表项样式缓存没有被清除导致行高一直和第一次可视区域里展示的一样。可使用组件的属性`resetAfterIndex(index: number, shouldForceUpdate: boolean = true): void`来清除样式。\r\n\r\n```jsx\r\n\r\nclass Example extends Component {\r\nconstructor(props) {\r\n        super(props)\r\n        this.myRef = React.createRef()\r\n    }\r\n......\r\n\r\nrender() {\r\n......\r\n  <VariableSizeList\r\n    className='friends-list'\r\n    height={66}\r\n    itemCount={100}\r\n    itemSize={64}\r\n    itemSize={getItemSize}\r\n    ref={this.myRef}\r\n    width={260}>\r\n    {Row}\r\n  </VariableSizeList>\r\n......\r\n<button onClick={()=>{this.myRef.current.resetAfterIndex(0, false)}}>\r\n    清除样式\r\n</button>\r\n......\r\n}\r\n}\r\n\r\n```\r\n","children":[]}]}]},{"name":"README.md","path":"../guanruihua.github.io/Front-End","data":"# [ruihuag](https://guanruihua.github.io/#/)\r\n\r\n<!-- ![](../__assets__/001.jpg) -->\r\n<!-- ![Metrics](https://metrics.lecoq.io/guanruihua?template=classic&isocalendar=1&languages=1&base=header%2C%20activity%2C%20community%2C%20repositories%2C%20metadata&base.indepth=false&base.hireable=false&base.skip=false&isocalendar=false&isocalendar.duration=half-year&languages=false&languages.limit=8&languages.threshold=0%25&languages.other=false&languages.colors=github&languages.sections=most-used&languages.indepth=false&languages.analysis.timeout=15&languages.categories=markup%2C%20programming&languages.recent.categories=markup%2C%20programming&languages.recent.load=300&languages.recent.days=14&config.timezone=Asia%2FShanghai) -->\r\n","children":[]},{"name":"UI","path":"../guanruihua.github.io/Front-End","data":"","children":[{"name":"antd","path":"../guanruihua.github.io/Front-End/UI","data":"","children":[{"name":"antd2.md","path":"../guanruihua.github.io/Front-End/UI/antd","data":"# antd2\n\n> [Ant Design - 一套企业级 UI 设计语言和 React 组件库](https://2x.ant.design/components/pagination-cn/)\n\n## Pagination分页\n\n> 采用分页的形式分隔长列表，每次只加载一个页面\n\n## Select\n\n### 添加搜索过滤功能\n\n> `showSearch\n> optionFilterProp=\"children\"`\n\n```jsx\n<Select\n showSearch\n optionFilterProp=\"children\"\n>\n {options.map((item,index)=><Option key={index} value={item.id}{item.name}</Option>)}\n</Select>\n```\n\n## DatePicker日期选择框\n\n> defaultValue: 是moment对象\n","children":[]},{"name":"antd4.md","path":"../guanruihua.github.io/Front-End/UI/antd","data":"# antd4\n\n\n\n## Form\n\n> initialValue: 和antd2的使用差别, 使用function组件, 只会挂载第一次初始化的值, 如果通过mobx管理的数据, 不会挂载修改后的数据, 只会挂载第一次的数据, 可以通过useForm , form.setFielsValue(valueObj) 后重置数据","children":[]}]},{"name":"elemnt-UI.md","path":"../guanruihua.github.io/Front-End/UI","data":"# element-UI\r\n","children":[]},{"name":"Swiper.md","path":"../guanruihua.github.io/Front-End/UI","data":"# Swiper\n\n> [轮播图幻灯片js插件](https://www.swiper.com.cn/)\n","children":[]}]},{"name":"_sidebar.md","path":"../guanruihua.github.io/Front-End","data":"* Node\n  * [git](Node/git.md)\n  * 中台\n    * [egg](Node/中台/egg.md)\n    * [express](Node/中台/express.md)\n    * [koa](Node/中台/koa.md)\n    * [Nest](Node/中台/Nest.md)\n    * ORM\n      * [typeorm](Node/中台/ORM/typeorm.md)\n    * [中台](Node/中台/中台.md)\n    * 中间件\n      * [multer](Node/中台/中间件/multer.md)\n  * 基础\n    * [fs](Node/基础/fs.md)\n    * [node-basis](Node/基础/node-basis.md)\n    * [node-demo](Node/基础/node-demo.md)\n    * [node-expand](Node/基础/node-expand.md)\n    * [node-mysql](Node/基础/node-mysql.md)\n    * [接收参数](Node/基础/接收参数.md)\n    * [模块化](Node/基础/模块化.md)\n  * [读取git信息](Node/读取git信息.md)\n* Package\n  * [dumi](Package/dumi/index.md)\n    * [home](Package/dumi/index.md)\n  * dva\n    * [问题](Package/dva/问题.md)\n  * [hexo](Package/hexo.md)\n  * [http-server.](Package/http-server..md)\n  * [Quagga](Package/Quagga.md)\n  * [roadhog](Package/roadhog.md)\n  * 全屏\n    * [react-flip-toolkit](Package/全屏/react-flip-toolkit.md)\n  * [兼容性](Package/兼容性.md)\n  * 可视化\n    * [cesium](Package/可视化/cesium.md)\n    * [D3](Package/可视化/D3.md)\n    * [echart](Package/可视化/echart/index.md)\n      * [home](Package/可视化/echart/index.md)\n    * [HighEchart](Package/可视化/HighEchart.md)\n    * threejs\n      * API\n        * [PerspectiveCamera](Package/可视化/threejs/API/PerspectiveCamera.md)\n        * [WebGLRenderer](Package/可视化/threejs/API/WebGLRenderer.md)\n        * 几何体\n          * [BoxGeometry](Package/可视化/threejs/API/几何体/BoxGeometry.md)\n          * [CircleGeometry](Package/可视化/threejs/API/几何体/CircleGeometry.md)\n          * [DodecahedronGeometry](Package/可视化/threejs/API/几何体/DodecahedronGeometry.md)\n        * 材质\n          * [LineBasicMaterial](Package/可视化/threejs/API/材质/LineBasicMaterial.md)\n          * [LineDashedMaterial](Package/可视化/threejs/API/材质/LineDashedMaterial.md)\n          * [MeshMatcapMaterial](Package/可视化/threejs/API/材质/MeshMatcapMaterial.md)\n        * 渲染器\n          * [CSS3DRenderer](Package/可视化/threejs/API/渲染器/CSS3DRenderer.md)\n      * [three](Package/可视化/threejs/three.md)\n      * [threejs](Package/可视化/threejs/threejs.md)\n  * [国际化](Package/国际化.md)\n  * 工具包\n    * jquery\n      * [jquery-demo](Package/工具包/jquery/jquery-demo.md)\n      * [jquery](Package/工具包/jquery/jquery.md)\n    * [lodash](Package/工具包/lodash.md)\n    * [mock](Package/工具包/mock.md)\n    * [Monaco Editor](Package/工具包/Monaco Editor.md)\n    * [RxJS](Package/工具包/RxJS.md)\n    * [自定义片段](Package/工具包/自定义片段.md)\n  * 拖拽\n    * [react-beautiful-dnd](Package/拖拽/react-beautiful-dnd.md)\n    * [react-dnd](Package/拖拽/react-dnd.md)\n  * 模板引擎\n    * [ejs](Package/模板引擎/ejs.md)\n    * [Pug](Package/模板引擎/Pug.md)\n  * 测试\n    * [jest](Package/测试/jest/index.md)\n      * [home](Package/测试/jest/index.md)\n      * [js](Package/测试/jest/js.md)\n      * [ts](Package/测试/jest/ts.md)\n  * 虚拟列表\n    * [react-window](Package/虚拟列表/react-window.md)\n* UI\n  * antd\n    * [antd2](UI/antd/antd2.md)\n    * [antd4](UI/antd/antd4.md)\n  * [elemnt-UI](UI/elemnt-UI.md)\n  * [Swiper](UI/Swiper.md)\n* 代码片段\n  * [获取鼠标选中内容](代码片段/获取鼠标选中内容.md)\n* 其他\n  * [伦敦CSS-2020](其他/伦敦CSS-2020.md)\n  * [待整理代码](其他/待整理代码.md)\n* 包管理器\n  * [cnpm](包管理器/cnpm.md)\n  * npm\n    * [npm-cli](包管理器/npm/npm-cli.md)\n    * [npm包](包管理器/npm/npm包.md)\n    * [npm指令说明](包管理器/npm/npm指令说明.md)\n    * [yarn](包管理器/npm/yarn.md)\n    * [制作NPM包](包管理器/npm/制作NPM包/index.md)\n      * [home](包管理器/npm/制作NPM包/index.md)\n      * [ts](包管理器/npm/制作NPM包/ts.md)\n      * [发包问题](包管理器/npm/制作NPM包/发包问题.md)\n      * [开发相关](包管理器/npm/制作NPM包/开发相关.md)\n    * 命令\n      * [version](包管理器/npm/命令/version.md)\n      * [命令](包管理器/npm/命令/命令.md)\n    * [快速删除文件](包管理器/npm/快速删除文件.md)\n    * [运行其他目录script](包管理器/npm/运行其他目录script.md)\n  * [nrm](包管理器/nrm.md)\n  * [package](包管理器/package/index.md)\n    * [author](包管理器/package/author.md)\n    * [bugs](包管理器/package/bugs.md)\n    * [contributors](包管理器/package/contributors.md)\n    * [description](包管理器/package/description.md)\n    * [homepage](包管理器/package/homepage.md)\n    * [home](包管理器/package/index.md)\n    * [keywords](包管理器/package/keywords.md)\n    * [license](包管理器/package/license.md)\n    * [name](包管理器/package/name.md)\n    * [repository](包管理器/package/repository.md)\n    * [version](包管理器/package/version.md)\n    * [依赖配置](包管理器/package/依赖配置/index.md)\n      * [bundleDependencies](包管理器/package/依赖配置/bundleDependencies.md)\n      * [dependencies](包管理器/package/依赖配置/dependencies.md)\n      * [devDependencies](包管理器/package/依赖配置/devDependencies.md)\n      * [home](包管理器/package/依赖配置/index.md)\n      * [optionalDependencies](包管理器/package/依赖配置/optionalDependencies.md)\n      * [overrides](包管理器/package/依赖配置/overrides.md)\n      * [peerDependencies](包管理器/package/依赖配置/peerDependencies.md)\n      * [peerDependenciesMeta](包管理器/package/依赖配置/peerDependenciesMeta.md)\n    * [发布配置](包管理器/package/发布配置/index.md)\n      * [home](包管理器/package/发布配置/index.md)\n      * [preferGlobal](包管理器/package/发布配置/preferGlobal.md)\n      * [private](包管理器/package/发布配置/private.md)\n      * [publishConfig](包管理器/package/发布配置/publishConfig.md)\n    * [文件配置](包管理器/package/文件配置/index.md)\n      * [files](包管理器/package/文件配置/files.md)\n      * [home](包管理器/package/文件配置/index.md)\n      * [type](包管理器/package/文件配置/type.md)\n      * [workspaces](包管理器/package/文件配置/workspaces.md)\n      * [入口文件](包管理器/package/文件配置/入口文件.md)\n    * [第三方配置](包管理器/package/第三方配置/index.md)\n      * [babel](包管理器/package/第三方配置/babel.md)\n      * [browserslist](包管理器/package/第三方配置/browserslist.md)\n      * [CDN服务](包管理器/package/第三方配置/CDN服务.md)\n      * [eslintConfig](包管理器/package/第三方配置/eslintConfig.md)\n      * [home](包管理器/package/第三方配置/index.md)\n      * [lint-staged](包管理器/package/第三方配置/lint-staged.md)\n      * [sideEffects](包管理器/package/第三方配置/sideEffects.md)\n      * [types&typings](包管理器/package/第三方配置/types&typings.md)\n    * [系统配置](包管理器/package/系统配置/index.md)\n      * [cpu](包管理器/package/系统配置/cpu.md)\n      * [engines](包管理器/package/系统配置/engines.md)\n      * [home](包管理器/package/系统配置/index.md)\n      * [os](包管理器/package/系统配置/os.md)\n    * 脚本配置\n      * [config](包管理器/package/脚本配置/config.md)\n      * [script](包管理器/package/脚本配置/script.md)\n* 多端\n  * [Electron](多端/Electron/index.md)\n    * [home](多端/Electron/index.md)\n    * [问题](多端/Electron/问题.md)\n  * Flutter\n    * [环境搭建](多端/Flutter/环境搭建.md)\n  * [React-Native](多端/React-Native/index.md)\n    * [home](多端/React-Native/index.md)\n  * 小程序\n    * Taro\n      * 文档\n        * [基础](多端/小程序/Taro/文档/基础.md)\n        * [框架](多端/小程序/Taro/文档/框架.md)\n        * [路由](多端/小程序/Taro/文档/路由.md)\n      * [问题](多端/小程序/Taro/问题.md)\n    * 微信小程序\n      * api\n        * [web-view](多端/小程序/微信小程序/api/web-view.md)\n      * [云函数](多端/小程序/微信小程序/云函数.md)\n      * 开放信息\n        * [UnionID](多端/小程序/微信小程序/开放信息/UnionID.md)\n      * [微信小程序_basic](多端/小程序/微信小程序/微信小程序_basic.md)\n      * [获取用户信息](多端/小程序/微信小程序/获取用户信息.md)\n      * 错误\n        * [600002](多端/小程序/微信小程序/错误/600002.md)\n* 拓展\n  * [CORS](拓展/CORS.md)\n  * css-in-js\n    * [特点](拓展/css-in-js/特点.md)\n  * [js垃圾回收机制](拓展/js垃圾回收机制.md)\n  * 前后端交互\n    * [ajax](拓展/前后端交互/ajax.md)\n    * [axios](拓展/前后端交互/axios.md)\n    * [fetch](拓展/前后端交互/fetch.md)\n    * [文件交互](拓展/前后端交互/文件交互/index.md)\n      * [home](拓展/前后端交互/文件交互/index.md)\n  * 加密\n    * [base64](拓展/加密/base64.md)\n  * 性能指标\n    * [指标](拓展/性能指标/指标.md)\n  * [时区](拓展/时区/index.md)\n    * [home](拓展/时区/index.md)\n  * [特殊备注](拓展/特殊备注.md)\n  * 编码规范\n    * [代码规范](拓展/编码规范/代码规范.md)\n    * [方法](拓展/编码规范/方法.md)\n  * 跨域\n    * [jsonp](拓展/跨域/jsonp.md)\n* 框架\n  * vue\n    * [begin](框架/vue/begin.md)\n    * [element](框架/vue/element.md)\n    * eslint\n      * [err](框架/vue/eslint/err.md)\n    * extend\n      * [vue-expand](框架/vue/extend/vue-expand.md)\n      * [vue-question](框架/vue/extend/vue-question.md)\n      * [父子通信](框架/vue/extend/父子通信.md)\n    * [package](框架/vue/package.md)\n    * question\n      * [sockjs-node](框架/vue/question/sockjs-node.md)\n    * SSR\n      * [nuxt](框架/vue/SSR/nuxt.md)\n    * [UI组件](框架/vue/UI组件/index.md)\n      * [home](框架/vue/UI组件/index.md)\n      * [制作UI组件](框架/vue/UI组件/制作UI组件.md)\n    * [vue-basis](框架/vue/vue-basis.md)\n    * [vue-router](框架/vue/vue-router.md)\n    * [vuex](框架/vue/vuex.md)\n    * [文件相关](框架/vue/文件相关/index.md)\n      * [home](框架/vue/文件相关/index.md)\n  * 微前端\n    * [Garfish](框架/微前端/Garfish.md)\n    * [icestark](框架/微前端/icestark.md)\n    * [qiankun](框架/微前端/qiankun/index.md)\n      * [home](框架/微前端/qiankun/index.md)\n  * 错误\n    * [npm错误](框架/错误/npm错误.md)\n    * [sockjs-node](框架/错误/sockjs-node.md)\n  * [问题](框架/问题/index.md)\n    * [home](框架/问题/index.md)\n* 浏览器\n  * [favicon](浏览器/favicon.md)\n  * [meta](浏览器/meta.md)\n  * [seo](浏览器/seo.md)\n  * [URL](浏览器/URL.md)\n  * [User Agent Stylesheet](浏览器/User Agent Stylesheet.md)\n  * Web Api\n    * [localStorage](浏览器/Web Api/localStorage.md)\n    * [location](浏览器/Web Api/location.md)\n    * [postMessage](浏览器/Web Api/postMessage.md)\n    * [requestAnimationFrame](浏览器/Web Api/requestAnimationFrame.md)\n  * [web点击劫持X-Frame-Options](浏览器/web点击劫持X-Frame-Options.md)\n  * window\n    * [closed](浏览器/window/closed.md)\n    * [content](浏览器/window/content.md)\n    * [customElements](浏览器/window/customElements.md)\n    * [devicePixelRatio](浏览器/window/devicePixelRatio.md)\n    * [document](浏览器/window/document/index.md)\n      * [home](浏览器/window/document/index.md)\n    * [frameElement](浏览器/window/frameElement.md)\n    * [frames](浏览器/window/frames.md)\n    * [history](浏览器/window/history.md)\n    * [innerHeight](浏览器/window/innerHeight.md)\n    * [innerWidth](浏览器/window/innerWidth.md)\n    * [length](浏览器/window/length.md)\n    * [localStorage](浏览器/window/localStorage.md)\n    * [location](浏览器/window/location.md)\n    * [open](浏览器/window/open.md)\n  * 兼容开发\n    * [IE8](浏览器/兼容开发/IE8.md)\n    * [var](浏览器/兼容开发/var.md)\n  * 分析页面\n    * [分析页面加载时间](浏览器/分析页面/分析页面加载时间.md)\n  * [开启手机控制台](浏览器/开启手机控制台.md)\n  * [怪异模式](浏览器/怪异模式.md)\n  * [标签](浏览器/标签.md)\n  * [浏览器多进程&JS单线程](浏览器/浏览器多进程&JS单线程.md)\n  * 浏览器插件\n    * [manifest](浏览器/浏览器插件/manifest.md)\n    * [插件](浏览器/浏览器插件/插件.md)\n  * 缓存\n    * [http缓存](浏览器/缓存/http缓存.md)\n    * [web缓存](浏览器/缓存/web缓存.md)\n  * [调试](浏览器/调试.md)\n* 问题\n  * [内存](问题/内存.md)\n  * [同步和异步](问题/同步和异步.md)\n  * [闭包](问题/闭包.md)\n* 项目搭建\n  * [esbuild](项目搭建/esbuild/index.md)\n    * [home](项目搭建/esbuild/index.md)\n  * [Gulp](项目搭建/Gulp/index.md)\n    * [home](项目搭建/Gulp/index.md)\n  * [Rollup](项目搭建/Rollup/index.md)\n    * [home](项目搭建/Rollup/index.md)\n    * [问题](项目搭建/Rollup/问题.md)\n  * [vite](项目搭建/vite/index.md)\n    * [home](项目搭建/vite/index.md)\n    * [问题](项目搭建/vite/问题.md)\n  * webpack\n    * Plugin\n      * [EslintWebpackPlugin](项目搭建/webpack/Plugin/EslintWebpackPlugin.md)\n    * [question](项目搭建/webpack/question.md)\n    * [react-webpack-ts](项目搭建/webpack/react-webpack-ts.md)\n    * [webpack](项目搭建/webpack/webpack.md)\n    * [webpack重构](项目搭建/webpack/webpack重构.md)\n    * [增量打包多页应用](项目搭建/webpack/增量打包多页应用.md)\n  * 代码类型检查\n    * [eslint](项目搭建/代码类型检查/eslint.md)\n    * [prettierc](项目搭建/代码类型检查/prettierc.md)\n    * [tslint](项目搭建/代码类型检查/tslint.md)\n  * 提交前置\n    * [commitlint](项目搭建/提交前置/commitlint.md)\n    * [husky](项目搭建/提交前置/husky.md)\n  * [案例](项目搭建/案例.md)\n","children":[]},{"name":"代码片段","path":"../guanruihua.github.io/Front-End","data":"","children":[{"name":"获取鼠标选中内容.md","path":"../guanruihua.github.io/Front-End/代码片段","data":"## 获取鼠标选中内容\r\n\r\n```js\r\n// 监听双击事件\r\ndocument.addEventListener(\"dblclick\", doubleClick, true);\r\n\r\n// 监听释放鼠标按钮事件\r\ndocument.addEventListener(\"mouseup\", mouseUp, true);\r\n\r\n// 双击处理函数\r\nfunction doubleClick() {\r\n    var text = \"\";\r\n    if (window.getSelection) {\r\n        text = window.getSelection().toString();\r\n    } else if (document.selection && document.selection.type != \"Control\") {\r\n        text = document.selection.createRange().text;\r\n    }\r\n    if (\"\" != text) {\r\n        console.log(text);\r\n    }\r\n\r\n}\r\n\r\n// 释放鼠标处理函数\r\nfunction mouseUp() {\r\n    var text = \"\";\r\n    if (window.getSelection) {\r\n        text = window.getSelection().toString();\r\n    } else if (document.selection && document.selection.type != \"Control\") {\r\n        text = document.selection.createRange().text;\r\n    }\r\n    if (\"\" != text) {\r\n        console.log(text);\r\n    }\r\n} \r\n\r\n```\r\n","children":[]}]},{"name":"其他","path":"../guanruihua.github.io/Front-End","data":"","children":[{"name":"伦敦CSS-2020.md","path":"../guanruihua.github.io/Front-End/其他","data":"# 伦敦CSS 2020\n\n> 还只是一个提案，离到TR阶段还需要很长的时间\n>\n> <https://www.motionblurjs.com/>\n>\n> ```html\n> <head>\n>     <script src = \"https://www.motionblurjs.com/blur.js\"></script>\n> </head>\n> ```\n\n## Web动效\n\n## 动态模糊（Motion Blur）\n\n> CSS\n>\n> - animation是新增了 motion-rendering 和 motion-shutter-angle\n> - 向引擎请求动态模糊:  motion-rendering : inherit | initial | auto | none | blur 值\n> - 类似于相机的快门，指的是快门角度，用来控制模糊量或模糊强度\n>   - motion-shutter-angle可受任意角度值 inherit | initial | auto = 180deg |``<a href=\"https://codepen.io/airen/pen/oNxQoLw\">``0deg, ..., 720deg]\n\n```css\n.animated-layer {\n    /* GPU加速动画 */\n    animation: rotate .5s linear infinite;\n    /* 向引擎请求动态模糊\n     * motion-rendering可以接受inherit | initial | auto | none | blur 值\n    */\n    motion-rendering: blur; \n    /* 类似于相机的快门，指的是快门角度，用来控制模糊量或模糊强度\n     * motion-shutter-angle可受任意角度值 inherit | initial | auto = 180deg | <a href=\"https://codepen.io/airen/pen/oNxQoLw\">0deg, ..., 720deg]\n    */\n    motion-shutter-angle: 180deg;\n}\n\n@keyframes rotate {\n    to {\n        transform: rotate(1turn);\n    }\n}\n```\n\n来看一个简单的[示例](https://codepen.io/airen/pen/oNxQoLw)：\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54fd731e901c41c1b028d0acea6e8778~tplv-k3u1fbpfcp-watermark.image)\n\n从效果上看似乎没看到动态模糊的效果。\n\n这里还是用文档中提供的一个带有动效的图向大家展示动态模糊的效果：\n\n![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acb11f2cab5f4c14acdf61cc6bf44a70~tplv-k3u1fbpfcp-watermark.image)\n\n虽然说， motion-rendering 和 motion-shutter-angle 还只是一个提案，离到TR阶段还需要很长的时间，但对于某些场景（动画场景），可以使用CSS的filter来模拟，比如[下面这个效果](https://codepen.io/ka4tik/pen/aFstu)：\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c63261a3356548cb9b478803ccbd751f~tplv-k3u1fbpfcp-watermark.image)\n\n代码很简单：\n\n```css\n.blur { \n    animation: blur 250ms; \n}\n\n@keyframes blur {\n    0% { \n        -webkit-filter: blur(0px); \n    }\n    50% { \n        -webkit-filter: blur(5px); \n    }\n    100% { \n        -webkit-filter: blur(0px); \n    }\n}\n```\n\n另外，现在提供的 motion-rendering 和 motion-shutter-angle 还只是一个提议，在Github中讨论的评论中，也有建议将这两个属性换成：\n\n```\nfilter: motion-blur(5px) motion-squash(2px)\n\n// 或\ntransform-filter: motion-blur(180deg)\n\n// 或\ntransition-filter: motion-blur(180deg)\n```\n\n也就是说，上面提供的CSS实现动态模糊的属性不是完全定下来的，随着后面的发展，CSS中实现动态模糊的属性，一切皆有可能。\n\n再来看看SVG世界中，相对于CSS世界而言，SVG中要实现动态模拟效果要更容易一些，可以使用SVG中的滤镜来模拟动态模糊效果：\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f36203f542d4d4eb135555fc0590fda~tplv-k3u1fbpfcp-watermark.image)\n\n上图来自于@Lucas Bebber的[《Motion Blur Effect with SVG](https://tympanus.net/codrops/2015/04/08/motion-blur-effect-svg/)》教程。\n\n如果你对SVG中的滤镜相关的知识感兴趣的话，可以阅读：\n\n*[SVG 1.1: Filter Effects](https://www.w3.org/TR/SVG11/filters.html)\n\n- [SVG Filters 101](https://tympanus.net/codrops/2019/01/15/svg-filters-101/)\n\n有意思的是，@Michelle Barker在Codepen写了一个[Demo](https://codepen.io/michellebarker/full/povdXRW)，这个Demo是用CSS的box-shadow模拟出有[动态模拟的效果](https://codepen.io/michellebarker/pen/povdXRW)：\n\n![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f4df78a44734000bd8da729426a3f70~tplv-k3u1fbpfcp-watermark.image)\n\n如果你真的想在项目中让自己的动画效果具有动态模糊效果（让动效看上去更真一点），而又担心CSS或SVG相关特性未得到主流浏览器支持而不敢使用，那么我在这里向大家推荐一个JavaScript库： [MotionBlurJS](https://www.motionblurjs.com/)：\n\n![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f4df78a44734000bd8da729426a3f70~tplv-k3u1fbpfcp-watermark.image)\n\n来看使用MotionBlurJS实现的动态模糊效果：\n\n![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a3f8d8cfa9546c4952317763c178280~tplv-k3u1fbpfcp-watermark.image)\n\n## @scroll-timeline\n\nWeb开发者时常会碰到使用滚动来触发某些元素的动画效果，比如说，页面滚动条滚动到某个位置，标题固定在顶部；页面顶部展示你页面进度（滚动指示器）；还是一些我们所说的[视差滚动](https://www.cnblogs.com/coco1s/p/9453938.html)效果等。以往实现这些效果，大都借助JavaScript来实现，可以通过DOM事件查看滚动位置，并根据该位置更改元素的样式。如果可以的话，最好使用IntersectionObserver。有关于这方面的介绍可以阅读：\n\n- [Trust is Good, Observation is Better—Intersection Observer v2](https://developers.google.com/web/updates/2019/02/intersectionobserver-v2)\n- [How to do scroll-linked animations the right way](https://blog.logrocket.com/how-to-do-scroll-linked-animations/)\n\n不过，现在有一个关于这方面的CSS草案，即 [Scroll-linked Animations](https://drafts.csswg.org/scroll-animations-1/#scroll-driven-animations)。也就是说，在未来，我们可以直接使用CSS的[@scroll-timeline](https://drafts.csswg.org/scroll-animations-1/#scroll-timeline-at-rule)属性来实现前面提到的一些动画效果。\n\n```\n@scroll-timeline = @scroll-timeline <timeline-name> { <declaration-list> }\n```\n\n![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a3f8d8cfa9546c4952317763c178280~tplv-k3u1fbpfcp-watermark.image)\n\n```css\n@media (prefers-reduced-motion: no-preference) {\n  div.circle {\n    animation-duration: 1s;\n    animation-timing-function: linear;\n    animation-timeline: collision-timeline;\n  }\n\n  #left-circle {\n      animation-name: left-circle;\n  }\n\n  #right-circle {\n      animation-name: right-circle;\n  }\n\n  #union-circle {\n      animation-name: union-circle;\n      animation-fill-mode: forwards;\n      animation-timeline: union-timeline;\n  }\n\n  @scroll-timeline collision-timeline {\n      source: selector(#container);\n      orientation: block;\n      start:  200px;\n      end: 300px;\n  }\n\n  @scroll-timeline union-timeline {\n      source: selector(#container);\n      orientation: block;\n      start:  250px;\n      end: 300px;\n  }\n\n  @keyframes left-circle {\n      to { transform: translate(300px) }\n  }\n\n  @keyframes right-circle {\n      to { transform: translate(350px) }\n  }\n\n  @keyframes union-circle {\n      to { opacity: 1 }\n  }\n}\n```\n\n如果是使用JavaScript的话，可以像下面这样：\n\n```js\nif (window.matchMedia('(prefers-reduced-motion: no-preference)').matches) {\n    const scrollableElement = document.querySelector('#container');\n\n    const collisionTimeline = new ScrollTimeline({\n        source: scrollableElement,\n        start: CSS.px(200),\n        end: CSS.px(300)\n    });\n\n    const left = leftCircle.animate({ transform: 'translate(300px)' }, 1000);\n    left.timeline = collisionTimeline;\n\n    const right = leftCircle.animate({ transform: 'translate(350px)' }, 1000);\n    right.timeline = collisionTimeline;\n\n    const union = unionCircle.animate({ opacity: 1 }, { duration: 1000, fill: \"forwards\" });\n    union.timeline = new ScrollTimeline({\n        source: scrollableElement,\n        start: CSS.px(250),\n        end: CSS.px(300)\n    });\n}\n```\n\n[再来看一个滚动计时器的效果](https://codepen.io/airen/pen/yJGJEJ)：\n\n![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a3f8d8cfa9546c4952317763c178280~tplv-k3u1fbpfcp-watermark.image)\n\n上面的示例，我们是使用渐变来模拟的一个效果，但有了@scroll-timeline我们就可以像下面这样来实现：\n\n```css\n@media (prefers-reduced-motion: no-preference) {\n    @scroll-timeline progress-timeline {\n        source: selector(#body);\n        start: 0;\n        end: 100%;\n    }\n\n    @keyframes progress {\n        to { width: 100%; }\n    }\n\n    #progress {\n        width: 0px;\n        height: 30px;\n        background: red;\n        animation: 1s linear forwards progress progress-timeline;\n    }\n}\n```\n\n如果使用Web Animation API的话，可以像下面这样：\n\n```\nif (window.matchMedia('(prefers-reduced-motion: no-preference)').matches) {\n    var animation = div.animate({ width: '100%' }, { duration: 1000, fill: \"forwards\" });\n    animation.timeline = new ScrollTimeline(\n        {\n            start: 0,\n            end: CSS.percent(100)\n        }\n    );\n}\n```\n\n@argyleink在他分享的PPT中也提供了一个简单的[示例](https://codepen.io/argyleink/pen/XWdNYaY),滚动页面的时候，你会发现两个数字之间的/符会不断的旋转：\n\n![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a3f8d8cfa9546c4952317763c178280~tplv-k3u1fbpfcp-watermark.image)\n\n上面的示例效果是基于Web Animation API来实现@scroll-timeline的效果，但是目前还需要其对应的[Polyfill](https://github.com/flackr/scroll-timeline)。\n\n```js\nimport 'https://flackr.github.io/scroll-timeline/dist/scroll-timeline.js'\n\nconst counter = document.querySelector('main')\nconst slashes = document.querySelectorAll('.slash')\n\nslashes.forEach(slash => { \n    slash.animate({\n        transform: <a href=\"https://drafts.csswg.org/scroll-animations-1/\">'rotateZ(0)','rotateZ(4turn)']\n    },{\n        duration: 1000,\n        fill: 'both',\n        timeline: new ScrollTimeline({\n            scrollSource: counter,\n            fill: 'both',\n        }),\n    })\n})\n```\n\n有关于@scroll-timeline更详细的介绍可以查阅 [Scroll-linked Animations([drafts.csswg.org/scroll-anim…](https://drafts.csswg.org/scroll-animations-1/)，另外，该规范目前还只是一个草案，在未来有可能还会有所变动。)\n\n# Web排版\n\n先看布局上将会有的一些新特性：\n\n## subgrid\n\nCSS Grid布局是Web布局模式中唯一一种二维布局，也是我自己最认可的布局模式（至少到目前为止还没有发现比Grid更强大的）。如果你从未接触过Grid布局的话，你可以把他想象成最初的table布局，因为他们俩之间有很多概念都非常的相似。\n\n随着Web布局技术不断的更新以及浏览器不断的发展，现在使用Grid布局的越来越多，特别是今年以来，Grid和Flexbox布局的占比越来越近：\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f9c53519ab643ddb6b72112de6ae6b2~tplv-k3u1fbpfcp-watermark.image)\n\n上面的数据是来自于MDN，更详细的可以阅读[MDN Browser Compatibility Report 2020](https://mdn-web-dna.s3-us-west-2.amazonaws.com/MDN-Browser-Compatibility-Report-2020.pdf)\n\n暂时把你拉回到90年代，那个时候Web的布局主要以table布局为主，在使用table布局的时候也时常会发现表格嵌套表格：\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5bcdc9d56c94d2083bc71a8bddaca59~tplv-k3u1fbpfcp-watermark.image?imageslim)\n\n在Grid布局也是相似的，也会碰到网格嵌套网格。\n\n```css\n<!-- HTML -->\n<div class=\"grid\">\n    <div class=\"item\">\n        <div class=\"subitem\"></div>\n    </div>\n</div> \n\n/* CSS */\n.grid {\n    display: grid;\n    grid-template-columns: repeat(9, 1fr);\n    grid-template-rows: repeat(4, minmax(100px, auto));\n}\n\n.item {\n    grid-column: 2 / 7;\n    grid-row: 2 /  4;\n\n    display: grid;\n    grid-template-columns: repeat(3, 1fr);\n    grid-template-rows: repeat(3, 80px);\n}\n\n.subitem {\n    grid-column: 2 / 4;\n    grid-row: 1 / 4;\n}\n```\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5bcdc9d56c94d2083bc71a8bddaca59~tplv-k3u1fbpfcp-watermark.image?imageslim)\n\n网格嵌套在网格中，各自的网格轨道是相互独立的，不过也会引起子网格中元素对齐会存在一些问题。不过在 CSS Grid Layout Module Level 2([drafts.csswg.org/css-grid-2](https://drafts.csswg.org/css-grid-2)) 模块中新增了[subgrid](https://drafts.csswg.org/css-grid-2/#subgrids) 属性（Firefox 71开始就支持该属性）。\n\n有了subgrid之后，在嵌套网格的时候，我们就可以在grid-template-columns和grid-template-rows设置subgrid。这样一来，上面示例的代码我们就可以修改成：\n\n```\n.grid {\n    display: grid;\n    grid-template-columns: repeat(9, 1fr);\n    grid-template-rows: repeat(4, minmax(100px, auto));\n}\n\n.item {\n    grid-column: 2 / 7;\n    grid-rows: 2 / 4;\n\n    display: grid;\n    grid-template-columns: subgrid;\n    grid-template-rows: subgrid;\n}\n\n.subitem {\n    grid-column: 3 / 6;\n    grid-row: 1 / 4;\n}\n```\n\n这样一来，子网格就会继承其父网格的网格轨道，反过来，在使用任何类型的自动调整（比如，auto、min-content、max-content等）时也会影响其维度（尺寸）。\n\n在我们平时的一些UI布局中，subgrid就可以用得上了：\n\n![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6558ff205c84075ab7ecacd4a800799~tplv-k3u1fbpfcp-watermark.image)\n\n我们一起来看一个[subgrid的具体实例](https://codepen.io/antonjb/pen/rNNgxWV)。注意，请使用Firefox 71+查看上面的Demo，看到的效果如下：\n\n![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfb2629e03c44e57932ed63807a0c189~tplv-k3u1fbpfcp-watermark.image)\n\nsubgrid和grid一样，是一套复杂的体系，如果要说清楚subgrid的话，可能会要多文章文章才能讲清楚。如果你对subgrid感兴趣的话，还可以阅读下面这几篇文章：\n\n- [CSS Grid Layout Module Level 2: subgrid](https://drafts.csswg.org/css-grid-2/#subgrids)\n- [Hello subgrid!](https://noti.st/rachelandrew/3sescR/hello-subgrid)\n- [CSS Grid Level 2: Here Comes Subgrid](https://www.smashingmagazine.com/2018/07/css-grid-2/)\n- [MDN: Subgrid](https://developer.mozilla.org/en-US/docs/Web/CSS/CSSGridlayout/Subgrid)\n- [Irregular-shaped Links with Subgrid](https://css-irl.info/irregular-shaped-links-with-subgrid/)\n\n## 可用于双屏幕和可折叠屏幕的媒体查询条件和环境变量\n\n随着技术不断的发展，我们所面对的终端个性化越来越强，比如现在市场上已有或将有的双屏幕和可折叠屏幕设备：\n\n![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1d4ab1d63ca46c6a36c7a64f0e0ba8f~tplv-k3u1fbpfcp-watermark.image?imageslim)\n\n作为Web开发者，我们终究有一天需要面对这些终端的适配处理。到目前为止，CSS世界具备处理方面适配的能力，即使用screen-spanning媒体查询条件和env(fold-left)、env(fold-top)、env(fold-height)及env(fold-width)环境变量：\n\n![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87dff1ed59894c16b581a1c50c7b744f~tplv-k3u1fbpfcp-watermark.image)\n\n有了这些特性，我们就可以很轻易的实现像下图这样的布局效果：\n\n![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c513fe738b6f4b8a8347e9c156354896~tplv-k3u1fbpfcp-watermark.image)\n\n如果你对这方面的知识感兴趣的话，可以阅读下面几篇文章，这几篇文章也是全网介绍双屏幕和可折叠屏幕最详细的教程：\n\n- [聊聊安卓折叠屏给交互设计和开发带来的变化](https://www.atatech.org/articles/140055)\n- [可折叠Web可能会给我们带来的变化](https://www.atatech.org/articles/177539)\n- 可用于双屏幕和折叠屏的[Web API](https://www.atatech.org/articles/181271)\n\n## 瀑布流布局\n\n瀑布流布局（Masonry Layout）也是Web布局中的典型布局之一：\n\n![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ac48d670d664274afa46df2a1c20adf~tplv-k3u1fbpfcp-watermark.image)\n\n虽然能使用CSS的多列布局、Flexbox布局和Grid布局等模拟出瀑布流布局效果，但更多的同学还是更喜欢使用一些JavaScript库来实现瀑布流布局，比如[Masoonry](https://masonry.desandro.com/)。\n\n为了能让原生的CSS直接实现瀑布流布局效果，早在2017年社区中就有人提出[用原生的CSS实现瀑布流布局效果](https://github.com/w3c/csswg-drafts/issues/945)，不幸的是，直到现在也还只是一个实验性的属性，而且仅在Firefox Nightly浏览器中支持。\n\n```css\n.masonry {\n    display: grid;\n    gap: 20px;\n    grid: masonry / repeat(auto-fill, minmax(250px, 1fr));\n}\n```\n\n比如这个[Demo](https://codepen.io/rachelandrew/pen/qBOpjPx)。\n\n为了能在Firefox Nightly浏览器能正常的查看上面Demo的效果，你需要确保开启了相应的功能。如果没有的话，请在Firefox Nightly浏览器地址栏中输入about:config，然后搜索layout.css.grid-template-masonry-value.enabled，并将其设置为true：\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24b855fb62b04c91945591547095db14~tplv-k3u1fbpfcp-watermark.image)\n\n然后重启浏览器，查看Demo，你看到的效果将会是像下面这样：\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be5159d44b95467ca95888ae770a4e1b~tplv-k3u1fbpfcp-watermark.image)\n\n## gap\n\n“Gap”从字面上来解释的话可以有“间隙，间隔”之意。那么在Web的布局中总是避免不了处理块与块以及行与行之间的间距。\n\n![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba53dbdc976f4facbe9520c32e96781c~tplv-k3u1fbpfcp-watermark.image)\n\n而在CSS的世界中，用来控制元素之间的间距的间距，一般会使用盒模型中的外距，即 margin 属性，但是往往很多时候，使用margin来控制元素之间间距并不能很好的满足设计师的诉求。比如说，元素只和元素之间有间距，但和它的父容器之间没有任何的间距。针对于这样的场景，使用gap属性会比使用margin要容易控制的多。\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4ee3e4a15e8415abfdb6db12794c4f5~tplv-k3u1fbpfcp-watermark.image)\n\n注意，上图来自于[《Next-generation web styling》](https://web.dev/next-gen-css-2019/)一文。\n\nCSS的gap属性自身最大的特点就是：gap是相对于流的，这意味着它会根据内容流的方向动态变化。比如说书写模式的改变，gap也会自动改变。\n\n早期在CSS中，gap分很多种，在不同的容器格式中，叫法不同，比如在多列布局[（Multi-column Containers）](https://www.w3.org/TR/css3-multicol/#multi-column-container)中对应的是column-gap：\n\n```css\nbody {\n    column-gap: 35px;\n}\n```\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/388af9c9f5204a8185f8247a8e64628a~tplv-k3u1fbpfcp-watermark.image)\n\n但在网格容器[（Grid Containers）](https://www.w3.org/TR/css-grid-1/#grid-container)又被称为grid-row-gap和grid-column-gap。\n\n除此之外，它还可以被运用于Flexbox容器[（Flexbox Containers）](https://www.w3.org/TR/css-flexbox-1/#flex-container)，只不过早前，在Flexbox中没有类似flex-row-gap和flex-column-gap这样的属性。\n\n需要注意的是，在Flexbox模块中是没有gap属性，但这并不影响我们在Flexbox布局中使用gap属性，这是因为gap统一纳入到了[CSS Box Alignment Module Level 3](https://www.w3.org/TR/css-align-3/#gaps)模块。而且gap是row-gap和column-gap的简写属性：\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5c66a53a0614135977125f45cda1090~tplv-k3u1fbpfcp-watermark.image)\n\n我们现在可以在多列布局，Flexbox布局和网格布局中像下面这样使用gap：\n\n```css\n// 多列布局\n.multi__column {\n    gap: 5ch\n}\n\n// Flexbox布局\n.flexbox {\n    display: flex;\n    gap: 20px\n}\n\n// Grid布局\n.grid {\n    display: grid;\n    gap: 10vh 20%\n}\n```\n\n从上面示例代码中我们可以发现，gap是row-gap和column-gap的简写属性，而且gap可以接受一个值也可以接受两个值，当gap只有一个值时，表示row-gap和column-gap的值相同；当gap有两个值时，其中第一个值是row-gap，第二个值是column-gap。\n\n```css\n.gap {\n    gap: 10px;\n}\n\n// 等同于\n.gap {\n    row-gap: 10px;\n    column-gap: 10px\n}\n\n.gap {\n    gap: 20px 30px;\n}\n\n// 等同于\n.gap {\n    row-gap: 20px;\n    column-gap: 30px;\n}\n```\n\n特别声明一点，虽然CSS新增了gap属性（row-gap、column-gap），但Grid中早期的grid-row-gap和grid-column-gap属性同样可用。\n\n## aspect-ratio\n\naspect-ratio 是[CSS Box Sizing Module Level 4](https://www.w3.org/TR/css-sizing-4/#aspect-ratio) 模块中的一个用来计算元素盒子宽高比的属性。在这个属性还没有之前，在CSS中都是通过其他一些方法来[模拟宽高比的效果](https://www.atatech.org/articles/81457)。比如：\n\n```css\n.aspectration { \n    position: relative;/*因为容器所有子元素需要绝对定位*/ \n    height: 0; /*容器高度是由padding来控制，盒模型原理告诉你一切*/ \n    width: 100%; \n} \n\n.aspectration<a href=\"https://codepen.io/rachelandrew/pen/WNrRZaV\">data-ratio=\"16:9\"] { \n    padding-top: 56.25%; \n} \n\n.aspectration[data-ratio=\"4:3\"]{ \n    padding-top: 75%; \n}\n```\n\n如果浏览器支持了aspect-ratio的话，可以像下面这样使用：\n\n```css\ndiv {\n    aspect-ratio: 1 / 1;\n}\n```\n\n比如[[@rachelandrew在Codepen提供的一个示例](https://codepen.io/rachelandrew/pen/WNrRZaV)，我在该示例的基础上稍作调整了一下([codepen.io/airen/pen/v…](https://codepen.io/airen/pen/vYGvqmZ)：)\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1293e1b702b0442ab31a08add1e9195d~tplv-k3u1fbpfcp-watermark.image)\n\n## :target`和`:target-within\n\n:target和:target-within都是 [Selectors Level 4](https://www.w3.org/TR/selectors-4) [模块中的两个伪元素](https://www.w3.org/TR/selectors-4/#the-target-within-pseudo)。可能很多同学对:target更熟悉一些，甚至用:target伪元素的特性制作了 [Tab](https://www.sitepoint.com/css3-tabs-using-target-selector/) 、[Accordion](https://www.w3cplus.com/blog/160.html) 和 [Modal](https://www.cssscript.com/simple-modal-box-using-css-and-target-pseudo-class/) 等UI交互效果。\n\n比如下面这个手风琴的效果就是用:[target伪元素制作](https://codepen.io/airen/pen/PxYxap)的：\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d54165209b29449db083c28498c50c01~tplv-k3u1fbpfcp-watermark.image)\n\n单的来看看:target和:target-within的作用。\n\n在某些文档语言中，文档的URL可以通过URL的片段进一步指向文档中的特定元素。以这种方式指向的元素是文档的目标元素。其中片段标识符是URL中紧跟#的部分，例如#top或#fontnote1。你可能已经使用它们创建页面内导航，比如大家常见的“跳转链接”。有了:target伪类，我们可以突出显示与该片段对应的文档部分，而且无需JavaScript也可以做到这一点。\n\n比如下面这个简单的[示例](https://codepen.io/airen/pen/BaKvjGj)：\n\n```css\n<!-- HTML -->\n<h3>Table of Contents</h3>\n<ol>\n    <li><a href=\"#p1\">Jump to the first paragraph!</a></li>\n    <li><a href=\"#p2\">Jump to the second paragraph!</a></li>\n    <li><a href=\"#nowhere\">This link goes nowhere, because the target doesn't exist.</a></li>\n</ol>\n\n<h3>My Fun Article</h3>\n<p id=\"p1\">You can target <i>this paragraph</i> using a URL fragment. Click on the link above to try out!</p>\n<p id=\"p2\">This is <i>another paragraph</i>, also accessible from the links above. Isn't that delightful?</p>\n\n/* CSS */\n\np:target {\n    background-color: gold;\n}\n\n/* 在目标元素中增加一个伪元素*/\np:target::before {\n    font: 70% sans-serif;\n    content: \"►\";\n    color: limegreen;\n    margin-right: .25em;\n}\n\n/*在目标元素中使用italic样式*/\np:target i {\n    color: red;\n}\n```\n\n点击示例中的链接，你可以看到像下图的效果：\n\n![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11f8aff714e440c5990771376f64cf9c~tplv-k3u1fbpfcp-watermark.image)\n\n而:target-within伪类应用于:target伪类所应用的元素，以及在平面树（Flat Tree）的后代（包括非元素节点，比如文本节点）与匹配:target-within的条件相匹配的元素。\n\narticle:target-within { background-color: hsl(var(--surfaceHSL) / 10%); } 其实在选择器Level 4模块中还新增了很多其他的伪类选择器，如果你对这方面新增的选择器感兴趣的话，可以听一听@Adam Argyle和@Ana Tudor一起办的[CSS Podcast](https://thecsspodcast.libsyn.com/)，其中第十四期就是专门聊CSS的[伪类选择器](https://thecsspodcast.libsyn.com/014-pseudo-elements)的。\n\n## CSS逻辑属性\n\n如果你阅读过[《Web中向左向右》](https://www.atatech.org/articles/159175)一文或者有接触过CSS书写模式特性，你会发现以前我们熟悉的物理属性在不同的语言环境之下很难满足布局的需求，比如英语和阿拉伯语，日语和蒙语等，我们设置的margin-left有可能不是margin-left，width也有可能不是width。\n\n![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11b538fc559240c0bc6ca299bd36ca7d~tplv-k3u1fbpfcp-watermark.image)\n\n这个时候，CSS逻辑属性就显得尤其重要。换句话说，逻辑属性的出现，我们以往熟悉的盒模型也将带来很大的变化：\n\n![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2b001945236486290f4b8388d0bcfa2~tplv-k3u1fbpfcp-watermark.image)\n\n下图是我们熟悉的 物理属性 和 逻辑属性 的对应关应：\n\n![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6214095ce083444f80ca531be7ebba4e~tplv-k3u1fbpfcp-watermark.image)\n\n对于[块轴（block axis）](https://drafts.csswg.org/css-writing-modes-4/#block-axis)和[内联轴（inline axis）](https://drafts.csswg.org/css-writing-modes-4/#inline-axis)区别，同样用一张图来描述这两者吧：\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/410d29a360da4db3b8c62225bee23803~tplv-k3u1fbpfcp-watermark.image?imageslim)\n\n块轴和内联轴和CSS的书写模式writing-mode以及direction和HTML的dir有关系。换句话说：\n\n- 块轴：主要定义网站文档（元素块）流，CSS的书写模式writing-mode会影响块轴的方向\n- 内联轴：主要定义网站的文本流方向，也就是文本的阅读方式，CSS的direction或HTML的dir会影响内联轴的方向\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8be6830d9c284c67aa44397f291f1a14~tplv-k3u1fbpfcp-watermark.image)\n\n有关于writing-mode、direction和dir对Web排版的影响相关的详细介绍可以阅读[《Web中向左向右》](https://www.atatech.org/articles/159175)一文。\n\n## min() max() 和 clamp()\n\nmin()、max()和clamp()三个函数称为“比较函数”。早在[《聊聊min()，max()和clamp()函数》](https://www.w3cplus.com/css/min-max-clamp-function.html)一文中对其做过详细的介绍。这里不做详细介绍，仅和三张图来分别展示他们的功能。\n\n我们可以使用 min()设置最大值：\n\n![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5cd1c0b78bb4bb78883f90cf4159127~tplv-k3u1fbpfcp-watermark.image)\n\nmax()和min()相反，返回的是最大值。使用max()设置一个最小值：\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35b11d99dda8497e9fe3a4a50ce38553~tplv-k3u1fbpfcp-watermark.image)\n\nclamp()函数和min()以及max()不同，它返回的是一个区间值。clamp()函数接受三个参数，即 clamp(MIN, VAL, MAX)，其中MIN表示最小值，VAL表示首选值，MAX表示最大值。它们之间：\n\n- 如果VAL在MIN和MAX之间，则使用VAL作为函数的返回值；\n- 如果VAL大于MAX，则使用MAX作为函数的返回值；\n- 如果VAL小于MIN，则使用MIN作为函数的返回值\n\n这里有一个关于clamp()的[示例](https://www.atatech.org/articles/'https://codepen.io/airen/pen/pojVpJv)，尝试着拖动浏览器视窗的大小，你可以看到类似下图这样的效果：\n\n![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c8ea1dc711e4af4bc6b366f3677994a~tplv-k3u1fbpfcp-watermark.image)\n\n我们再来看几个和文本相关的特性：\n\n## leading-trim 和 text-edge\n\n一直以来，在Web的排版中行高（line-height）总是令Web开发者感到困惑和头痛，主要是因为line-height在CSS中是一个非常复杂的体系。他的计算总是会涉及到很多因素：\n\n@iamvdo的[《Deep dive CSS: font metrics, line-height and vertical-align》](https://iamvdo.me/en/blog/css-font-metrics-line-height-and-vertical-align)一文对这方面做过深入的阐述！\n\n在还原UI时，文本的行高总是让我们计算元素块之间的间距带来一定的麻烦：\n\n![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdc437f49aa142c0a9cc33d39b947582~tplv-k3u1fbpfcp-watermark.image)\n\n为了解决这方面的烦恼， [CSS Inline Layout Module Level 3](https://www.w3.org/TR/css-inline-3)新增了一个[leading-trim](https://www.w3.org/TR/css-inline-3/#leading-trim)和[text-edge](https://www.w3.org/TR/css-inline-3/#text-edges)属性。可以让我们删除每一种字体中的额外间距，以便我们可以更好的计算相邻块元素之间的间距。\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65b1b4f2b6bf449eacf6ad481b122db8~tplv-k3u1fbpfcp-watermark.image)\n\n```css\nh1 { \n    leading-trim: both;\n    text-edge: cap alphabetic;\n}\n```\n\n上面的示例首先使用text-edge来告诉浏览器想要的文本边缘是cap高度和字母基线（alphabetic baseline）。然后用leading-trim对文本两边进行修剪。\n\n注意，leading-trim只影响文本框，它不会切断其中的文字。\n\n示例中的两行简单的CSS创建了一个包含文本的干净的文本框（不受line-height相关的特性影响）。这有助于实现更精确的间距，并创建更好的视觉层次结构。\n\nCSS的text-edge和leading-trim分别可接受的值：\n\n```css\ntext-edge: leading | <a href=\"https://matthiasott.com/notes/the-thing-with-leading-in-css?ref=heydesigner\"> text | cap | ex | ideographic | ideographic-ink ] [ text | alphabetic | ideographic | ideographic-ink ]?\n\nleading-trim: normal | start | end | both\n```\n\n如果你对leading-trim特性感兴趣的话，除了阅读规范之外，还可以阅读下面几篇文章：\n\n- [[The Thing With Leading in CSC\\]](https://matthiasott.com/notes/the-thing-with-leading-in-css?ref=heydesigner)\n- [Leading-Trim: The Future of Digital Typesetting](https://medium.com/microsoft-design/leading-trim-the-future-of-digital-typesetting-d082d84b202)\n- [Rethinking line-sizing and leading-trim](https://github.com/w3c/csswg-drafts/issues/5168)\n\n## ::grammar-error 和 ::spelling-error\n\n::grammar-error和::spelling-error是两个非常有意思的伪元素选择器。从字面说我们可以知道， Grammar error 指的是语法错误， Spelling error指的是拼写错误。其实这两种现象在我们平时书写文本的时候经常可见，可能会由于手误， 将某个单词或标点符号用错，甚至语法上的错误。针对于这种现象，我们总是希望有一定的提示信息来提示我们，比如颜色上的差异，添加一些下划线等等：\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/278eeff5d6244f309347a59ddfb2e6af~tplv-k3u1fbpfcp-watermark.image)\n\n在[CSS Pseudo-Elements Module Level 4](https://drafts.csswg.org/css-pseudo) 的[高亮伪元素](https://drafts.csswg.org/css-pseudo/#highlight-pseudos)中我们可以看到这两个伪元素的身影：\n\n- ::grammar-error：浏览器为语法错误的文本段添加样式\n- ::spelling-error：浏览器为拼写错误的文本段添加样式\n\n在CSS中并不是所有属性都能运用于这两个伪元素，到目前为止，只有color、background-color、cursor、text-emphasis-color、text-shadow、outline、text-decoration、fill-color、stroke-color 和stroke-width可以用于这两个伪元素。\n\n```css\n:root::spelling-error { \n    text-decoration-line: spelling-error; \n}\n\n:root::grammar-error  { \n    text-decoration-line: grammar-error; \n}\n\n<a href=\"https://drafts.csswg.org/css-values-4\">spellcheck]::spelling-error {\n    text-decoration: wavy underline var(--neon-red);\n}\n\n[grammarcheck]::grammar-error {\n    text-decoration: wavy underline var(--neon-blue);\n}\n```\n\n## 新增相对单位：cap、lh、rlh、vi和 vb\n\n[CSS中单位和值([drafts.csswg.org/css-values-…](https://drafts.csswg.org/css-values-4)) 中单位有：\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb570e4de16e46e9bd744e11ff6542eb~tplv-k3u1fbpfcp-watermark.image)\n\n但在 相对[单位](https://drafts.csswg.org/css-values-4/#relative-lengths)中并没有提到cap、lh、rlh、vi和vb这几个相对单位。\n\n![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dcf3c24296a4dbb978f62ab4b6c28e8~tplv-k3u1fbpfcp-watermark.image)\n\n从上表的描述来看，其中cap、lh、rlh的计算都和元素的字体以及行高等有关系。我用下图来描述一个字体的Cap Height，Line Height等：\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97b79650b8ef4cbda29ccebefcf8cef2~tplv-k3u1fbpfcp-watermark.image)\n\n# Web性能\n\n## contain 和 content-visibility\n\n这两个属性是属于 CSS容器模块 的，其最大的特点应该是可以帮助Web开发者提高Web页面的性能：\n\n当容器的内容发生变化时，浏览器考虑到其他元素可能也会发生变化，于是就会去检查页面中所有的元素。一直以来浏览器都是这么做的，大家都习以为常了。但从另一方面来说，开发者很清楚当前修改的元素是否独立、是否影响其他元素。因此如果开发者能把这个信息通过CSS告诉浏览器，那么浏览器就不需要再去考虑其他元素了，这就是非常完美的事情。而CSS容器模块中的contain属性就为我们提供了这种能力。\n\n们来看@Manuel Rego Casasnovas在[《An introduction to CSS Containment》](https://blogs.igalia.com/mrego/2019/01/11/an-introduction-to-css-containment/?ref=heydesigner)文章中提供的一个[示例](https://blogs.igalia.com/mrego/files/2019/01/css-contain-example.html)：\n\n假设一个页面有很多个元素，在这个示例中，我们有10000个这样的元素：\n\n```\n<div class=\"item\">\n    <div>Lorem ipsum...</div>\n</div>\n```\n\n使用JavaScript的textContent这个API来动态更改div.item > div的内容：\n\n```js\nconst NUM_ITEMS = 10000; \nconst NUM_REPETITIONS = 10; \nfunction log(text) { \n    let log = document.getElementById(\"log\"); \n    log.textContent += text; \n} \n\nfunction changeTargetContent() { \n    log(\"Change \\\"targetInner\\\" content...\"); \n\n    // Force layout. \n    document.body.offsetLeft; \n    let start = window.performance.now(); \n    let targetInner = document.getElementById(\"targetInner\"); \n    targetInner.textContent = targetInner.textContent == \"Hello World!\" ? \"BYE\" : \"Hello World!\"; \n\n    // Force layout. \n    document.body.offsetLeft; \n    let end = window.performance.now(); \n    let time = window.performance.now() - start; log(\" Time (ms): \" + time + \"\\n\"); \n\n    return time; \n} \n\nfunction setup() { \n    for (let i = 0; i < NUM_ITEMS; i++) { \n        let item = document.createElement(\"div\"); \n        item.classList.add(\"item\"); \n        let inner = document.createElement(\"div\"); \n        inner.style.backgroundColor = \"#\" + Math.random().toString(16).slice(-6); \n        inner.textContent = \"Lorem ipsum...\"; \n        item.appendChild(inner); \n        wrapper.appendChild(item); \n    } \n}\n```\n\n如果不使用contain，即使更改是在单个元素上，浏览器在布局上的渲染也会花费大量的时间，因为它会遍历整个DOM树（在本例中，DOM树很大，因为它有10000个DOM元素）：\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19cec39c8af44304a01e7bc442155f9e~tplv-k3u1fbpfcp-watermark.image)\n\n在本例中，div的大小是固定的，我们在内部div中更改的内容不会溢出它。因此，我们可以将contain: strict应用到项目上，这样当项目内部发生变化时，浏览器就不需要访问其他节点，它可以停止检查该元素上的内容，并避免到外部去。\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2584344468f47439c3ecef01fe00814~tplv-k3u1fbpfcp-watermark.image)\n\nCSS容器模块中的content-visibility属性会显著影响第一次下载和第一次渲染的速度。此外，你可以立即与新渲染的内容交互，而无需等待内容的其余部分加载。该属性强制用户代理跳过不在屏幕上的标记和绘制元素。实际上，它的工作方式类似于延迟加载，只是不加载资源，而是渲染资源。\n\n简单地说，CSS的content-visibility属性 可跳过不在屏幕上的内容渲染，包括布局（Layout）和渲染（Paint），直到真正需要布局渲染的时候为止。所以利用它可以使用初始用户加载速度更快，还能与屏幕上的内容进行更快的交互。\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01765bad264b49d2949d5c8ff05b7a7a~tplv-k3u1fbpfcp-watermark.image)\n\n上图来自于@Una Kravets和@Vladimir Levin的《content-visibility: the new CSS property that boosts your rendering performance([web.dev/content-vis…](https://web.dev/content-visibility/)》一文。从图中我们可以获知，使用content-visibility): auto属性可使分块的内容区域的初始加载性能提高7倍。\n\n有关于这方面的介绍，还可以阅读：\n\n- [CSS Containment in Chrome 52](https://developers.google.com/web/updates/2016/06/css-containment)\n- [Helping Browsers Optimize With The CSS Contain Property](https://www.smashingmagazine.com/2019/12/browsers-containment-css-contain-property/)\n- [An introduction to CSS Containment](https://blogs.igalia.com/mrego/2019/01/11/an-introduction-to-css-containment)\n- [Let’s Take a Deep Dive Into the CSS Contain Property](https://css-tricks.com/lets-take-a-deep-dive-into-the-css-contain-property/)\n- [CSS Containment](([developer.mozilla.org/zh-CN/docs/…](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Containment))\n- [content-visibility: the new CSS property that boosts your rendering performance](https://web.dev/content-visibility/)\n- [Short note on content-visibility: hidden](https://html5accessibility.com/stuff/2020/08/25/short-note-on-content-visibility-hidden/)\n- [Using content-visibility: hidden](https://www.w3.org/TR/css-contain-2/#using-cv-hidden)\n- [Using content-visibility: auto](https://www.w3.org/TR/css-contain-2/#using-cv-auto)\n\n## 数据服务\n\n数据服务指的是 Data Saver。啥意思呢？不做解释，直接用一段代码来描述：\n\n```css\n@media (prefers-reduced-data: reduce) {\n    header {\n        background-image: url(/grunge.avif);\n    }\n}\n```\n\n我想大家对于@media (prefers-reduced-data: reduce)应该不会陌生吧。是的，它就是我们所说的CSS媒体查询。只不过稍有不同的是，这个媒体查询是根据用户在设备上的设置喜好来做条件判断。比如上面示例代码，当用户在设备上开启了“Low Data Mode”（低数据模式），会加载grunge.avif图像，可以帮助iPhone上的应用程序减少网络数据的使用：\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00676b3813724664bb85d1a7bb9a75ca~tplv-k3u1fbpfcp-watermark.image)\n\n到目前为止，CSS媒体查询提供了多个媒体特性，可以以用户在设备上的喜好设置做为判断，比如iOS13+开始，[iPhone提供的DarkMode模式（prefers-color-scheme）](https://www.atatech.org/articles/153525)：\n\n![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2764327f5de4e3b88911a54e0de5876~tplv-k3u1fbpfcp-watermark.image)\n\n比如，使用prefers-reduced-motion媒体查询用于检测用户的系统是否被开启了动画减弱功能：\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/296c3e7cf4924b359ac39170b9036fbc~tplv-k3u1fbpfcp-watermark.image)\n\n上面提到的这些媒体查询条件都是在 CSS Media Queries Level 5([www.w3.org/TR/mediaque…](https://www.w3.org/TR/mediaqueries-5/)) 模块中新增的。\n\n除了上面提到的之外，还有一些我们平时很少见的媒体查询条件，比如：\n\n```css\n@media (hover: hoveer) {}\n\n@media (hover: none) and (pointer: coarse) {}\n\n@media (hover: none) and (pointer: fine) {}\n\n@media print and (min-resolution: 300dpi) {}\n\n@media (scan: interlace) {}\n\n@media (update) {}\n\n@media(environment-blending: additive){}\n\n@media (color) {}\n```\n\n## 变量字体\n\n变量字体是一个非常有意思的CSS特性，它也常被称为“可变字体”，先给大家展示一个[Demo](https://codepen.io/airen/pen/yLNpQQW)：\n\n![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e86397ef899e478e95e9aeee40458cc5~tplv-k3u1fbpfcp-watermark.image)\n\n变量字体的目标是让网站性能更好，同时给用户提供了更多选择和扩展。变量字体是类似矢量图形，允许为各种字体轴定义不同的值。变量字体设计中一般有五个注册轴，包括字体、字宽、斜体和光学尺寸。每个注册轴都有一个对应的四个字母的标记，可以映射到现有的CSS属性：\n\n![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/195ba4a12cc2421bb3ee59e28e116dca~tplv-k3u1fbpfcp-watermark.image)\n\n除了注册轴之外，字体设计器还可以包含自定义轴。自定义轴让可变字体变得更具创造性，因为不限制自定义轴的范围、定义或数量。与注册轴类似，自定义轴具有相应的四个字母标记。但是，自定义轴的字母标记必须是大写的。例如，你定义了一个注册轴是grade，其对应的字母标记是 GRAD。\n\n比如上面示例效果对应的代码：\n\n```css\n.text {\n    font-weight: 800;\n    font-style: italic;\n    font-variation-settings: \"SSTR\" 183, \"INLN\" 648, \"TSHR\" 460, \"TRSB\" 312, \"TWRM\" 638, \"SINL\" 557, \"TOIL\" 333, \"TINL\" 526, \"WORM\" 523;\n    transition: font-variation-settings .28s ease;\n}  \n\n.text:hover {\n    font-weight: 400;\n    font-style: normal;\n    font-variation-settings: \"SSTR\" 283, \"INLN\" 248, \"TSHR\" 160, \"TRSB\" 112, \"TWRM\" 338, \"SINL\" 257, \"TOIL\" 133, \"TINL\" 426, \"WORM\" 223;\n}\n```\n\n在Firefox浏览器中，我们还可以通过开发者工具中“字体”选项提供的相关可变字体注册轴的值调整：\n\n![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2543d829b0f34dae9fe57a58e9b9ebca~tplv-k3u1fbpfcp-watermark.image)\n\n调整完之后，可以获得新代码：\n\n```css\np {\n    font-size: 60px;\n    line-height: 37px;\n    letter-spacing: 0.113em;\n    font-variation-settings: \"SSTR\" 450, \"INLN\" 741, \"TSHR\" 292, \"TRSB\" 497, \"TWRM\" 173, \"SINL\" 557, \"TOIL\" 728, \"TINL\" 526, \"WORM\" 523, \"TFLR\" 362, \"TRND\" 516, \"SWRM\" 536, \"TSLB\" 509;\n    font-weight: 491;\n}\n```\n\n对应效果如下：\n\n![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dd014614fe948fab8560ba9ae5c8587~tplv-k3u1fbpfcp-watermark.image)\n\n# Web可访问性\n\n## :focus-visible 和 :focus-within\n\n一直以来我很容易把:focus-within和:focus-visible混淆。其实:focus-within和:focus-visible都是CSS选择器[Level 4中用户操作类伪类选择器](https://www.w3.org/TR/selectors-4/#useraction-pseudos)。早前在[《初探CSS 选择器Level 4》](https://www.w3cplus.com/css/css-selectors-level-4.html)中聊过:focus-within，但没有聊过:focus-visible。\n\n另外，在[《CSS :focus-within》](https://www.w3cplus.com/css/focus-within.html)教程中就提到过， :focus-within能非常方便处理获取焦点状态。当元素本身或其后代元素获得焦点时，:focus-within伪类的元素就会有效 。:focus-within伪类选择器的行为本质上是一种父选择器行为，子元素的状态会影响父元素的样式。由于这种“父选择器”行为需要借助用户的行为触发，属于“后渲染”，不会与现有的渲染机制相互冲突。\n\n![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5449da8502064eb9823f008db4adcfbd~tplv-k3u1fbpfcp-watermark.image)\n\n如果上面的介绍让你感到困惑的话，可以看下面这个[Demo](https://codepen.io/ericwbailey/pen/KQOpRM)。你会发现，当\n\n的后代元素\n\n得到焦点时，会有一个放大的效果：\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1593c1a20da14e7a8cc258c245b2f045~tplv-k3u1fbpfcp-watermark.image)\n\n实现上图的效果代码非常的简单：\n\n```css\nform:focus-within {\n    box-shadow: 0px 0.2em 2.5em #c4c4c4;\n    transform: scale(1.025); \n}\n```\n\n对于:focus-visible伪类来说，当元素匹配:focus伪类并且客户端(UA)的启发式引擎决定焦点应当可见时就会生效。这个选择器可以有效地根据用户的输入方式(鼠标 vs 键盘)展示不同形式的焦点。\n\n简单点说，按键盘tab键和鼠标点击得到的焦点效果不同。比如：\n\n```css\n/* 链接得到焦点时的样式 */ \na:focus { \n\n}\n\n/* \n* 1\\. 如果链接有焦点，但是浏览器通常不会显示默认的焦点样式，会覆盖上面的焦点样式 \n* 2\\. 不是按键盘`tab`键让链接得到的焦点，比如说鼠标点击链接\n*/\na:focus:not(:focus-visible) {\n\n}\n\n/* 按键盘tab键让链接得到焦点的样式 */ \na:focus-visible { \n\n}\n```\n\n[来看一个具体的案例](https://codepen.io/airen/pen/GRZPPVR)。这个示例中分别用鼠标点击链链和按键盘tab键让链接得到焦点，它的样式是不一样的：\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2598e55ccf5248fcbd154f2104e6e28a~tplv-k3u1fbpfcp-watermark.image)\n\n# Web美化\n\n## Color Level 4 和 Level 5\n\n[CSS Color Level 4](https://www.w3.org/TR/css-color-4) 和 [Level 5](https://www.w3.org/TR/css-color-5)两个模块主要是为我们推出了一些颜色使用的新属性，比如：\n\n- <hwb()> ：HWB(白色-白色-黑色的缩写)是另一种指定颜色的方法，类似于HSL，它描述了一开始的色调，然后是一定程度的白色和黑色混合到基本色调\n- <lab()>和<lch()> ：Lab是由一个亮度通道和两个颜色通道组成的。在Lab颜色空间中，每个颜色用L(亮度)、a(从绿色到红色的分量)和b(从蓝色到黄色的分量)三个数字表示。而Lch分别表示了颜色的亮度、饱和度和色调\n- <gray()> ：灰色是完全去饱和的颜色，gray()函数表示法简化了对这组常见颜色的指定，因此只需要一个数值参数，用来指定颜色的灰度\n- <color()> ：该函数允许在特定的颜色空间中指定颜色\n- <device-cmyk()> ：该函数是以CMYK(青色、品红、黄色和黑色)组合，在该设备上生成特定的颜色\n- ：根据用户操作系统来匹配颜色\n- color-mix() ：该函数接受两个规范，并在给定的颜色空间中以指定的数量返回它们混合的结果\n- color-contrast() ：该函数首先使用一种颜色(通常是背景色)，然后使用两种或两种以上颜色的列表，它从该列表中选择亮度对比度最高的颜色到单一颜色\n- color-adjust() ：该函数接受一个规范，并通过指定的转换函数在给定的颜色空间中返回调整该颜色的结果 颜色扩展：根据现有的颜色(在这称为“原始颜色”)在函数的目标颜色空间中生成颜色，它是<rgb()>、<rgba()>、<hsl()>、<hsla()>、<hwb()>、<lab()>和<lch()>的扩展颜色\n\n对于Web开发者来说，最大的感受是语法规则有较大的变化：\n\n![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89701d59c2614bd9a541ec99c25794bf~tplv-k3u1fbpfcp-watermark.image)\n\n来看两个示例：\n\n```\n// Color Level 4\n.colour {\n    --fn-notation: hsl(2rad 50% 50% / 80%);\n    --neon-pink: color(display-p3 1 0 1);\n    --gray: lch(50% 0 0);\n    --fallback: color(lab 25 25 25, display-p3 1 0 1, #ccc);\n}\n\n// Color Level 5\n.colour {\n    --pink: color-mix(red, white);\n    --halfpink: color(var(--pink) / 50%);\n    --halfred: rgb(from #f00 / 50%);\n    --darkred: hsl(from red h s calc(l * .25));\n}\n```\n\n这里再特意提一下display-p3颜色，我们可以配合CSS的媒体查询@media (dynamic-range: high)一起使用：\n\n```\n@media (dynamic-range: high) {\n    .neon-red {\n        --neon-glow: color(display-p3 1 0 0);\n    }\n\n    .neon-pink {\n        --neon-glow: color(display-p3 1 0 1);\n    }\n\n    .neon-purple {\n        --neon-glow: color(display-p3 0 0 1);\n    }\n\n    .neon-blue {\n        --neon-glow: color(display-p3 0 1 1);\n    }\n\n    .neon-green {\n        --neon-glow: color(display-p3 0 1 0);\n    }\n\n    .neon-yellow {\n        --neon-glow: color(display-p3 1 1 0);\n    }\n\n    .neon-white {\n        --neon-glow: color(display-p3 1 1 1);\n    }\n}\n```\n\n注意，Display-P3颜色空间颜色要比sRGB颜色空间中的颜色更鲜艳：\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e35a157b2ec4ca4aa0e3fb5f45ec4ca~tplv-k3u1fbpfcp-watermark.image)\n\n也可以说，Display-P3是sRGB的一个超集，大约要大35%：\n\n![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7facc99fcacd4175bd29210dbbadbcd7~tplv-k3u1fbpfcp-watermark.image)\n\nSafari 97预览版本可以查看到display-p3的效果：\n\n![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac858ab58de04d29968e517b7a3ae325~tplv-k3u1fbpfcp-watermark.image)\n\n同样的，在color()函数中使用display-p3指定颜色空间时，也可以和sRGB颜色空间相互转换，如下图所示：\n\n![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4a590cd6ac049e18648280836dffb00~tplv-k3u1fbpfcp-watermark.image)\n\n下面是@Adam Argyle 在Codepen提供的一个有关于[display-p3的示例](https://codepen.io/argyleink/pen/MWymQGj)：\n\n![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b1f6532e1ba48b790ed8a25f9962f1e~tplv-k3u1fbpfcp-watermark.image)\n\n## ::marker\n\n::marker也是CSS的伪元素，现在被纳入到CSS Lists Module Level 3规范中。在该规范中涵盖了列表和计算数器相关的属性，比如我们熟悉的list-style-type、list-style-position、list-style、list-item、counter-increment、counter-reset、counter()和counters()等属性。\n\n在CSS中display设置list-item值之后就会生成一个Markers标记以及控制标记位置和样式的几个属性，而且还定义了计数器（计数器是一种特殊的数值对象），而且该计数器通常用于生成标记（Markers）的默认内容。\n\n一时之间，估计大家对于Markers标记并不熟悉，但对于一个列表所涉及到的相关属性应该较为熟悉，对于一个CSS List，它可以涵盖了下图所涉及到的相关属性：\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db4275d10de5461c908691dd4a76be5e~tplv-k3u1fbpfcp-watermark.image)\n\n事实上，CSS的::marker和伪元素::before（或::after）类似，也可以通过content和attr()一起来控制Marker标记的效果。需要记住，生成个性化Marker标记内容需要做到几下几点：\n\n非列表项li元素需要显式的设置display:list-item （内联列表项需要使用display: inline list-item）\n\n需要显式设置list-style-type为none\n\n使用content添加内容（也可以通过attr()配合data-*来添加内容）\n\n比如下面这个小示例：\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fadd1aeb08749cbbe54a14912b8bd02~tplv-k3u1fbpfcp-watermark.image)\n\n另外，::marker还没有得到浏览器支持之前，一般都是使用CSS的计数器来实现一些带有个性化的有顺序列表，比如下面这样的效果：\n\n![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5902e78ed3f9412bb977229e54572324~tplv-k3u1fbpfcp-watermark.image)\n\n是不是很有意思，有关于::marker伪元素更详细的介绍，还可以阅读：[《 Custom bullets with CSS ::marker》](https://web.dev/css-marker-pseudo-element/)一文。\n\n## text-emphasis\n\n先上张图：\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f894714b58e446baaa5d86138b847d35~tplv-k3u1fbpfcp-watermark.image)\n\n上图的效果就是使用CSS的text-emphasis实现的。在以往我们要给文本添加一些装饰效果，除了加粗（font-weight）、倾斜（font-style）、阴影（text-shadow），文本上面或下面添加线条（text-decoration）等之外也没有别的了（当然，还可以使用其他的CSS实现一些特殊效果）。但要实现上图的效果还是有一定难度的。不过text-emphasis的出现，这一切变得要简单地多。\n\ntext-emphasis是属于 CSS Text Decoration Module 规范中的一个特性，在 [Level 3](https://www.w3.org/TR/css-text-decor-3/#emphasis-marks)中和text-emphasis有关的属性还有text-emphasis-style和text-emphasis-color，而且text-emphasis是这两个属性的简写属性。另外还有一个用来指定标记符位置的属性text-emphasis-position：\n\n```\n.emphasis {\n    text-emphasis: triangle rebeccapurple;\n    text-emphasis-position: under;\n}\n```\n\n![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8ccd0f5617a4f96a05c71aa42d037b5~tplv-k3u1fbpfcp-watermark.image)\n\n在 Level 4的规范中还新增了[text-emphasis-skip属性](https://www.w3.org/TR/css-text-decor-4/#text-emphasis-skip)。\n\n[具体的效果如下：](https://codepen.io/airen/pen/yLOZpzO)\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/538851f309cd43cc8bdd65d27b10ab97~tplv-k3u1fbpfcp-watermark.image)\n\n## color-scheme\n\ncolor-scheme属性来自于 [CSS Color Adjustment Module Level 1](https://drafts.csswg.org/css-color-adjust/#color-scheme-prop)。如果你在自己的项目中实现过[iOS的DarkMode的效果](https://www.atatech.org/articles/153525)，你肯定使用过CSS的媒体查询prefers-color-scheme。\n\n```css\n:root {\n    --color: #fff;\n    --color-bg: #000;\n}\n\n@media (prefers-color-scheme: dark) {\n    --color: #000;\n    --color-bg: #fff;\n}\n\nbody {\n    color: var(--color);\n    background-color: var(--color-bg)\n}\n```\n\n虽然说，这可以让用户根据自己喜好来选择自己喜欢的皮肤，但这并不能覆盖所有的。这个时候可以使用color-scheme属性来做一定的补充。该属性允许用户通过用户代理控制自动调整色彩模式，比如暗色模式，对比度调整或特定所需的配色方案。这些值与用户的首选项进行协商，从而产生影响用户界面（UI）内容的所选颜色方案，例如表单控制和滚动条的默认颜色，以及CSS系统颜色的使用值。\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27d242673ae94a6bba57a48893317a56~tplv-k3u1fbpfcp-watermark.image)\n\ncolor-scheme有两种用法，先来看第一种:\n\n```\n:root {\n    color-scheme: dark light;\n}\n```\n\n在:root元素上，使用color-scheme颜色方案进行渲染，会影响画布的表面颜色（即全局背景颜色），color属性的初始值和系统颜色的使用值，还应该影响视窗滚动条颜色。\n\n另外一种使用方式是在标签上：\n\n```\n<meta name=\"color-scheme\" content=\"dark light\" />\n```\n\n要遵守color-scheme CSS属性，需要先下载CSS（如果它是通过引用的）并进行解析。为了帮助用户代理立即用所需的颜色方案渲染页面背景，还可以在元素中提供一个颜色方案值。\n\n由于meta标记和CSS属性(如果应用到:root)最终都会导致相同的行为，所以我更建议通过meta标记指定颜色方案，这样浏览器可以更快地采用首选方案。\n\n最后给大家提供[@tomayac](https://twitter.com/tomayac)提供的一个关于[color-scheme的Demo](https://color-scheme-demo.glitch.me/)，下图是dark和light下相应的效果：\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bce8135058a545688d0131dcac558da5~tplv-k3u1fbpfcp-watermark.image)\n\n这里仅仅是简单的说了一下color-scheme属性，如果想深入的了解还是需要阅读一些相关的教程：\n\n[CSS Color Adjustment Module Level 1: color-scheme](https://drafts.csswg.org/css-color-adjust/#color-scheme-prop)\n\n[Improved dark mode default styling with the color-scheme CSS property and the corresponding meta tag](https://web.dev/color-scheme/)\n\n[Don’t Forget the color-scheme Property](https://blog.jim-nielsen.com/2020/color-scheme-property/)\n\n# 其他\n\n## & > 和 @nest\n\n很多同学应该使用过像Sass、LESS之类的CSS处理器，这些处理器中有一个特大的特性就是选择器的嵌套，比如Sass中：\n\n```css\n.parent {\n    & > .child {\n        color: red;\n    }\n}\n\n.child {\n    .parent & {\n        color: blue;\n    }\n}\n```\n\n编译之后的CSS：\n\n```css\n.parent > .child {\n    color: red;\n}\n\n.parent .child {\n    color: blue;\n}\n```\n\n以往只能在CSS处理器中使用这样的特性，但将来在CSS中也可以使用这方面的特性，因为现在CSS中新增了一个嵌套模块，即 [CSS Nesting Module](https://drafts.csswg.org/css-nesting-1)。有点类似于CSS自定义属性（变量）特性一样，最早也是出现在CSS处理器中，现在原生CSS也支持了这方面的特性。\n\n也就是说，在不久的将来（如果在你的工程构建中配置了[postcss-preset-env](https://preset-env.cssdb.org/)，现在就可以使用）：\n\n```css\narticle, section {\n    &  p { \n        color: blue; \n    }\n}\n```\n\n相当于：\n\n```css\n:is(article, section) p { \n    color: blue; \n}\n```\n\n也就是：\n\n```css\narticle p,\nsection p {\n    color: blue\n}\n```\n\n还可以是& >结合起来使用：\n\n```css\narticle, section {\n    & > p { \n        color: blue; \n    }\n}\n```\n\n相当于：\n\n```css\narticle > p, \nsection > p{\n    color: blue; \n}\n```\n\n再来看另外几种有效的嵌套方式：\n\n```css\n.foo {\n    color: blue;\n    & > .bar { \n        color: red; \n    }\n}\n/* 等同于 */\n.foo { \n    color: blue; \n}\n.foo > .bar { \n    color: red; \n}\n\n.foo {\n    color: blue;\n    &.bar { \n        color: red; \n    }\n}\n/* 等同于 */\n.foo { \n    color: blue; \n}\n.foo.bar { \n    color: red; \n}\n\n.foo, .bar {\n    color: blue;\n    & + .baz, &.qux { \n        color: red; \n    }\n}\n/* 等同于 */\n.foo, .bar { \n    color: blue; \n}\n:is(.foo, .bar) + .baz,\n:is(.foo, .bar).qux { \n    color: red; \n}\n```\n\n但是下面这几种写法将是 无效的：\n\n```css\n/* 无效，因为没有嵌套选择器 */\n.foo {\n    color: red;\n    .bar { \n        color: blue; \n    }\n}\n\n/* 无效，因为&不在第一个复合选择器中 */\n.foo {\n    color: red;\n    .bar & { \n        color:blue; \n    }\n}\n\n/* 无效，因为列表中的第二个选择器不包含嵌套选择器 */\n.foo {\n    color: red;\n    &.bar, .baz { \n        color: blue; \n    }\n}\n```\n\n还可以结合 @nest 使用。下面这几种嵌套方式都是有效的：\n\n```css\n.foo {\n    color: red;\n    @nest & > .bar {\n        color: blue;\n    }\n}\n/* 等同于 */\n.foo { \n    color: red; \n}\n.foo > .bar { \n    color: blue; \n}\n\n.foo {\n    color: red;\n    @nest .parent & {\n        color: blue;\n    }\n}\n/* 等同于 */\n.foo { \n    color: red; \n}\n.parent .foo { \n    color: blue; \n}\n\n.foo {\n    color: red;\n    @nest :not(&) {\n        color: blue;\n    }\n}\n/* 等同于 */\n.foo { \n    color: red; \n}\n:not(.foo) { \n    color: blue; \n}\n```\n\n但像下面这样嵌套则是无效的：\n\n```css\n/* 无效，因为没有嵌套选择器 */\n.foo {\n    color: red;\n    @nest .bar {\n        color: blue;\n    }\n}\n\n/* 无效，因为不是列表中的所有选择器都包含嵌套选择器 */\n.foo {\n    color: red;\n    @nest & .bar, .baz {\n        color: blue;\n    }\n}\n```\n\n注意，如果使用@nest时记得要和&结合在一起使用才有效。\n\n## @property\n\n在CSS Houdini中，最令人兴奋的是给CSS自定义属性和值的API。这个API通过赋予CSS自定义属性（通常也称为CSS变量）语义意义（由语法定义）甚至回退值来增强CSS自定义属性。\n\n简单地说，可以使用CSS Houdini的CSS自定义属性和值的CSS.registerProperty()来注册一个自定义属性：\n\n```css\nCSS.registerProperty({\n    name: '--colorPrimary',\n    syntax: '<color>',\n    initialValue: 'magenta',\n    inherits: false\n});\n```\n\n这样一来就可以使用已注册好的--colorPrimary自定义属性：\n\n```css\n.card {\n    background-color: var(--colorPrimary); /* magenta */\n}\n\n.highlight-card {\n    --colorPrimary: yellow;\n    background-color: var(--colorPrimary); /* yellow */\n}\n\n.another-card {\n    --colorPrimary: 23;\n    background-color: var(--colorPrimary); /* magenta */\n}\n```\n\n现在或者将来，我们可以直接使用CSS的@property来注册一个自定义属性：\n\n```css\n@property --gradient-start {\n    syntax: \"<color>\";\n    initial-value: white;\n    inherits: false;\n}\n```\n\n在CSS中就可以直接像下面这样使用：\n\n```css\n.el {\n    --gradient-start: white;\n    background: linear-gradient(var(--gradient-start), black);\n    transition: --gradient-start 1s;\n}\n\n.el:hover {\n    --gradient-start: red;\n}\n```\n\n比如下面这个[示例](https://codepen.io/airen/pen/poyqBGe)（请使用Chrome 85+查看）：\n\n![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b510aab114fb4247ae1206f30347d13a~tplv-k3u1fbpfcp-watermark.image)\n\n在CSS的世界中，还有另外一套规范是和CSS自定义属性有关的，那就是[CSS Custom Properties for Cascading Variables Module Level 1](https://www.w3.org/TR/css-variables-1/)。使用--在选择器块中声明自定义属性，然后使用var()函数引用已声明的自定义属性，将其当作CSS属性的值：\n\n```css\n:root {\n    --color: #f09\n}\n\nbody {\n    color: var(--color)\n}\n```\n\n到目前为止，CSS自定义属性（也有同学称为CSS变量）已经得到了主流浏览器的使用，而且在一些大型Web应用中可以看到其身影。另外CSS自定义属性被运用的场景也很多，比如说@Adam Argyle就用CSS自定义属性模拟了[一套缓动函数](https://codepen.io/argyleink/full/BajvPLz)，我们可以用于CSS Animation中：\n\n```css\n:root {\n    --ease-in-quad: cubic-bezier(0.55, 0.085, 0.68, 0.53);\n    --ease-in-cubic: cubic-bezier(0.55, 0.055, 0.675, 0.19);\n    --ease-in-quart: cubic-bezier(0.895, 0.03, 0.685, 0.22);\n    --ease-in-quint: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n    --ease-in-expo: cubic-bezier(0.95, 0.05, 0.795, 0.035);\n    --ease-in-circ: cubic-bezier(0.6, 0.04, 0.98, 0.335);\n    --ease-out-quad: cubic-bezier(0.25, 0.46, 0.45, 0.94);\n    --ease-out-cubic: cubic-bezier(0.215, 0.61, 0.355, 1);\n    --ease-out-quart: cubic-bezier(0.165, 0.84, 0.44, 1);\n    --ease-out-quint: cubic-bezier(0.23, 1, 0.32, 1);\n    --ease-out-expo: cubic-bezier(0.19, 1, 0.22, 1);\n    --ease-out-circ: cubic-bezier(0.075, 0.82, 0.165, 1);\n    --ease-in-out-quad: cubic-bezier(0.455, 0.03, 0.515, 0.955);\n    --ease-in-out-cubic: cubic-bezier(0.645, 0.045, 0.355, 1);\n    --ease-in-out-quart: cubic-bezier(0.77, 0, 0.175, 1);\n    --ease-in-out-quint: cubic-bezier(0.86, 0, 0.07, 1);\n    --ease-in-out-expo: cubic-bezier(1, 0, 0, 1);\n    --ease-in-out-circ: cubic-bezier(0.785, 0.135, 0.15, 0.86);\n\n    --easing: var(--ease-in-quad);\n}\n\n.animation__target {\n    animation: ani 5s var(--easing) alternate infinite;\n}\n\n// JavaScript\nconst handlerElement = document.getElementById(\"easing\");\n\nhandlerElement.addEventListener(\"change\", function (e) {\n        document.documentElement.style.setProperty(\"--easing\", e.target.value);\n});\n```\n\n[点击这里查看效果](https://codepen.io/airen/pen/ExPryme)：\n\n![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9fea68f071e46f28f8bce7469a45a25~tplv-k3u1fbpfcp-watermark.image)\n\n## ::cue`和`::cue(selector)\n\n::cue和::cue(selector)对我而言是一个全新的东西，这两个伪元素是 [WebVTT: The Web Video Text Tracks Format](https://w3c.github.io/webvtt/#the-cue-pseudo-element) 模块中的。\n\n::cue和::cue(selector)两个伪元素最大的差别是后者带参数的伪元素。具体的作用：\n\n- ::cue伪元素（不带参数）匹配元素构造的任何WebVTT节点对象列表，但与背景符号对应的属性必须应用于WebVTT线索背景框，而不是WebVTT节点对象列表\n- ::cue(selector)是带有参数的伪元素，必须有一个由CSS选择器组成的参数。它匹配元素构造的WebVTT内部节点对象，该元素也匹配给定的CSS选择器\n\n在CSS中只有部分属性可以运用于::cue和::cue(selector)两个伪元素，比如color、opacity、visibility、text-decoration、text-shadow、background、outline、font、line-height、white-space、text-combine-upright和ruby-position等。\n\n```\n::cue {\n    color: white;\n    background-color: hsl(0 0% 0% / 90%);\n}\n```\n\n说实话，没有完全阅读 WebVTT: [The Web Video Text Tracks Format](https://w3c.github.io/webvtt) 模块所有内容，对其并不完全了解。这里只是做一个抛砖引玉的作用，如果你的工作内容和WebVTT相关，那应该对你会有一定的作用；如果你对这方面感兴趣的话，可以深挖这方面的知识。\n","children":[]},{"name":"待整理代码.md","path":"../guanruihua.github.io/Front-End/其他","data":"\r\n16.::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用\r\n（1）、冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。\r\n（2）、::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。\r\n🍀注意： :before 和 :after 这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before ::after。\r\n\r\n38.有哪几种隐藏元素的方法？\r\n\r\nvisibility: hidden; 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在；\r\nopacity: 0;``CSS3属性，设置0可以使一个元素完全透明；\r\nposition: absolute; 设置一个很大的 left 负值定位，使元素定位在可见区域之外；\r\ndisplay: none; 元素会变得不可见，并且不会再占用文档的空间；\r\ntransform: scale(0); 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留；\r\n<div hidden=\"hidden\"> HTML5属性,效果和display:none;相同，但这个属性用于记录一个元素的状态；\r\nheight: 0; 将元素高度设为 0 ，并消除边框；\r\nfilter: blur(0); CSS3属性，括号内的数值越大，图像高斯模糊的程度越大，到达一定程度可使图像消失（此处感谢小伙伴支持）；\r\n\r\n39.li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？\r\nli排列受到中间空白(回车/空格)等的影响，因为空白也属于字符，会被应用样式占据空间，产生间隔。解决办法：\r\n\r\n在ul中用font-size：0（谷歌不支持）；可以使用letter-space：-3px;\r\n设置float：left；\r\n\r\n41.🤭全屏滚动的原理是什么？用到了CSS的哪些属性？\r\n全屏滚动有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%。也可以理解为超出隐藏部分，滚动时显示。\r\n可能用到的CSS属： overflow:hidden; transform:translate(100%, 100%); display:none;\r\n❤️拓展 ： 也可以利用全屏视觉滚动差，使用background-attachment: fixed; 来实现全屏效果。（这里是细心的小伙伴提出的另一个idea🤨）\r\n\r\n18.html转图片\r\n需要安装插件dom-to-image\r\nnpm install dom-to-image\r\n\r\nimport domtoimage from 'dom-to-image';\r\ndownLoadPhoto () {\r\n  const node = document.getElementById('table')//对应的html标签id\r\n  domtoimage.toPng(node)\r\n    .then((dataUrl) => {\r\n      const img = new Image()\r\n      img.src = dataUrl\r\n      // 将获取到的base64下载下来\r\n      const imgUrl = img.src\r\n      if (window.navigator.msSaveOrOpenBlob) {\r\n        const bstr = atob[imgUrl.split(','](1))\r\n        let n = bstr.length\r\n        const u8arr = new Uint8Array(n)\r\n        while (n--) {\r\n          u8arr[n] = bstr.charCodeAt(n)\r\n        }\r\n        const blob = new Blob([u8arr])\r\n        window.navigator.msSaveOrOpenBlob(blob, 'chart-download' + '.' + 'png')\r\n      } else {\r\n        // 这里就按照chrome等新版浏览器来处理\r\n        const a = document.createElement('a')\r\n        a.href = imgUrl\r\n        a.setAttribute('download', 'chart-download')\r\n        a.click()\r\n      }\r\n    })\r\n}\r\n\r\n19.字符串转base与base64转字符串\r\n// 加密\r\nfunction base64EncodeUnicode(str) {\r\n    return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {\r\n        return String.fromCharCode('0x' + p1);\r\n    }));\r\n}\r\n\r\n// 解密\r\nfunction base64DecodeUnicode(str) {\r\n    return decodeURIComponent(atob(str).split('').map(function(c) {\r\n        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\r\n    }).join(''));\r\n}\r\n\r\n20.图片添加水印\r\nconst setWatermark = ({\r\n  url = '',\r\n  textAlign = 'center',\r\n  textBaseline = 'middle',\r\n  font = \"20px Microsoft Yahei\",\r\n  fillStyle = 'rgba(184, 184, 184, 0.8)',\r\n  content = '水印',\r\n  cb = null,\r\n  textX = 100,\r\n  textY = 30\r\n} = {}) => {\r\n  const img = new Image()\r\n  img.src = url\r\n  img.crossOrigin = 'anonymous'\r\n  img.onload = function () {\r\n    const canvas = document.createElement('canvas')\r\n    // 斜式水印处理\r\n    const _w = img.width\r\nconst_h = img.height\r\n    const clientWidth = document.body.clientWidth\r\nconst proportion =_h /_w\r\n\r\n    canvas.width = _w\r\n    canvas.height = _h\r\n    const ctx = canvas.getContext('2d')\r\n    ctx.drawImage(img, 0, 0, clientWidth, clientWidth * proportion)\r\n    ctx.textAlign = textAlign\r\n    ctx.textBaseline = textBaseline\r\n    ctx.font = font\r\n    ctx.fillStyle = fillStyle\r\n    // ctx.fillText(content, _w - textX, _h - textY) // 右下角水印\r\n\r\n    // 斜式水印\r\n    ctx.rotate((-15 * Math.PI) / 180)\r\n    for (let i = 0; i < 5; i++) {\r\n      for (let j = 0; j < 7; j++) {\r\n        ctx.fillText(content, i * (clientWidth / 5), j * (clientWidth * proportion / 5))\r\n      }\r\n    }\r\n    const base64Url = canvas.toDataURL()\r\n    cb && cb(base64Url)\r\n  }\r\n}\r\n//  用法\r\nsetWatermark({\r\n  url: 'xxxx',\r\n  content: '测试水印',\r\n  cb: (base64Url) => {\r\n    console.log(base64Url)\r\n  }\r\n})\r\n\r\n21.获取hh:mm:ss时间\r\nconst timeFormat = date => date.toTimeString().slice(0, 8)\r\ntimeFormat(new Date())\r\n\r\n22.移动端获取软键盘高度\r\n// ios软键盘弹起后 可以修改固定底部的元素bottom的值\r\nvisualViewport.addEventListener('resize', () => {\r\n  let keyboardHeight = document.body.clientHeight - visualViewport.height\r\n})\r\n\r\n一、日期处理\r\n\r\n1. 去除字符串中的HTML\r\n该方法用于去除字符串中的HTML元素：\r\nconst stripHtml = html => (new DOMParser().parseFromString(html, 'text/html')).body.textContent || '';\r\n","children":[]}]},{"name":"包管理器","path":"../guanruihua.github.io/Front-End","data":"","children":[{"name":"cnpm.md","path":"../guanruihua.github.io/Front-End/包管理器","data":"# cnpm\r\n\r\n## 问题\r\n\r\n### cnpm : 无法加载文件 C:\\Users\\AppData\\Roaming\\npm\\cnpm.ps1，因为在此系统上禁止运行脚本\r\n\r\n> 提示信息：系统禁止运行脚本。这时我们需要更改系统的执行策略，使得脚本能够在我们的系统上执行。\r\n过程如下：\r\n>\r\n> 首先，以管理员身份运行 Windows PowerShell\r\n> 然后，输入命令 set-ExecutionPolicy RemoteSigned 更改执行策略。\r\n> 最后，输入 Y, 执行更改策略。\r\n","children":[]},{"name":"npm","path":"../guanruihua.github.io/Front-End/包管理器","data":"","children":[{"name":"npm-cli.md","path":"../guanruihua.github.io/Front-End/包管理器/npm","data":"# npm CLI\r\n\r\n## 目录\r\n\r\n- 本地模式：npm 将包安装到当前项目目录，默认为当前工作目录。\r\n  - 软件包安装到 `./node_modules`，并将 bin 安装到`./node_modules/.bin`\r\n\r\n- 全局模式：npm 将包安装到安装前缀到 `$npm_config_prefix/lib/node_modules`和 `$npm_config_prefix/bin`\r\n\r\n## Hooks\r\n\r\n- `prepublish`: 在publish该包之前执行。(在包目录下执行npm install时也会执行)\r\n- `postpublish`: 在该包publish之后执行\r\n- `preinstall`: 在该包被install之前执行\r\n- `postinstall`: 在该包被install之后执行\r\n- `preuninstall`: 在该包被uninstall之前执行\r\n- `postuninstall`: 在该包被uninstall之后执行\r\n- `preversion`: 在修改该包的version之前执行\r\n- `postversion`: 在修改该包的version之后执行\r\n- `pretest`, `posttest`: 在该包内执行test时执行，其中pretest先于posttest\r\n- `prestop`, `poststop`: 在该包内执行stop时执行，其中prestop先于poststop\r\n- `prestart`,`poststart`: 在该包内执行start时执行，其中prestart先于poststart\r\n\r\n- `prerestart`, `postrestart`: 在该包内执行`restart`脚本时执行，其中prerestart先于postrestart。注意: 如果没有在scripts里显示指定restart脚本，则会自动调用stop，然后再start\r\n\r\n- 上面这些Hooks都是npm预定义好的，也就是说，当你执行npm install时，如果你在scripts里定义了preinstall和postinstall，那它们分别会在npm install之前/后自动执行\r\n","children":[]},{"name":"npm包.md","path":"../guanruihua.github.io/Front-End/包管理器/npm","data":"# npm包\n\n## react\n\n> 代码高亮 <https://github.com/react-syntax-highlighter/react-syntax-highlighter>\n>\n> - 组件拖拽 <https://react-dnd.github.io/react-dnd/docs/api/drag-source>\n> - 组件拖拽 <https://github.com/atlassian/react-beautiful-dnd#readme>\n> - [React源码技术揭秘](https://react.iamkasong.com/preparation/source.html#拉取源码)\n> - react-quill  [react-quill的使用_Alone patients的博客](https://blog.csdn.net/weixin_45551411/article/details/104791466)\n\n## npm包\n\n- <https://www.npmjs.com/package/qs>\n- [node打包可执行文件工具——Pkg](https://www.cnblogs.com/mordom/archive/2018/01/23/8337337.html)\n- prisma\n- <http://createjs.cc/>\n- <https://github.com/jaywcjlove/onlinenetwork>\n- <https://www.npmjs.com/package/mitt>\n- <https://www.npmjs.com/package/validator>\n- <https://www.npmjs.com/package/yup>\n- <https://www.npmjs.com/package/date-fns>\n- <https://www.npmjs.com/package/jsonwebtoken>\n- <https://ramda.cn/>\n- <https://www.npmjs.com/package/winston>\n- <https://github.com/junqiuzhang/react-virtualize>\n- <https://github.com/junqiuzhang/easy-drag>\n\n## 包管理器\n\n管理、读取和打包 JavaScript 库的工具。\n\n- [npm](https://www.npmjs.com/)：npm 是 JavaScript 的包管理器。\n- [Bower](https://github.com/bower/bower)：一个 web 应用的包管理器。\n- [component](https://github.com/componentjs/component)：能构建更好 web 应用的客户端包管理器。\n- [spm](https://github.com/spmjs/spm)：全新的静态包管理器。\n- [jam](https://github.com/caolan/jam)：一个专注于浏览器端的包管理器, 兼容 RequireJS 。\n- [jspm](https://github.com/jspm/jspm-cli)：流畅的浏览器包管理器。\n- [Ender](https://github.com/ender-js/Ender)：没有库文件的程序库。\n- [volo](https://github.com/volojs/volo)：以项目模板、添加依赖项与自动化生成的方式创建前端项目。\n- [Duo](https://github.com/duojs/duo)：融合了 Component、Browserify 和 Go 的最佳思想，快速无痛开发组织前端代码的下一代包管理器。\n- [yarn](https://yarnpkg.com/lang/en/)：高效、稳定、安全的依赖管理器。\n- [pnpm](https://pnpm.js.org/)：效率高、磁盘利用率高的包管理器\n\nrnm\n\nnvm: node版本管理器\n","children":[]},{"name":"npm指令说明.md","path":"../guanruihua.github.io/Front-End/包管理器/npm","data":"# npm\n\n## 常用npm命令\n\n1. `npm -v`：查看npm版本。\n2. `npm init`：初始化后会出现一个`package.json`配置文件。可以在后面加上`-y` ，快速跳过问答式界面。\n3. `npm install`：会根据项目中的`package.json`文件自动下载项目所需的全部依赖。\n4. `npm install 包名 --save-dev`(`npm install 包名 -D`)：安装的包只用于开发环境，不用于生产环境，会出现在`package.json`文件中的`devDependencies`属性中。\n5. `npm install 包名 --save`(`npm install 包名 -S`)：安装的包需要发布到生产环境的，会出现在package.json文件中的`dependencies`属性中。\n6. `npm list`：查看当前目录下已安装的node包。\n7. `npm list -g`：查看全局已经安装过的node包。\n8. `npm --help`：查看npm帮助命令。\n9. `npm update 包名`：更新指定包。\n10. `npm uninstall 包名`：卸载指定包。\n11. `npm config list`：查看配置信息。\n12. `npm 指定命令 --help`：查看指定命令的帮助。\n13. `npm info 指定包名`：查看远程npm上指定包的所有版本信息。\n14. `npm config set registry https://registry.npm.taobao.org`： 修改包下载源，此例修改为了淘宝镜像。\n15. `npm root`：查看当前包的安装路径。\n16. `npm root -g`：查看全局的包的安装路径。\n17. `npm ls 包名`：查看本地安装的指定包及版本信息，没有显示empty。\n18. `npm ls 包名 -g`：查看全局安装的指定包及版本信息，没有显示empty。\n\n## Config\n\n`npm config ls -l`: 查看一组 npm 内部的配置参数，如果没有指定其他参数，则为默认值。\n\n- `-a`: `--all`\n- `--enjoy-by`: `--before`\n- `-c`: `--call`\n- `--desc`: `--description`\n- `-f`: `--force`\n- `-g`: `--global`\n- `-L`: `--location`\n- `-d`: `--loglevel info`\n- `-s`: `--loglevel silent`\n- `--silent`: `--loglevel silent`\n- `--ddd`: `--loglevel silly`\n- `--dd`: `--loglevel verbose`\n- `--verbose`: `--loglevel verbose`\n- `-q`: `--loglevel warn`\n- `--quiet`: `--loglevel warn`\n- `-l`: `--long`\n- `-m`: `--message`\n- `--local`: `--no-global`\n- `-n`: `--no-yes`\n- `--no`: `--no-yes`\n- `-p`: `--parseable`\n- `--porcelain`: `--parseable`\n- `-C`: `--prefix`\n- `--readonly`: `--read-only`\n- `--reg`: `--registry`\n- `-S`: `--save`\n- `-B`: `--save-bundle`\n- `-D`: `--save-dev`\n- `-E`: `--save-exact`\n- `-O`: `--save-optional`\n- `-P`: `--save-prod`\n- `-?`: `--usage`\n- `-h`: `--usage`\n- `-H`: `--usage`\n- `--help`: `--usage`\n- `-v`: `--version`\n- `-w`: `--workspace`\n- `--ws`: `--workspaces`\n- `-y`: `--yes`\n\n## 更新安装包\n\n### 手动更新\n\n修改`package.json`中依赖包版本，执行`npm install --force`\n\n### 使用第三方插件\n\n`npm install -g npm-check-updates`\n`ncu` // 查看可更新包\n`ncu` -u // 更新package.json\n`npm install` // 升级到最新版本\n\n### 更新指定包\n\n`npm -g install <name>`\n\n```shell\n安装但不写入package.json；\nnpm install xxx\n\n安装并写入package.json的\"dependencies\"中\nnpm install xxx –S \n\n安装并写入package.json的\"devDependencies\"中\nnpm install xxx –D\n\n全局安装\nnpm install xxx -g\n\n安装指定版本\nnpm install xxx@1.2.0\n\n更新\n先检查更新\nnpm outdated\n\n执行以上命令，可以看到所有可以更新的模块。\n我们需要先更新 package.json文件：\n安装\"npm-check-updates\"模块\nnpm install -g npm-check-updates\n\n检查可更新的模块\nncu\n\nnpm-check-updates\n\n以上两条命令都可检查可更新模块。接下来更新package.json的依赖包到最新版本：\nncu -u\n\n以上命令执行，更新全部模块。但在实际开发中不建议一次全部更新，可以根据实际需要，更新指定的模块，并且可以根据作用范围在后面加上 -D、-S 或 -g\nnpm update xxx\n\n注意：指定更新需要提前修改 package.json 中的版本号。\n为了保险起见，package.json 更新后，可删除整个node_modules目录并重新初始化项目。\nnpm install\n\n删除\n删除指定模块；\nnpm uninstall xxx \n\n删除全局模块\nnpm uninstall -g xxx\n```\n","children":[]},{"name":"yarn.md","path":"../guanruihua.github.io/Front-End/包管理器/npm","data":"---\ntitle: yarn\ndate: 2020-10-31 14:02:19\ntags:\n- yarn\n- tool\n---\n\n# yarn\n\n**安装 Yarn**\n\n> npm install -g yarn\n\n**安装 CYarn**\n\n> npm install -g cyarn\n\n或者使用 cnpm 源：\n\n> npm install -g cyarn –registry=[https://registry.npm.taobao.org](https://registry.npm.taobao.org/)\n\n**1、初始化一个新的项目**\n\n> yarn init = 》 **npm init**\n\n**2、添加一个依赖包**\n\n> `yarn add [package] = 》**npm install [package] - -save**\n> yarn add [package]@[version]\n> yarn add [package]@[tag]\n> yarn add [package] - -dev = 》npm install [package]- -save-dev\n> yarn global add [package] = 》npm install [package]- -global `\n\n**3、更新一个依赖包**\n\n> `yarn upgrade [package] =》npm update - -save\n> yarn upgrade [package]@[version]\n> yarn upgrade [package]@[tag] `\n\n**4、删除一个依赖包**\n\n> `yarn remove [package] =》npm uninstall [package]- -save`\n\n**5、安装所有的依赖包**\n\n> yarn or yarn install =》**npm install**\n\n**6、 运行脚本**\n\n> yarn run =》 **npm run**\n\n**7、package缓存**\n\n> yarn cache ls 列出每个缓存的包\n> yarn cache clean 清除本地缓存\n\n**8、yarn配置文件**\n\n> yarn config list 列出所有配置项\n> yarn config get xxx 显示某项配置的值\n> yarn config set xxx xxx 修改配置\n> yarn config delete xxx 删除配置\n\n更改路径配置（换成淘宝镜像）\n\n> `yarn config set registry [https://registry.npm.taobao.org](https://registry.npm.taobao.org/)`\n\n**9、显示包信息**\n\n> `yarn info React`\n\n```powershell\nnpm init                                 ---- yarn init\nnpm install                               ---- yarn add\nnpm install xxx@1.1.1 -g                  \t\t ---- yarn global add xxx@1.1.1\nnpm install xxx@1.1.1 --save            \t\t\t  \t---- yarn add xxx@1.1.1\nnpm install xxx@1.1.1 --save-dev    \t\t\t\t\t\t\t ---- yarn add xxx@1.1.1 --dev\nnpm uninstall xxx --save(-dev)         \t\t\t\t\t ----yarn remove xxx\nnpm run xxx                              ---- yarn run xxxx\n```\n\n","children":[]},{"name":"制作NPM包","path":"../guanruihua.github.io/Front-End/包管理器/npm","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Front-End/包管理器/npm/制作NPM包","data":"# NPM包制作\n\n## 前置工作\n\n> 1. 先去<https://www.npmjs.com/signup> 注册一个用户\n> 2. 在本地登录好自己的账号`npm login`\n\n### 登录失败\n\n> 指向源出错\n\n```shell\nnpm login --registry=https://registry.npmjs.org/\n```\n\n### 开始\n\n> 1. 创建项目\n> 2. 创建``package.json`:`npm init`\n> 3. 开始编辑您的组件\n\n### 发布\n\n> 1. 发布`npm publish`\n> 2. 然后就可以到官网搜索发布的包\n\n### 添加链接访问功能\n\n```json\n{\n  \"unpkg\": \"dist/bundle.js\",\n  \"jsdelivr\": \"dist/bundle.js\"\n}\n```\n\n### npm 上传白名单\n\n> 在``package.json`添加代码\n\n```js\n\"files\":[\n \"src\",\n  \"demo\",\n  \"index.js\",\n]\n```\n\n### npm上传黑名单\n\n> 在项目根目录下添加`.npmignore`文件: 定义即使在白名单中, 也会被忽略\n>\n> 和`gitignore`文件写法类似\n\n```js\n/demo\n```\n\n### npm包删除和弃用\n\n> - 撤销发布的包( 24 小时内 ): `npm unpublish`\n>\n> - 弃用特定版本以及版本范围: `npm deprecate <pkg>[@version] <message>`\n\n### 发布问题\n\n> - 必须要有``package.json`, 而且里面的`version` 要有改变\n>\n> - 手动更改版本号:\n>\n>   ```bash\n>   // version : 1.1.1\n>   npm version patch // 第三位+1\n>   npm version minor // 第二位+1\n>   npm version major // 第一位+1\n>   ```\n>\n>\n\n### 使用\n\n> - `npm install [包名]`\n","children":[]},{"name":"ts.md","path":"../guanruihua.github.io/Front-End/包管理器/npm/制作NPM包","data":"# 使用TS制作NPM包\n\n## 前置工作\n\n> - `npm  init` 初始化一个`package.json`文件\n\n```json\n# package.json\n\n{\n  \"name\": \"ts-hi\",\n  \"version\": \"0.0.1\",\n  \"description\": \"create npm package with typescript\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/youthcity/ts-hi.git\"\n  },\n  \"keywords\": [\n    \"typescript\"\n  ],\n  \"author\": \"youthcity\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/youthcity/ts-hi/issues\"\n  },\n  \"homepage\": \"https://github.com/youthcity/ts-hi#readme\"\n}\n```\n\n## 配置==Typescript==\n\n> - 安装`Typescript`\n>\n>   - 方法一 : `npm i typescript -D`\n>\n>   - 方法二 : `yarn add typescript -D`\n>\n> - 配置`tsconfig.json`\n>\n>   - 方法一 : 直接自己创建改文件\n>\n>   - 方法二 :\n>     - 全局安装`typescript`包: `npm i typescript -g`\n>     - 命令行创建`tsc --init`\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"es5\",\n    \"module\": \"commonjs\",\n    \"declaration\": true,\n    \"outDir\": \"./dist\",\n    \"strict\": true\n  }\n}\n```\n\n## 开始制作\n\n> 1. 创建`lib`文件夹\n> 2. 创建`index.ts`\n\n```tsx\n# 非常简单的加法函数\nexport function add(a:number, b:number) : number {\n  return a + b;\n}\n```\n\n## 修改==package.json==\n\n```json\n{\n  \"name\": \"ts-hi\",\n  \"version\": \"0.0.1\",\n  \"description\": \"create npm package with typescript\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"build\": \"tsc\" # 增加 ts 编译命令\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/youthcity/ts-hi.git\"\n  },\n  \"keywords\": [\n    \"typescript\"\n  ],\n  \"author\": \"youthcity\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/youthcity/ts-hi/issues\"\n  },\n  \"homepage\": \"https://github.com/youthcity/ts-hi#readme\",\n  \"devDependencies\": {\n    \"typescript\": \"^3.0.3\"\n  }\n}\n```\n\n> 然后运行命令编译: `npm run build`\n\n![image-20210603112139825](ts.assets/image-20210603112139825-1622690502121.png)\n\n## 编写测试\n\n> 安装测试框架和断言库\n>\n> - `npm i mocha -D`\n>\n> - `npm i chai -D`\n>\n> 创建测试文件目录和文件\n>\n> - `mkdir test`\n> - `touch test/test.js`\n\n```js\n'use strict';\nconst expect = require('chai').expect;\nconst add = require('../dist/index').add;\n\ndescribe('ts-hi function test', () => {\n  it('should return 2', () => {\n    const result = add(1, 1);\n    expect(result).to.equal(2);\n  });\n});\n```\n\n### 添加测试脚本\n\n```js\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"test\": \"mocha --reporter spec\"\n  },\n```\n\n> 运行测试脚本`npm run test`\n\n## 提交 和 推送\n\n```shell\ntouch .gitignore // 创建 .gitignore 文件，并添加 node_modules/ 避免将node_modules 添加到版本控制中\ngit add . \ngit commit -m “Initial release”\ngit tag v0.1.0  # 修改一下 package.json中的版本号为 0.1.0\ngit push origin master --tags\n```\n\n### 添加提交忽略文件\n\n> 创建`.npmignore`文件\n\n```shell\n# 忽略 lib\nlib/\n```\n\n## 发布\n\n> 1. 在`https://www.npmjs.com/` 注册或登录账号\n> 2. `npm adduser`\n> 3. `Username: [name]`\n> 4. `Password:[pwd]`\n> 5. `Email:(this IS public )[填写邮箱]`\n> 6. 发布包 :`npm publish`( 已经登录了账号的, 可直接执行这一步 )\n","children":[]},{"name":"发包问题.md","path":"../guanruihua.github.io/Front-End/包管理器/npm/制作NPM包","data":"\r\n# 发包问题\r\n\r\n# `npm ERR! need auth This command requires you to be logged in to <https://registry.npm.taobao.org/>  npm ERR! need auth You need to authorize this machine using 'npm adduser'`\r\n\r\n`npm set registry <https://registry.npmjs.org>`\r\n","children":[]},{"name":"开发相关.md","path":"../guanruihua.github.io/Front-End/包管理器/npm/制作NPM包","data":"# 开发相关\r\n\r\n## 基本快捷方式\r\n\r\n- 安装  —  常规：npm install，简写：npm i。\r\n- 测试  —  常规：npm test，简写：npm t。\r\n- 帮助  —  常规：npm --help，简写：npm -h。\r\n- 全局标志 —  常规： --global，简写：-g。\r\n- 保存为开发依赖 - 常规： - save-dev，简写：-D。\r\n- npm init 默认值 - 常规：npm init --yes 或 npm init --force，简写：npm init -y 或 npm init -f\r\n- 我们知道使用-save或-S来保存包，但现在这是个已经是默认值。要安装一个包而不保存它，可以使用 ——no-save标志。\r\n\r\n### 不太常见的快捷键\r\n\r\n- 安装包信息将加入到`optionalDependencies`（可选阶段的依赖）-  常规：`--save-optional`， 简写：-O。\r\n- 精确安装指定模块版本 -  常规：`--save-optional`， 简写：-O。\r\n- 如果需要在本地保存一个npm包，或者通过单个文件下载选择一组可用的包，可以使用`--save-bundle`或-B将它们捆绑在一起，并使用npm pack获得捆绑包\r\n\r\n## 设置默认npm init属性\r\n\r\n```sh\r\nnpm config set init.author.name \"ruihuag\"\r\nnpm config set init.author.email \"ruihuag@qq.com\"\r\nnpm config set init.author.url \"guanruihua.github.io\"\r\nnpm config set init.license \"MIT\"\r\n\r\n# 查看配置文件信息\r\nnpm config edit \r\n# 编辑全局\r\nnpm config edit -g\r\n```\r\n\r\n## 让脚本跨平台兼容\r\n\r\n- `cross-env`: 实现跨平台兼容性的最无缝的方法\r\n\r\n## 并行运行脚本\r\n\r\n可以使用&&来依次运行两个或多个进程。但是并行运行脚本呢?为此，我们可以从各种npm包中进行选择。concurrent 和 npm-run-all 是最流行的解决方案。\r\n首先通过 npm i -D concurrently 安装开发依赖。然后按照以下格式将其添加到脚本中：\r\n\r\n```json\r\n{\r\n  \"start\": \"concurrently \\\"command1 arg\\\" \\\"command2 arg\\\"\"\r\n}\r\n```\r\n\r\n## 在不同的目录中运行脚本\r\n\r\n- 在不同的文件夹中拥有一个包含多个package.json文件的应用程序。 从根目录访问这些脚本会很方便，而不是每次要运行脚本时导航到不同的文件夹，有两种方法可以执行此操作。\r\n\r\n- 第一种是手动 cd 并运行对应的命令：\r\n`cd folder && npm start && cd ..`\r\n\r\n- 但还有一个更优雅的解决方案，即使用--prefix标志指定路径:\r\n`npm start --prefix path/to/your/folder`\r\n\r\n- 下面是一个工作应用程序中此解决方案的示例，我们希望在前端(在客户机目录中)和后端(在服务器目录中)运行 npm start。\r\n`\"start\": \"concurrently \\\"(npm start --prefix client)\\\" \\\"(npm start --prefix server)\\\"\"`\r\n\r\n## 延迟运行脚本直到端口准备就绪\r\n\r\n通常，在开发全堆栈应用程序期间，咱们可能希望同时启动服务器和客户端。wait-on 节点模块提供了一种方便的方法来确保进程只在某些进程就绪时发生:在我们的例子中，我们有一个特定的端口。\r\n例如，这是我在使用React前端的Electron项目中使用的dev脚本。 同时使用，脚本并行加载表示层和Electron窗口。 但是，使用wait-on，只有在 `<http://localhost:3000>` 启动好，才会打开Electron窗口。\r\n\r\n`\"dev\": \"concurrently \\\"cross-env BROWSER=none npm run start\\\" \\\"wait-on http://localhost:3000 && electron .\\\"\"`\r\n\r\n`React`默认情况下会打开一个浏览器窗口，但对于 `Electron` 开发来说，这是不必要的。咱们可以通过传递环境变量`BROWSER=none`来禁用此行为。\r\n\r\n## 控制应用程序版本\r\n\r\n```sh\r\n# 1.0.0\r\nnpm version patch\r\n# 1.0.1\r\nnpm version minor\r\n# 1.1.0\r\nnpm version major\r\n# 2.0.0\r\n\r\n```\r\n\r\n## 自动设置和打开你的github库\r\n\r\n- 如果package.json文件中有“repository”，则可以通过输入 npm repo在默认浏览器中打开它。\r\n- 如果你的项目已经连接到远程存储库，并且已经在命令行上安装了git，那您可以使用这个命令找到你的连接存储库\r\n`git config --get remote.origin.url`\r\n\r\n- 更好的是，如果你按照上面的提示并安装了json模块，可以使用下面的脚本自动将正确的存储库添加到 package.json\r\n`json -I -f package.json -e \"this.repository=\\\"$(git config --get remote.origin.url)\\\"\"`\r\n\r\n## 自定义npm init脚本\r\n\r\n- 让我们更进一步，使用我们自己的npm init脚本，它接受GitHub存储库URL并自动推送我们的第一个提交。在本技巧中，我们将讨论如何创建自定义npm init脚本。在下一个(也是最后一个)技巧中，我们将合并git。\r\n可以通过重定向到主目录中的.npm-init.js文件来编辑npm init脚本。（在Windows上，通常是 c/Users/<用户名>，在 Mac 上，它是/Users/<用户名>）。\r\n- 先在我们的主目录中创建一个.nmm-init.js文件。为了确保npm init被指向正确的文件，可以运行:\r\n`npm config set init-module ~\\.npm-init.js`\r\n\r\n在集成git之前，这里有一个简单的.npm-init.js文件，它模拟了默认npm init的问题\r\n\r\n```js\r\nmodule.exports = {\r\n  name: prompt('package name', basename || package.name),\r\n  version: prompt('version', '0.0.0'),\r\n  decription: prompt('description', ''),  \r\n  main: prompt('entry point', 'index.js'),\r\n  repository: prompt('git repository', ''),\r\n  keywords: prompt(function (s) { return s.split(/\\s+/) }),\r\n  author: prompt('author', 'Joe Bloggs <ruihuag@qq.com> (guanruihua.github.io)'),\r\n  license: prompt('license', 'ISC')\r\n}\r\n```\r\n\r\n每个问题都遵循`nameInPackage`模式:`prompt('nameInPrompt','defaultValue')`。要在缺省情况下设置值而不带问题，只需删除prompt方法。\r\n如果要返回默认设置，只需删除`.npm-init.js`\r\n\r\n## 使用自定义npm init脚本将你的第一个 Commit 提交到 GitHub\r\n\r\n为了将git命令合并到`.npm-init.js`文件中，需要一种方法来控制命令行。为此，可以使用 `child_process` 模块。在文件的顶部引入它，因为我们只需要`execSync`函数，所以可以使用析构赋值语法自己获取它：\r\n`const { execSync } = require('child_process');`\r\n\r\n我还创建了一个helper函数，它将函数的结果打印到控制台：\r\n\r\n```js\r\nfunction run(func) {\r\n  console.log(execSync(func).toString())\r\n}\r\n```\r\n\r\n最后，我们将提示输入GitHub存储库URL，如果提供，我们将生README.md文件，并启动我们的第一次提交。\r\n\r\n```js\r\nrepository: prompt('github repository url', '', function (url) {\r\n  if (url) {\r\n    run('touch README.md');\r\n    run('git init');\r\n    run('git add README.md');\r\n    run('git commit -m \"first commit\"');\r\n    run(`git remote add origin ${url}`);\r\n    run('git push -u origin master');\r\n  }\r\n  return url;\r\n})\r\n```\r\n\r\n总的来说，`.npm-init.js`文件大概如下：\r\n\r\n```js\r\nconst { execSync } = require('child_process');\r\n\r\nfunction run(func) {\r\n  console.log(execSync(func).toString())\r\n}\r\n\r\nmodule.exports = {\r\n  name: prompt('package name', basename || package.name),\r\n  version: prompt('version', '0.0.1'),\r\n  description: prompt('description', ''),\r\n  main: prompt('entry point', 'index.js'),\r\n  keywords: prompt(function (s) { return s.split(/\\s+/) }),\r\n  author: prompt('author', 'ruihuag <ruihuag@qq.com> (guanruihua.github.io)'),\r\n  license: prompt('license', 'ISC'),\r\n  repository: prompt('github repository url', '', function (url) {\r\n    if (url) {\r\n      run('touch README.md');\r\n      run('git init');\r\n      run('git add README.md');\r\n      run('git commit -m \"first commit\"');\r\n      run(`git remote add origin ${url}`);\r\n      run('git push -u origin master');\r\n    }\r\n    return url;\r\n  }),\r\n}\r\n```\r\n\r\npackage.json文件：\r\n\r\n```json\r\n{\r\n  \"name\": \"Custom npm init\",\r\n  \"version\": \"0.0.0\",\r\n  \"decription\": \"A test project, to demonstrate a custom npm init script.\",\r\n  \"main\": \"index.js\",\r\n  \"keywords\": [],\r\n  \"author\": \"ruihuag <ruihuag@qq.com> (guanruihua.github.io)\",\r\n  \"license\": \"ISC\",\r\n  \"repository\": {\r\n    \"type\": \"git\",\r\n    \"url\": \"git+<https://github.com/JoeBloggs/custom.git>\"\r\n  },\r\n  \"bugs\": {\r\n    \"url\": \"https://github.com/JoeBloggs/custom/issues\"\r\n  },\r\n  \"homepage\": \"https://github.com/JoeBloggs/custom#readme\"\r\n}\r\n```\r\n","children":[]}]},{"name":"命令","path":"../guanruihua.github.io/Front-End/包管理器/npm","data":"","children":[{"name":"version.md","path":"../guanruihua.github.io/Front-End/包管理器/npm/命令","data":"# version\r\n\r\n## 查看包历史版本\r\n\r\n```shell\r\n# 查看包全部包历史版本\r\nnpm v [package-name] versions\r\n# 查看包最新版本\r\nnpm v [package-name] version\r\n```\r\n\r\n## version\r\n\r\n- `npm version [<newversion> | major | minor | patch | premajor | preminor | prepatch | prerelease | from-git]`\r\n- 版本控制\r\n\r\n- major：主版本号（大版本）(3.1.0 -->4.0.0)\r\n- premajor：预备主版本 (1.1.0-0 变为 2.0.0-0)\r\n- minor：次版本号（小更新）( 2.0.1 变为 2.1.0 )\r\n- preminor: 预备次版本 (1.0.2-0 变为 1.1.0-0)\r\n- patch：补丁号（补丁）(2.0.0- 0变为 2.0.0 / 2.0.0 变为 2.0.1)\r\n- prepatch：预备补丁版本 (1.0.1-1 变为 1.0.2-0)\r\n- prerelease：预发布版本\r\n\r\n```shell\r\nnpm version patch  // 1.0.1 表示小的bug修复\r\nnpm version minor // 1.1.0 表示新增一些小功能\r\nnpm version major // 2.0.0 表示大的版本或大升级\r\nnpm version preminor // 1.1.0-0 后面多了个0，表示预发布\r\n```\r\n\r\n## `npm versino`\r\n\r\n```shell\r\nnpm version\r\n\r\n{\r\n  npm: '6.14.10',\r\n  ares: '1.18.1',\r\n  brotli: '1.0.9',\r\n  cldr: '40.0',\r\n  icu: '70.1',\r\n  llhttp: '6.0.4',\r\n  modules: '93',\r\n  napi: '8',\r\n  nghttp2: '1.45.1',\r\n  nghttp3: '0.1.0-DEV',\r\n  ngtcp2: '0.1.0-DEV',\r\n  node: '16.14.0',\r\n  openssl: '1.1.1m+quic',\r\n  tz: '2021a3',\r\n  unicode: '14.0',\r\n  uv: '1.43.0',\r\n  v8: '9.4.146.24-node.20',\r\n  zlib: '1.2.11'\r\n}\r\n```\r\n","children":[]},{"name":"命令.md","path":"../guanruihua.github.io/Front-End/包管理器/npm/命令","data":"# 命令\r\n\r\n## 收藏包\r\n\r\n> `npm star [package-name]`\r\n\r\n> 用于收藏包\r\n\r\n```shell\r\n# 收藏包\r\nnpm star [package-name] \r\n# 取消收藏\r\nnpm unstar [package-name] \r\n# 查看收藏列表\r\nnpm stars\r\n```\r\n\r\n## 查看包文档\r\n\r\n```shell\r\n# 此命令会尝试猜测包文档 URL 的可能位置，一般没有自定义的话，就会打开包的github地址。\r\nnpm docs [package-name]\r\n# or\r\nnpm home [package-name].\r\n# 打开当前项目文档\r\nnpm docs/home\r\n```\r\n\r\n> 若不接受参数, 默认打开 `package.json` 汇总的 `homepage` 配置\r\n\r\n## 查看包仓库\r\n\r\n> 打开`package.json` 配置的 `repository` 的url\r\n\r\n```shell\r\n# 此命令尝试猜测包的存储库 URL 的可能位置\r\nnpm repo [package-name]\r\n```\r\n\r\n## 给包提issues\r\n\r\n> 打开 `package.json` 配置的 `bugs` 的url\r\n\r\n```shell\r\nnpm bugs [package-name]\r\n```\r\n\r\n## 查看包信息\r\n\r\n> 包括作者信息等\r\n\r\n```shell\r\nnpm v [package-name]\r\n# or\r\nnpm view [package-name]\r\nnpm info [package-name]\r\nnpm show [package-name]\r\n```\r\n\r\n## 查看当前项目哪些包过时\r\n\r\n```shell\r\nnpm outdated\r\n```\r\n\r\n## 查看本地全局环境有哪些包过时\r\n\r\n```shell\r\nnpm outdated -g --depth=0\r\n```\r\n\r\n## 审计项目中所有包的安全漏洞\r\n\r\n```shell\r\nnpm audit\r\n# 这个命令依赖 package-lock.json 文件,所以如果你用的是yarn需要使用下面的命令\r\nyarn audit\r\n\r\npnpm audit\r\n```\r\n\r\n## 给出问题的严重性\r\n\r\n```shell\r\nnpm token list\r\n```\r\n\r\n## 检测镜像延迟\r\n\r\n```shell\r\nnpm ping\r\n```\r\n\r\n## 检测 node 和 npm 问题\r\n\r\n```shell\r\nnpm doctor\r\n```\r\n","children":[]}]},{"name":"快速删除文件.md","path":"../guanruihua.github.io/Front-End/包管理器/npm","data":"# 快速删除文件\n\n> 安装 `npm install rimraf -g`\n>\n> 删除 `rimraf [文件名]`\n","children":[]},{"name":"运行其他目录script.md","path":"../guanruihua.github.io/Front-End/包管理器/npm","data":"# [`运行其他目录script`]()\r\n\r\n> 运行指定目录的`package.json` 脚本\r\n\r\n```bash\r\nnpm start --prefix path/to/your/app\r\n```\r\n","children":[]}]},{"name":"nrm.md","path":"../guanruihua.github.io/Front-End/包管理器","data":"# nrm\r\n\r\n## 安装\r\n\r\n```shell\r\nnpm install -g nrm\r\n```\r\n\r\n## 命令\r\n\r\n### 查看可选源\r\n\r\n```shell\r\nnrm ls                                                                                                                                   \r\n*npm ---- https://registry.npmjs.org/\r\n\r\ncnpm --- http://r.cnpmjs.org/\r\n\r\ntaobao - http://registry.npm.taobao.org/\r\n\r\neu ----- http://registry.npmjs.eu/\r\n\r\nau ----- http://registry.npmjs.org.au/\r\n\r\nsl ----- http://npm.strongloop.com/\r\n\r\nnj ----- https://registry.nodejitsu.com/\r\n```\r\n\r\n### 切换\r\n\r\n```shell\r\nnrm use taobao\r\n```\r\n\r\n### 添加源\r\n\r\n```shell\r\nnrm add <registry>\r\nnrm add registry http://registry.npm.frp.trmap.cn/\r\n```\r\n\r\n### 删除源\r\n\r\n```shell\r\nnrm del <registry>\r\n```\r\n\r\n### 测试源的响应时间\r\n\r\n```shell\r\nnrm test npm  \r\n```\r\n","children":[]},{"name":"package","path":"../guanruihua.github.io/Front-End/包管理器","data":"","children":[{"name":"author.md","path":"../guanruihua.github.io/Front-End/包管理器/package","data":"# author\r\n\r\n> 项目作者\r\n> 表示该项目包的作者\r\n\r\n## 字符串\r\n\r\n```json\r\n{\r\n \"author\": \"ruihuag\",\r\n // or\r\n \"author\": \"ruihuag <ruihuag@qq.com> (https://guanruihua.github.io)\"\r\n}\r\n```\r\n\r\n## 对象形式\r\n\r\n```json\r\n{\r\n \"author\": {\r\n  \"name\" : \"CUGGZ\",\r\n  \"email\" : \"xxxxx@xx.com\",\r\n  \"url\" : \"https://juejin.cn/user/3544481220801815\"\r\n }\r\n}\r\n```\r\n","children":[]},{"name":"bugs.md","path":"../guanruihua.github.io/Front-End/包管理器/package","data":"# bugs\r\n\r\n> 项目 `bugs` 反馈地址, 通常 `github issue` 页面的链接\r\n\r\n```json\r\n{\r\n \"bugs\": \"https://github.com/vuejs/core/issues\"\r\n}\r\n```\r\n","children":[]},{"name":"contributors.md","path":"../guanruihua.github.io/Front-End/包管理器/package","data":"# contributors\r\n\r\n> 表示该项目包的贡献者，和author不同的是，该字段是一个数组，包含所有的贡献者，它同样有两种写法：\r\n\r\n```json\r\n{\r\n\r\n\"contributors\": [\r\n  \"ruihuag0 <ruihuag@qq.com> (https://guanruihua.github.io)\",\r\n  \"ruihuag1 <ruihuag@qq.com> (https://guanruihua.github.io)\"\r\n ],\r\n\r\n// or\r\n\r\n\"contributors\": [\r\n  {\r\n   \"name\" : \"ruihuag0\",\r\n   \"email\" : \"ruihuag@qq.com\",\r\n   \"url\" : \"https://guanruihua.github.io\"\r\n },\r\n  {\r\n   \"name\" : \"ruihuag1\",\r\n   \"email\" : \"ruihuag@qq.com\",\r\n   \"url\" : \"https://guanruihua.github.io\"\r\n }\r\n ]\r\n\r\n}\r\n```\r\n","children":[]},{"name":"description.md","path":"../guanruihua.github.io/Front-End/包管理器/package","data":"# description\r\n\r\n> 1. 项目描述\r\n> 2. 展示在npm官网\r\n\r\n```json\r\n{\r\n \"description\": \"React is a JavaScript library for building user interfaces.\"\r\n}\r\n```\r\n","children":[]},{"name":"homepage.md","path":"../guanruihua.github.io/Front-End/包管理器/package","data":"# homepage\r\n\r\n> 项目官网 / 文档首页\r\n> 通常是项目 `github` 链接\r\n\r\n```json\r\n{\r\n \"homepage\": \"https://reactjs.org/\"\r\n}\r\n```\r\n","children":[]},{"name":"index.md","path":"../guanruihua.github.io/Front-End/包管理器/package","data":"# package.json\r\n\r\n## 初始化\r\n\r\n> 配置 `npm init` 的默认字段\r\n\r\n```shell\r\nnpm config set init.author.name \"ruihuag\"\r\nnpm config set init.author.email \"2116047353@qq.com\"\r\nnpm config set init.author.url \"https://github.com/guanruihua\"\r\nnpm config set init.license \"MIT\"\r\n```\r\n\r\n> 查看配置文件信息: `npm config edit`\r\n> 查看全局配置文件信息: `npm config --global edit`\r\n","children":[]},{"name":"keywords.md","path":"../guanruihua.github.io/Front-End/包管理器/package","data":"# keywords\r\n\r\n> 项目关键词\r\n\r\n```json\r\n// Antd 组件库\r\n{\r\n \"keywords\": [\r\n  \"ant\",\r\n  \"component\",\r\n  \"components\",\r\n  \"design\",\r\n  \"framework\",\r\n  \"frontend\",\r\n  \"react\",\r\n  \"react-component\",\r\n  \"ui\"\r\n ]\r\n}\r\n```\r\n\r\nkeywords字段是一个字符串数组，表示这个项目包的关键词。和description一样，都是用来增加项目包的曝光率的。\r\n下面是eslint包的描述和关键词：\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ade17781b5104432a6f13eec9a4411ad~tplv-k3u1fbpfcp-watermark.awebp)\r\n","children":[]},{"name":"license.md","path":"../guanruihua.github.io/Front-End/包管理器/package","data":"# license\r\n\r\n> - 项目的开源许可证\r\n>   - 指定项目的版权拥有人可以使用开源许可证来限制源码的使用、复制、修改和再发布等行为\r\n> - 常见的开源许可证有 BSD、MIT、Apache 等\r\n\r\n![](./__assets__/license-2022-11-12-14-10-42.png)\r\n\r\n```json\r\n{\r\n \"license\": \"MIT\"\r\n}\r\n```\r\n","children":[]},{"name":"name.md","path":"../guanruihua.github.io/Front-End/包管理器/package","data":"# name\r\n\r\n> 1. 项目的名称\r\n> 2. 如果是第三方包的话，其他人可以通过该名称使用 `npm install [name]`进行安装\r\n\r\n给name字段命名时，需要注意以下几点：\r\n\r\n- 名称的长度必须小于或等于214个字符，不能以“.”和“_”开头，不能包含大写字母（这是因为当软件包在npm上发布时，会基于此属性获得自己的URL，所以不能包含非URL安全字符（non-url-safe））；\r\n- 名称可以作为参数被传入`require(\"\")`，用来导入模块，所以应当尽可能的简短、语义化；\r\n- 名称不能和其他模块的名称重复，可以使用`npm view`命令查询模块明是否重复，如果不重复就会提示404：\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a19278d60f5a4edbaab907273a7e3a90~tplv-k3u1fbpfcp-watermark.awebp)\r\n\r\n如果npm包上有对应的包，则会显示包的详细信息：\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/143f24d9f95c4c1e97b90fabe4171536~tplv-k3u1fbpfcp-watermark.awebp) 实际上，我们平时开发的很多项目并不会发布在npm上，所以这个名称是否标准可能就不是那么重要，它不会影响项目的正常运行。如果需要发布在npm上，name字段一定要符合要求。\r\n","children":[]},{"name":"repository.md","path":"../guanruihua.github.io/Front-End/包管理器/package","data":"# repository\r\n\r\n> 项目的仓库控制地址以及版本控制信息\r\n\r\n```json\r\n{\r\n  \"repository\": \"https://github.com/facebook/react.git\",\r\n  // or\r\n \"repository\": {\r\n  \"type\": \"git\",\r\n  \"url\": \"https://github.com/facebook/react.git\",\r\n  \"directory\": \"packages/react\"\r\n }\r\n}\r\n```\r\n","children":[]},{"name":"version.md","path":"../guanruihua.github.io/Front-End/包管理器/package","data":"# version\r\n\r\n> 版本管理\r\n> 与`name`构成项目唯一标识符\r\n> 版本管理标准 [semver](https://semver.org/)\r\n\r\n![](./__assets__/version-2022-11-12-13-36-07.png)\r\n\r\n1. 主版本号 `Major`，通常在涉及重大功能更新，产生了破坏性变更时会更新此版本号\r\n\r\n2. 次版本号 `Minor`，在引入了新功能，但未产生破坏性变更，依然向下兼容时会更新此版本号\r\n\r\n3. 修订号 `Patch`，在修复了一些问题，也未产生破坏性变更时会更新此版本号\r\n\r\n4. `Pre-release` 和 `Metadata` 来描述项目的测试版本\r\n   - 如果某个版本的改动较大，并且不稳定，可能如法满足预期的兼容性需求，就需要发布先行版本，先行版本通过会加在版本号的后面，通过“-”号连接以点分隔的标识符和版本编译信息：内部版本（alpha）、公测版本（beta）和候选版本（rc，即release candiate）\r\n\r\n## 查看版本\r\n\r\n可以通过以下命令来查看npm包的版本信息，以react为例：\r\n\r\n```javascript\r\n// 查看最新版本\r\nnpm view react version\r\n// 查看所有版本\r\nnpm view react versions\r\n```\r\n\r\n当执行第二条命令时，结果如下：\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/691978ac852647c18af70b3208ed32c3~tplv-k3u1fbpfcp-watermark.awebp)\r\n\r\n## package 文件\r\n\r\n- node 项目中使用到的相关依赖和依赖的版本号\r\n\r\n- 在 package.json 的依赖中，版本号使用的是semver 版本表示法，即“主版本.次版本.补丁版本”的格式，版本号的递增规则如下：\r\n\r\n  - 主版本号，一些不兼容的 breaking change\r\n  - 次版本号，能向下兼容，在不影响低版本的使用下可以新增和弃用一些 api，但要确保向下兼容\r\n  - 补丁版本号，一些向下兼容的修正，一般都是对于一些缺陷的修复 当发布新版本的时候，可不能随心所欲地增加数字，一定要遵循上述的规则，这是作为一个合格的项目所必备的基本条件。 同时，npm 也设置了一些规则，用于在运行 np`m update 的时候，为 package.json 中的依赖更新到尽可能新的版本号，你一定不陌生\r\n  - `～`: 只更新修订号，用于静默获取一些包中对于 bug 修复的最新版本\r\n  - `^`: 只执行不更新最左边非零数字版本号的更新。例如 ^0.1.0 ，可以更新到 0.1.1 0.1.2 等，但不会更新到 0.2.0 或更高版本；而 1.0.0 可以更新到 1.0.1 或 1.1.0 等，但不会更新到 2.0.0 或更高版本\r\n  - `>`: 只接受高于指定版本的任何版本\r\n  - `≥`: 只接受高于或等于指定版本的任何版本\r\n  - `<`: 只接受低于指定版本的任何版本\r\n  - `≤`: 只接受低于或等于指定版本的任何版本\r\n  - `=`: 接受确切版本\r\n  - `-`: 接受一定范围的版本，如：`2.1.0-2.6.2`\r\n  - `||`: 组合集合，如： `< 2.1 || > 2.6`\r\n  - `latest`: 使用可用的最新版本\r\n  - 无符号，等同于 `=`\r\n\r\n## package lock 文件\r\n\r\n- 在 npm 5 版本中，引入了 package-lock.json 文件\r\n- 其它的包管理工具也有其对应的 lock 文件，如 yarn 的 yarn.lock 、pnpm 的 pnpm-lock.yaml\r\n- package-lock.json 文件相比 package.json 文件\r\n  - 不仅可以跟踪项目中使用到的 npm 包\r\n  - 还能跟踪每个 npm 包的确切版本\r\n  - 以确保产品可以拥有完整且相同的 node_modules 树，产品的表现形式一致\r\n- 正如上述关于 package.json 依赖工作的描述，package.json 一直都存在着一个比较尴尬的问题，即在运行 npm update 或者 npm install 的时候，会尽可能地安装最新的依赖，如果虽然补丁版本和次版本不应该引入重大的更改，但并不是所有的开源项目的作者都是遵守 semver 规则（我相信有些人可能都还不知道这东东），免不了的，还是有可能会产生 bug。 那如果在服务器的 ci 服务器，每次都是先 npm install 安装依赖再执行打包构建的时候，不就有可能会产生问题了吗？ 这里就不得不先提一下 npm ci 这个命令了，npm ci 跟 npm install 不同。看到 ci，也应该能想到持续集成中的这个 ci。没错啦，这个就是专门用于 CI/CD 中的安装依赖操作。\r\n npm ci 相比 npm install 命令，有几个特点： npm 版本要 ≥ v5.7.1\r\n\r\n- 不会更改 package.json 、package-lock.json 文件\r\n- 执行的之前如果存在 node_modules ，会先将之删除\r\n- 优先依赖于 package-lock.json 或 npm-shrinkwrap.json 文件安装依赖\r\n- 如果在以上两个文件中的依赖在 package.json 中找不到，就抛错退出执行 这些特性确保了相同的 lock 文件能拥有相同的依赖环境，避免在构建的时候出现与开发时环境不一致的情况。\r\n","children":[]},{"name":"依赖配置","path":"../guanruihua.github.io/Front-End/包管理器/package","data":"","children":[{"name":"bundleDependencies.md","path":"../guanruihua.github.io/Front-End/包管理器/package/依赖配置","data":"# [`bundleDependencies`]()\r\n\r\n> 打包依赖。它的值是一个数组，在发布包时，bundleDependencies 里面的依赖都会被一起打包\r\n比如指定 react 和 react-dom 为打包依赖：\r\n\r\n```json\r\n{\r\n \"bundleDependencies\": [\r\n  \"react\",\r\n  \"react-dom\"\r\n]\r\n}\r\n```\r\n\r\n> 在执行 npm pack 打包生成 tgz 压缩包中，将出现 `node_modules` 并包含 react 和 react-dom。\r\n>\r\n> 需要注意的是，这个字段数组中的值必须是在 `dependencies`，`devDependencies` 两个里面声明过的依赖才行。\r\n>\r\n> 普通依赖通常从 npm registry 安装，但当你想用一个不在 npm registry 里的包，或者一个被修改过的第三方包时，打包依赖会比普通依赖更好用\r\n","children":[]},{"name":"dependencies.md","path":"../guanruihua.github.io/Front-End/包管理器/package/依赖配置","data":"# [`dependencies`]()CUGGZ\r\n\r\n> - 运行依赖，也就是项目生产环境下需要用到的依赖。比如 react，vue，状态管理库以及组件库等\r\n> - 使用 `npm install xxx` 或则 `npm install xxx --save` 时，会被自动插入到该字段中\r\n\r\n```json\r\n{\r\n \"dependencies\": {\r\n  \"react\": \"^18.2.0\",\r\n  \"react-dom\": \"^18.2.0\"\r\n }\r\n}\r\n```\r\n","children":[]},{"name":"devDependencies.md","path":"../guanruihua.github.io/Front-End/包管理器/package/依赖配置","data":"# [`devDependencies`]()\r\n\r\n> - 开发依赖，项目开发环境需要用到而运行时不需要的依赖，用于辅助开发，通常包括项目工程化工具比如 `webpack`，`vite`，`eslint` 等。\r\n> - 使用 `npm install xxx -D` 或者 `npm install xxx --save-dev` 时，会被自动插入到该字段中。\r\n\r\n```json\r\n{\r\n \"devDependencies\": {\r\n   \"webpack\": \"^5.69.0\"\r\n }\r\n}\r\n```\r\n","children":[]},{"name":"index.md","path":"../guanruihua.github.io/Front-End/包管理器/package/依赖配置","data":"# 依赖配置\r\n\r\n> 项目依赖其他包, 在`package.json`里配置这些信息\r\n","children":[]},{"name":"optionalDependencies.md","path":"../guanruihua.github.io/Front-End/包管理器/package/依赖配置","data":"# [`optionalDependencies`]()\r\n\r\n> - 可选依赖，顾名思义，表示依赖是可选的，它不会阻塞主功能的使用，安装或者引入失败也无妨\r\n> - 这类依赖如果安装失败，那么 npm 的整个安装过程也是成功的\r\n> - 比如我们使用 `colors` 这个包来对 `console.log` 打印的信息进行着色来增强和区分提示，但它并不是必需的, 所以可以将其加入到 `optionalDependencies`，并且在运行时处理引入失败的逻辑\r\n\r\n使用 `npm install xxx -O` 或者 `npm install xxx --save-optional` 时，依赖会被自动插入到该字段中\r\n\r\n```json\r\n{\r\n \"optionalDependencies\": {\r\n  \"colors\": \"^1.4.0\"\r\n }\r\n}\r\n```\r\n","children":[]},{"name":"overrides.md","path":"../guanruihua.github.io/Front-End/包管理器/package/依赖配置","data":"# [`overrides`]()\r\n\r\n> overrides 可以重写项目依赖的依赖，及其依赖树下某个依赖的版本号，进行包的替换。\r\n\r\n比如某个依赖 A，由于一些原因它依赖的包 foo@1.0.0 需要替换，我们可以使用 overrides 修改 foo 的版本号：\r\n\r\n```json\r\n{\r\n \"overrides\": {\r\n   \"foo\": \"1.1.0-patch\"\r\n }\r\n}\r\n```\r\n\r\n当然这样会更改整个依赖树里的 foo，我们可以只对 A 下的 foo 进行版本号重写：\r\n\r\n```json\r\n{\r\n \"overrides\": {\r\n  \"A\": {\r\n    \"foo\": \"1.1.0-patch\",\r\n  }\r\n}\r\n}\r\n```\r\n\r\n> `overrides` 支持任意深度的嵌套。\r\n>\r\n> 如果在 yarn 里也想复写依赖版本号，需要使用 resolution 字段，而在 pnpm 里复写版本号需要使用 pnpm.`overrides` 字段。\r\n","children":[]},{"name":"peerDependencies.md","path":"../guanruihua.github.io/Front-End/包管理器/package/依赖配置","data":"# [`peerDependencies`]()\r\n\r\n> - 同伴依赖，一种特殊的依赖，不会被自动安装，通常用于表示与另一个包的依赖与兼容性关系来警示使用者\r\n> - 比如我们安装 A，A 的正常使用依赖 B@2.x 版本，那么 B@2.x 就应该被列在 A 的 peerDependencies 下，表示“如果你使用我，那么你也需要安装 B，并且至少是 2.x 版本”\r\n\r\n比如 React 组件库 Ant Design，它的 package.json 里 peerDependencies 为\r\n\r\n```json\r\n{\r\n \"peerDependencies\": {\r\n  \"react\": \">=16.9.0\",\r\n  \"react-dom\": \">=16.9.0\"\r\n }\r\n}\r\n```\r\n\r\n表示如果你使用 Ant Design，那么你的项目也应该安装 react 和 react-dom，并且版本需要大于等于 16.9.0。\r\n","children":[]},{"name":"peerDependenciesMeta.md","path":"../guanruihua.github.io/Front-End/包管理器/package/依赖配置","data":"# [`peerDependenciesMeta`]()\r\n\r\n> 同伴依赖也可以使用 `peerDependenciesMeta` 将其指定为可选的\r\n\r\n```json\r\n{\r\n \"peerDependencies\": {\r\n  \"colors\": \"^1.4.0\"\r\n },\r\n \"peerDependenciesMeta\": {\r\n  \"colors\": {\r\n    \"optional\": true\r\n   }\r\n }\r\n}\r\n```\r\n","children":[]}]},{"name":"发布配置","path":"../guanruihua.github.io/Front-End/包管理器/package","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Front-End/包管理器/package/发布配置","data":"# 发布配置\r\n\r\n> 项目发布配置\r\n","children":[]},{"name":"preferGlobal.md","path":"../guanruihua.github.io/Front-End/包管理器/package/发布配置","data":"# preferGlobal\r\n\r\n> 表示当用户不把该模块安装为全局模块时，如果设置为true就会显示警告。它并不会真正的防止用户进行局部的安装，只是对用户进行提示，防止产生误解：\r\n\r\n```json\r\n{\r\n \"preferGlobal\": true\r\n}\r\n```\r\n","children":[]},{"name":"private.md","path":"../guanruihua.github.io/Front-End/包管理器/package/发布配置","data":"# [`private`]()\r\n\r\n> 如果是私有项目，不希望发布到公共 npm 仓库上，可以将 private 设为 true\r\n\r\n```json\r\n{\r\n \"private\": true\r\n}\r\n```\r\n","children":[]},{"name":"publishConfig.md","path":"../guanruihua.github.io/Front-End/包管理器/package/发布配置","data":"# [`publishConfig`]()\r\n\r\n> publishConfig 就是 npm 包发布时使用的配置。\r\n\r\n比如在安装依赖时指定了 registry 为 taobao 镜像源，但发布时希望在公网发布，就可以指定 publishConfig.registry。\r\n\r\n```json\r\n{\r\n \"publishConfig\": {\r\n   \"registry\": \"https://registry.npmjs.org/\"\r\n }\r\n}\r\n```\r\n","children":[]}]},{"name":"文件配置","path":"../guanruihua.github.io/Front-End/包管理器/package","data":"","children":[{"name":"files.md","path":"../guanruihua.github.io/Front-End/包管理器/package/文件配置","data":"# files\r\n\r\n- 项目在进行 `npm` 发布时，可以通过 `files` 指定需要跟随一起发布的内容来控制 `npm` 包的大小，避免安装时间太长\r\n- 发布时默认会包括 `package.json`，`license`，`README` 和`main` 字段里指定的文件。忽略 `node_modules`，`lockfile` 等文件\r\n- 在此基础上，我们可以指定更多需要一起发布的内容。可以是单独的文件，整个文件夹，或者使用通配符匹配到的文件\r\n- 一般情况下，`files` 里会指定构建出来的产物以及类型文件，而 `src`，`test` 等目录下的文件不需要跟随发布\r\n\r\n```json\r\n{\r\n\"files\": [\r\n  \"filename.js\",\r\n  \"directory/\",\r\n  \"glob/*.{js,json}\"\r\n ]\r\n}\r\n```\r\n","children":[]},{"name":"index.md","path":"../guanruihua.github.io/Front-End/包管理器/package/文件配置","data":"# 文件配置\r\n\r\n> 包含项目所包含的文件, 以及入口配置文件等信息\r\n","children":[]},{"name":"type.md","path":"../guanruihua.github.io/Front-End/包管理器/package/文件配置","data":"# type\r\n\r\n- 在 node 支持 ES 模块后，要求 ES 模块采用 .mjs 后缀文件名\r\n- 只要遇到 .mjs 文件，就认为它是 ES 模块\r\n- 如果不想修改文件后缀，就可以在 `package.json`文件中，指定 `type` 字段为 `module`\r\n\r\n```js\r\n\"type\": \"module\"\r\n```\r\n\r\n复制代码\r\n这样所有 .js 后缀的文件，node 都会用 ES 模块解释。\r\n\r\n```js\r\n // 使用 ES 模块规范\r\n node index.js\r\n```\r\n\r\n如果还要使用 CommonJS 模块规范，那么需要将 CommonJS 脚本的后缀名都改成.cjs，不过两种模块规范最好不要混用，会产生异常报错。\r\n","children":[]},{"name":"workspaces.md","path":"../guanruihua.github.io/Front-End/包管理器/package/文件配置","data":"# workspaces\r\n\r\n> 项目的工作区配置，用于在本地的根目录下管理多个子项目\r\n> 可以自动地在 `npm install` 时将 `workspaces` 下面的包，软链到根目录的 `node_modules` 中，不用手动执行 `npm link` 操作\r\n>\r\nworkspaces 字段接收一个数组，数组里可以是文件夹名称或者通配符。比如：\r\n\r\n```json\r\n{\r\n \"workspaces\": [\r\n   \"workspace-a\"\r\n ]\r\n}\r\n```\r\n\r\n表示在 workspace-a 目录下还有一个项目，它也有自己的 package.json。\r\n`package.json`\r\n\r\nworkspace-a\r\n  └── package.json\r\n\r\n> 通常子项目都会平铺管理在 packages 目录下，所以根目录下 workspaces 通常配置为：\r\n\r\n```json\r\n{\r\n \"workspaces\": [\r\n   \"packages/*\"\r\n ]\r\n}\r\n```\r\n","children":[]},{"name":"入口文件.md","path":"../guanruihua.github.io/Front-End/包管理器/package/文件配置","data":"# 入口文件\r\n\r\n```json\r\n{\r\n \"main\": \"./index.js\", \r\n \"browser\": \"./browser/index.js\",\r\n \"module\": \"./index.mjs\"\r\n}\r\n```\r\n\r\n## main\r\n\r\n- 项目发布时，默认会包括 `package.json`，`license`，`README` 和`main` 字段里指定的文件，因为 main 字段里- 指定的是项目的入口文件，在 browser 和 Node 环境中都可以使用\r\n- 如果不设置 main 字段，那么入口文件就是根目录下的 `index.js`\r\n\r\n- 比如 packageA 的 main 字段指定为 `index.js`\r\n\r\n```json\r\n{\r\n \"main\": \"./index.js\"\r\n}\r\n```\r\n\r\n> 引入 packageA 时，实际上引入的就是 node_modules/packageA/index.js。\r\n这是早期只有 CommonJS 模块规范时，指定项目入口的唯一属性。\r\n\r\n## browser\r\n\r\n> - `main` 字段里指定的入口文件在 browser 和 Node 环境中都可以使用\r\n> - 如果只想在 web 端使用，不允许在 server 端使用，可以通过 browser 字段指定入口\r\n\r\n```json\r\n{\r\n \"browser\": \"./browser/index.js\"\r\n}\r\n```\r\n\r\n## module\r\n\r\n> 同样，项目也可以指定 ES 模块的入口文件，这就是 module 字段的作用\r\n\r\n```json\r\n{\r\n \"module\": \"./index.mjs\"\r\n}\r\n```\r\n\r\n## webpack 构建项目\r\n\r\n比如 `webpack` 构建项目时默认的 `target` 为 `web`，也就是 `Web` 构建。它的 `resolve.mainFeilds` 字段默认为  `['browser', 'module', 'main']`\r\n\r\n```js\r\nmodule.exports = {\r\n  resolve: {\r\n  // 此时会按照 browser -> module -> main 的顺序来查找入口文件。\r\n    mainFields: ['browser', 'module', 'main'],\r\n  }\r\n};\r\n```\r\n\r\n## exports\r\n\r\n> node 在 14.13 支持在 package.json 里定义 exports 字段，拥有了条件导出的功能。\r\n> exports 字段可以配置不同环境对应的模块入口文件，并且当它存在时，它的优先级最高。\r\n\r\n比如使用 require 和 import 字段根据模块规范分别定义入口：\r\n\r\n```json\r\n{\r\n\"exports\": {\r\n  \"require\": \"./index.js\",\r\n  \"import\": \"./index.mjs\"\r\n }\r\n}\r\n```\r\n\r\n> 这样的配置在使用 import 'xxx' 和 require('xxx') 时会从不同的入口引入文件，exports 也支持使用 browser 和 node 字段定义 browser 和 Node 环境中的入口。\r\n上方的写法其实等同于：\r\n\r\n```json\r\n{\r\n \"exports\": {\r\n  \".\": {\r\n    \"require\": \"./index.js\",\r\n    \"import\": \"./index.mjs\"\r\n  }\r\n }\r\n}\r\n```\r\n\r\n为什么要加一个层级，把 require 和 import 放在 \".\" 下面呢？\r\n因为 exports 除了支持配置包的默认导出，还支持配置包的子路径。\r\n比如一些第三方 UI 包需要引入对应的样式文件才能正常使用。\r\n`import packageA/dist/css/index.css`;\r\n\r\n我们可以使用 exports 来封装文件路径：\r\n\r\n```json\r\n{\r\n \"exports\": {\r\n   \"./style\": \"./dist/css/index.css'\r\n }\r\n}\r\n```\r\n\r\n用户引入时只需：\r\n\r\n`import packageA/style;`\r\n\r\n除了对导出的文件路径进行封装，exports 还限制了使用者不可以访问未在 \"exports\" 中定义的任何其他路径。\r\n\r\n- 比如发布的 `dist` 文件里有一些内部模块 `dist/internal/module` ，被用户单独引入使用的话可能会导致主模块不可用。为了限制外部的使用，我们可以不在 exports 定义这些模块的路径，这样外部引入 packageA/`dist/internal/module` 模块的话就会报错\r\n结合上面入口文件配置的知识，再来看看下方 vite 官网推荐的第三方库入口文件的定义\r\n\r\n![](./__assets__/入口文件-2022-11-12-17-39-33.png)\r\n","children":[]}]},{"name":"第三方配置","path":"../guanruihua.github.io/Front-End/包管理器/package","data":"","children":[{"name":"babel.md","path":"../guanruihua.github.io/Front-End/包管理器/package/第三方配置","data":"# babel\r\n\r\n> 用来指定Babel的编译配置，代码如下：\r\n\r\n```javascript\r\n\"babel\": {\r\n \"presets\": [\"@babel/preset-env\"],\r\n \"plugins\": [...]\r\n}\r\n\r\n```\r\n","children":[]},{"name":"browserslist.md","path":"../guanruihua.github.io/Front-End/包管理器/package/第三方配置","data":"# [`browserslist`]()\r\n\r\n> - 设置项目的浏览器兼容情况\r\n> - `babel` 和 `autoprefixer` 等工具会使用该配置对代码进行转换。当然你也可以使用 `.browserslistrc` 单文件配置\r\n\r\n```json\r\n{\r\n \"browserslist\": [\r\n   \"> 1%\",\r\n   \"last 2 versions\"\r\n ]\r\n}\r\n```\r\n\r\n```json\r\n{\r\n  \"browserslist\": {\r\n    \"production\": [\r\n      \">0.2%\",\r\n      \"not dead\",\r\n      \"not op_mini all\"\r\n    ],\r\n    \"development\": [\r\n      \"last 1 chrome version\",\r\n      \"last 1 firefox version\",\r\n      \"last 1 safari version\"\r\n    ]\r\n  }\r\n}\r\n```\r\n","children":[]},{"name":"CDN服务.md","path":"../guanruihua.github.io/Front-End/包管理器/package/第三方配置","data":"# [`CDN服务`]()\r\n\r\n> 可以让npm上的文件都开启CDN服务\r\n\r\n## unpkg\r\n\r\n> 访问 unpkg.com/vue 会重定向到 `unpkg.com/vue@3.2.37/… 3.2.27` 是 Vue 的最新版本\r\n\r\n```json\r\n{\r\n \"unpkg\": \"dist/vue.global.js\",\r\n}\r\n```\r\n\r\n## jsdelivr\r\n\r\n> [jsDelivr - A free, fast, and reliable CDN for open source](https://www.jsdelivr.com/)\r\n> 访问 `cdn.jsdelivr.net/npm/vue` 实际上获取到的是 jsdelivr 字段里配置的文件地址\r\n\r\n```json\r\n{\r\n \"jsdelivr\": \"dist/vue.global.js\",\r\n}\r\n```\r\n","children":[]},{"name":"eslintConfig.md","path":"../guanruihua.github.io/Front-End/包管理器/package/第三方配置","data":"# eslintConfig\r\n\r\n> eslint的配置可以写在单独的配置文件`.eslintrc.json` 中，也可以写在package.json文件的eslintConfig配置项中\r\n\r\n```json\r\n{\r\n\"eslintConfig\": {\r\n \"root\": true,\r\n \"env\": {\r\n  \"node\": true\r\n },\r\n \"extends\": [\r\n  \"plugin:vue/essential\",\r\n  \"eslint:recommended\"\r\n ],\r\n \"rules\": {},\r\n \"parserOptions\": {\r\n  \"parser\": \"babel-eslint\"\r\n },\r\n}\r\n}\r\n```\r\n","children":[]},{"name":"index.md","path":"../guanruihua.github.io/Front-End/包管理器/package/第三方配置","data":"# 第三方配置\r\n\r\n> 一些第三方库或应用在进行某些内部处理时会依赖这些字段，使用它们时需要安装对应的第三方库\r\n","children":[]},{"name":"lint-staged.md","path":"../guanruihua.github.io/Front-End/包管理器/package/第三方配置","data":"# [`lint-staged`]()\r\n\r\n> `lint-staged` 是用于对 git 的暂存区的文件进行操作的工具，比如可以在代码提交前执行 lint 校验，类型检查，图片优化等操作\r\n\r\n```json\r\n{\r\n \"lint-staged\": {\r\n  \"src/**/*.{js,jsx,ts,tsx}\": [\r\n    \"eslint --fix\",\r\n    \"git add -A\"\r\n  ]\r\n}\r\n}\r\n```\r\n\r\n> `lint-staged` 通常配合 `husky` 这样的 `git-hooks` 工具一起使用\r\n> `git-hooks` 用来定义一个钩子，这些钩子方法会在 git 工作流程中比如 `pre-commit`，`commit-msg` 时触发，可以把 `lint-staged` 放到这些钩子方法中\r\n","children":[]},{"name":"sideEffects.md","path":"../guanruihua.github.io/Front-End/包管理器/package/第三方配置","data":"# [`sideEffects`]()\r\n\r\n- 显示设置某些模块具有副作用，用于 webpack 的 tree-shaking 优化\r\n- 比如在项目中整体引入 Ant Design 组件库的 css 文件\r\n\r\n`import 'antd/dist/antd.css'; // or 'antd/dist/antd.less'`\r\n\r\n- 如果 Ant Design 的 package.json 里不设置 sideEffects，那么 webpack 构建打包时会认为这段代码只是引入了但并没有使用，可以 tree-shaking 剔除掉，最终导致产物缺少样式\r\n- 所以 Ant Design 在 package.json 里设置了如下的 sideEffects，来告知 webpack，这些文件具有副作用，引入后不能被删除\r\n\r\n```json\r\n{\r\n \"sideEffects\": [\r\n  \"dist/*\",\r\n  \"es/**/style/*\",\r\n  \"lib/**/style/*\",\r\n  \"*.less\"\r\n ]\r\n}\r\n```\r\n","children":[]},{"name":"types&typings.md","path":"../guanruihua.github.io/Front-End/包管理器/package/第三方配置","data":"# [`types&typings`]()\r\n\r\n> 指定 `Typescript` 的类型定义的入口文件\r\n\r\n```json\r\n{\r\n \"types\": \"./index.d.ts\",\r\n // or\r\n \"typeings\": \"./index.d.ts\",\r\n}\r\n```\r\n","children":[]}]},{"name":"系统配置","path":"../guanruihua.github.io/Front-End/包管理器/package","data":"","children":[{"name":"cpu.md","path":"../guanruihua.github.io/Front-End/包管理器/package/系统配置","data":"# [`cpu`]()\r\n\r\n> 指定项目只能在特定的 CPU 体系上运行\r\n\r\n```json\r\n{\r\n \"cpu\": [\"x64\", \"ia32\"]\r\n}\r\n```\r\n","children":[]},{"name":"engines.md","path":"../guanruihua.github.io/Front-End/包管理器/package/系统配置","data":"# [`engines`]()\r\n\r\n一些项目由于兼容性问题会对 node 或者包管理器有特定的版本号要求，比如：\r\n\r\n```json\r\n{\r\n \"engines\": {\r\n  \"node\": \">=14 <16\",\r\n  \"pnpm\": \">7\"\r\n}\r\n}\r\n```\r\n\r\n> 要求 node 版本大于等于 14 且小于 16，同时 pnpm 版本号需要大于 7\r\n","children":[]},{"name":"index.md","path":"../guanruihua.github.io/Front-End/包管理器/package/系统配置","data":"# 系统配置\r\n\r\n> - 和项目关联的系统配置，比如 node 版本或操作系统兼容性之类\r\n> - 这些要求只会起到提示警告的作用，即使用户的环境不符合要求，也不影响安装依赖包\r\n","children":[]},{"name":"os.md","path":"../guanruihua.github.io/Front-End/包管理器/package/系统配置","data":"# [`os`]()\r\n\r\n在 linux 上能正常运行的项目可能在 windows 上会出现异常，使用 os 字段可以指定项目对操作系统的兼容性要求。\r\n\r\n```json\r\n{\r\n \"os\": [\"darwin\", \"linux\"]\r\n}\r\n```\r\n","children":[]}]},{"name":"脚本配置","path":"../guanruihua.github.io/Front-End/包管理器/package","data":"","children":[{"name":"config.md","path":"../guanruihua.github.io/Front-End/包管理器/package/脚本配置","data":"# config\r\n\r\n> config 用于设置 scripts 里的脚本在运行时的参数。比如设置 port 为 3001：\r\n\r\n```json\r\n{\r\n \"config\": {\r\n  \"port\": \"3001\"\r\n }\r\n}\r\n```\r\n\r\n> 在执行脚本时，我们可以通过 npm_package_config_port 这个变量访问到 3001。\r\n\r\n```js\r\nconsole.log(process.env.npm_package_config_port); // 3001\r\n```\r\n","children":[]},{"name":"script.md","path":"../guanruihua.github.io/Front-End/包管理器/package/脚本配置","data":"# Script\r\n\r\n> 脚本\r\n\r\n## 列出可运行脚本\r\n\r\n> `npm i -g ntl`\r\n> 到对应的目录下运行`npm run`\r\n\r\n## 并行运行脚本\r\n\r\n> `&&` 符号依次运行多个脚本\r\n> `并行运行脚本`: [concurrently](https://www.npmjs.com/package/concurrently)\r\n\r\n```json\r\n{\r\n \"start\": \"concurrently \\\"command1 arg\\\" \\\"command2 arg\\\"\"\r\n}\r\n```\r\n\r\n### 延迟运行脚本直到端口准备就绪\r\n\r\n```json\r\n\"dev\": \"concurrently \\\"cross-env BROWSER=none npm run start\\\" \\\"wait-on http://localhost:3000 && electron .\\\"\"\r\n```\r\n\r\n> `wait-on`: 只有在`http://localhost:3000`启动好, 才打开electron窗口\r\n> React默认情况下会打开一个浏览器窗口，但对于 Electron 开发来说，这是不必要的。咱们可以通过传递环境变量BROWSER=none来禁用此行为\r\n\r\n## 不同目录运行脚本\r\n\r\n```shell\r\n# 手动打开到对应目录\r\ncd folder && npm start && cd ..\r\n# 使用prefix\r\nnpm start --prefix path/to/your/folder\r\n```\r\n\r\n```json\r\n{\r\n \"start\": \"concurrently \\\"(npm start --prefix client)\\\" \\\"(npm start --prefix server)\\\"\",\r\n}\r\n```\r\n\r\n## 脚本跨平台\r\n\r\n> `cross-env`\r\n> `npm i -D cross-env`\r\n\r\n```json\r\n{\r\n  \"scripts\": {\r\n    \"build\": \"cross-env NODE_ENV=production webpack --config build/webpack.config.js\"\r\n  }\r\n}\r\n```\r\n","children":[]}]}]}]},{"name":"多端","path":"../guanruihua.github.io/Front-End","data":"","children":[{"name":"Electron","path":"../guanruihua.github.io/Front-End/多端","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Front-End/多端/Electron","data":"# Electron\r\n\r\n> <https://juejin.cn/post/7084126780390375461>\r\n> 快速搭建桌面应用\r\n>\r\n> [快速入门 | Electron (electronjs.org)](https://www.electronjs.org/docs/tutorial/quick-start)\r\n>\r\n> [Electron 桌面环境集成_w3cschool](https://www.w3cschool.cn/electronmanual/lz4y1ql3.html)\r\n\r\nshell : 通过电脑的默认浏览器打开链接\r\n","children":[]},{"name":"问题.md","path":"../guanruihua.github.io/Front-End/多端/Electron","data":"\n# electron 问题\n\n杀毒软件破坏检查\n防止debug调试\n客户端崩溃报告\n提升客户端启动速度\n性能监测分析\n延迟加载模块\n滚动条样式统一\nbrowserWindow 错误监听\nbrowserWindow a 标签，打开默认浏览器\nelectron-中无法使用-jquery、requirejs、meteor、angularjs。\nelectron-bridge\n代理设置\n系统版本比较(mac)\n多窗口管理\n类似vscode无缝升级安装\n杀毒软件破坏检查\n\n对于内部的一些核心的文件，可以通过白名单机制，来查看文件是否存在，如果不存在则报告软件被破坏，直接退出。\n\n```js\n\nconst getBinaryFileCheckList = ()=>{\n    const dir = [];\n    // 比如 network-interface 这个包是必须的。\n    const network = require.resolve(\"network-interface/package\"),\n\n    dir.push(network);\n\n    return dir;\n}\n\nconst binaryFileCheckList = getBinaryFileCheckList();\n\n<!--检查-->\nfor (let e = 0; e < binaryFileCheckList.length; e++) {\n    const n = binaryFileCheckList[e];\n\n    if (!fs.existsSync(n)) {\n        dialog.showErrorBox(\"启动失败\", \"应用文件损坏，可能是杀毒软件导致，请重新下载安装\");\n        // 直接 exit\n        electronApp.exit(1);\n        break\n    }\n}\n```\n\n## 防止debug调试\n\n需要检查 argv 的参数上是否存在 chrome 调试的关键词 例如inspect 或者debugging 等。\n\n```js\n\nconst runWithDebug = process.argv.find(e => e.includes(\"--inspect\") || e.includes(\"--inspect-brk\") || e.includes(\"--remote-debugging-port\"));\n\nif(runWithDebug){\n    // 直接退出。\n    electronApp.quit()\n}\n```\n\n## 客户端崩溃报告\n\n可以借助第三方插件来辅助客户端崩溃报告\n\n@sentry/electron\n中文文档 <https://www.yuque.com/lizhiyao/dxydance/sentry-javascript-readme-cn>\n\n## 提升客户端启动速度\n\n提升客户端的启动速度有好几个方面去着手。\n\n### 使用 V8 缓存数据\n\nelectorn 使用 V8 引擎运行 js，V8 运行 js 时，需要先进行解析和编译，再执行代码。其中，解析和编译过程消耗时间多，经常导致性能瓶颈。而 V8 缓存功能，可以将编译后的字节码缓存起来，省去下一次解析、编译的时间。\n\n使用v8-compile-cache缓存编译插件的代码\n\nv8-compile-cache 的使用非常简单，在需要缓存的代码中，添加一行代码即可：\n\n`require('v8-compile-cache')`\nv8-compile-cache 默认缓存到临时文件夹 <os.tmpdir()>/v8-compile-cache-<V8_VERSION>下，电脑重启后，该文件会被清除掉。\n\n如果希望缓存永久化，可以通过环境变量 process.env.V8_COMPILE_CACHE_CACHE_DIR 来指定缓存文件夹，避免电脑重启后删除。另外，如果希望项目的不同版本对应的缓存不同，可以在文件夹名中加入代码版本号（或其他唯一标识），以此保证缓存和项目版本完全对应。当然，这也意味着项目的多个版本有多份缓存。为了不占用过多磁盘空间，在程序退出时，我们需要删除其他版本的缓存。\n\n### 性能监测分析\n\n主进程，可以用 v8-inspect-profiler 进行性能监测。生成的 .cpuprofile 文件，可以用 devtools 上的 Javascript Profiler 进行分析。如果用 fork 等方法启动了子进程，也可以用相同的方法监测，只需要设置不同的监测端口。\n\nv8-inspect-profiler\n设置启动命令，添加参数 --inspect=${port}，设置主进程的 v8 调试端口。\n\n```js\n\n// package.json\n{\n    \"name\": \"test\",\n    \"version\": \"1.0.0\",\n    \"main\": \"main.js\",\n    \"devDependencies\": {\n        \"electron\": \"9.2.1\"\n    },\n    \"scripts\": {\n        \"start\": \"electron . --inspect=5222\"\n    },\n    \"dependencies\": {\n        \"v8-inspect-profiler\": \"^0.0.20\"\n    }\n}\n```\n\n### 延迟加载模块\n\n项目的一些依赖模块，是在特定功能触发时才需要使用。所以，没有必要在应用启动时立刻加载，可以在方法调用时再加载。\n\n优化前\n\n```js\n\n// 导入模块\nconst xxx = require('xxx');\n\nexport function share() {\n    ...\n    // 执行依赖的方法\n    xxx()\n}\n```\n\n优化后\n\n```js\n\nexport function share() {\n    // 导入模块\n    const xxx = require('xxx');\n\n    ...\n    // 执行依赖的方法\n    xxx()\n}\n```\n\n## 滚动条样式统一\n\n> 对于window 和macOs系统里面,默认的滚动轴的宽度是不一样的，先获取滚动轴宽度\n\n```js\nfunction getScrollbarWidth() {\n    const div = document.createElement('div');\n    div.style.visibility = 'hidden';\n    div.style.width = '100px';\n    document.body.appendChild(div);\n    const offsetWidth = div.offsetWidth;\n    div.style.overflow = 'scroll';\n    const childDiv = document.createElement('div');\n    childDiv.style.width = '100%';\n    div.appendChild(childDiv);\n    const childOffsetWidth = childDiv.offsetWidth;\n    div.parentNode.removeChild(div);\n    return offsetWidth - childOffsetWidth;\n}\n```\n\n然后根据 getScrollbarWidth 做不同设置。\n\n例如：\n\n```js\n\n<!-- 滚动条上的滚动滑块 -->\n::-webkit-scrollbar-thumb{\n     background-color: rgba(180, 180, 180, 0.2);\n     border-radius: 8px;\n}\n\n::-webkit-scrollbar-thumb:hover{\n    background-color: rgba(180, 180, 180, 0.5);\n}\n\n<!-- 滚动条轨道 -->\n::-webkit-scrollbar-track {\n    border-radius: 8px;\n}\n\n<!-- 整个滚动条 -->\n::-webkit-scrollbar{\n    width: 8px;\n    height: 8px;\n}\ndocument.onreadystatechange=(()=>{\n if(\"interactive\" === document.readyState){\n    // 处理逻辑\n }\n})\n```\n\n## browserWindow 错误监听\n\n> 主要是监听 unhandledrejection 和 error 事件\n\n### error\n\n```js\n\nwindow.addEventListener('error',(error)=>{\n\n    const message = {\n        message: error.message,\n        source: error.source,\n        lineno: error.lineno,\n        colno: error.colno,\n        stack: error.error && error.error.stack,\n        href: window.location.href\n    };\n\n    // 通过 ipcRender 发送到 主进程 进行日志记录。\n    ipcRenderer.send(\"weblog\", n)\n},false)\n```\n\n### unhandledrejection\n\n```js\n\nwindow.addEventListener('unhandledrejection',(error)=>{\n    if(!error.reason){\n        return;\n    }\n\n    const message = {\n           message: error.reason.message,\n            stack: error.reason.stack,\n            href: window.location.href\n    }\n\n    <!-- 通过 ipcRender 发送到 主进程 进行日志记录。-->\n    ipcRenderer.send(\"weblog\", n)\n\n},false)\n```\n\n## browserWindow a 标签，打开默认浏览器\n\n业务上面，一般会在 browserWindow 页面上面，会存在a标签，这个时候，如果在electron容器里面，就需要做拦截，并通过默认浏览器打开。\n\n```js\n\ndocument.addEventListener('click',(event)=>{\n    const target = event.target;\n    if(target.nodeName === 'A'){\n        if(event.defaultPrevented){\n            return;\n        }\n        if(location.hostname){\n            event.preventDefault();\n        }\n\n        if(target.href){\n            shell.openExternal(target.href);\n        }\n\n    }\n},false);\n```\n\n暴露一个全局的 打开浏览器的方法\n\n```js\n\nwindow.openExternalLink = ((r)=>{\n\n    shell.openExternal(r)\n});\n```\n\n## 无法使用->\n\n> 因为 Electron 在运行环境中引入了 Node.js，所以在 DOM 中有一些额外的变量，比如 module、exports 和 require。 这导致 了许多库不能正常运行，因为它们也需要将同名的变量加入运行环境中。\n>\n> 1. 一种就是通过配置 webPreferences.nodeIntegration 为false ，通过禁用node.js\n> 2. 通过在electron-bridge.js 里面 最头部 delete window.require;,delete window.exports;,delete window.module; 方式a\n>\n```js\n\n// 在主进程中\nconst { BrowserWindow } = require('electron')\nconst win = new BrowserWindow(format@@\n  webPreferences: {\n    nodeIntegration: false\n  }\n})\nwin.show()\n```\n\n```html\n\n<head>\n<script>\nwindow.nodeRequire = require;\ndelete window.require;\ndelete window.exports;\ndelete window.module;\n</script>\n<script type=\"text/javascript\" src=\"jquery.js\"></script>\n</head>\n```\n\n### electron-bridge\n\n> 通过bridge 向 browserWindow 注入 electron 额外的 api\n\n```js\n\nconst {ipcRenderer: ipcRenderer, shell: shell, remote: remote, clipboard: clipboard} = require(\"electron\"),\n```\n\n<!-- process 里面参数-->\n```js\n\nconst processStaticValues = _.pick(process, [\"arch\", \"argv\", \"argv0\", \"execArgv\", \"execPath\", \"helperExecPath\", \"platform\", \"type\", \"version\", \"versions\"]);\n\nmodule.exports = (() => ({\n    ipcRenderer: ipcRenderer, // ipc renderer\n    shell: shell, // shell\n    remote: remote, //\n    clipboard: clipboard,\n    process: {\n        ...processStaticValues,\n        hang: () => {\n            process.hang()\n        },\n        crash: () => {\n            process.crash()\n        },\n        cwd: () => {\n            process.cwd()\n        }\n    }\n}));\n```\n\n## 代理设置\n\n对于代理设置，一般有两种模式：\n\nPAC\nHTTP\nPAC\n直接输入地址 Protocol://IP:Port\n\nHTTP\n对于HTTP 模式下，有\n\nHTTP\nSOCKS4\nSOCKS5\n输入 Protocol://IP:Port\n\n系统版本比较(mac)\n推荐使用semver 来。\n\n多窗口管理\n推荐electron-windows,支持动态创建窗口。\n\n地址\n\n类似vscode无缝升级安装\n大体思路：先挂载 dmg, 找到挂载目录,在 mac 下是 /Volumes 目录下; 删除 /Applications 下的 app, 将 /Volumes 下的 app 拷贝到 /Applications 目录下; 再卸载 dmg; 重启应用即可,该方法可实现类似无缝更新的效果。\n\n主要借助于 hdiutil 实现的、\n\n主要分为六个步骤：\n\n> which hdiutil\n> hdiutil eject [/Volumes/appDisplayName latestVersion]\n> hdiutil attach [latest Dmg Path]\n> mv [local App Path] [temp dir]\n> cp -R [latest app path] [local app path]\n> hdiutil eject [/Volumes/appDisplayName latestVersion]\n> which hdiutil\n> 查看 hdiutil 可执行文件 是否存在。\n>\n> hdiutil eject [/Volumes/appDisplayName latestVersion]\n> 卸载 [/Volumes/appDisplayName latestVersion] 下面的文件 。\n>\n> hdiutil attach [latest Dmg Path]\n> 安装 dmg 文件\n>\n> mv [local App Path] [temp dir]\n> 将 旧的本地app目录 移动到 tempDir 目录中。\n>\n> cp -R [latest app path] [local app path]\n> 将 latest app path 文件下的所有文件，都复制到原本的app 目录下面。\n>\n> hdiutil eject [/Volumes/appDisplayName latestVersion]\n> 再次 卸载 [/Volumes/appDisplayName latestVersion] 下面的文件\n>\n> 每一步下来，如果都成功了，则成功了。\n\n实例代码。\n\n```js\n\nconst path = require(\"path\");\nconst os = require('os');\nconst {waitUntil, spawnAsync} = require('../../utils');\nconst {existsSync} = require('original-fs');\n\nconst getMacOSAppPath = () => {\n    const sep = path.sep;\n    const execPathList = process.execPath.split(sep);\n    const index = execPathList.findIndex(t => 'Applications' === t);\n    return execPathList.slice(0, index + 2).join(sep);\n};\n\nmodule.exports = (async (app) => {\n    const {appDisplayName} = app.config;\n\n    const {latestVersion, latestDmgPath} = app.updateInfo;\n    //\n    const macOsAppPath = getMacOSAppPath();\n    // temp dir\n    const tempDir = path.join(os.tmpdir(), String((new Date).getTime()));\n\n    const appDisplayNameVolumesDir = path.join('/Volumes', `${appDisplayName} ${latestVersion}`);\n    //\n    const latestAppPath = path.join(appDisplayNameVolumesDir, `${appDisplayName}.app`);\n\n    // step 1 which hdiutil\n    // /usr/bin/hdiutil\n    try {\n        const hdiutilResult = await spawnAsync('which', ['hdiutil']);\n\n        if (!hdiutilResult.includes('/bin/hdiutil')) {\n            throw new Error('hdiutil not found');\n        }\n    } catch (e) {\n        app.logger.warn(e);\n        return {\n            success: false,\n            type: 'dmg-install-failed'\n        }\n    }\n\n    // step 2 hdiutil eject appDisplayNameVolumesDir\n    try {\n        await spawnAsync(\"hdiutil\", [\"eject\", appDisplayNameVolumesDir])\n    } catch (e) {\n        e.customMessage = '[InstallMacOSDmgError] step2 volume exists';\n        app.logger.warn(e);\n    } finally {\n        const result = await waitUntil(() => !existsSync(latestAppPath), {\n            ms: 300,\n            retryTime: 5\n        });\n        if (!result) {\n            app.logger.warn('[InstallMacOSDmgError] step2 volume exists');\n            return {\n                success: false\n            }\n        }\n    }\n\n    //step 3 hdiutil attach latestDmgPath\n    try {\n        await spawnAsync('hdiutil', ['attach', latestDmgPath])\n    } catch (e) {\n        e.customMessage = '[InstallMacOSDmgError] step3 hdiutil attach error';\n        app.logger.warn(e);\n    } finally {\n        const result = await waitUntil(() => !existsSync(latestAppPath), {\n            ms: 300,\n            retryTime: 5\n        });\n\n        if (!result) {\n            app.logger.warn('[InstallMacOSDmgError] step3 hdiutil attach fail');\n            return {\n                success: false\n            }\n        }\n    }\n\n    // step 4 mv\n    try {\n        await spawnAsync('mv', [macOsAppPath, tempDir]);\n    } catch (e) {\n        e.customMessage = '[InstallMacOSDmgError] step4 mv to tmp path error';\n        app.logger.warn(e);\n    } finally {\n        const result = await waitUntil(() => !existsSync(tempDir), {\n            ms: 300,\n            retryTime: 5\n        });\n\n        if (!result) {\n            app.logger.warn('[InstallMacOSDmgError] step4 cp to tmp path fail');\n            return {\n                success: false,\n                type: \"dmg-install-failed\"\n            }\n        }\n    }\n\n    // step 5\n    try {\n        await spawnAsync('cp', ['-R', latestAppPath, macOsAppPath])\n    } catch (e) {\n        e.customMessage = '[InstallMacOSDmgError] step5 cp to app error';\n        app.logger.warn(e);\n    } finally {\n        const result = await waitUntil(() => !existsSync(macOsAppPath), {\n            ms: 300,\n            retryTime: 5\n        });\n        if (!result) {\n            app.logger.warn('[InstallMacOSDmgError] step5 cp to app fail');\n            await spawnAsync('mv', [tempDir, macOsAppPath]);\n            return {\n                success: false,\n                type: \"dmg-install-failed\"\n            }\n        }\n    }\n\n    // step 6\n    try {\n        await spawnAsync('hdiutil', ['eject', appDisplayNameVolumesDir])\n    } catch (e) {\n        e.customMessage = '[InstallMacOSDmgError] step6 hdiutil eject fail';\n        app.logger.warn(e);\n    }\n\n    return {\n        success: true\n    }\n\n});\n```\n","children":[]}]},{"name":"Flutter","path":"../guanruihua.github.io/Front-End/多端","data":"","children":[{"name":"环境搭建.md","path":"../guanruihua.github.io/Front-End/多端/Flutter","data":"# 环境搭建\r\n\r\n> <https://zhuanlan.zhihu.com/p/367097967>\r\n> <https://github.com/flutter/flutter/issues/98170>\r\n> <https://github.com/flutter/flutter/issues/98170>\r\n> <https://blog.csdn.net/ouhuanquan/article/details/123134340>\r\n> 需要C++,Android环境,Flutter环境\r\n\r\n## flutter doctor\r\n\r\n> 检查环境是否成功\r\n\r\n## flutter doctor --android-licenses\r\n\r\n> 生成证书\r\n","children":[]}]},{"name":"React-Native","path":"../guanruihua.github.io/Front-End/多端","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Front-End/多端/React-Native","data":"# React-Native\r\n\r\n> <https://blog.csdn.net/qq_40259641/article/details/100115329>\r\n> <https://reactnative.cn/docs/environment-sectup>\r\n> <https://docs.microsoft.com/zh-cn/windows/dev-environment/javascript/react-native-for-android>\r\n\r\n## 环境配置问题\r\n\r\n> <https://reactnative.cn/docs/environment-setup>\r\n","children":[]}]},{"name":"小程序","path":"../guanruihua.github.io/Front-End/多端","data":"","children":[{"name":"Taro","path":"../guanruihua.github.io/Front-End/多端/小程序","data":"","children":[{"name":"文档","path":"../guanruihua.github.io/Front-End/多端/小程序/Taro","data":"","children":[{"name":"基础.md","path":"../guanruihua.github.io/Front-End/多端/小程序/Taro/文档","data":"","children":[]},{"name":"框架.md","path":"../guanruihua.github.io/Front-End/多端/小程序/Taro/文档","data":"","children":[]},{"name":"路由.md","path":"../guanruihua.github.io/Front-End/多端/小程序/Taro/文档","data":"# 路由\r\n\r\n## `Taro.switchTab(option)`\r\n\r\n> 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面\r\n>\r\n> 支持情况：微信小程序, H5, React Native\r\n\r\n### 类型\r\n\r\n`(option: Option) => Promise<TaroGeneral.CallbackResult>`\r\n\r\n### Option\r\n\r\n| 参数     | 类型                                        | 必填 | 说明                                                                                       |\r\n| -------- | ------------------------------------------- | :----: | ------------------------------------------------------------------------------------------ |\r\n| url      | string                                      | 是   | 需要跳转的 tabBar 页面的路径（需在 app.json 的 tabBar 字段定义的页面），路径后不能带参数。 |\r\n| complete | `(res: TaroGeneral.CallbackResult) => void` | 否   | 接口调用结束的回调函数（调用成功、失败都会执行）                                           |\r\n| fail     | `(res: TaroGeneral.CallbackResult) => void`  | 否   | 接口调用失败的回调函数                                                                     |\r\n| success  | `(res: TaroGeneral.CallbackResult) => void` | 否   | 接口调用成功的回调函数                                                                     |\r\n\r\n```js\r\n{\r\n  \"tabBar\": {\r\n    \"list\": [{\r\n      \"pagePath\": \"index\",\r\n      \"text\": \"首页\"\r\n    },{\r\n      \"pagePath\": \"other\",\r\n      \"text\": \"其他\"\r\n    }]\r\n  }\r\n}\r\n```\r\n\r\n```js\r\nTaro.switchTab({\r\n  url: '/index'\r\n})\r\n```\r\n","children":[]}]},{"name":"问题.md","path":"../guanruihua.github.io/Front-End/多端/小程序/Taro","data":"# 小程序开发问题\r\n\r\n> 多端小程序框架\r\n> [Hooks | Taro 文档 (jd.com)](https://taro-docs.jd.com/taro/docs/hooks)\r\n> <https://cloud.tencent.com/developer/article/1820510>\r\n> <https://github.com/NervJS/taro/issues/7302>\r\n> <https://github.com/flutter/flutter/issues/98170>\r\n\r\n## tabBar 切换失败问题\r\n\r\n> 平台: 微信小程序\r\n> 需要清理缓存和dist文件, 重新生成, 不然会有切换失败\r\n\r\n## Taro-UI 问题\r\n\r\n> 2022-04-15 09:50:04 Taro@3 不支持使用Taro-ui@2, Taro-ui@3还没有正式版\r\n> Taro-ui 引入index.scss错误问题\r\n安装tao-ui时,如果出现报错，可以尝试更换taro-ui版本，因为目前taro ui2.+和taro3.+版本不兼容,使用以下命令可解决\r\n`npm install taro-ui@3.0.0-alpha.3`\r\n","children":[]}]},{"name":"微信小程序","path":"../guanruihua.github.io/Front-End/多端/小程序","data":"","children":[{"name":"api","path":"../guanruihua.github.io/Front-End/多端/小程序/微信小程序","data":"","children":[{"name":"web-view.md","path":"../guanruihua.github.io/Front-End/多端/小程序/微信小程序/api","data":"# web-view\r\n\r\n> 组件是一个可以用来承载网页的容器，会自动铺满整个小程序页面。个人类型与海外类型的小程序暂不支持使用\r\n> 个人版只可以在开发者工具预览, 手机预览失败\r\n","children":[]}]},{"name":"云函数.md","path":"../guanruihua.github.io/Front-End/多端/小程序/微信小程序","data":"# 云函数\r\n\r\n## 添加第三方包\r\n\r\n> 如果`npm install package`等命令失败\r\n> 可以直接修改package.json, 添加对应的包, 部署时候不用部署node_modules即可\r\n","children":[]},{"name":"开放信息","path":"../guanruihua.github.io/Front-End/多端/小程序/微信小程序","data":"","children":[{"name":"UnionID.md","path":"../guanruihua.github.io/Front-End/多端/小程序/微信小程序/开放信息","data":"# UnionID\r\n\r\n> 需要微信开放平台绑定了小程序才有\r\n\r\n## 机制\r\n\r\n> 如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 UnionID 来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 UnionID 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，UnionID是相同的。\r\n\r\n## 获取途径\r\n\r\n- 绑定了开发者帐号的小程序，可以通过以下途径获取 UnionID。\r\n\r\n- 开发者可以直接通过 `wx.login + code2Session` 获取到该用户 `UnionID`，无须用户授权。\r\n\r\n- 小程序端调用云函数时，可在云函数中通过 `Cloud.getWXContext` 获取 `UnionID`。\r\n\r\n- 用户在小程序（暂不支持小游戏）中支付完成后，开发者可以直接通过`getPaidUnionId`接口获取该用户的 `UnionID`，无需用户授权。注意：本接口仅在用户支付完成后的5分钟内有效，请开发者妥善处理。\r\n\r\n## 微信开放平台绑定小程序流程\r\n\r\n> 登录微信开放平台 — 管理中心 — 小程序 — 绑定小程序\r\n\r\n![](./__assets__/UnionID-2022-04-24-09-59-31.png)\r\n","children":[]}]},{"name":"微信小程序_basic.md","path":"../guanruihua.github.io/Front-End/多端/小程序/微信小程序","data":"# 微信小程序\n\n> [小程序开发文档](https://developers.weixin.qq.com/miniprogram/dev/framework/)\n\n## 搭建环境\n\n> 申请AppID\n>\n> 编辑器 -> 选择小程序 -> 点击 + ;\n>\n> 自行创建项目 + 填入appid, 不选择云开发, 然后点击新建\n\n### 目录结构\n\n```basic\n├─pages\n│  ├─index  // 对应每个页面 内部必须包含以下四个文件\n│  │      index.js  // 页面逻辑\n│  │      index.json // 页面配置\n│  │      index.wxml // 页面结构\n│  │      index.wxss // 页面样式\n│  └─logs\n│          logs.js\n│          logs.json\n│          logs.wxml\n│          logs.wxss\n└─utils  // 工具类\n│      util.js\n│  app.js  // 描述小程序整体逻辑\n│  app.json  // 小程序公共配置\n│  app.wxss  // 小程序公共样式\n│  project.config.json // 项目配置文件\n│  sitemap.json\n/**\n* 需要注意的是 page 中4个文件必须同名\n**/\n```\n\n## 小程序配置\n\n> 小程序根目录下的 `app.json` 文件用来对微信小程序进行**全局配置**\n\n```json\n{ \n    // 配置小程序默认启动页\n    \"entryPagePath\": \"pages/logs/logs\",\n    // 对应小程序中的每一个页面,如果没有 entryPagePath, pages中的第一项为启动页\n    \"pages\": [\n        \"pages/index/index\",\n        \"pages/logs/logs\"\n    ],\n    \"window\": {\n        // 导航栏背景颜色\n        \"navigationBarBackgroundColor\": \"#ccc\",\n        // 导航栏文字颜色 white black\n        \"navigationBarTextStyle\":\"white\",\n        // 导航栏文字内容\n        \"navigationBarTitleText\": \"wx\",\n        // 下拉 loading 样式 dark light; 需要配置下面这个配置才能开启\n        \"backgroundTextStyle\": \"dark\",\n        // 是否开启全局的下拉刷新\n        \"enablePullDownRefresh\": true,\n        // 导航栏样式 custom, default; custom以上配置全部失效,只保留右上角胶囊, topBar需要自己写样式定义\n        \"navigationStyle\": \"custom\"\n    },\n    \"tabBar\": {\n        // tabBar 文字颜色\n        \"color\": \"#444\",\n        // tabBar 文字选中颜色\n        \"selectedColor\": \"#f1f1f1\",\n        // tabBar 背景颜色\n        \"backgroundColor\": \"#fff\",\n        // tabBar 上边框颜色\n        \"borderStyle\": \"#ccc\",\n        // 最多配置5个 tab, 最少2个\n        \"list\": [\n            // 必须在 pages 中存在\n            \"pagePath\": \"pages/index/index\",\n            // tab 名字\n            \"text\": \"homePage\",\n            // 建议大小 81*81 不支持网络图片\n            \"iconPath\": \"\",\n            \"selectedIconPath\": \"\"\n        ]\n    }\n}\n```\n\n> 每一个小程序页面也可以使用 `.json` 文件对本页面的窗口表现进行配置 页面配置项会覆盖 `app.json` 的 `window` 中相同的配置项\n>\n> [页面配置](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/page.html)\n\n## WXML 语法\n\n### 数据绑定\n\n> WXML 中的动态数据均来自对应 Page 的 data ; 数据绑定使用双大括号语法 与 Vue 基本一致 , 但是也有些许不同 , 简单总结一下就是小程序中的 页面里面所有的表达式都应在  \\{\\{变量\\}\\}内部去做\n\n```html\n<view>{{ message }}</view>\n<!-- 绑定动态属性还是要用大括号 -->\n<view class=\"item-{{ id }}\"></view>\nPage({\n    data: {\n        message: \"hello world\",\n        id: 123\n    }\n})\n```\n\n### [列表渲染](https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/conditional.html)\n\n```html\n<!-- 小程序内部会自动生成 item 和 index -->\n<view wx:for=\"{{ list }}\" wx:key=\"{{ index }}\">\n    <text>{{ item.uname }} -- {{ item.uage }}</text>\n</view>\nPage({\n    data: {\n        list: [\n            { uname: 'zs', uage: 23 },\n            { uname: 'ls', uage: 24 },\n            { uname: 'we', uage: 25 },\n            { uname: 'mz', uage: 26 }\n        ]\n    }\n})\n```\n\n### 条件渲染\n\n```html\n<view wx:if=\"{{ isShow }}\">是否渲染</view>\n<view wx:elif=\"{{ !isShow }}\">分支判断</view>\n<view wx:else>否则</view>\n```\n\n## WXSS\n\n> WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式 ;\n>\n> WXSS 具有 CSS 的大部分特性 , 为了更适合小程序开发 , 对 CSS 也做了对应的扩充和修改 **尺寸单位(rpx) 样式导入(@import)**\n\n## 生命周期\n\n> 小程序的生命周期分为三种, 分别是 `app` `page` `component` 这里咱们只说一下前面的两种\n\n### App\n\n- `onLaunch` : 监听小程序初始化\n- `onShow` : 小程序启动时和后台切回前台的时候被调用\n- `onHide` : 小程序切入到后台时调用\n\n```\nApp({\n    onLaunch() {\n        console.log('onLaunch...');\n    },\n    onShow() {\n        console.log('onShow...');\n    },\n    onHide() {\n        console.log('onHide...');\n    }\n})\n```\n\n### Page\n\n- `onLoad` : 页面加载时触发 , 一个页面只会调用一次 , 可以在 onLoad 的参数中获取当前打开页面所携带的参数\n- `onShow` : 页面显示时和切入前台时被调用\n- `onReady` : 页面初次渲染完成时触发只调用一次 类似于 vue 中的 `Mounted`\n- `onHide` : 页面隐藏和切入后台时调用, 如`wx.navgationTo` 或 tab 切换\n- `onUnload` : 页面卸载时触发 , 如 `wx.redirectTo`或`wx.navigationBack`到其他页面时\n\n```\nPage({\n    // 默认获取到的是空对象, 如果传递有参数就是参数对象\n    onLoad(params) {\n        console.log(params);\n    },\n    onShow() {\n        console.log('page--onShow...');\n    },\n    onReady() {\n        console.log('page--onReady...');\n    },\n    onHide() {\n        console.log('page--onHide...');\n    },\n    onUnload() {\n        console.log('page--onUnload...');\n    }\n})\n```\n\n> App 和 Page 之间的顺序为\n>\n> 启动时 : App`onLaunch` `onShow` Page `onLoad` `onShow` `onReady`\n>\n> 切后台 : Page `onHide` App `onHide`\n>\n> 切前台 : App `onShow` Page `onShow`\n\n## 事件\n\n```js\n<button type=\"primary\" bindtap=\"clickMe\">click me</button>\nPage({\n    clickMe(event) {\n        console.log(event)\n    }\n})\n```\n\n## 组件\n\n> 个人理解这个组件可以理解为微信又基于一些HTML做了二次封装 ; 这里内容比较多, 但是大部分都不是很难 , 直接放链接吧 , 建议文档反复观看并实践 [戳这里](https://developers.weixin.qq.com/miniprogram/dev/component/)\n\n## API\n\n> 微信提供的接口还是比较多的 这里也不说了 详情看这里 [👉](https://developers.weixin.qq.com/miniprogram/dev/api/base/wx.canIUse.html)\n\n### 路由\n\n> 介绍三个比较个人认为比较常用的 api 详细看这里 [👉](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.switchTab.html)\n\n```js\nPage({\n    clickHandle() {\n        // 关闭当前页面, 跳转到应用某个页面 不能到 tabBar 页面\n        wx.redirectTo({\n            url: '/pages/index/index'\n        });\n        // 保留当前页面, 跳转到应用内某个页面 不能到 tabBar 页面\n        wx:navigateTo({\n            url: '/pages/index/index'\n        });\n        // 关闭当前页面, 返回上一级或多级页面\n        wx.navigateBack({\n            delta: 1 // 数字大小代表回退几个页面\n        });\n    }\n})\n```\n\n## 数据设置\n\n> 在小程序中 设置数据一定要使用 `setData` 方法设置\n\n- 直接修改 `this.data` 而不调用 `setData` 是无法改变页面状态的 , 还会造成数据不一致\n- 仅支持设置可 JSON 化的数据\n- 单次设置的数据不能超过 `1024KB`\n- 不要把 `data` 中的任一数据设置为 `undefined` , 可能存在诡异的 **bug**\n\n```js\n<input type=\"text\" bindinput=\"input\" /> \n// 双向绑定示例\nPage({\n data: {\n  value: ''\n },\n input(event) {\n  this.setData({\n   value: event.detail.value\n  });\n }\n})\n```\n\n## 数据库\n\n> [mongoDB](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/capabilities.html#数据库)\n\n创建了一个 `cloud-demo` 的 collection 并且添加了一些数据 下面我们读取一下试试\n\n![03](https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2469b00725549a9a1d3c8077aa6cfc9~tplv-k3u1fbpfcp-zoom-1.image)\n\n```js\nPage({\n    onLoad() {\n        // 初始化数据库\n        const db = wx.cloud.database();\n        db.collection('cloud-demo').get().then(res => console.log(res));\n        // 除了 promise 也可以使用 回调函数\n        db.collection('cloud-demo').get({\n            success: function(res) {\n                console.log(res);\n            }\n        })\n    }\n})\n```\n\n> 这里给大家说一个小坑 ; 有可能你们读取到的是一个空的数组 , 这是因为你创建的 `collection` 有权限问题 ; 大家可以选择对应的 `collection` 然后勾选上方的**数据权限** 然后选择对应的选线即可 ;\n\n## 存储\n\n> 云开发提供一块存储空间 , 提供上传文件到云端 带权限管理的云端下载功能 , 可以使用小程序和云函数通过 API 使用云存储功能 ; 这里我个人理解就像是一个静态资源服务器, 可以用来存储一些图片等等 ;  演示的话就暂时先演示 小程序的上传下载吧\n\n```js\n<button type=\"primary\" bindtap=\"upload\">点击上传</button>\nPage({\n    // 上传文件\n    upload() {\n        wx.cloud.uploadFile({\n            cloudPath: '这是填云控制台中 存储模块 下面的路径',\n            filePath: '/images/create-collection.png',\n            success(res) {\n                console.log(res);\n            }\n        })\n    },\n    // 下载文件\n    download() {\n        wx.downloadFile({\n            url: 'https://xxx.png',\n            // res 中会包含 tempPath 找了半天没能保存到本地工程中的api 都是保存到手机的尴尬\n            success(res) {\n                console.log(res)\n            }\n        })\n    }\n})\n```\n\n## 云函数\n\n> 云函数 (云端运行的函数) 功能独立 , 只需要编写函数代码并部署到云端可在小程序调用 , 同时云函数之间也可以互相调用 ;\n>\n> 云函数写法与 javascript 写法基本一致 , 代码运行在云端的 Node.js 环境中 , 可以在这个环境中进行网络请求等操作, 还可以通过云函数后端 SDK 搭配使用多种服务 , 比如使用云函数 SDK 中提供的数据库和存储API进行数据和存储的操作;\n>\n> 云开发的原函数的独特优势在于与微信鉴权的无缝整合 , 当小程序调用云函数时 , 云函数的传入参数中会被注入小程序用户的 openid , 开发者无需校验 openid 的正确性因为微信已经完成了这部分鉴权 , 开发者可以直接使用openid ;\n\n### 云函数简单示例\n\n> 找到项目根目录 , 在根目录上右键 , 右键菜单中选择 新建Node.js 云函数 , 名字符合规范即可 , 然后进入刚才新建的云函数中的 index.js 文件中\n\n- `wx-server-sdk`: 帮助云函数中操作数据库, 存储以及调用其他云函数的微信提供的库\n- `event` :  触发云函数的事件, 当小程序调用时 event 就是小程序调用云函数时传入的参数, 外加后端自动注入的小程序用户的openid 和 appid\n- `context`:  包含此处的调用信息和运行状态, 可以用来了解服务运行的状态\n\n```js\n// 云函数入口文件\nconst cloud = require('wx-server-sdk')\ncloud.init()\n// 云函数入口函数\nexports.main = async (event, context) => {\n  const wxContext = cloud.getWXContext()\n  return {\n    // 比如这里我们顺便加个小功能\n    sum: event.a + event.b,\n    event,\n    openid: wxContext.OPENID,\n    appid: wxContext.APPID,\n    unionid: wxContext.UNIONID,\n  }\n}\n```\n\n云函数书写完成后, 一定要记得鼠标右键在云函数目录上选择上传将云函数打包后在进行测试;\n\n> 小程序中调用云函数\n\n```js\nPage({\n    onShow() {\n        wx.cloud.callFunction({\n            name: 'testDemo', // 云函数名称, 文件夹名称,\n            data: { // 传入的参数 \n                a: 1,\n                b: 2\n            },\n            success(res) {\n                // 结果集是放到 result 中的\n                console.log(res.result);\n            }\n        })\n        // 也可以使用 promise 方式\n        wx.cloud.callFunction({\n            name: 'testDemo', // 云函数名称, 文件夹名称,\n            data: { // 传入的参数 \n                a: 1,\n                b: 2\n            }\n        }).then(res => console.log(res.result))\n    }\n})\n```\n\n当然还提供了很多的功能 , 这里就不细说了 大家看文档 比如 **异步返回结果** **使用npm** **使用wx-server-sdk** 大家可以重点先看下 [戳这里](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/functions.html#云函数)\n\n## todoList Demo\n\n- 实现了 item 的新增 删除 和更新 使用了 云函数的增删改 这里查询就直接写到本地了\n- 实现了获取个人信息\n\n> 个人总结 , 感觉小程序写着好不方便, 有点小坑 , 不过还是建议大家看一下, 熟悉一下微信原生开发, 毕竟小程序这个东西就是微信先出来的, 下一步准备总结一些 uni-app 相关内容, 个人感觉这个要好好看看了 毕竟工作中相信大家很少写原生的小程序, 肯定都是基于 mpvue 或者 uni-app 这些类 vue 框架或者类 react 框架去完成的工作 ; 下面看一下效果吧 !  [代码地址 🤞](https://gitee.com/shuqingxuTest/wx-todo-list)\n\n## 项目演示\n\n![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f64760e6b7ea463bb762fd6829f3f4ad~tplv-k3u1fbpfcp-watermark.image)\n","children":[]},{"name":"获取用户信息.md","path":"../guanruihua.github.io/Front-End/多端/小程序/微信小程序","data":"# 获取用户信息\r\n\r\n```tsx\r\n    Taro.getUserProfile({\r\n      lang: 'zh_CN',\r\n      desc: '获取你的昵称, 头像,地区及性别',\r\n      success: res => {\r\n        // console.log(\"userInfo:\", res.userInfo)\r\n        const userInfo = res.userInfo || {}\r\n        // _this.handleUserInfo(userInfo)\r\n\r\n      },\r\n      fail: () => {\r\n        console.log('您拒绝了请求');\r\n        return;\r\n      }\r\n    })\r\n```\r\n","children":[]},{"name":"错误","path":"../guanruihua.github.io/Front-End/多端/小程序/微信小程序","data":"","children":[{"name":"600002.md","path":"../guanruihua.github.io/Front-End/多端/小程序/微信小程序/错误","data":"# 600002错误\r\n\r\n## 情况1：未设置合法域名\r\n\r\n解决方法:请在微信公众平台登录小程序后台设置。\r\n\r\n## 情况2：设置了合法域名，开发工具仍然报错\r\n\r\n解决方法:\r\n在右上角点击详情，之后刷新一下项目配置，看看有无域名信息，如果有了，清除全部缓存重新编译小程序，如果还是没有请确认是否设置合法域名。\r\n![](./__assets__/60002-2022-07-28-09-54-25.png)\r\n\r\n## 情况3：设置了合法域名，开发工具不报，真机调试和体验版报\r\n\r\n这种情况一般开发工具正常运行，真机调试和体验版不行，因为之前使用过真机调试和发布体验版，在测试机上留下缓存\r\n\r\n解决方法:手机微信下拉找到最近使用的小程序，长按之后拖到底部删除，然后重新尝试真机调试和体验版。\r\n\r\n## 情况4：设置了合法域名，到哪都报错，清缓存也没用\r\n\r\n解决方法:请确认访问该域名时，是否会出现重定向，将重定向域名添加进合法域名\r\n\r\n## 情况5：设置了合法域名（含重定向），到哪都报错，清缓存也没用\r\n\r\n解决方法:请确认访问该域名是否是三级域名，请设置为一级或二级域名\r\n\r\n## 情况6：以上所有解决方案都不行\r\n\r\n解决方法:请在微信小程序平台反馈bug\r\n","children":[]}]}]}]}]},{"name":"拓展","path":"../guanruihua.github.io/Front-End","data":"","children":[{"name":"CORS.md","path":"../guanruihua.github.io/Front-End/拓展","data":"# CORS\n\n> **CORS** （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的[HTTP头](https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP_header)组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应。\n>\n> [同源安全策略](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy) 默认阻止“跨域”获取资源。但是 CORS 给了web服务器这样的权限，即服务器可以选择，允许跨域请求访问到它们的资源\n\n## [Access-Control-Allow-Origin](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin)\n\n> 指示请求的资源能共享给哪些域。\n>\n> `Header type`: `Response header`\n>\n> `Access-Control-Allow-Origin: *` // 允许所有资源都可以访问您的资源,\n> `Access-Control-Allow-Origin: https://developer.mozilla.org` // 允许 <https://developer.mozilla.org>访问您的资源\n\n## [Access-Control-Allow-Credentials](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials)\n\n> 指示当请求的凭证标记为 true 时，是否响应该请求。\n>\n> 响应头表示是否可以将对请求的响应暴露给页面, 返回true可以, 其他值均不可以;\n>\n> `Header type`: `Response header`\n>\n> Credentials可以是 cookies, authorization headers 或 TLS client certificates。\n>\n> 当作为对预检请求的响应的一部分时，这能表示是否真正的请求可以使用credentials。\n>\n> 注意简单的`GET` 请求没有预检，所以若一个对资源的请求带了credentials，如果这个响应头没有随资源返回，响应就会被浏览器忽视，不会返回到web内容。\n\n允许credentials:\n\n```\nAccess-Control-Allow-Credentials: true\n```\n\n使用带credentials的 [XHR](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) ：\n\n```\nvar xhr = new XMLHttpRequest();\nxhr.open('GET', 'http://example.com/', true);\nxhr.withCredentials = true;\nxhr.send(null);\n```\n\nCopy to Clipboard\n\n使用带credentials的 [Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) ：\n\n```js\nfetch(url, {\n  credentials: 'include'\n})\n```\n\n## [Access-Control-Allow-Headers](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Headers)\n\n> 用在对预请求的响应中，指示实际的请求中可以使用哪些 HTTP 头。\n>\n> 响应首部 **`Access-Control-Allow-Headers`** 用于 [preflight request](https://developer.mozilla.org/zh-CN/docs/Glossary/Preflight_request) （预检请求）中，列出了将会在正式请求的 [Access-Control-Request-Headers](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers) 字段中出现的首部信息。\n>\n> 简单首部，如 [simple headers](https://developer.mozilla.org/zh-CN/docs/Glossary/Simple_header)、[Accept](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept)、[Accept-Language](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language)、[Content-Language](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language)、[Content-Type](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type) （只限于解析后的值为 `application/x-www-form-urlencoded、multipart/form-data`或 `text/plain 三种MIME类型（不包括参数）），它们始终是被支持的，不需要在这个首部特意列出。`\n>\n> ```xml\n> Access-Control-Allow-Headers: <header-name>[, <header-name>]*\n> Access-Control-Allow-Headers: *\n> ```\n>\n> `<header-name>`: 可支持的请求首部名字。请求头会列出所有支持的首部列表，用逗号隔开。\n\n## [Access-Control-Allow-Methods](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Methods)\n\n> 指定对预请求的响应中，哪些 HTTP 方法允许访问请求的资源。\n>\n> `Access-Control-Allow-Methods: <method>, <method>, ...`\n>\n> `Access-Control-Allow-Methods: POST, GET, OPTIONS`\n>\n> `<method>` :  GET, POST, HEAD, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH\n\n## [Access-Control-Expose-Headers](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Expose-Headers)\n\n> 指示哪些 HTTP 头的名称能在响应中列出\n>\n> `Access-Control-Expose-Headers: <header-name>, <header-name>, ...`\n>\n> 默认情况七种`simple response headers`\n>\n> - [Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)\n> - [Content-Language](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language)\n> - [Content-Length](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Length)\n> - [Content-Type](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type)\n> - [Expires](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires)\n> - [Last-Modified](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified)\n> - [Pragma](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Pragma)\n\n## [Access-Control-Max-Age](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Max-Age)\n\n> 指示预请求的结果能被缓存多久。(即 [Access-Control-Allow-Methods](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Methods) 和[Access-Control-Allow-Headers](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Headers) 提供的信息） 可以被缓存多久。)\n>\n> `Access-Control-Max-Age: <delta-seconds>`\n>\n> `<delta-seconds>`\n>\n> - 返回结果可以被缓存的最长时间（秒）。\n>   在 Firefox 中，[上限是24小时](https://dxr.mozilla.org/mozilla-central/rev/7ae377917236b7e6111146aa9fb4c073c0efc7f4/netwerk/protocol/http/nsCORSListenerProxy.cpp#1131) （即 86400 秒）。\n>   在 Chromium v76 之前， [上限是 10 分钟](https://cs.chromium.org/chromium/src/services/network/public/cpp/cors/preflight_result.cc?l=36&rcl=52002151773d8cd9ffc5f557cd7cc880fddcae3e)（即 600 秒)。\n>   从 Chromium v76 开始，[上限是 2 小时](https://cs.chromium.org/chromium/src/services/network/public/cpp/cors/preflight_result.cc?l=31&rcl=49e7c0b4886cac1f3d09dc046bd528c9c811a0fa)（即 7200 秒)。\n>   Chromium 同时规定了一个默认值 5 秒。\n>   如果值为 **-1**，表示禁用缓存，则每次请求前都需要使用 OPTIONS 预检请求。\n\n## [Access-Control-Request-Headers](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers)\n\n> 用于发起一个预请求，告知服务器正式请求会使用那些 HTTP 头。\n>\n> `Access-Control-Request-Headers: <header-name>, <header-name>, ...`\n>\n> `Access-Control-Request-Headers: X-PINGOTHER, Content-Type`\n\n## [Access-Control-Request-Method](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Method)\n\n> 用于发起一个预请求，告知服务器正式请求会使用哪一种 [HTTP 请求方法](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods)。\n>\n> `Access-Control-Request-Method: <method>`\n>\n> `Access-Control-Request-Method: POST`\n\n## [Origin](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin)\n\n> 指示获取资源的请求是从什么域发起的\n>\n> `Origin: \"\"`\n>\n> `Origin: <scheme> \"://\" <host> [ \":\" <port> ]`\n>\n> `Origin: https://developer.mozilla.org`\n>\n> - `<scheme>`:  请求所使用的的协议, 通常是HTTP协议或他的安全版本HTTPS协议\n> - `<host>`:  服务器的域名或IP地址\n> - `<port>`:(可选) 服务器正在监听的TCP端口号, 缺省为服务的默认蹲坑(HTTP请求而言, 默认端口为80)\n\n## [Vary - HTTP](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary)\n\n> `Header type`: `Response header`\n>\n> `Vary: *` : 所有请求都被视为唯一并且非缓存\n>\n> - 使用`Cache-Control: no-store`: 实现更加使用\n>\n> `Vary: <header-name>, <header-name>...`: 都好分隔的一系列http头部名称, 用户确定缓存是否可用\n>\n> 动态服务:\n>\n> - `Vary: User-Agent`: 可以防止客户端使用了桌面端的缓存\n\n## Response header 响应头\n\n> 响应头(Response header) : 定义为被用于http响应中并且和相应信息主题无关的那一类HTTP header\n\n```xml\n200 OK\nAccess-Control-Allow-Origin: *\nConnection: Keep-Alive\nContent-Encoding: gzip\nContent-Type: text/html; charset=utf-8\nDate: Mon, 18 Jul 2016 16:06:00 GMT\nEtag: \"c561c68d0ba92bbeb8b0f612a9199f722e3a621a\"\nKeep-Alive: timeout=5, max=997\nLast-Modified: Mon, 18 Jul 2016 02:36:04 GMT\nServer: Apache\nSet-Cookie: mykey=myvalue; expires=Mon, 17-Jul-2017 16:06:00 GMT; Max-Age=31449600; Path=/; secure\nTransfer-Encoding: chunked\nVary: Cookie, Accept-Encoding\nX-Backend-Server: developer2.webapp.scl3.mozilla.com\nX-Cache-Info: not cacheable; meta data too large\nX-kuma-revision: 1085259\nx-frame-options: DENY\n```\n\n### Age\n\n> `Age: <delta-seconds>`: 表示对象在缓存代理服务器中存储的时长( 单位秒) [delta-seconds非负整数]\n\n### Location\n\n> `Header type`: `Response header`\n>\n> `Location` 首部指定的是需要将页面重新定向至的地址。一般在响应码为3xx的响应中才会有意义。\n>\n> 发送新请求，获取Location指向的新页面所采用的方法与初始请求使用的方法以及重定向的类型相关：\n>\n> - [303](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/303) (See Also) 始终引致请求使用 [GET](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET) 方法，而，而 [307](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/307) (Temporary Redirect) 和 [308](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/308) (See Also) 始终引致请求使用 [GET](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET) 方法，而，而 [307](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/307) (Temporary Redirect) 和 [308](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/308) (Permanent Redirect) 则不转变初始请求中的所使用的方法；\n> - [301](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/301) (Permanent Redirect) 和 [302](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/302) (Found) 在大多数情况下不会转变初始请求中的方法，不过一些比较早的用户代理可能会引发方法的变更（所以你基本上不知道这一点）。\n>\n> 状态码为上述之一的所有响应都会带有一个Location首部。\n>\n> 除了重定向响应之外， 状态码为 [201](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/201) (Created) 的消息也会带有Location首部。它指向的是新创建的资源的地址。\n>\n> [Location](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Location) 与 `Content-Location`是不同的，前者（[Location](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Location) ）指定的是一个重定向请求的目的地址（或者新创建的文件的URL），而后者（ `Content-Location`） 指向的是经过内容协商后的资源的直接地址，不需要进行进一步的内容协商。Location 对应的是响应，而Content-Location对应的是要返回的实体。\n\n```\nLocation: <url>\nLocation: /index.html\n- url: 相对地址（相对于要访问的URL）或绝对地址。\n```\n\n### Server\n\n> `Header type`: `Response header`\n>\n> Server: 首部包含请求的源头服务器所用到的软件相关信息\n>\n> - 尽量避免使用过长或者过于信息的描述作为Server的值, 太长容易泄漏服务器的内部实现细节, 容易被通过已知安全漏洞攻击, 不安全\n>\n> `Server: <product>`\n>\n> `Server:Apache/2.4.1(Unix)`\n>\n> `<product>`: 处理请求的软件或产品或组件产品的名称\n\n## 禁止修改的消息首部\n\n> 禁止修改的消息首部: 不能再代码中修改的HTTP协议消息首部\n>\n> 用户代理对这些消息首部保留全部控制权,   应用程序无法设置它们\n>\n> `User-Agent`: 以及从列表冲移除\n\n禁止修改消息首部包括Proxy- 和Sec-开头的消息首部, 以及\n\n```xml\nAccept-Charset\nAccept-Encoding\nAccess-Control-Request-Headers\nAccess-Control-Request-Method\nConnection\nContent-Length\nCookie\nCookie2\nDate\nDNT\nExpect\nHost\nKeep-Alive\nOrigin\nProxy-\nSec-\nReferer\nTE\nTrailer\nTransfer-Encoding\nUpgrade\nVia\n```\n","children":[]},{"name":"css-in-js","path":"../guanruihua.github.io/Front-End/拓展","data":"","children":[{"name":"特点.md","path":"../guanruihua.github.io/Front-End/拓展/css-in-js","data":"# `css-in-js`\r\n\r\n> `css-in-js` 作为一个理念较新的开发思路，拥有如下几个明显的优缺点。\r\n\r\n优点：\r\n\r\n> 无全局样式冲突。就像 js 文件天然支持模块化的好处一样，原生 css 因为没有模块化能力，天然容易导致全局样式污染，如果不是特意用 BEM 方式命名，想要避免冲突就只能借助 `css-in-js` 了。（css-modules 也一样能做到）\r\n> 与 js 代码合在一起。天然融合进 js 代码方便模块化管理，使 css 可以与某个局部模块绑定。（css-modules 也一样能做到，只是必须单独拆一个样式文件）\r\n> 能将 js 变量应用到样式上。虽然 css 变量也能解决这个问题，但不如 `css-in-js` 那么直观，inline-style 也能解决这个问题，但会产生大量重复的局部样式，且这个优势 `css-modules` 做不到。\r\n缺点：\r\n\r\n> `css-in-js` 运行时解析的实现版本增加了运行时性能压力，尤其在 `React18` 调度机制模式下，存在无法解决的性能问题（运行时插入样式会导致 React 渲染暂停，浏览器解析一遍样式，渲染再继续，然后浏览器又解析一遍样式）。\r\n> 增加了包体积。相比原生或者 css-modules 方案来说，增加了运行时框架代码 8kb 左右。\r\n> 让 ReactDevTools 结构变得复杂，因为 `css-in-js` 会包裹额外的 React 组件层用来实现样式插入。\r\n除了上述缺点外，`css-in-js` 还有三点深度使用后才能察觉的坑：\r\n\r\n多个不同（甚至是相同）版本的 `css-in-js` 库同时加载时可能导致错误。笔者用 styled-components 就遇到了类似问题，甚至语法会产生不兼容的情况，虽然这些问题都可以被解决，但花费的额外时间需要计算一样，相比 `css-in-js` 得到的收益是否值得。\r\n样式插入优先级无法自定义，这就导致产生样式覆盖时，业务对样式覆盖的优先级无法产生稳定的预期。class 优先级由 header 定义顺序决定，而非 className 的字符顺序决定，而 header 定义顺序又由资源加载与 `css-in-js` 插入执行时机决定，导致业务几乎不可能有稳定的样式覆盖顺序。这里产生的问题就是业务代码不断增多的 !important 定义。\r\n不同 React 版本的 SSR，`css-in-js` 需要适配不同的实现，这对框架作者不太友好。\r\n除了性能问题以外，其他问题都可以忍，但偏偏在性能问题上，`css-in-js` 遇到了无解的场景。\r\n\r\n无解的性能问题\r\n第一条缺点提到的运行时解析，是 `css-in-js` 方案永远跨不过去的困境，即便对于编译时 `css-in-js` 方案来说，也免不了在渲染时做额外的逻辑执行拖慢渲染速度：\r\n\r\n```js\r\nfunction App() {\r\n  return <div css={{ color: \"red\" }} />; // 就是这种代码导致了性能问题\r\n}\r\n```\r\n\r\n原因是当 React 重渲染组件时，需要重新解析样式定义，并序列化 className，当渲染非常频繁时会导致明显的性能瓶颈，而解决方法是把样式定义抽出来，但这样就损失了第三个优点，即无法读取 js 变量了：\r\n\r\n```js\r\nconst myCss = css({\r\n  backgroundColor: \"blue\",\r\n  width: 100,\r\n  height: 100,\r\n});\r\n```\r\n\r\n不得不的说 React 的渲染机制实在是太有问题了，如果换成 `SolidJS` 这个问题就好办了，因为运行时的样式代码仅会运行一次，组件重渲染也不会导致这段解析代码被重复执行，此时 `css-in-js` 在样式变化时再做一次精确样式更新，性能问题就可以被解决了。\r\n\r\n- 换成 `css modules`\r\n\r\n> `css-modules` 同时支持优点一和二，而优点三可以通过一些特定语法糖绕过：通过 :import :export 伪类做 css 变量的导入导出，用 `webpack-loader` 实现 js 中引用 css 变量，用 css variable 实现 css 引用 js 变量。\r\n> 所以当性能问题是绕不过去的话题，而 css-modules 在性能最优的情况下，有一些曲线方案可以同时支持 `css-in-js` 的优点，也就能理解为什么作者要弃用 `css-in-js` 了。\r\n\r\n- 包体积真的变大了吗\r\n\r\n> 原文谈到的 `css-in-js` 增加了 8~16kb 其实是在强行堆缺点了，除非你的项目只有一行 css 定义。如果我们只考虑传输时的包体积与 HTML 中样式定义数量，而忽略运行时产生的性能负担，那么 `css-in-js` 在大型项目无疑是最优的。\r\n> 原因就是 `css-in-js` 样式是按需插入的，没有渲染的组件就不会插入样式。甚至渲染了的组件也不一定会插入样式，因为 `css-in-js` 可以对包含相同样式定义的场景做 className 合并，类似于 webpack 打包时，可以把不同模块公共代码抽到一个 chunk 里。\r\n\r\n- 编译时 `css-in-js` 方案是出路吗\r\n\r\n> 理论上是出路，但限制了 `css-in-js` 的灵活性。从 vanilla-extract 等编译时 `css-in-js` 框架来看，确实解决了运行时 `css-in-js` 性能问题，但带来了更多语法限制，比如必须预先定义样式再使用：\r\n\r\n```jsx\r\nimport { style } from '@vanilla-extract/css'\r\n\r\nconst myStyle = style({\r\n  display: 'flex',\r\n  paddingTop: '3px'\r\n})\r\n\r\nconst App = () => <div className={myStyle}/>\r\n ```\r\n\r\n编译时 `css-in-js` 想要做到通用性，只能提供一个 className，这样就不受任何框架和环境的限制了，但这样也限制了声明语法的灵活性，显然不可以用内连方式定义样式。\r\n\r\n而且这种编译时的方案本质上和 css-modules 是一样的，背后都是定义了一些静态样式名，只是说这些样式问题以 .sass 定义还是 .ts 定义，如果用 .ts 定义，配合编译工具可以使代码原生 import 的更加舒服。\r\n\r\n所以使用了编译时 `css-in-js` 方案，本质上还是抛弃了运行时 `css-in-js`，投向了变种的 css-modules 阵营。\r\n\r\n## 总结\r\n\r\n> `css-in-js` 本身方向是对的，即把 css 与 js 融合，但太过灵活的运行时 `css-in-js` 方案遇到了几乎不可解的性能问题，编译时的 `css-in-js` 方案可能是更好的出路。\r\n\r\n> `css-in-js` 这个名字本身就表示它拥有 in js 的灵活性，而编译时 `css-in-js` 方案本质因为是 css-module，所以不可避免拥有一些比较奇怪的限制，如果 js 里的代码不能像真的 js 一样灵活，可能还不如回到 .scss 或者 .less 的后缀更好理解一些。\r\n","children":[]}]},{"name":"js垃圾回收机制.md","path":"../guanruihua.github.io/Front-End/拓展","data":"# js垃圾回收机制\n\n```mermaid\ngraph LR\nA(JS垃圾回收机制) -->B(内存泄漏理解)\nA --> C(垃圾回收机制)\nA --> D(内存泄漏识别)\n```\n\n## 内存泄漏\n\n> - 程序的运行需要内存，当程序提出要求，操作系统就会供给内存。\n> - 对于不再用到的内存，没有及时释放，就叫做内存泄漏。\n> - 对于持续运行的服务进程，必须及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。\n\n## 垃圾回收机制\n\n> JavaScript具有垃圾收集器，垃圾收集器会按照固定的时间间隔周期性的执行。\n>\n> - 最常见的垃圾回收方式有两种：标记清除, 引用计数\n\n### 标记清除\n\n> 原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。\n\n垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。\n去掉环境中的变量以及被环境中的变量引用的变量的标记。\n再被加上标记的会被视为准备删除的变量。\n垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。\n\n### 引用计数\n\n> 原理：跟踪记录每个值被引用的次数。\n\n声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。\n同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1。\n当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1。\n当引用次数变成0时，说明没办法访问这个值了。\n当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。\n（注意：当循环引用的时候就会释放不掉内存。）\n\n## 观察内存泄漏\n\n> 如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用。\n\n可以浏览器查看内存占用。\n通过命令行，命令行可以使用 Node process.memoryUsage提供的方法。process.memoryUsage返回一个对象，包含了 Node 进程的内存占用信息。（判断内存泄漏，以heapUsed字段为准。）\n四、总结\n内存没有释放或释放及时会造成内存泄漏。\n\n垃圾回收机制的常用方式是标记清除和引用计数。\n\n查看内存泄漏可以通过浏览器和命令行的方式。\n","children":[]},{"name":"前后端交互","path":"../guanruihua.github.io/Front-End/拓展","data":"","children":[{"name":"ajax.md","path":"../guanruihua.github.io/Front-End/拓展/前后端交互","data":"# ajax\n\n> - 全称`Asynchronous JavaScript and XML`\n> - 主要实现`获取促进 -> 处理数据 ->展示数据`\n\n```js\nfunction ajaxRequest () {\n  //实例化一个XMLHttpRequest对象\n  var xhr = new XMLHttpRequest();\n  //open()规定请求的类型、url、是否异步\n  xhr.open(\"GET\",\"https://www.w3cschool.cn/statics/demosource/ajax_info.txt\", true);\n  xhr.send();\n  //send()发送请求，必须结合open一起使用\n  xhr.onreadystatechange = function(){\n    //监测服务器响应的状态\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      //当 readyState 等于 4 且状态为 200 时，表示成功响应\n      document.getElementById(\"view\").innerHTML = xhr.responseText;\n    }                \n  }\n}\n```\n\n## ajax和flash的优缺点\n\n```\nAjax\n  Ajax的优势：1.可搜索性 2.开放性 3.费用 4.易用性 5.易于开发。\n  Ajax的劣势：\n    1.它可能破坏浏览器的后退功能   \n    2.使用动态页面更新使得用户难于将某个特定的状态保存到收藏夹中 ，不过这些都有相关方法解决。\n\nFlash\n  Flash的优势：1.多媒体处理 2.兼容性 3.矢量图形 4.客户端资源调度\n  Flash的劣势：\n   1.二进制格式 \n   2.格式私有 \n   3.flash 文件经常会很大，用户第一次使用的时候需要忍耐较长的等待时间  \n   4.性能问题\n```\n\n## 优缺点\n\n 优点：\n\n 1. 页面无刷新更新，用户的体验非常好；\n 2. 异步通信，响应更快\n 3. 可以将一些服务器工作转移到客户端，利用客户端资源来处理，减轻服务器和带宽的压力，节约空间和带宽租用成本；\n 4. 技术标准化，并被`浏览器广泛支持`，不需要下载插件或者小程序；\n 5. Ajax 可使因特网应用程序更小、更快、更友好。\n\n 缺点：\n\n 1. Ajax 不支持浏览器 back 返回按钮；\n 2. 有安全问题，Ajax 暴露了与服务器交互的细节；\n 3. 对搜索引擎不友好；\n 4. 破坏了程序的异常机制；\n 5. 不容易调试。\n\n## 同源策略\n\n> **一个 URL 地址可以有以下几个组成部分：**`scheme`**: //**`host`**:**`post`**/**`path`**?**`query`**#**`fragment`\n>\n> - **scheme**：通信协议，一般为 http 、https；\n> - **host**：域名；\n> - **post**：端口号，此项为可选项，http 协议默认的端口号为 80，https 协议默认的端口号为 443；\n> - **path**：路径，由 \"/ \"隔开的字符串；\n> - **query**：查询参数，此项为可选项；\n> - **fragment**：信息片段，用于指定网络资源中的某片断，此项为可选项；\n\n### 同源\n\n> - URL地址动的协议, 域名, 端口都相同, 不相同就会产生跨域\n> - 只能和同源的后端接口进行数据交互\n\n### 跨域处理\n\n> - JSONP技术\n> - 服务端代理\n> - 通过修改window.name 实现跨域\n> - 使用HTML5中新引进的window.postMessage 方法来跨域传送数据\n\n## XMLHttpRequest\n\n> - Ajax技术 核心就是 `XMLHttpRequest`类, 简称XHR, 允许脚本 `异步调用` HTTP API.\n> - 浏览器在`XMLHttpRequest` 类上定义了HTTP API , 这个类每个实例都是独立 的请求/ 响应 对象, 可指定对象上和方法允许 指定细节 和提取响应数据\n\n### 创建实例\n\n```js\nvar xhr = new XMLHttpRequest();\n// 兼容 IE7之前并不支持前者\nvar xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");\n// 兼容性写法\nvar xhr = window.XMLHttpRequest ? new window.XMLHttpRequest() : new ActiveXObject(\"Microsoft.XMLHTTP\");\n```\n\n## open()\n\n创建 XMLHttpRequest 对象之后，发起 HTTP 请求的`下一步`是调用 XMLHttpRequest 对象的`open`方法，指定 HTTP 请求的两个必需部分：**请求方法** 和 **URL**\n\n**xhr.open(method, url, async)**\n\n- **method：**\n  - 第一个参数用于指定 HTTP 请求的方法，不区分大小写；\n  - 该参数可取的值包括：\"GET\"、\"POST\"、\"HEAD\"、\"PUT\"、\"OPTIONS\"、\"DELETE\"，其中，\"GET\" 和 \"POST\" 是得到广泛支持的请求方法；\n- **url：**\n  - 第二个参数用于指定 HTTP 请求的 URL 地址，可以是 **绝对URL** 或 **相对URL**；\n  - 绝对URL：需要满足 \"同源策略\"（服务器明确允许跨域请求的情况除外）；\n  - 相对URL：即相对于文档的 URL；\n- **async：**\n  - 第三个参数是可选的，可用`布尔值`指定脚本是否以异步的方式调用此次 Ajax 请求；\n  - 该参数默认为 true，表示异步调用此次 Ajax 请求，不阻塞后续脚本的执行；\n\n**注意**：\n\n`open()`方法其实还可以有第四、第五个参数，分别是用于 HTTP 请求访问认证的`用户名和密码`，使用它们需要在服务器做相应的配置，较为少用。\n\n## setRequestHeader\n\n如果你的 HTTP 请求需要`设置请求头`，那么调用 open 方法之后的`下个步骤`就是设置它，使用的方法是：`setRequestHeader`\n\n```js\n// 在 open 方法之后设置请求头\nxhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n```\n\n**xhr.setRequestHeader(name, value)**\n\n- **name**:请求头名称；\n- **value**:请求头的值。\n\n## send()\n\n使用 XMLHttpRequest `发起 HTTP 请求`的`最后一步`是指定可选的请求主体、并向服务器发送它，使用的方法是：`send`\n\n```js\nvar xhr = new XMLHttpRequest();\nxhr.open(\"GET\", \"/statics/demosource/demo_get_json.php\");\n\n// 由于GET请求,没有请求主体，所以在调用 send 方法时可以传递 null或省略这个参数；\nxhr.send(null);\nvar xhr = new XMLHttpRequest();\nxhr.open(\"POST\", \"/statics/demosource/demo_post_json.php\");\n\n// 把 msg 作为请求主体发送\nxhr.send(msg);\n```\n\n1. POST 请求通常都拥有请求主体，可在 send 方法中指定它；\n2. POST 请求的请求主体，`应该匹配` `setRequestHeader`方法所指定的 \"Content-Type\" 头。\n\n## 获取响应\n\n> - 一个完整的 HTTP 响应由 `状态码、响应头和 响应主体` 组成，这三者都可以通过`XMLHttpRequest`对象提供的属性和方法获取。\n>\n> - 为了能够在 HTTP 响应准备就绪时得到通知，必须**监听**`XMLHttpRequest`对象上的`readystatechange`事件。但为了理解这个事件类型，需要先了解下`readyState`属性，因为该事件监听的是`readyState`属性值的改变。\n> - XMLHttpRequest`对象上的`readyState`属性在 HTTP 请求过程中，会`从 0 变到 4\n\n```html\n\n<script>\n  var oBtn = document.getElementById(\"btn\");\n  oBtn.onclick = function () {\n  //兼容处理\n  var xhr = window.XMLHttpRequest ? new window.XMLHttpRequest() : new ActiveXObject(\"Microsoft.XMLHTTP\");\n  alert(xhr.readyState);//0\n  xhr.onreadystatechange = function () {\n  alert(xhr.readyState);\n  }\n  xhr.open(\"GET\", \"/statics/demosource/demo_get_json.php\");\n  xhr.send();\n  }\n</script>\n\n```\n\n### readyState 属性\n\n `readyState`属性是一个整数，它的值代表了不同的 HTTP 请求状态。\n\n- 0：初始值，表示请求未初始化，`open`方法尚未调用；\n- 1：启动请求，open 方法已经调用，但尚未调用 send 方法；\n- 2：请求发送，已经调用 send 方法，但尚未接收到响应；\n- 3：接收响应，已经接受到`部分响应`数据，主要是响应头；\n- 4：HTTP 响应完成，已经接收到全部响应数据，而且可以在客户端使用。\n\n 每次`readyState`属性值的改变都会触发`readystatechange`事件，**但只有`readyState`属性值为 4 时才是我们所关心的状态**，因为只有这个状态才表示 HTTP 的响应准备就绪，可以真正意义上的结合服务器所响应的数据来实现我们的业务需求。\n\n### 发送请求规范\n\n```html\n<body>\n    <button id=\"btn\">点我观察 readyState 属性的改变</button>\n    <div id=\"tip\"></div>\n    \n    <script>\n        var oBtn = document.getElementById(\"btn\"),\n            oTip = document.getElementById(\"tip\");\n        oBtn.onclick = function () {\n            var xhr = window.XMLHttpRequest ? new window.XMLHttpRequest() : new ActiveXObject(\"Microsoft.XMLHTTP\");\n            xhr.onreadystatechange = function () {\n                if (xhr.readyState === 4) {\n                    oTip.innerText = \"HTTP 响应完成\";\n                }\n            };\n\n            xhr.open(\"GET\", \"/statics/demosource/demo_get_json.php\");\n            xhr.send();\n        }\n    </script>\n</body>\n```\n\n**注意**：\n\n- `readyState`的属性值只代表此时的 HTTP 请求处于哪个阶段：是发送了请求还是未发送请求，是只接收到了响应头还是响应完成；\n- \"响应完成\" 只代表 HTTP 请求结束，至于服务器的响应状态：是请求成功还是请求错误，又或者是服务器错误，需要通过 `HTTP 状态码`判断，它存储在`XMLhttpRequest`的`status`属性上；\n\n### status属性\n\n`status`属性会以数字的形式保存服务器响应的 HTTP 状态码，诸如使用最频繁的 \"200\" 表示请求成功，\"404\" 表示 URL 不能匹配服务器上的任何资源。\n\n`HTTP 状态码`是用来表示网页服务器响应状态的 `3 位`数字代码，所有状态码的第一个数字代表了响应的五种状态之一：\n\n- 1xx：临时响应\n- 2xx：成功\n- 3xx：重定向\n- 4xx：请求错误\n- 5xx：服务器错误\n\n哪些 HTTP 状态码表示我们可以获取到 HTTP 响应数据呢？\n\n**2开头的状态码** 与 **304**。2开头的状态码都表示请求成功，而 304 是对客户端可读取缓存的一种响应，同样能获取到 HTTP 的响应数据。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Tryrun 4</title>\n    <style>\n        #btn { margin-top: 7px; }\n    </style>\n</head>\n<body>\n    <div id=\"tip\"></div>\n    <button id=\"btn\">点我发起 Ajax 请求</button>\n    \n    <script>\n        var oBtn = document.getElementById(\"btn\"),\n            oTip = document.getElementById(\"tip\");\n\n        oBtn.onclick = function () {\n            var xhr = window.XMLHttpRequest ? new window.XMLHttpRequest() : new ActiveXObject(\"Microsoft.XMLHTTP\");\n\n            xhr.onreadystatechange = function () {\n                if (xhr.readyState === 4) return;\n                if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {\n                    oTip.innerText = \"HTTP 请求成功\";\n                }\n            };\n\n            xhr.open(\"GET\", \"/statics/demosource/demo_get_json.php\");\n            xhr.send();\n        }\n    </script>\n</body>\n</html>\n```\n\n### responseText 属性\n\n`responseText`属性以字符串的形式存储了响应主体，即：服务器的响应数据。\n\n无论返回的数据类型是什么，响应主体的内容都会保存在`responseText`属性中；\n\n#### 响应html\n\n```js\nvar xhr = new XMLHttpRequest();\n\nxhr.onreadystatechange = function () {\n    if (xhr.readyState !== 4) return;\n    if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {\n        // 当响应成功，获取响应数据,将数据赋值给本地\n        oView.innerHTML = xhr.responseText;\n    }\n};\n\nxhr.open(\"GET\", \"/statics/demosource/demo_get.php\");\nxhr.send();\n```\n\n响应json\n\n```js\nvar xhr = new XMLHttpRequest();\n\nxhr.onreadystatechange = function () {\n    if (xhr.readyState !== 4) return;\n    if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {\n        // 使用JSON.parse把 响应数据转换为json数据\n        var res = JSON.parse(xhr.responseText);\n        // 将响应数据中的data属性赋值给oTime做内容\n        oTime.innerText = res.data;\n    }\n};\n\nxhr.open(\"GET\", \"/statics/demosource/demo_get_json.php\");\nxhr.send();\n```\n\n### 查询 HTTP 响应头的方法\n\n在`XMLHttpRequest`对象上，可通过`getAllResponseHeaders`和`getResponseHeader`方法查询响应头信息。\n\n#### getAllResponseHeaders\n\n- `getAllResponseHeaders`方法无参数，用于一次性返回可查询的全部响应头信息\n\n```js\nvar xhr = new XMLHttpRequest();\n\nxhr.onreadystatechange = function () {\n    if (xhr.readyState !== 4) return;\n    if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {\n        // 获取所有可查询的响应头信息\n        oView.innerText = xhr.getAllResponseHeaders();\n    }\n};\n\nxhr.open(\"GET\", \"/statics/demosource/demo_get_json.php\");\nxhr.send();\n```\n\n#### getResponseHeader\n\n- `getResponseHeader`方法用于查询`单一`响应头信息，需要传入一个指定 \"头名称\" 的字符串作为参数：`getResponseHeader(headerName)`\n\n```js\nvar xhr = new XMLHttpRequest();\n\nxhr.onreadystatechange = function () {\n    if (xhr.readyState !== 4) return;\n    if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {\n        // 查询 \"Content-Type\" 响应头信息\n        alert( xhr.getResponseHeader(\"Content-Type\") );\n    }\n};\n\nxhr.open(\"GET\", \"/statics/demosource/demo_get_json.php\");\nxhr.send();\n```\n\n**注意**：\n\n由于`XMLHttpRequest`会自动处理 cookie，将 cookie 从`getAllResponseHeaders`方法返回的响应头集合中过滤掉，并且如果给`getResponseHeader`方法传递 \"Set-Cookie\" 或 \"Set-Cookie2\"，则返回 null。\n\n### 同步响应\n\n```js\nvar xhr = new XMLHttpRequest();\n\n// 指定 open 方法的第三个参数为 false\nxhr.open(\"GET\", \"/statics/demosource/demo_get_json.php\", false);\n\n// send 方法的调用将阻塞后面代码的执行，直到此次 HTTP 请求完成\nxhr.send();\n\n// 不再需要监听 readystatechange 事件\nif (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {\n    oTime.innerText = JSON.parse(xhr.response).date;\n} else {\n    // 如果请求不成功，就报错\n    throw new Error(xhr.status);\n}\n```\n\n### abort 中止请求\n\n若 HTTP 请求的时间超出预期，可以调用`XMLHttpRequest`对象上的`abort`方法来中止 HTTP 请求。\n\n```js\nvar xhr = new XMLHttpRequest();\nvar timer = null;    // 用于存储定时器标识\n\nxhr.onreadystatechange = function () {\n    if (xhr.readyState !== 4) return;\n    if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {\n        clearTimeout(timer);    // 未超时则取消定时器\n    }\n};\n\nxhr.open(\"GET\", \"/statics/demosource/demo_get_json.php\");\nxhr.send();\n\n// 2秒后中止此次 GET 请求\ntimer = setTimeout(function(){\n    xhr.abort();\n}, 2000)\n```\n\n## GET请求\n\nGET 请求一般用于信息`获取`，它`没有请求主体`，而是使用 URL 传递参数（即：传递数据给后台）。\n\n传递参数的方式：\n\n1. 对所需发送的数据（具有名称和值）执行普通的 URL 编码，即：由一对对 \"名称=值\" 组成（称为：名/值对），每一对之间用 \"&\" 拼接，如 \"name=value&name=value&...&name=value\"；\n2. 由于 名/值对 会附加在 URL 地址后面，因此在这串字符参数的最前面需要添加个 \"?\"，表示 URL 的 查询参数 开始。\n\n```html\n\n<body>\n    <div id=\"form\">\n        <label for=\"country\">国家：<input type=\"text\" name=\"country\" id=\"country\"></label>\n        <label for=\"city\">城市：<input type=\"text\" name=\"city\" id=\"city\"></label>\n    </div>\n    <hr>\n    <div>你查询的国家是：<span id=\"ipt_country\"></span></div>\n    <div>你查询的城市是：<span id=\"ipt_city\"></span></div>\n    <br>\n    <button type=\"button\" id=\"search\">查询</button>\n    （查询成功后会把你输入的值显示在上方）\n\n    <script>\n        var oSearch = document.getElementById(\"search\"),\n            oIpt_country = document.getElementById(\"ipt_country\"),\n            oIpt_city = document.getElementById(\"ipt_city\");\n\n        var url = \"/statics/demosource/demo_get_json.php\";\n\n        oSearch.onclick = function () {\n            var country = document.getElementById(\"country\").value,\n                city = document.getElementById(\"city\").value;\n\n            var query = \"country=\" + country + \"&city=\" + city;\n\n            var queryURL = url + \"?\" + query;\n\n            // 发起 get 请求\n            ajaxGet(queryURL);\n        }\n\n        function ajaxGet (url) {\n            var xhr = window.XMLHttpRequest ? new window.XMLHttpRequest() : new ActiveXObject(\"Microsoft.XMLHTTP\");\n            xhr.onreadystatechange = function () {\n                if (xhr.readyState === 4) {\n                    if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {\n                        var res = JSON.parse(xhr.responseText);\n                        oIpt_country.innerText = res.params.country;\n                        oIpt_city.innerText = res.params.city;\n                    }\n                }\n            }\n            \n            xhr.open(\"GET\", url);\n            xhr.send();\n        }\n    </script>\n</body>\n```\n\n### 缓存问题\n\n对于 GET 请求，请求的结果会被浏览器缓存，特别是在 IE 浏览器下。这时，如果 GET 请求的 URL 不变，那么请求的结果就是浏览器的缓存（也就是上次 GET 请求的结果）。\n\n**解决办法**\n\n实时改变 GET 请求的 URL，只要 URL 不同，就不会取到浏览器的缓存结果。\n\n在 URL 末尾`添加时间戳参数`。由于时间戳可以精确到毫秒，从而保证了每次发起 GET 请求的时间不同，达到实时改变请求 URL 的目的。\n\n```js\nvar url = \"/statics/demosource/demo_get_json.php\";\n\n// 在请求参数的最后附加时间戳参数 t\nvar query = \"user=\" + user + \"&pwd=\" + pwd + \"&t=\" + new Date().getTime();\n\nvar queryURL = url + \"?\" + query;\n// ajax_get为自己封装的请求对象，不是固定用法\najax_get(queryURL);\n```\n\n### 封装 GET 异步请求函数\n\n步骤：\n\n- 实例化一个`XMLHttpRequest`对象，如果你正在使用 IE7 以下版本的浏览器，应该对它做兼容处理；\n- 对`data`数据执行普通的 URL 编码，也可以使用预置代码中提供的`urlencodeData`工具函数完成这步操作；\n- 调用`open()`方法，指定请求方式、请求地址、是否异步，注意请求地址需要是`url`与请求参数拼接的结果；\n- 调用`send()`方法；\n- 给`XMLHttpRequest`实例添加`readystatechange`事件处理程序：\n  - 最好在`open()`方法调用之前实现`readystatechange`事件，比较严谨；\n  - 在事件处理程序中判断 HTTP 请求状态，只有请求状态为 \"完成\" 时，才能保证响应内容完整；\n- 根据 HTTP 状态码（即`status`属性值），执行对应的回调函数：\n- HTTP 状态码在 200 与 300 之间（不包括300）、或为 304 都表示成功：使用`JSON.parse()`方法将`responseText`属性值解析为 JavaScript 对象，并作为`success`函数的实参传出；\n\n- HTTP 状态码为其它值则表示请求失败：调用`error`函数，并将失败的 HTTP 状态码作为实参传出；\n\n- 在运行结果区封装的 `ajaxPost`,能否正常响应，常见的错误有：\n  - 成功请求的测试出现 403：GET 请求的 URL 地址不正确，可以检查一下是否在`url`与 请求参数之间拼接了 \"?\"。\n\n```html\n\n    <script>\n        function ajaxGet (url, data, success, error) {\n            // 在下方开始你的代码\n            var xhr = window.XMLHttpRequest ? new     window.XMLHttpRequest():new ActiveXObject('Microsoft.XMLHTTP');\n            data = urlencodeData (data)\n            console.log(data);\n            xhr.onreadystatechange = function(){\n                if(xhr.readyState !== 4) return;\n                if(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304){\n                    console.log(xhr.status);\n                    var res = JSON.parse(xhr.responseText)\n                        success(res);\n                }else{\n                    var res = JSON.parse(xhr.responseText)\n                    console.log(res);\n                    error(res);\n                }\n               \n                    \n            };\n            url = url + '?' + data;\n            xhr.open('GET',url,true);\n            xhr.send(null);\n            }\n         \n    </script>\n    \n    \n    <!-- 工具函数 -->\n    <script>\n        // 用于对 JavaScript 对象执行普通的 URL 编码\n        // 编码后的格式为：\"名称=值&...&名称=值\"\n        function urlencodeData (data) {\n            if (!data) return;\n            var pairs = [];\n            for (var name in data) {\n                if (!data.hasOwnProperty(name)) continue;\n                if (typeof data[name] === \"function\") continue;\n                var value = (data[name] === null || data[name] === undefined) ? \"\" : data[name].toString();\n                pairs.push(encodeURIComponent(name) + \"=\" + encodeURIComponent(value));\n            }\n            return pairs.join(\"&\");\n        }\n    </script>\n    \n    <!-- 以下均是测试代码 -->\n    <!-- 测试代码的 css 部分 -->\n    <style>\n        #request { text-align: center; }\n        .request-result { padding: 12px; border: 1px solid #e8e8e8;    border-radius: 2px; box-shadow: 0 1px 3px 1px #d9dfe9; }\n        .request-btn { margin-top: 12px; padding: 7px; color: #fff;    border-radius: 7px; transition: all .2s; cursor: pointer; }\n        .request-success { background-color: #1890ff; }\n        .request-success:hover { background-color: #40a9ff; }\n        .request-error { background-color: #d9363e; }\n        .request-error:hover { background-color: #ff7875; }\n    </style>\n</head>\n<body>\n    <!-- 测试代码的 html 部分 -->\n    <div id=\"request\">\n        <div class=\"request-result\">\n            <div class=\"res-tip\">测试下你封装的异步 GET 请求能不能正常响</div>\n            <div class=\"res-param\"></div>\n        </div>\n        <div class=\"request-btn request-success\">成功请求的测试</div>\n        <div class=\"request-btn request-error\">失败请求的测试</div>\n    </div>\n    \n    <!-- 测试代码的 js 部分 -->\n    <script>\n        var oDivs = document.getElementsByTagName(\"div\");\n        var oResult_tip = oDivs[2],\n            oResult_param = oDivs[3],\n            oSuccess = oDivs[4],\n            oError = oDivs[5];\n            \n        var url = \"/statics/demosource/demo_get_json.php\",\n            badUrl = \"/statics/demosource/404.txt\";\n        var data = {\n                aa:null,\n                from: \"南昌\",\n                to: \"厦门\",\n                time: \"今天\"\n            };\n        var success = function (res) {\n            oResult_tip.innerText = \"请求成功\";\n            oResult_param.innerHTML = \"<div><span>起点：</span><span>\" + res.params.from + \"</span></div><div><span>终点：</span><span>\" + res.params.to + \"</span></div><div><span>时间：</span><span>\" + res.params.time + \"</span></div>\";\n        };\n        var error = function (res) {\n            oResult_tip.innerText = \"请求失败：\" + res;\n            oResult_param.innerHTML = \"\";\n        };\n        \n        oSuccess.onclick = function () {\n            ajaxGet(url, data, success, error);\n        };\n        \n        oError.onclick = function () {\n            ajaxGet(badUrl, data, success, error);\n        }\n    </script>\n</body>\n```\n\n## POST请求\n\nPOST 请求一般用于修改服务器上的资源，它需要发送一个请求主体，客户端传递给服务器的数据就包含在这个请求主体中。\n\n`\"Content-Type\"`请求头用于设置请求主体的编码格式。\n\n### 表单编码的 POST 请求\n\nPOST 请求使用 **表单编码** 的方式来发送数据的关键步骤：\n\n1. 对所需发送的数据（具有名称和值）执行普通的 URL 编码，即：像 GET 请求那样拼接为 名/值 对的形式；\n2. 将`\"Content-Type\"`请求头的值设置为`\"application/x-www-form-urlencoded\"`。\n\n```js\n// 获取用户输入的表单数据\nvar country = document.getElementById(\"country\").value,\n    city = document.getElementById(\"city\").value;\n\n// 将数据拼接为 名/值对 的形式\nvar query = \"country=\" + country + \"&city=\" + city;\n\nvar xhr = new XMLHttpRequest();\nxhr.onreadystatechange = function () {\n    // ... ... 省略事件处理程序\n}\n\n// 指定 POST 请求\nxhr.open(\"POST\", \"/statics/demosource/demo_post_json.php\");\n\n// 设置请求主体的编码方法\nxhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n// 发送请求主体（数据）\nxhr.send(query);\n\n```\n\n### JSON 编码的 POST 请求\n\nJSON 是一种轻量级的前后端`数据交换格式`，直接使用`JSON.stringify`原生 API 即可实现 JSON 编码，比表单编码的方式更加快捷。\n\nPOST 请求使用 **JSON编码** 的方式来发送数据的关键步骤：\n\n1. `\"Content-Type\"`请求头的值需要为`\"application/json\"`；\n2. 对请求主体进行序列化，在 JavaScript 中可使用`JSON.stringify`完成这步操作。\n\n```js\n// 获取用户输入的表单数据\nvar country = document.getElementById(\"country\").value,\n    city = document.getElementById(\"city\").value;\n\n// 将数据转换为 JavaScript 对象\nvar data = {\n    country : country,\n    city : city\n}\n\nvar xhr = new XMLHttpRequest();\nxhr.onreadystatechange = function () {\n    // ... ... 省略事件处理程序\n}\n\n// 指定 POST 请求\nxhr.open(\"PO ST\", \"/statics/demosource/demo_json_data.php\");\n\n// 设置请求主体的编码方法\nxhr.setRequestHeader(\"Content-Type\", \"application/json\");\n\n// 编码请求主体并发送\nxhr.send(JSON.stringify(data));\n\n```\n\n## 两种方式的比较\n\n**GET 请求：**\n\n1. 一般用于信息`获取`：通过发送一个请求来取得服务器上的资源；\n2. 数据包含在 URL 地址中；\n3. 数据量受 URL 的长度限制；\n4. 不安全：浏览器的 URL `可见`到，明文传输；\n5. GET 请求`会被缓存`；\n6. GET 没有请求主体，请求速度相对较快。\n\n**POST 请求：**\n\n1. 一般用于`修改`服务器上的资源：向指定资源提交数据，后端处理请求后往往会导致服务器 建立新的资源 或 修改已有资源；\n2. 数据包含在请求主体中；\n3. 没有数据量限制，可在服务器的配置里进行限制；\n4. 只能是比 GET `安全`，实际上也是不安全的：可通过开发者工具或者抓包看到，明文传输；\n5. POST 请求`不会缓存`；\n6. POST 相对稳定、可靠：可发送包含未知字符的内容。\n\n**容易产生的误区**：HTTP 协议里并没有限制 GET 和 POST 的长度，GET 的最大长度限制是因为浏览器和 Web 服务器对 URL 的长度限制，不同的浏览器和 Web 服务器限制的最大长度不一样，它们所限制的是整个 URL 的长度，而不仅仅是查询参数的数据长度。\n\n## Ajax扩展\n\n### jQuery 中的 Ajax\n\njQuery 是一个 JavaScript 工具库，它封装了 JavaScript 常用的功能代码，包括我们刚刚学完的 Ajax。\n\n**jQuery 中，Ajax 常见的请求方式有以下几种：**\n\n- `$.ajax(url, options)`\n- `$.get(url, data, callback, dataType)`\n- `$.post(url, data, callback, dataType)`\n- `$.getJSON(url, data, callback)`\n- `$.getScript(url, callback)`\n- jQuery元素`.load(url, data, callback)`\n\n```js\n// 使用jQuery发起ajax请求\n$.ajax(\"/statics/demosource/demo_get_json.php\", {\n    //请求类型\n    type: \"GET\",\n    //要发送的数据\n    data: {\n        country: country,\n        city: city\n    },\n    //数据格式\n    dataType: \"json\",\n    //请求成功后执行\n    success: function (res) {    // res为响应成功返回的数据\n        oIpt_country.innerText = res.params.country;\n        oIpt_city.innerText = res.params.city;\n    },\n    //请求失败后执行\n    error: function (res) {    // 这里的res为响应失败返回的数据\n        alert(\"请求失败：\" + res.status);\n    }\n});\n```\n\n### Ajax 的替代品：fetch\n\nFetch API 是随 ES6 发展而出现的一个 JavaScript 原生接口，与 Ajax 一样允许开发者异步发起 HTTP 请求，但却以更加简单明了的调用方式、基于 Promise 的数据处理方式被称作是 Ajax 的替代品。\n\n```js\nfetch(\"/statics/demosource/demo_json_data.php\", {\n    method: \"POST\",\n    header: new Headers({\"Content-Type\" : \"application/json\"}),\n    body: JSON.stringify(data)\n})\n.then(function (res) {\n    return res.ok ? res.json() : Promise.reject(res);\n})\n.then(function (data) {\n    oIpt_country.innerText = data.country;\n    oIpt_city.innerText = data.city;\n})\n.catch(function (res) {\n    alert(\"请求失败：\" + res.status);\n})\n```\n\n## JSON\n\nJSON = JavaScript Object Notation，意思是：JavaScript 对象表示法，是一种轻量级的`数据交换格式`。\n\n### 语法规则\n\nJSON 的语法可以表示以下三种类型的值：\n\n- **简单值**：使用与 JavaScript 相同的语法，可以在 JSON 中表示`number`、`string`、`boolean` 与 `null`，但 JSON 不支持 JavaScript 中的特殊值`undefined`；\n- **对象**：对象作为一种复杂数据类型， 表示的是一组无序的键值对，而每个键值对中的值可以是简单值，也可以是复杂数据类型的值；\n- **数组**：数组也是一种复杂数据类型，表示一组有序的值的列表，数组的值也可以是任意类型 —— 简单值、对象 或 数组。\n\n### 简单值\n\n```js\n//JSON 表示数值 7\n7\n//JSON 表示字符串\n\"JSON is a format for data exchange\"\n```\n\n**注意**：\n\nJSON字符串 与 JavaScript字符串 的最大区别在于，JSON 字符串必须使用 **双引号**，单引号会导致语法错误。\n\n### 对象\n\nJSON 中的对象与 JavaScript 对象字面量稍微有一些不同。\n\nJavaScript 的对象字面量：\n\n```js\n{\n    name : \"Alan\",\n    age : 21\n}\n```\n\njson表示\n\n```js\n{\n    \"name\" : \"Alax\",\n    \"age\" : 21\n}\n```\n\nJSON 对象的键（属性名） **必须** 加 **双引号**。\n\nJSON 对象的属性值可以是简单值，也可以是复杂类型值\n\n```js\n{\n    \"name\" : \"Alan\",\n    \"age\" : 21,\n    \"child\" : {\n        \"name\" : \"Tim\",\n        \"age\" : 7    \n    }\n}\n```\n\n### 数组\n\nJSON 数组采用的就是 JavaScript 中的数组字面量形式。\n\nJavaScript 中的数组字面量：\n\n```js\n[21, \"Alan\", false]\n```\n\njson表示\n\n```js\n[21, \"Alan\", false]\n```\n\n### **总结**\n\n1. 对于 JSON 与 JavaScript 的关系，你现在可以这么理解：JSON 是 JavaScript 对象的字符串表示法，它使用纯文本格式来表示一个 JavaScript 对象的信息，本质上是一个字符串；\n2. 通常，我们会将对象和数组作为 JSON 数据结构的最外层形式，利用它们能够创造出各种各样的数据结构。当然，这不是强制规定的。\n\n## JavaScript 内置的 JSON 对象\n\nECMAScript 5 定义了一个原生的 JSON 对象，可把 JavaScript 对象序列化为 JSON 字符串，或把 JSON 字符串解析为原生的 JavaScript 值。\n\n**JSON 对象的方法：**\n\n1. `JSON.stringify()`：用于序列化 JavaScript 对象，将其转换为 JSON 字符串；\n2. `JSON.parse()`：用于解析 JSON 字符串，将其转换为 JavaScript 值。\n\n**提示**：除了以上两个方法，JSON 对象本身并没有其它作用，也不能被做为构造函数使用。\n\n### stringify 方法\n\n`JSON.stringify()`方法用于将一个 JavaScript 值 / 对象 转换为 JSON 字符串。\n\n```js\nvar obj = {\n    name: \"Alan\",\n    age: 21,\n    child: {\n        name: \"Tim\",\n        age: 7\n    }\n};\n\n// 序列化 obj 对象，转换为 JSON 格式的字符串\nvar json = JSON.stringify(obj)\n```\n\n### parse 方法\n\n`JSON.parse()`方法用于将 JSON 数据解析为原生的 JavaScript 值。\n\n```js\nvar json = '{\"name\":\"Alan\",\"age\":21,\"child\":{\"name\":\"Tim\",\"age\":7}}';\n\n// json 数据本质上是字符串，无法直接访问某一属性\nconsole.log(json.name);    // undefined\n\n// 解析 json，转换为原生的 JavaScript 对象\nvar obj = JSON.parse(json);\nconsole.log(obj.name);    // 此时可以使用 JavaScript 方法访问某一属性\n```\n","children":[]},{"name":"axios.md","path":"../guanruihua.github.io/Front-End/拓展/前后端交互","data":"# axios\n\n> 相关: `axios-jsonp`, `axios-retry`\n> [axios中文文档|axios中文网 | axios (axios-js.com)](http://www.axios-js.com/zh-cn/docs/)\n\n## 配置header\n\naxios 使用 post 发送数据时，默认是直接把 json 放到请求体中提交到后端的。也就是说，我们的 Content-Type 变成了 application/json;charset=utf-8 ,这是axios默认的请求头content-type类型。但是实际我们后端要求的 'Content-Type': 'application/x-www-form-urlencoded' 为多见，这就与我们不符合。所以很多同学会在这里犯错误，导致请求数据获取不到。明明自己的请求地址和参数都对了却得不到数据。\n\n我们现在来说说post请求常见的数据格式（content-type）\n\n1. Content-Type: application/json ： 请求体中的数据会以json字符串的形式发送到后端\n2. Content-Type: application/x-www-form-urlencoded：请求体中的数据会以普通表单形式（键值对）发送到后端\n3. Content-Type: multipart/form-data： 它会将请求体的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。\n\n### application/x-www-form-urlencoded配置\n\n#### a.【用 URLSearchParams 传递参数】代码简单，省事。 需要注意的是： URLSearchParams 不支持所有的浏览器，但是总体的支持情况还是 OK 的\n\n```js\nlet param = new URLSearchParams()\nparam.append('username', 'admin')\nparam.append('pwd', 'admin')\naxios({\n    method: 'post',\n    url: '/api/lockServer/search',\n    data: param\n})\n```\n\n#### b. 配置axios请求头中的content-type为指定类型\n\n`axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';` 或者\n\n```js\n{ headers:{'Content-Type':'application/x-www-form-urlencoded'} }\n```\n\n将参数转换为query参数, 利用qs，引入 qs ，这个库是 axios 里面包含的，不需要再下载了。\n\n```js\nimport Qs from 'qs'\nlet data = {\n    \"username\": \"cc\",\n    \"psd\": \"123456\"\n}\n\naxios({\n    headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n    },\n    method: 'post',\n    url: '/api/lockServer/search',\n    data: Qs.stringify(data)\n})\n```\n\n## **Content-Type: multipart/form-data**\n\n```js\n let params = new FormData()\n params.append('file', this.file)\n params.append('id', localStorage.getItem('userID'))\n params.append('userName', this.name)\n params.append('sex', this.sex)\n params.append('mobile', this.phone)\n params.append('email', this.email)\n params.append('qq', this.qq)\n params.append('weChat', this.WeChat)\n\naxios.post(URL, params, {headers: {'Content-Type': 'multipart/form-data'}}).then(res => {\n  if (res.data.code === 0) {\n  this.$router.go(-1)\n  }\n  }).catch(error => {\n  alert('更新用户数据失败' + error)\n})\n```\n\n## **Content-Type: application/json**\n\n> axios默认的请求数据类型，我们只需将参数序列化json字符串进行传递即可，无需多余的配置。\n\n## axios-retry\n\n> 让axios支持重试\n\n```ts\nimport Axios, { AxiosRequestConfig } from 'axios'\nimport axiosRetry from 'axios-retry'\n\nconst client = Axios.create({\n  // 你的配置\n})\n\n// 安装 retry 插件\n// 当请求失败后，自动重新请求，只有3次失败后才真正失败\naxiosRetry(client, { retries: 3 })\n\nexport async function request(url: string, config?: AxiosRequestConfig) {\n  const response = await client.request({ url, ...config })\n  const result = response.data\n  // 你的业务判断逻辑\n  return result\n}\n\n// 只有3次失败后才真正失败\nconst data = request('http://example.com/test')\n\n```\n\n## axios-jsonp\n\n> 支持jsonp的功能\n\n```ts\nimport Axios, { AxiosRequestConfig } from 'axios'\nimport jsonpAdapter from 'axios-jsonp'\n\nconst client = Axios.create({\n  // 你的配置\n})\n\nexport async function request(url: string, config?: AxiosRequestConfig) {\n  const response = await client.request({ url, ...config })\n  const result = response.data\n  // 你的业务判断逻辑\n  return result\n}\n\nexport function jsonp(url: string, config?: AxiosRequestConfig) {\n  return request(url, { ...config, adapter: jsonpAdapter })\n}\n\n// 你现在可以发送 jsonp 的请求了\nconst data = jsonp('http://example.com/test-jsonp')\n\n```\n","children":[]},{"name":"fetch.md","path":"../guanruihua.github.io/Front-End/拓展/前后端交互","data":"# fetch\n\n> Fetch 的核心在于对HTTP接口的抽象\n\n## fetch() 方法的使用\n\n> `fetch(input ?: Requset | string, init ?: RequestInit ): Promise<Response>`\n\n```js\nfetch(url, option).then(function(response){\n  // 处理 HTTP 响应\n}, function(error){\n // 处理网络错误\n})\n```\n\n## fetch() 参数\n\n> `fetch(input ?: Requset | string, init ?: RequestInit ): Promise<Response>`\n>\n> - input 参数 : 字符串, | 包含获取资源的URL | 一个Request 对象\n> - option : (可选) , 一个配置对象\n>   - method: 请求方式 [GET, POST]\n>   - headers: 请求的头信息, 包含与请求关联的Headers对象\n>   - body : 请求的body信息,  [ 注意: GET 或 HEAD 方法的请求不得包含body信息 ]\n>   - mode : 请求模式 , cors, no-cors 或 same-origin\n>   - credentials: 请求 的credentidials, 如omit, same-origin 或 include [ 为了在当前域名内自动发送cookie, 必须提供这个选项 ]\n\n## 常用Fetch请求\n\n### html\n\n```js\nfetch('/index/fetchHtml')\n .then(res => {\n return res.text()\n}).then( result => {\n  document.body.innerHTML += result\n}).catch( err => {\n  // errs\n})\n```\n\n### JSON\n\n```js\nfetch('/api/user/a')\n .then( res => return res.josn())\n .then( json => console.log(json))\n .catch( err => {\n    // err\n  })\n```\n\n### POST Form\n\n```js\nfunction postForm(){\n  const form = document.querySelector('form')\n  const name = encodeURL(document.getElementByName('name')[0].value)\n  fetch(`/api/user/${name}`,{\n    method: 'POST',\n    body: new FormData(form)\n })\n}\n```\n\n### POST JSON\n\n```js\nfetch('/api/user/a', {\n  method: 'POST',\n  header: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    name: 'a',\n    age: 23,\n  })\n})\n```\n\n## fetch中止\n\n> fetch自身没有提供中止请求的话方法, 但是大部分浏览器有实现AbortController, 可以通过AbortController中止fetch请求\n\n```js\nconst controller = new AbortController();\nconst signal = controller.signal;\nsetTimeout(() => controller.abort(), 5000);\n\n\nfetch('/api/user/CaiCai', {\n  signal, // 在option中加入signal\n  method: 'POST',\n  // credentials:'include',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    name: 'CaiCai',\n    age: '26',\n  })\n}).then((res) => {\n  return res.json()\n}).then((result) => {\n  console.log(result)\n}).catch((err) => {\n  console.log(err)\n})\n```\n\n## 兼容性\n\n![Snipaste_2020-12-14_16-00-39](https://gitee.com/grh-gitee/picgo/raw/master/Snipaste_2020-12-14_16-00-39.png)\n\n## 缺点\n\n1. fetch不支持jsonp, 使用到该功能需要单独实现JSONP\n2. fetch自身没有abort的方法, 需要AbortController去处理中止, AbortController兼容性也不是很好\n3. fetch兼容性不是很好, 不支持的浏览器可以使用`fetch polyfill`\n","children":[]},{"name":"文件交互","path":"../guanruihua.github.io/Front-End/拓展/前后端交互","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Front-End/拓展/前后端交互/文件交互","data":"# 文件交互\n\n> [(31条消息) js实现通过url下载文本/图片/视频且不跳转新页面_zhangx-CSDN博客](https://blog.csdn.net/kezanxie3494/article/details/104433087)\n>\n> [(36条消息) 前端实现文件下载功能的三种方式_hfhwfw161226的博客-CSDN博客](https://blog.csdn.net/hfhwfw161226/article/details/105700504)\n>\n> [文件上传，搞懂这8种场景就够了](https://juejin.cn/post/6980142557066067982)\n","children":[]}]}]},{"name":"加密","path":"../guanruihua.github.io/Front-End/拓展","data":"","children":[{"name":"base64.md","path":"../guanruihua.github.io/Front-End/拓展/加密","data":"# base64\n\n> Base64 编码普遍应用于需要通过被设计为处理文本数据的媒介上储存和传输二进制数据而需要编码该二进制数据的场景。这样是为了保证数据的完整并且不用在传输过程中修改这些数据。Base64也被一些应用（包括使用MIME的电子邮件）和在XML中储存复杂的数据时使用。\n>\n> 由于 BASE64 是一种非常常用的编码方案，在开发中经常会使用到，所以当前浏览器标准 API（atob、btoa） 都支持进行 BASE64 操作，遗憾的是上面提到的标准 API 仅支持 ASCII 字符。所以使用范围受限。\n>\n> [(79条消息) img标签 轻松显示 base64格式的图片_Teheran的博客-CSDN博客](https://blog.csdn.net/Teheran/article/details/84569991)\n>\n> [(79条消息) 使用 JavaScript 进行 Base64 编码与解码_FKNIGHT 的博客-CSDN博客](https://blog.csdn.net/gulang03/article/details/88854858)\n>\n> [用JS进行Base64编码、解码 - 简书 (jianshu.com)](https://www.jianshu.com/p/14437764eff3)\n>\n> [浅析data:image/png;base64的应用 - Angel_Kitty - 博客园 (cnblogs.com)](https://www.cnblogs.com/ECJTUACM-873284962/p/9245474.html)\n","children":[]}]},{"name":"性能指标","path":"../guanruihua.github.io/Front-End/拓展","data":"","children":[{"name":"指标.md","path":"../guanruihua.github.io/Front-End/拓展/性能指标","data":"# [性能指标](https://web.dev/learn-core-web-vitals/)\r\n\r\n| 指标名称| 全称 | 描述 |\r\n|:----|:----|:----|\r\n| `FP` | First Paint | 浏览器第一次绘制时间，第一个像素时间 |\r\n| `TTI` | Time To Interactive | 页面渲染完毕，可以响应用户输入的时间 |\r\n| `FID` | First Input Delay | 用户与页面输入框等控件第一次可交互的时间 |\r\n| `LCP` | Largest Contentful Paint | 最大内容绘制时间 |\r\n| `FMP` | First Meaningful Paint | 首次有意义的绘制，页面主要内容出现在屏幕的时间 |\r\n| `FCP` | First Contentful Paint | 浏览器第一次屏幕绘制内容时间 |\r\n| `CLS` | Cumulative Layout Shift | 累计布局版式位移，页面抖动，屏闪 |\r\n","children":[]}]},{"name":"时区","path":"../guanruihua.github.io/Front-End/拓展","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Front-End/拓展/时区","data":"# 时区\n\n> 注意`Date()`的默认时区问题, 我这里采用统一指定为格林威治时间, 然后通过偏移量来转换\n\n## 基本使用\n\n### `Date`支持的格式\n\n```js\n new Date('4-21-2019 21:00:00 EST'),\n  new Date(\"2019/04/21 21:00:00 EDT\"),\n  new Date(\"2019/04/21 9:00 PM EDT\"),\n  new Date('4/21/2019 9:00 PM EST'),\n  new Date('2019-04-21T21:00:00'),\n  new Date(\"Apr 21, 2019 9:00:00\"),\n  new Date(\"April 21, 2019 9:00:00\"),\n  new Date(95, 3, 21), //两位数年份表示 1900 - 1999 年,\n  new Date(),\n  new Date(1453094034000),\n  new Date('Tue Apr 02 2019 16:39:08'),\n  new Date(2019, 3, 2, 16, 37, 22),\n  new Date(\"2019-04-21 21:00:00 EDT\"),\n  new Date(\"2019-04-21 21:00:00 EDT\").toUTCString(),\n```\n\n## momnent\n\n> [文档 | Moment.js 中文网 (momentjs.cn)](http://momentjs.cn/docs/#/parsing/now/)\n>\n> [Moment Timezone | Home (momentjs.com)](https://momentjs.com/timezone/)\n\n### Install & Use\n\n```shell\n// Install \nbower install moment-timezone --save # bower\nnpm install moment-timezone --save   # npm\nyarn add moment-timezone             # Yarn\n\n// Use\n<script src=\"moment.js\"></script>\n<script src=\"moment-timezone-with-data.js\"></script>\nlet moment = require('moment-timezone');\n```\n\n### Webpack\n\n```js\n// webpack.config.js\nconst MomentTimezoneDataPlugin = require('moment-timezone-data-webpack-plugin');\nconst currentYear = new Date().getFullYear();\n\nmodule.exports = {\n    plugins: [\n        // To include only specific zones, use the matchZones option\n        new MomentTimezoneDataPlugin({\n            matchZones: /^America/\n        }),\n\n        // To keep all zones but limit data to specific years, use the year range options\n        new MomentTimezoneDataPlugin({\n            startYear: currentYear - 5,\n            endYear: currentYear + 5,\n        }),\n    ],\n};\n```\n\n### 常用方法\n\n> 常用方法 :\n>\n> 1. `moment([待转换的时间]).tz([指定时区]).format([时间格式])`\n> 2. `moment.tz([待转换的时间],([指定时区]).format([时间格式])`\n>\n> 注意点:\n>\n> 1. `待转换的时间`: 注意格式, 不是全部时间格式都支持的\n> 2. `指定时区`: 注意和其他语言支持的指定时区格式不完全支持\n> 3. `时间格式`:\n>    1. `z`:  时区\n\n```js\nsessionStorage.setItem(\"sysTimeZoneOffset\", \"28800000\");// 服务器时区\nsessionStorage.setItem(\"refTimeZoneOffset\", \"28800000\");// 指定的时区\n\n// 将时间 强行指定为格林威治时间, 然后再转换为时间戳\nconst f_formatToTimeStamp = (time) => {\n if (time.match(/^\\d{4}(-|\\s)\\d{1,2}(-|\\s)\\d{1,2}(\\s)\\d{1,2}:\\d{1,2}/g)) {\n  time += \" GMT\";\n } else if (time.match(/^\\d{4}(-|\\s)\\d{1,2}(-|\\s)\\d{1,2}$/g)) {\n  time += \" 00:00:00 GMT\"\n } else if (time.match(/^\\d{8}$/g)) {\n  let temp = time.split(\"\");\n  temp.splice(4, 0, \"-\");\n  temp.splice(7, 0, \"-\");\n  time = temp.join(\"\") + \" 00:00:00 GMT\";\n } else if (time.match(/^\\d{14}$/g)) {\n  let temp = time.split(\"\");\n  temp.splice(4, 0, \"-\");\n  temp.splice(7, 0, \"-\");\n  temp.splice(10, 0, \" \");\n  temp.splice(13, 0, \":\");\n  temp.splice(16, 0, \":\");\n  time = temp.join(\"\") + \" GMT\";\n } else if (time.match(/^\\d{1,2}-\\d{1,2}-\\d{4}$/g)) {\n  time = time.split(\"-\").reverse().join(\"-\") + \" 00:00:00 GMT\";\n } else if (time.match(/^\\d{10,}$/g)) {\n  return String(time * 1000).split(\"\").map((item, index) => index < 13 && item).filter(i => i !== false).join(\"\");\n }\n return Date.parse(String(time))\n}\n\n// 通过偏移量来指定转换前后的时区\nfunction f_Timezone(time = \"\", offset) {\n let timeStamp = f_formatToTimeStamp(String(time)) // 时间戳 string\n offset = offset || Number(sessionStorage.getItem('refTimeZoneOffset')) - Number(sessionStorage.getItem('sysTimeZoneOffset')) || 0;\n return momentz(Number(timeStamp) + Number(offset)).tz(\"GMT\")\n}\n\nfunction f_TimezoneFormat(time = \"\", offset, format = \"YYYY-MM-DD HH:mm:ss\") {\n return f_Timezone(time, offset).format(format);\n}\n\nfunction f_gmtTime(time) {\n return Number(f_formatToTimeStamp(String(time))) + Number(new Date().getTimezoneOffset()) * 60 * 1000;\n}\n```\n\n## [时区缩写](https://www.cnblogs.com/tracy/archive/2010/07/16/1778566.html)\n\n```tex\nEST: 美国东部标准时间 ，GMT-5\nEDT: 美国东部夏令时时间 ，GMT-4\nCST：美国中部标准时间，GMT-6\nCDT：美国中部夏令时时间，GMT-5\nPST: （美国）太平洋标准时间，GMT-8\nPDT:（美国）太平洋夏令时时间，GMT-7\nGMT: 格林威治标准时间，即UTC时间\nCCT：北京时间（中国沿海时间），GMT+8\n```\n","children":[]}]},{"name":"特殊备注.md","path":"../guanruihua.github.io/Front-End/拓展","data":"# 特殊备注\r\n\r\n- 浏览的时候看见源码里居然手动写`/*#__PURE__*/`，一般这个是没人写，倒是经过polyfill转换之后，很多代码会自然带上这个标记\r\n- 既然这玩意开始有点用处，就稍微总结一下。其实除了这个标记，还有 `inline` , `noinline` 之类的注释，这个就是给`terser`使用的\r\n\r\n## terser\r\n\r\n- 我们知道terser是个很强大的压缩工具，而为啥react没写pure呢，因为react使用的是`googleclosure`压缩工具，是个自己整的java压缩工具，跟一般的压缩方式并不相同，是一种破坏性压缩，在书写代码时需要注意某种规定，否则压缩出来的代码无法正常运行。但terser的压缩是非破坏性的，所以压缩效果上自然比google那个差点，但不容易出问题（反正vue代码比react代码少太多了）\r\n\r\n- 其中terser认可的行内注释一般有3种：\r\n  - `/*@__INLINE__*/` - forces a function to be inlined somewhere.\r\n  - `/*@__NOINLINE__*/` - Makes sure the called function is not inlined into the call site.\r\n  - `/*@__PURE__*/` - Marks a function call as pure. That means, it can safely be dropped.\r\n\r\n- 可以把@换成#。\r\n- `inline`表示内联，会强制把标记的函数里依赖的函数内敛在里面\r\n- 而`noinline`则相反，不会把函数拆成内容内联进函数体内\r\n- 最后的`pure`则是用的最多的。会告诉编辑器，如果没用到这玩意，可以放心删了\r\n","children":[]},{"name":"编码规范","path":"../guanruihua.github.io/Front-End/拓展","data":"","children":[{"name":"代码规范.md","path":"../guanruihua.github.io/Front-End/拓展/编码规范","data":"# [`代码规范`]()\r\n\r\n[2021最新阿里代码规范（前端篇）](https://developer.aliyun.com/article/850913)\r\n[腾讯前端规范](https://tgideas.qq.com/doc/index.html)\r\n[京东前端规范](https://guide.aotu.io/index.html)\r\n[百度前端规范](https://github.com/ecomfe/spec/blob/master/javascript-style-guide.md)\r\n","children":[]},{"name":"方法.md","path":"../guanruihua.github.io/Front-End/拓展/编码规范","data":"# 方法\r\n\r\n|       | 描述                         |\r\n| :---- | :--------------------------- |\r\n| `to*` | 非破坏性修改, 不修改原有数据 |\r\n","children":[]}]},{"name":"跨域","path":"../guanruihua.github.io/Front-End/拓展","data":"","children":[{"name":"jsonp.md","path":"../guanruihua.github.io/Front-End/拓展/跨域","data":"# JOSNP\n\n> 名称: `JSON with Padding`\n>\n> 同源策略解决的问题:  跨域\n>\n> 简述: 非官方的协议, 它允许在服务器集成`script`返回客户端, 通过``javascirpt callback `的形式实现跨域访问\n>\n> 同源策略:\n>\n> - 同源是指, 域名, 协议, 端口相同\n> - 当一个浏览器打开两个`tab`页,  分别打开两个页面, 当一个页面执行脚本, 只有检查是否同源才会被执行\n\n## 原理\n\n> 通过`<script>`标签并不会被同源策略所束缚, 所以可以获取任何服务器上脚本并执行.\n>\n> JSONP实现模式  `javascript CallBack`   的形式.\n","children":[]}]}]},{"name":"框架","path":"../guanruihua.github.io/Front-End","data":"","children":[{"name":"vue","path":"../guanruihua.github.io/Front-End/框架","data":"","children":[{"name":"begin.md","path":"../guanruihua.github.io/Front-End/框架/vue","data":"# 创建项目\n\n## vue2\n\n> 1. 安装vue脚手架: `npm install -g @vue/cli`[ 最新版 ]\n> 2. 创建项目`vue create hello-world`\n> 3. 根据需要选择对应的依赖\n> 4. `cd hello-world`\n> 5. `npm run serve`\n\n","children":[]},{"name":"element.md","path":"../guanruihua.github.io/Front-End/框架/vue","data":"# [element](https://element.eleme.cn/#/zh-CN/component/dialog)\n\n> [官网](https://element.eleme.cn/#/zh-CN/component/dialog)\n","children":[]},{"name":"eslint","path":"../guanruihua.github.io/Front-End/框架/vue","data":"","children":[{"name":"err.md","path":"../guanruihua.github.io/Front-End/框架/vue/eslint","data":"# vue 使用 eslint 报错\n\n\n\n## Unexpected tab character(no-tabs)\n\n1. 在创建项目的时候`Use ESlint to lint your code?(Y/n)`这里选no\n2. 在`.eslintrc.js`中在`rules`:加入一行`\"no-tabs\": \"off\"`\n3. 在文件中添加`/* eslint-disable */`\n\n","children":[]}]},{"name":"extend","path":"../guanruihua.github.io/Front-End/框架/vue","data":"","children":[{"name":"vue-expand.md","path":"../guanruihua.github.io/Front-End/框架/vue/extend","data":"# vue-expand\n\n## 设计项目结构\n\n> 1. 路由层 `router`\n> 2. 静态文件层 `assets`\n> 3. 页面结构层 `views`\n> 4. 组件结构层 `components`\n> 5. 全局状态管理层 `store`\n> 6. 功能逻辑处理层 `util`\n> 7. 常量管理层 `constants`\n> 8. 在 `Vue` 项目中还可以引入更多的配置如混入层 `mixins` 、过滤层 `filtters` 等。\n\n### 数据请求 methods中 OR actions中\n\n一般项目中对于数据请求的方式都是基于 `methods` 钩子或其他生命周期钩子中调用请求方法，也存在一些项目中是通过发送一个 `disptach` 异步请求方法在 `actions` 中调用请求函数。使用后者的说法是便于统一管理请求接口，并对请求返回的数据进行统一的管理。\n综合以上两种做法，可以优化项目中的请求方式，若请求接口发出后返回的数据需要在多个页面或多个不同的组件中共享和使用，则推荐在需要发请求的函数中 `dispath` 触发，在 `actions` 中发送请求，返回的数据保存在全局状态管理 `state` 中。\n`methods` 中发送请求方式：\n\n```javascript\ngetGraphicCode () {\n  let vm = this;\n  api.login.getCheckCode({\n    type: '2'\n  }).then(res => {\n    if (res.code === '000') {\n      vm.graphicCode = 'data:image/png;base64,' + res.data.img;\n      vm.imgId = res.data.imgId;\n    } else {\n      vm.$message.error(res.msg);\n    }\n  })\n}\n```\n\n`actions` 中发送请求方式：\n\n```javascript\nfindAllRoles({ commit }) {\n  return new Promise((resolve, reject) => {\n    api.systemAccount.findAllRoles().then(response => {\n      if (response.code === \"000\" && response.success) {\n        commit(MUTATIONS_TYPE.AllROLES, response.data)\n        resolve(response);\n      } else {\n        reject(new Error(response.code, response.msg))\n      }\n    })\n  })\n},\n```\n\n### 登录与权限管理\n\n`token` 验证是目前大部分前后端分离的 `Web` 项目做登录验证比较常见的方法。前端通过发送账号和密码或账号和验证码给到后端后，后端验证通过会返回一个唯一的 `token` 作为该用户的登录凭证，在之后的每个请求当中，请求头中都需带上这个 `token` 作为后端的登录校验。 `token` 有过期的机制，可以在请求拦截中做逻辑判断处理，若当前时间接近了过期时间，则通过更新 `token` 的接口请求更新 `token` ，在之后的请求中带上新的 `token` 。以此循环，若用户过长时间无操作，则可认为用户为离线状态，在用户之后的第一次请求时，由于 `token` 已经过期，访问后端接口会发生错误，根据后端返回的错误状态码作为判断，将系统定向至登录页面。\n通过带有 `token` 请求头的请求方法，后端可以判断到是哪一个用户，前端也可以通过获取权限接口获得该用户的权限列表，根据权限列表做一份路由映射表，如果后端返回的数据结构与前端的路由设置的数据结构不同，此时还需编写此映射路由的业务功能函数。如果该用户拥有此路由权限，则通过在全局路由监控中 `router.beforeEach` 进行 `router` 中的 `addRoutes` 方法将有权限的路由配置添加到路由当中，侧边栏也可根据路由列表中的 `meta` 字段中关键字的判断进行相应的渲染。如果权限的颗粒度小到一个按钮，则可根据后端返回的权限列表映射出的权限参数，通过 `v-if` 进行判断该功能组件是否渲染。\n在路由管理中通过 `router.beforeEach` 钩子中判断当前的路由权限是否为空，是的话则可执行获取权限路由的接口：\n\n```javascript\nstore.dispatch(\"getUserInfoAndAuthorityInfo\").then(res => {\n  // 根据后端返回的路由权限格式转成前端路由配置格式\n  const rolesRoute = setAsyncRouterMap(res.menuList, asyncRouterMap, mainChildrenAsyncRoutes)\n  store.commit(Vue.VUEX_TYPES.ROLESROUTE, rolesRoute);\n  // 添加路由\n  router.addRoutes(rolesRoute);\n  next({ ...to })\n}).catch(() => {\n  Message.error(\"验证失败\")\n  next('/login')\n})\n```\n\n### 常量枚举值管理\n\n在项目当中对关键的常量枚举值进行管理是非常有必要的。比如在项目当中后端用某个状态码 `1` 代表账号为启用状态，如果在项目当中多次使用 `===1` 去判断账号是否为启用状态，当需要更改这个状态码的时候，对于前端来说是一件十分麻烦的事情，所以可以通过把 `1` 赋值给一个常量，在项目代码中引用这个常量，如果需要更改状态码的时候，则直接改变这个赋值给常量枚举值的状态码即可，常量的配置也可提醒开发人员此参数不可轻易修改，便于项目的维护和统一管理。一般常量枚举值的管理写在 `constants` 层中，常量的变量名使用大写字母编写。\n状态枚举值得配置如下：\n\n```javascript\n/**\n * 账号状态对照表\n * \"0\" 未启用 NOTUSED_CODE\n * \"1\" 已启用 ENABLE_CODE\n * \"2\" 已停用 DISABLE_CODE\n */\n\nconst NOTUSED_CODE = \"0\";\nconst ENABLE_CODE = \"1\";\nconst DISABLE_CODE = \"2\";\n\nconst ACCOUNT_TYPE = {\n  [NOTUSED_CODE]: \"未启用\",\n  [ENABLE_CODE]: \"已启用\",\n  [DISABLE_CODE]: \"已停用\"\n};\n\nexport default Object.freeze({\n  NOTUSED_CODE,\n  ENABLE_CODE,\n  DISABLE_CODE,\n  ACCOUNT_TYPE\n});\n```\n\n### 组件设计\n\n前端项目当中可以把展示组件分为两部分，分别为页面组件和功能组件。对于页面组件，常用于展现页面的整体内容，承担着业务逻辑的正常运行，与业务比较有强的耦合性。功能组件是用于展现和处理某一单一或某一模块的功能，功能组件并不关心页面的业务逻辑，充当着一个函数的作用，只要有输入便有对应的输出，并可在多个页面组件或功能组件中被调用。综上，在设计页面组件的时候，不仅应该考虑该组件能够正常的完成业务的功能，还要考虑其是否能够脱离业务成为一个功能组件，对于内容比较多的页面组件，可以在其同级目录下新建多个子页面组件共同构建。在设计功能组件时，需考虑组件的布局、逻辑、视图，功能组件的设计难度在于其要考虑到满足不断更新的需求变化，可扩展性，灵活性是设计的一大挑战。\n页面组件目录格式如下：\n![image.png](https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22a3e0791dd74af5838f4359dca00746~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 必要的开发文档或注释\n\n项目的开发文档可编写为md文件格式存放于项目的根目录，一份好的开发文档能够对项目的背景进行介绍，说明项目的结构和开发的步骤，更有利于其他开发人员参与或接手项目。对于项目当中使用到的与业务功能耦合的逻辑函数，较为复杂的，编写函数的介绍以及使用方法，做好边界条件判断，示范输入数据以及对应的输出结果，可在项目中新建 `docs` 文件夹存放开发过程中的使用文档。对于非复杂功能的业务逻辑函数或非业务逻辑函数，可直接在定义函数之前编写注释，说明函数作用功能，以及对应的输入和输入参数的类型。\n\n> 每次的开发过程都可当做是一个学习和总结经验的过程，对比以往的代码，我们可以思考代码结构是否能设计得更加完善，逻辑函数是否清晰且考虑边界条件，性能是否可以更加的优化。\n\n## 常用webpack配置\n\n### **vue-lic3脚手架（vue.config.js）**\n\n#### publicPath\n\n类型：String\n\n默认：'/'\n\n部署应用包时的基本 URL。默认情况下，Vue CLI会假设你的应用是被部署在一个域名的根路径上，例如<https://www.my-app.com/。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在https://www.my-app.com/my-app/，则设置publicPath为/my-app/>\n\n这个值也可以被设置为空字符串 ('') 或是相对路径 ('./')，这样所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径，也可以用在类似 Cordova hybrid 应用的文件系统中。\n\n#### productionSourceMap\n\n类型：boolean\n\nmoren：true\n\n不允许打包时生成项目来源映射文件，在生产环境下可以显著的减少包的体积\n\n> 注 Source map的作用：针对打包后的代码进行的处理，就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便\n\n#### assetsDir\n\n放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录,默认是'',\n\n#### indexPath\n\n指定生成的 index.html 的输出路径(相对于outputDir)。也可以是一个绝对路径。默认是'index.html'\n\n#### lintOnSave\n\n是否在每次保存时使用eslint检查，这个对语法的要求比较严格，对自己有要求的同学可以使用\n\n#### css\n\n```js\ncss: {\n    //是否启用css分离插件，默认是true，如果不启用css样式分离插件，打包出来的css是通过内联样式的方式注入至dom中的，\n    extract: true,\n    sourceMap: false,//效果同上\n    modules: false,// 为所有的 CSS 及其预处理文件开启 CSS Modules。\n    // 这个选项不会影响 `*.vue` 文件。\n  },\n```\n\n#### devServer\n\n本地开发服务器配置\n\n```js\ndevServer: { \n    //配置开发服务器\n    host: \"0.0.0.0\",\n    //是否启用热加载，就是每次更新代码，是否需要重新刷新浏览器才能看到新代码效果\n    hot: true,\n    //服务启动端口\n    port: \"8080\",\n    //是否自动打开浏览器默认为false\n    open: false,\n    //配置http代理\n    proxy: { \n      \"/api\": { //如果ajax请求的地址是http://192.168.0.118:9999/api1那么你就可以在jajx中使用/api/api1路径,其请求路径会解析\n        // http://192.168.0.118:9999/api1，当然你在浏览器上开到的还是http://localhost:8080/api/api1;\n        target: \"http://192.168.0.118:9999\",\n        //是否允许跨域，这里是在开发环境会起作用，但在生产环境下，还是由后台去处理，所以不必太在意\n        changeOrigin: true,\n        pathRewrite: {\n            //把多余的路径置为''\n          \"api\": \"\"\n        }\n      },\n      \"/api2\": {//可以配置多个代理，匹配上那个就使用哪种解析方式\n        target: \"http://api2\",\n        // ...\n      }\n    }\n},\n```\n\n#### pluginOptions\n\n这是一个不进行任何 schema 验证的对象，因此它可以用来传递任何第三方插件选项，例如：\n\n```js\n{\n    //定义一个全局的less文件，把公共样式变量放入其中，这样每次使用的时候就不用重新引用了\n    'style-resources-loader': {\n      preProcessor: 'less',\n      patterns: [\n        './src/assets/public.less'\n      ]\n    }\n}\n```\n\n#### chainWebpack\n\n是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改。例如：\n\n```js\nchainWebpack(config) { \n//添加一个路径别名 假设有在assets/img/menu/目录下有十张图片，如果全路径require(\"/assets/img/menu/img1.png\")\n//去引入在不同的层级下实在是太不方便了，这时候向下方一样定义一个路劲别名就很实用了\n    config.resolve.alias\n      //添加多个别名支持链式调用\n      .set(\"assets\", path.join(__dirname, \"/src/assets\"))\n      .set(\"img\", path.join(__dirname, \"/src/assets/img/menu\"))\n      //引入图片时只需require(\"img/img1.png\");即可\n}\n```\n\n## 组件传值\n\n#### 父传子\n\n通过props传递\n\n```\n父组件： <child value = '传递的数据' />\n\n子组件: props['value'],接收数据,接受之后使用和data中定义数据使用方式一样\n```\n\n#### 子传父\n\n在父组件中给子组件绑定一个自定义的事件，子组件通过$emit()触发该事件并传值。\n\n```\n父组件： <child @receive = 'receive' />\n\n 子组件: this.$emit('receive','传递的数据')\n```\n\n#### 兄弟组件传值\n\n- 通过中央通信 let bus = new Vue()\n\n> A：methods :{ 函数{bus.$emit(‘自定义事件名’，数据)} 发送\n\n> B：created （）{bus.$on(‘A发送过来的自定义事件名’，函数)} 进行数据接收\n\n- 通过vuex\n\n## **v-for key的作用**\n\n当Vue用 v-for 正在更新已渲染过的元素列表是，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。\n\n为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。key属性的类型只能为 string或者number类型。\n\nkey 的特殊属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用 key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除 key 不存在的元素。\n\n## **Vue的双向数据绑定原理**\n\nvue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：\n\n> 1、需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化\n\n> 2、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图\n\n> 3、Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。\n\n> 4、MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。\n\n## vue-loader\n\n> vue文件加载器, 跟template/js/style转换为js模块\n\n## Vue-typeScript\n\n### 环境搭建\n\n```shell\nvue create typescript-app & cd typescript-app & npm run serve\n```\n\n### Main\n\n#### 基于类的组件\n\n```typescript\n//Typescript code\n<script lang=\"ts\">//这里指定是typescript\nimport { Component, Vue } from \"vue-property-decorator\"\n@Component\nexport default class HelloWorld extends Vue {\n  //coding...\n}\n//显式地使用name属性\n@Component({\n  name: 'HelloWorld',\n})\n</script>\n\n\n//Javascript code\n<script>\n  export default {\n name: 'helloWorld',\n}\n</script> \n```\n\n#### 引入组件\n\n````javascript\n//typescript\n<template>\n  <div class=\"main\">\n    <Project/>\n  </div>\n</template>\n<script lang='ts'>\n import { Component, Vue } from 'vue-property-decorator'\n import Project from '@/components/Project.vue'\n @Component({\n    commponents: {\n      Project\n    }\n  })\nexport default class HelloWorld extends Vue{\n  //coding...\n}\n</script>\n\n\n//javascript\n<template>\n  <div class = \"main\">\n    <Project/>\n  </div>\n</template>\n<script>\n  import Project from '@/components/Project.vue'\n export defaulf {\n    name : 'HelloWordl',\n    components : {\n      Project\n    }\n  } \n</script>\n````\n\n#### Data, props, computed, methods, watchers, emit\n\n##### Data\n\n```javascript\n//Typescript\n@Component\nexport default class HelloWorld extends Vue{\n  private msg : string = 'guanruihua'\n private list : Array<object> = [\n    {\n      name : 'ruihua',\n      age : '23',\n    },\n    {\n      name : 'ruihua', \n      age : '30',\n    }\n  ]\n}\n\n//javascript\nexport default {\n  data(){\n    return {\n      msg : 'guanruihua',\n      list : [\n        {\n          name : 'ruihau',\n          age : '23',\n        },\n        {\n          name : 'ruihua', \n          age : '30'\n        }\n      ]\n    }\n  }\n}\n```\n\n##### props\n\n```javascript\n//typescript\nimport { Component, Prop, Vue } from 'vue-property-decorator'\n@Component\nexport default class HelloWorld extends Vue {\n  @Prop() readonly msg!:string\n  @Prop({default : 'ruihua' }) readonly name : string\n  @Prop({required: true }) readonly age : number\n  @Prop(String) readonly address : string\n  @Prop({ require: false, type: String, default: 'Developer'}) readonly job: string\n}\n\n//javascript\nprops:{\n  msg,\n  name: {\n    default: 'ruihua'\n  },\n  age: {\n   require: true,\n  },\n  address: {\n   type: String\n  },\n  job: {\n   require: false,\n    type: String,\n    default: 'Developer'\n  }\n    \n}\n```\n\n#### Computed\n\n```javascript\n//Typescript\nexport default class HelloWorld extends Vue {\n get fullName() :string {\n  return this.firstName + '' + this.lastName\n  }\n set fullName(newValue: string){\n    let names = newValue.split(' ')\n    this.firstName = names[0]\n    this.lastName = names[ names.lenght - 1 ]\n  }\n}\n//javascript\nexport default{\n fullName() {\n   return this.firstName + '' + this.lastName\n  }\n}\n\nexport default{\n fullName() {\n    get: function(){\n     return this.firstName + '' + this.lastName  \n    }\n   set: function( newValue ){\n      let names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[ names.lenght - 1 ]\n    }\n  }\n}\n```\n\n#### methods\n\n```javascript\n//Typescript\nexport default class HelloWorld extends Vue {\n public Fn() : void {\n    console.log( this.addNum(4, 2) )\n  }\n public addNum( num1: number, num2: number): number {\n    return num1 + num2\n  }\n}\n\n//javascript\nexport default {\n  methods: {\n   Fn() {\n     console.log( this.addNum(4, 2))\n    },\n    addNum(num1, num2){\n      return num1 + num2\n    }\n  }\n}\n```\n\n#### wetchers\n\n```javascript\n//typescript\n@Watch('name')//监听的变量名称\nnameChange(newVal: string){\n  this.name = newVal\n}\n\n@Watch('project', { \n  immediate: true, deep: true \n})\nprojectChanged(newVal: Person, oldVal: Person) {\n  // do something\n}\n//javascript\nwatch: {\n person: {\n   handler: 'projectChanged',\n  immediate: true,\n     deep: true\n  }\n},\n  methods:{\n   projectChanged:(new Val, oldVal){\n      //do something\n    }\n  }\n```\n","children":[]},{"name":"vue-question.md","path":"../guanruihua.github.io/Front-End/框架/vue/extend","data":"# VUE-QUESTION\n\n## Vue提示报错警告\"TypeError: handler.call is not a function\"\n\n> 组件中声明了未定义的方法，或者只声明了钩子函数，并未使用。\n\n## `vue/cle3`项目运行报错`sockjs-node/info`解决方案\n\n### 控制台报错\n\n```shell\nget http://localhost:8080/sockjs-node/info?t=1462183700002 net::ERR_CONNECTION_REFUSED\n[WDS] Disconnected!\nget http://localhost:8080/sockjs-node/info?t=1462183700002 net::ERR_CONNECTION_REFUSED\n[WDS] Disconnected!\nget http://localhost:8080/sockjs-node/info?t=1462183700002 net::ERR_CONNECTION_REFUSED\n[WDS] Disconnected!\n...\n```\n\n### 解决方案\n\n#### 1. 注释法\n\n  顾名思义，找到依赖包中的源码，将其注释：\n\n1. 进入路径 `/node_modules/sockjs-client/dist/sockjs.js`\n2. 代码1605行注释掉：\n\n```javascript\ntry {\n        // self.xhr.send(payload);  //本行注释\n    } catch (e) {\n        self.emit('finish', 0, '');\n        self._cleanup(false);\n    }\n```\n\n3. 重启项目\n\n#### 2. 配置`vue.config`\n\n  `vue.config.js`中的`module.xports`中添加如下，然后重启：\n\n```javascript\ndevServer: {\n    proxy: 'http://localhost:8080',\n    public: '192.168.xxx.xxx:8080'  // 本地ip\n}\n```\n","children":[]},{"name":"父子通信.md","path":"../guanruihua.github.io/Front-End/框架/vue/extend","data":"# 父子组件通信\n\n## 子组件调用父组件的方法\n\n### this.$parent.event\n\n> 直接在子组件中通过this.$parent.event来调用父组件的方法\n\n父组件\n\n```vue\n<template>\n  <div>\n    <child></child>\n  </div>\n</template>\n<script>\n  import child from './components/dam/child';\n  export default {\n    components: {\n      child\n    },\n    methods: {\n      fatherMethod() {\n        console.log('测试');\n      }\n    }\n  };\n</script>\n```\n\n子组件\n\n```vue\n<template>\n  <div>\n    <button @click=\"childMethod()\">点击</button>\n  </div>\n</template>\n<script>\n  export default {\n    methods: {\n      childMethod() {\n        this.$parent.fatherMethod();\n      }\n    }\n  };\n</script>\n```\n\n### $emit\n\n> 在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了。\n\n父组件\n\n```vue\n<template>\n  <div>\n    <child @fatherMethod=\"fatherMethod\"></child>\n  </div>\n</template>\n<script>\n  import child from '~/components/dam/child';\n  export default {\n    components: {\n      child\n    },\n    methods: {\n      fatherMethod() {\n        console.log('测试');\n      }\n    }\n  };\n</script>\n```\n\n子组件\n\n```vue\n<template>\n  <div>\n    <button @click=\"childMethod()\">点击</button>\n  </div>\n</template>\n<script>\n  export default {\n    methods: {\n      childMethod() {\n        this.$emit('fatherMethod');\n      }\n    }\n  };\n</script>\n```\n\n### 父组件把方法传入子组件\n\n> 父组件把方法传入子组件中，在子组件里直接调用这个方法\n\n父组件\n\n```vue\n<template>\n  <div>\n    <child :fatherMethod=\"fatherMethod\"></child>\n  </div>\n</template>\n<script>\n  import child from '~/components/dam/child';\n  export default {\n    components: {\n      child\n    },\n    methods: {\n      fatherMethod() {\n        console.log('测试');\n      }\n    }\n  };\n</script>\n```\n\n子组件\n\n```vue\n<template>\n  <div>\n    <button @click=\"childMethod()\">点击</button>\n  </div>\n</template>\n<script>\n  export default {\n    props: {\n      fatherMethod: {\n        type: Function,\n        default: null\n      }\n    },\n    methods: {\n      childMethod() {\n        if (this.fatherMethod) {\n          this.fatherMethod();\n        }\n      }\n    }\n  };\n</script>\n```\n\n子组件 更简便的写法\n\n```vue\n<template>\n  <div>\n    <button @click=\"fatherMethod()\">点击</button>\n  </div>\n</template>\n<script>\n  export default {\n    props: {\n      fatherMethod: {\n        type: Function,\n        default: null\n      }\n    },\n    methods: {}\n  };\n</script>\n```\n","children":[]}]},{"name":"package.md","path":"../guanruihua.github.io/Front-End/框架/vue","data":"# package\n\n## vue-virtual-scroll-list\n\n> <https://github.com/tangbc/vue-virtual-scroll-list>\n","children":[]},{"name":"question","path":"../guanruihua.github.io/Front-End/框架/vue","data":"","children":[{"name":"sockjs-node.md","path":"../guanruihua.github.io/Front-End/框架/vue/question","data":"# vue项目报错http://localhost:8080/sockjs-node/info?t=xxxx，解决办法，亲测绝对有效！\n\n## 方法一: 修改node_modules文件\n\n> 找到/node_modules/sockjs-client/dist/sockjs.js \n>\n> 找到代码的 1606行 ，并注释掉\n\n   ```js\ntry{\n  //self.xhr.send(payload); //注释这一行\n}catch(e){\n  self.emit('finish', 0, '');\n  self._cleanup(false);\n}\n   ```\n\n## 方法二\n\n> 其实造成这个原因是：网络环境变更（如切换wifi导致开发服务器的IP地址更换），服务器不知道如何确定访问源，就有可能造成上述情况。\n>\n> **解决办法**：如果是开发环境，重新npm run serve,重启项目即可解决问题。如果是生产环境，很大可能是应该是域名和ip映射出问题，检查重新配置域名和ip映射就可以了。","children":[]}]},{"name":"SSR","path":"../guanruihua.github.io/Front-End/框架/vue","data":"","children":[{"name":"nuxt.md","path":"../guanruihua.github.io/Front-End/框架/vue/SSR","data":"# nuxt\r\n\r\n> vue2 的 SSR 框架\r\n","children":[]}]},{"name":"UI组件","path":"../guanruihua.github.io/Front-End/框架/vue","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Front-End/框架/vue/UI组件","data":"","children":[]},{"name":"制作UI组件.md","path":"../guanruihua.github.io/Front-End/框架/vue/UI组件","data":"# 开发UI组件\n\n> 参考视频 https://www.bilibili.com/video/BV1nJ411V75n\n>\n> [hucongcong/heima-uui (github.com)](https://github.com/hucongcong/heima-uui)\n>\n>  [构建目标 | Vue CLI (vuejs.org)](https://cli.vuejs.org/zh/guide/build-targets.html#库)\n>\n> 仿制Element-UI组件的文件目录\n\n\n\n## 开发准备\n\n> 使用 vue 脚手架创建项目\n\n### 修改文件目录\n\n> 创建\n>\n> - packages :组件的文件夹\n>   - index.js:写成注册packages组件的的方法\n> - .npmignore : npm 提交忽略目录 \n> - vue.config.js: 修改webpack的打包方法\n>\n> 修改\n>\n> - src => examples \n\n#### packages / index.js\n\n```js\n// 整个包的入口\n// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册\n// 统一导出\n// 导入颜色选择器组件\nimport Button from './button'\n...\n\n// 存储组件列表\nconst components = [\n  Button,\n  \n]\nconst install = function (Vue) {\n  // 全局注册所有的组件\n  components.forEach((item) => {\n    Vue.component(item.name, item)\n  })\n}\n\n// 判断是否是直接引入文件,如果是，就不用调用 Vue.use()\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue)\n}\n\nexport default {\n  install\n}\n\n```\n\n\n\n#### .npmignore\n\n```\n# 忽略目录 \nexamples/\npackages/\npublic/\n\n# 忽略指定文件\nvue.config.js\nbabel.config.js\n*.map\n.gitignore\n```\n\n\n\n#### vue.config.js\n\n```js\nconst path = require('path')\nmodule.exports = {\n\tpages: {\n\t\tindex: {\n\t\t\t// 修改项目的入口文件\n\t\t\tentry: 'examples/main.js',\n\t\t\ttemplate: 'public/index.html',\n\t\t\tfilename: 'index.html'\n\t\t}\n\t},\n\t// 扩展 webpack 配置，使 packages 加入编译\n\tchainWebpack: config => {\n\t\tconfig.module\n\t\t\t.rule('js')\n\t\t\t.include.add(path.resolve(__dirname, 'packages')).end()\n\t\t\t.use('babel')\n\t\t\t.loader('babel-loader')\n\t\t\t.tap(options => {\n\t\t\t\t// 修改它的选项...\n\t\t\t\treturn options\n\t\t\t})\n\t}\n}\n```\n\n### 其他修改\n\n#### 添加构建dist指令\n\n```json\n{\n  ...\n  \"scripts\": {\n    \"serve\": \"vue-cli-service serve\",\n    \"build\": \"vue-cli-service build\",\n    \"lib\": \"vue-cli-service build --target lib packages/index.js\"\n  }\n  ...\n}\n```\n\n\n\n## 发布\n\n```npm\nnpm login\nnpm publish\n```\n\n\n\n## 使用\n\nmain.js\n\n```js\nimport RHUI from 'rh-vue-ui'\nimport 'rh-vue-ui/dist/rh-vue-ui.css'\n```\n\n使用\n\n```vue\n<RH-Button>我是按钮</RH-Button>\n```\n\n\n\n","children":[]}]},{"name":"vue-basis.md","path":"../guanruihua.github.io/Front-End/框架/vue","data":"# Vue-basis\n\n> 用户构建用户界面的渐进式框架, 与其他大象框架不同的是, Vue被设计为可以自底向上层应用, Vue的核心库值关视图, 便于与第三方库或基友的项目整合\n\n`Object.freeze()`，这会阻止修改现有的 property，也意味着响应系统无法再*追踪*变化。\n\n## 生命周期\n\n<img src=\"vue-basis.assets/lifecycle.png\" style=\"zoom: 50%;\" />\n\n### 创建阶段\n\n> 1. `new Vue()`: `var vm = new Vue( { } );`表示创建一个Vue对象(实例)\n> 2. `Init ( Events&Lifecycle )`: 对象初始化, 在新建的对象身上,具备了一些生命周期相关的函数( 生命周期的钩子函数)和默认的事件,其他组件还没有创建(data, methods, filter等都没有创建出来)\n>    - 执行`Init( Event&Lifecycle)`之后, 钩子函数都被创建出来, 马上调研生命周期函数`beforeCreate`, data和methods等组件都还没有创建出来\n> 3. `Init( injections&reactivity )` : 对象初始化的后期阶段。执行生命周期函数`created`，data和methods都已经被初始化好了。\n> 4. `Init`对象初始化完成阶段执行完毕后,通过对元素及其模板进行判断, 系统开始编辑模板, 将Vue代码的指令进行执行,然后再内存中生成一个编辑好的模板字符串, 最终改模板字符串渲染为内存中的DOM\n>    - 只在内存中渲染好了模板, 并没有见模板挂载到页面中去, 该阶段完成后执行`beforeMount` 方法\n> 5. `Create vm` : 该阶段是将内存中编译好的模板, 替换到浏览器的页面中,该阶段执行的是mounted方法\n>    - 只要`mounted`方法执行完后, 就标识整个Vue对象已经初始化完毕,真实脱离创建阶段进入运行阶段, 可以开始操作页面上DOM节点\n\n### 运行阶段\n\n> 6. Virtual DOM: 该阶段会根据data中的最新数据,重新渲染出一份最新的DOM树, DOM树更新后悔把最新的DOM数重新渲染到页面中, 这时候完成了使用模型Model去渲染视图View\n>    - 常使用两个函数beforeUpdate和updated, 会根据data数据变化, 可重复多次执行\n>    - `beforeUpdate`方法执行的时候,页面显示的数据还是以前的数据, 但是data中保存的是更新后的\n>    - `update`函数执行的时候, 页面和data的数据以及保持同步,都是最新的数据\n\n### 对象销毁\n\n> 7. `Teardown( 拆卸 )` : 对象销毁阶段, 当该对象实例运行完成后, 达到独享销毁的条件, 执行`beforeDestroy`函数, 该函数执行标志的这对象从运行状态进入到了销毁的阶段\n>    - 当`beforeDestroy`函数执行的时候, 对象身上所有的组件 data, methods, filter, directive的等组件都还处于可用状态(对象只是步入到了销毁的阶段, 还没有销毁) , 该函数执行完毕后, 对象正式销毁.\n> 8. `Destroy` : 对象已经销毁了,data, methodsfilter, directive等组件都不可用了\n\n### 生命周期的钩子函数\n\nbeforeCreate\n\ncreated\n\nbeforeMount\n\nmounted\n\nbeforeUpdate\n\nupdated\n\nbeforeDestroy\n\ndestroyed\n\n## 指定端口运行\n\n- 在根目录新建配置文件`vue.config.js`;\n\n- 配置文件内容\n\n  ```js\n  module.exports = {\n   devServer: {\n    // 项目运行时候的端口号\n    port: 8000\n   }\n  };\n  ```\n\n## computed 和 watch\n\n#### 计算属性computed\n\n- 支持缓存，只有依赖数据发生改变，才会重新进行计算\n- 不支持异步，当computed内有异步操作时无效，无法监听数据的变化\n- computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值\n- 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed\n- 如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。\n\n#### 侦听属性watch\n\n- 不支持缓存，数据变，直接会触发相应的操作；\n- watch支持异步；\n- 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；\n- 当一个属性发生变化时，需要执行对应的操作；一对多；\n- 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：\n\n> immediate：组件加载立即触发回调函数执行\n\n```js\nwatch: {\n  firstName: {\n    handler(newName, oldName) {\n      this.fullName = newName + ' ' + this.lastName;\n    },\n    // 代表在wacth里声明了firstName这个方法之后立即执行handler方法\n    immediate: true\n  }\n}\n```\n\n> deep: deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler\n\n```js\nwatch: {\n  obj: {\n    handler(newName, oldName) {\n      console.log('obj.a changed');\n    },\n    immediate: true,\n    deep: true\n  }\n}\n```\n\n优化：我们可以使用字符串的形式监听\n\n```\nwatch: {\n  'obj.a': {\n    handler(newName, oldName) {\n      console.log('obj.a changed');\n    },\n    immediate: true,\n    // deep: true\n  }\n}\n```\n\n这样Vue.js才会一层一层解析下去，直到遇到属性a，然后才给a设置监听函数。\n\n### **prop 验证，和默认值**\n\n我们在父组件给子组件传值的时候，可以指定该props的默认值及类型，当传递数据类型不正确的时候，vue会发出警告\n\n```\nprops: {\n    visible: {\n        default: true,\n        type: Boolean,\n        required: true\n    },\n},\n```\n\n## 指令\n\n### vue自带指令\n\n1. ### v-cloak\n\n   - 解决插值表达式的闪烁问题\n\n   - 网速等问题可能显示出 双花括号 ,加载完毕后才会转换成动态赋予的值\n\n   ```js\n   先定义好样式\n   [v-cloak]{\n    display:none;\n   }\n   再在标签中引用\n   <p v-cloak >{{str}}</p> // 不适用v-cloak可能会出现{{}}\n   ```\n\n2. ### v-text\n\n   1. ```js\n      <p v-text=\"str\"></p>\n      ```\n\n   2. 可以插入内容\n\n3. ### v-html\n\n   1. ```js\n      <p v-text=\"str\"></p>\n      ```\n\n   2. 不建议使用,容易受到xss攻击\n\n   3. 可以插入html的片段,可以得到浏览器的解析\n\n4. 插值表达式 与 v-text/v-html的区别\n\n   1. 对元素中已经存在的值, 只有插值表达式能够将原有的值保留, 在原有的已经存在的值的基础上添加动态数据\n   2. v-text/v-html不能够保留标签原有的的内容,不会出现页面闪烁的问题\n\n5. v-bind:\n\n   1. 单向数据绑定\n\n   2. 将data中的信息动态赋予给标签的属性或者变量值中\n\n   3. 只能实现数据的单向绑定, 从模型(M) 绑定到视图(V),使用VM将数据去渲染视图,但是我们无法通过该形式实现数据的双向绑定\n\n   4. 简写\":\"\n\n   5. ```js\n      <p v-bind:title=\"str\"></p>\n      <p v-bind:title=\"str+'拼接'\"\"></p>\n      ```\n\n   6. 使用class演示\n\n      ```js\n      :class = \"[class1, class2, class3...]\"\n      \n      三目运算符操作以上数组\n      :class=\"[boolean? 'trueClass' : 'falseClass', ...]\"\n      \n      使用对象(json)来表达以上三目运算符的操作\n      :class = \"[{'style_class':flag}]\"\n      \n      ```\n\n   7. 常用的使用方式\n\n      1. 直接为元素的属性进行绑定操作\n      2. 使用简化后的方式 , 将v-bind去除, 直接使用: 用来厎元素中的额外属性进行绑定\n\n6. v-on:\n\n   1. 简写: \"@\"\n   2. v-on: click = \"fun\"相当于原生的onclick = \"fun()\"\n\n7. v-model:\n\n   1. 双向数据绑定\n   2. 只能运用在表单元素中\n   3. 和data数据是实现双向绑定\n   4. `v-model = \"str\"`\n\n8. v-for\n\n   > - key: 提供一个有效的辨识指定元素\n   > - key属性值只能为数值或字符串\n   > - key一定要v-bind绑定\n   > - 值必须是记录中的唯一标识\n\n   1. 遍历字符串数组\n      - `<p v-for=\"(item, index) in arrayList\" :key = index>{{item}}</p>`\n   2. 遍历对象数组\n      - `<p v-for=\"(item, index) in arrayList\" :key = index>{{item.id}}---{{item.name}}</p>`\n   3. 遍历对象的属性和属性值\n      - `(value[属性值], key(属性名)) in 对象`\n      - ``<p v-for=\"(value, key, index) in arrayList\" :key = index>{{value}}</p>``\n   4. 遍历整形数字\n      - ``<p v-for=\"index in 10\" :key = index>{{index}}</p>``\n\n9. v-show ,v-if , v-else-if, v-else\n\n   - v-xxx=\"true\":展示元素内容(创建该元素) false: 去除该元素\n   - v-if=\"true\" : 创建条件元素   false : 去除该元素\n     - 每次切换true都会重新创建元素, 降低元素的效率\n   - v-show=\"true\" :  展现条件元素   false: 隐藏该元素\n     - 频繁切换boolean建议使用\n\n### 自定义全局指令\n\n> - 自定义全局指令: `Vue.directive()`\n> - 定义时候不用加\"v-\", 使用时候才用\n> - `bind, inserted, update`是vue对象生命周期相关函数\n>   - bind:操作元素样式(css)\n>   - inserted: 操作元素行为(js)\n>   - update:元素更新\n\n```js\n<div id=\"app\">\n <input type = \"text\" v-dt/>\n</div>\n\nVue.directive(\"dt\",{\n  //绑定时, 就可以触发\n  //还没有插入到dom\n  //binding 是传递过来的数据, 即v-dt=\"数据\"\n  bind: function(el,binding){\n   el.style.color = \"red\";\n  },\n  //inserted函数, 表示元素插入到dom中,\n  inserted: function(el){\n  \n },\n  //表示元素更新时候触发, 可以随时触发\n update:function(el){\n    \n  }\n})\n\nvar vm = new Vue({\n el: \"#app\",\n data: {\n  str : \"str\"\n }\n})\n```\n\n## 修饰符\n\n### 键盘修饰符\n\n在JavaScript事件中除了前面所说的事件，还有键盘事件，也经常需要监测常见的键值。在Vue中允许`v-on`在监听键盘事件时添加关键修饰符。记住所有的`keyCode`比较困难，所以Vue为最常用的键盘事件提供了别名：\n\n- **`.enter`**：回车键\n- **`.tab`**：制表键\n- **`.delete`**：含`delete`和`backspace`键\n- **`.esc`**：返回键\n- **`.space`**: 空格键\n- **`.up`**：向上键\n- **`.down`**：向下键\n- **`.left`**：向左键\n- **`.right`**：向右键\n\n### 鼠标修饰符\n\n鼠标修饰符用来限制处理程序监听特定的滑鼠按键。常见的有：\n\n- **`.left`**：鼠标左键\n- **`.middle`**：鼠标中间滚轮\n- **`.right`**：鼠标右键\n\n### 修饰键\n\n可以用如下修饰符开启鼠标或键盘事件监听，使在按键按下时发生响应：\n\n- **`.ctrl`**\n- **`.alt`**\n- **`.shift`**\n- **`.meta`**\n\n### 事件修饰符\n\na.stop : 阻止事件的冒泡机制(点击内层事件会触发外层的点击事件)\n\na.prevent: 阻止默认行为\n\nc.capture : 事件会优先触发,如果加在最外层的事件会往里冒泡\n\nd.self : 阻止自身冒泡行为的行为,(它不会真正阻止冒泡行为)\n\n```text\n案例: div>div>button\n1. 在内层加入.stop修饰符\n 点击button,只会触发事件冒泡到内层事件\n2. 在内层加入.self修饰符\n 点击button,在事件冒泡过程,不会触发.self的事件\n```\n\ne.once : 只会触发一次事件处理函数,\n\n >  .once 需要结合.prevent来使用\n >\n >  语法: @click.prevent.once \n\n#### 自定义私有指令\n\n> - 在指定vm对象中定义, 值针对vm对象描述的元素生效的指令,\n> - 其他vm对象不能使用该指令\n\n```js\n<div id=\"app\">\n <input type = \"text\" v-dt/>\n</div>\n\nVue.directive(\"dt\",{\n  //绑定时, 就可以触发\n  //还没有插入到dom\n  //binding 是传递过来的数据, 即v-dt=\"数据\"\n  bind: function(el,binding){\n   el.style.color = \"red\";\n  },\n  //inserted函数, 表示元素插入到dom中,\n  inserted: function(el){\n  \n },\n  //表示元素更新时候触发, 可以随时触发\n update:function(el){\n    \n  }\n})\n\nvar vm = new Vue({\n el: \"#app\",\n data: {\n  str : \"str\"\n },\n  directives: {\n   \"dt\": {\n     bind: function(el,binding){}\n     inserted: function(el){}\n    update: function(el){}\n    }\n  }\n})\n```\n\n## 过滤器\n\n> - 就是通过输入数据,能够及时对数据进行处理并返回一个数据结果的简单函数\n> - 复用性\n> - 系统会先查找私有再找全局过滤器\n\n### 全局过滤器\n\n> - 所有VM对象都能共此案使用的过滤器\n>\n> - ```js\n>   单个过滤器的使用\n>   <p>{{str | myfilter}}</p>\n>   <script>\n>     Vue.filter(\"myfilter\", function(value){\n>     ....\n>       return outValue;\n>    })\n>   var vm = new Vue({\n>     el: \"app\",\n>     data: {\n>       str: \"aaa\"\n>     }\n>      \n>   })\n>   </script>\n>     \n>   连续使用多个过滤器\n>   <p>{{str | myfilter1 | myfilter2 | ... }}</p>\n>   ```\n\n### 私有过滤器\n\n> - 在VM对象定义过滤器\n>\n> - 只能在vm对象中作用\n>\n> - ```js\n>   <p>{{str | myfilter}}</p>\n>   <script>\n>     Vue.filter(\"myfilter\", function(value){\n>     ....\n>       return outValue;\n>    })\n>   var vm = new Vue({\n>     el: \"app\",\n>     data: {\n>       str: \"aaa\"\n>     },\n>     filters : {\n>       myfilter1 : function(value){\n>         ....\n>           return outValue;\n>        }\n>     }\n>      \n>   })\n>   </script>\n>   ```\n\n## vue对ajax的支持\n\n### vue-resource\n\n#### get\n\nthis.$http.get(\"请求路径\" , \"请求参数\").then( \"回调函数\" )//拿数据data.body.key\n\nthis.$http.get(\"请求路径\" , \"请求参数\").then(function (data){...}) )\n\n#### post\n\nthis.$http.get(\"请求路径?name=data\" , \"请求参数\").then(function (data){...}) )\n\nthis.$http.get(\"请求路径\" ,  {name: data } ,{ emulateJSON : true }).then(function (data){...}) )\n\n### axios\n\n> 一个基于Promise的HTTP请求客户端, 用来发出请求, 官方推荐\n\n#### get\n\n```js\naxios({\n method : \"get\", \n  url : \"url\",\n  params : {\"name\":\"data\"},//传递参数\n}).then(function(result){\n  console.log(result.data.key)\n})\n\n//使用箭头函数\naxios({\n method : \"get\", \n  url : \"url\"\n}).then(result=>{\n  console.log(result.data.key)\n})\n\naxios.get(\"url\", {params : { \"name\" : \"data\"}).then(result => {\n console.log(result.data.key);                 \n})\n```\n\n#### post\n\n```js\n//使用箭头函数\naxios({\n method : \"post\", \n  url : \"url\",\n  params : { \"key\" : \"data\" }\n}).then(result=>{\n  console.log(result.data.key)\n})\n\naxios.post(\"url\", \"key = data\".then(result => {\n console.log(result.data.key);                 \n})\n```\n\n## 跨域请求的处理\n\njsonp来处理\n\n```js\nthis.$http.jsonp(\"http://localhost: 8080/projectName/getData.do\").then(result=>{\n  data = result.body\n})\n```\n\n## Vue动画\n\n<img src=\"vue-basis.assets/transition.png\" style=\"zoom:50%;\" />\n\nEnter(信息进入阶段)\n\nv-enter : 进去前\n\nv-enter-active :  进入过程\n\nv-enter-to : 进去后\n\nLeave(信息离开阶段)\n\nv-leave : 离开前\n\nv-leave-active : 离开过程\n\nv-leave-to :离开后\n\n```html\n<transition>\n  <p v-show=\"flag\" >aaa</p>\n</transition>\n<style>\n  .v-enter, .v-leave-to{\n    opacity: 0;\n    transform: opacity;\n  }\n  .v-enter-active, .v-leave-active{\n    transition: all 0.8s ease;\n  }\n</style>\n```\n\n通过name来给指定元素添加特效\n\n```html\n<transition name=\"tran1\">\n  <p v-show=\"flag\" >aaa</p>\n</transition>\n<style>\n  .tran1-enter, .tran1-leave-to{\n    opacity: 0;\n    transform: opacity;\n  }\n  .tran1-enter-active, .tran1-leave-active{\n    transition: all 0.8s ease;\n  }\n</style>\n```\n\n## 其他\n\n@keyup = \"fn\" : 敲键盘之后就会触发\n\n@change = \"fn\" : 数据改变就会触发\n","children":[]},{"name":"vue-router.md","path":"../guanruihua.github.io/Front-End/框架/vue","data":"# vue-router\n\n# vue-router-基础\n\n> - [官网](https://router.vuejs.org/zh/)\n>\n> - [API](https://router.vuejs.org/zh/api/#router-link)\n\n## router和route的区别\n\n> route为当前router跳转对象里面可以获取name、path、query、params等\n\n> router为VueRouter实例，想要导航到不同URL，则使用router.push方法\n\n## 一个Router\n\n### HTML\n\n> - router-link, router-view, to\n\n```html\n<script src=\"https://unpkg.com/vue/dist/vue.js\"></script>\n<script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"></script>\n\n<div id=\"app\">\n  <h1>Hello App!</h1>\n  <p>\n    <!-- 使用 router-link 组件来导航. -->\n    <!-- 通过传入 `to` 属性指定链接. -->\n    <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->\n    <router-link to=\"/foo\">Go to Foo</router-link>\n    <router-link to=\"/bar\">Go to Bar</router-link>\n  </p>\n  <!-- 路由出口 -->\n  <!-- 路由匹配到的组件将渲染在这里 -->\n  <router-view></router-view>\n</div>\n```\n\n### JavaScript\n\n```js\n// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)\n\n// 1. 定义 (路由) 组件。\n// 可以从其他文件 import 进来\nconst Foo = { template: '<div>foo</div>' }\nconst Bar = { template: '<div>bar</div>' }\n\n// 2. 定义路由\n// 每个路由应该映射一个组件。 其中\"component\" 可以是\n// 通过 Vue.extend() 创建的组件构造器，\n// 或者，只是一个组件配置对象。\n// 我们晚点再讨论嵌套路由。\nconst routes = [\n  { path: '/foo', component: Foo },\n  { path: '/bar', component: Bar }\n]\n\n// 3. 创建 router 实例，然后传 `routes` 配置\n// 你还可以传别的配置参数, 不过先这么简单着吧。\nconst router = new VueRouter({\n  routes // (缩写) 相当于 routes: routes\n})\n\n// 4. 创建和挂载根实例。\n// 记得要通过 router 配置参数注入路由，\n// 从而让整个应用都有路由功能\nconst app = new Vue({\n  router\n}).$mount('#app')\n\n// 现在，应用已经启动了！\n```\n\n### Home.vue\n\n> - 注入路由器后\n>   - this.$router : 访问路由器\n>   - this.$route : 访问当前路由\n\n```vue\nexport default {\n  computed: {\n    username() {\n      // 我们很快就会看到 `params` 是什么\n      return this.$route.params.username\n    }\n  },\n  methods: {\n    goBack() {\n      window.history.length > 1 ? this.$router.go(-1) : this.$router.push('/')\n    }\n  }\n}\n```\n\n## 动态路由\n\n> - $route.params\n> - beforeRouteUpdate\n> - this.$route.\n> - this.$route.params.pathMatch\n\n### 动态路由匹配\n\n```js\nconst User = {\n template:  '<div>{{$route.params.id}}</div>'\n}\n\nconst router = new VueRouter({\n  routes: [\n    //动态路径参数 以冒号开头\n    //`/user/foo`  和 `/user/bar`  都会映射到相同的路由\n    { path: '/user/:id', component: User }\n  ]\n})\n```\n\n> - $route.params\n>\n>   | 模式                         | 匹配路径            | $route.params                        |\n>   | ---------------------------- | ------------------- | ------------------------------------ |\n>   | /user/:username              | /user/evan          | { username: 'evan' }                 |\n>   | /user/:usrname/post/:post_id | /user/evan/post/123 | { username: 'evan', post_id: '123' } |\n\n### 响应路由参数的变化\n\n> - 当使用路由, 从 /user/foo 导航到 /user/bar , 原来的组件实例会被复用, 比起两个路由都渲染同个组件, 比起销毁再创建, 复用则显得更加高效\n>\n>   - 但是复用意味着生命周期钩子不会再被调用\n>\n>   - 复用组件可以使用watch(检测变化) $route 对象\n>\n>     - ```js\n>       const User={\n>        template: `...`,\n>         watch: {\n>          $route(to, from) {\n>            //对路由变化做出响应....\n>           }\n>         }\n>       }\n>       ```\n>\n>   - 2.2引入 beforeRouteUpdate 导航守卫\n>\n>     - ```js\n>       const User = {\n>        template: '...',\n>         beforeRouteUpdate(to, from, next) {\n>           //next() ; 放行\n>         }\n>       }\n>       ```\n\n### 捕获所有路由 或 404 Not found 路由\n\n> - 通配符 *  , pathMatch : 匹配的部分\n>\n>   - path: '  *  '  匹配所有路径\n>\n>   - path: ' /user-*' => 匹配 '/user-' 开头的任意路径\n>\n>   - ```js\n>     // 给出一个路由 { path: '/user-*' }\n>     this.$router.push('/user-admin')\n>     this.$route.params.pathMatch // 'admin'\n>     // 给出一个路由 { path: '*' }\n>     this.$router.push('/non-existing')\n>     this.$route.params.pathMatch // '/non-existing'\n>     ```\n\n## 嵌套路由\n\n> - router-view\n\n```html\n<div id=\"app\">\n  <router-view></router-view>\n</div>\n```\n\n```js\nconst User = {\n  template: `\n <div class='user'>\n  <h2>User {{ $route.params.id }}</h2>\n  <router-view></router-view>\n </div>\n `\n}\n\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/user/:id', \n      component: User,\n      children: [{\n        // 当 /user/:id/profile 匹配成功，\n          // UserProfile 会被渲染在 User 的 <router-view> 中\n          path: 'profile',\n          component: UserProfile\n      },{\n     // 当 /user/:id/posts 匹配成功\n          // UserPosts 会被渲染在 User 的 <router-view> 中\n          path: 'posts',\n          component: UserPosts\n      }]\n    }\n  ]\n})\n```\n\n## 编程式的导航\n\n### router.push\n\n> - router.push(lacation, onComplate?, onAbort?) 等同于 <router-link :to='....'>\n> - params, query\n\n```js\n// 字符串\nrouter.push('home')\n\n// 对象\nrouter.push({ path: 'home' })\n\n// 命名的路由\nrouter.push({ name: 'user', params: { userId: '123' }})\n\n// 带查询参数，变成 /register?plan=private\nrouter.push({ path: 'register', query: { plan: 'private' }})\n\nconst userId = '123'\nrouter.push({ name: 'user', params: { userId }}) // -> /user/123\nrouter.push({ path: `/user/${userId}` }) // -> /user/123\n// 这里的 params 不生效\nrouter.push({ path: '/user', params: { userId }}) // -> /user\n```\n\n### router.replace\n\n> - `router.replace(location, onComplete?, onAbort?)`\n> - 替换掉当前history, 不会向history添加新的记录\n> - 例如一个用户资料到另一个, /users/1 => /users/2\n\n```js\n<router-link :to=\"...\" replace></router-link> \n//等同于\nrouter.replace(...)\n```\n\n### router.go(n)\n\n> - 在history记录中向前 或 后退多少步\n>   - 类似window.history.go(n)\n\n```js\n// 在浏览器记录中前进一步，等同于 history.forward()\nrouter.go(1)\n\n// 后退一步记录，等同于 history.back()\nrouter.go(-1)\n\n// 前进 3 步记录\nrouter.go(3)\n\n// 如果 history 记录不够用，那就默默地失败呗\nrouter.go(-100)\nrouter.go(100)\n```\n\n## 命名路由\n\n> - 通过一个名称来标识路由\n\n```js\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/user/:userId',\n      name: 'user',\n      component: User\n    }\n  ]\n})\n\n<router-link :to=\"{ name: 'user', params: { userId: 123 }}\">User</router-link>\n\nrouter.push({ name: 'user', params: { userId: 123 }})\n```\n\n## 命名视图\n\n> - 同时(同级)展示多个视图, 而且不是嵌套\n\n```html\n<router-view class=\"view one\"></router-view>\n<router-view class=\"view two\" name=\"a\"></router-view>\n<router-view class=\"view three\" name=\"b\"></router-view>\n//默认是default\n```\n\n```js\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/',\n      components: {\n        default: Foo,\n        a: Bar,\n        b: Baz\n      }\n    }\n  ]\n})\n```\n\n### 嵌套命名视图\n\n```\n/settings/emails                                       /settings/profile\n+-----------------------------------+                  +------------------------------+\n| UserSettings               |                  | UserSettings            |\n| +-----+-------------------------+ |                  | +-----+--------------------+ |\n| | Nav | UserEmailsSubscriptions | |  +------------>       | | Nav | UserProfile      | |\n| |    +-------------------------+ |                  | |    +--------------------+ |\n| |    |                 | |                  | |    | UserProfilePreview | |\n| +-----+-------------------------+ |                  | +-----+--------------------+ |\n+-----------------------------------+                  +------------------------------+\n```\n\n> - Nav : 常规组件\n> - UserSetting: 视图组件\n> - `UserEmailsSubscriptions`,`UserProfile`, `UserProfilePreview` 是嵌套的视图组件\n\n```html\n<!-- UserSettings.vue -->\n<div>\n  <h1>User Settings</h1>\n  <NavBar/>\n  <router-view/>\n  <router-view name=\"helper\"/>\n</div>\n```\n\n```js\n{\n  path: '/settings',\n  // 你也可以在顶级路由就配置命名视图\n  component: UserSettings,\n  children: [{\n    path: 'emails',\n    component: UserEmailsSubscriptions\n  }, {\n    path: 'profile',\n    components: {\n      default: UserProfile,\n      helper: UserProfilePreview\n    }\n  }]\n}\n```\n\n## 重定向和别名\n\n### 重定向\n\n> - /a 重定向到 /b\n\n```js\nconst router = new VueRouter({\n  routes: [\n    { path: '/a', redirect: '/b' },\n    { path: '/a', redirect: { name: 'foo' }},\n    { path: '/a', redirect: to => {\n      // 方法接收 目标路由 作为参数\n      // return 重定向的 字符串路径/路径对象\n    }}\n  ]\n})\n```\n\n### 别名\n\n> - `/a` 的别名是 `/b`，意味着，当用户访问 `/b` 时，URL 会保持为 `/b`，但是路由匹配则为 `/a`，就像用户访问 `/a` 一样。\n\n```js\nconst router = new VueRouter({\n  routes: [\n    { path: '/a', component: A, alias: '/b' }\n  ]\n})\n```\n\n## 路由组件传参\n\n> - $route会使之其对应的路由形成高度耦合, 从而使组件只能在某些URL上是使用, 限制其灵活性\n\n### 取代$route的耦合\n\n```js\nconst User = {\n  template: '<div>User {{ $route.params.id }}</div>'\n}\nconst router = new VueRouter({\n  routes: [\n    { path: '/user/:id', component: User }\n  ]\n})\n```\n\n使用props解耦\n\n```js\nconst User = {\n  props: ['id'],\n  template: '<div>User {{ id }}</div>'\n}\nconst router = new VueRouter({\n  routes: [\n    { path: '/user/:id', component: User, props: true },\n\n    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：\n    {\n      path: '/user/:id',\n      components: { default: User, sidebar: Sidebar },\n      props: { default: true, sidebar: false }\n    }\n  ]\n})\n```\n\n### 布尔模式\n\n> props被设置成true, route.params将会被设置为组件属性\n\n### 对象模式\n\n> props是一个对象, 他会被按照原样设置为组件属性. 当props 是静态的时候有用\n\n```js\nconst router = new VueRouter({\n  routes: [\n    { \n      path: '/promotion/from-newsletter', \n       component: Promotion, \n      props: { newsletterPopup: false } \n    }\n  ]\n})\n```\n\n### 函数模式\n\n> 创建一个函数返回props, 这样子就可以将参数转换成另一种类型, 将静态值与基于路由的值结合等\n\n```js\nconst router = new VueRouter({\n routes: [\n    {\n      paht: '/search',\n      component: SearchUser, \n      props: route => ({ query: route.query.q })\n    }\n  ]\n})\n// 当URL 为/search?q=vue 会将{ query; 'vue' } 作为属性传递给 SearchUser 组件\n```\n\n## HTML5 History 模式\n\n> - vue-router 默认hash模式 : 模拟一个完整的URL , 当URL改变时, 页面不后悔重新加载,\n> - history 模式, URL就像正常的url, 例如 <http://yoursite.com/user/id>\n>   - 需要后台正确的配置\n\n```js\nconst router = new VueRouter({\n  mode: 'history',\n  routes: [\n    { path: '*', component: NotFoundComponent }\n  ]\n})\n```\n\n# vue-rotuer-进阶\n\n## 导航守卫\n\n> - 参数或查询的改变不会进去或离开导航守卫\n>   - 可以通过观察$route对象来应对这些变化, 或beforeRouteUpdate 的组件类守卫\n\n### 全局前置守卫\n\n```js\nconst router = new VueRouter({ ... })\n\nrouter.beforeEach((to, from, next) => {\n  // ...\n})\n```\n\n> - to : Route : 即将要进入的目标\n> - from : Rotue :  当前导航正要离开的路由\n> - next: Function :\n>   - next() : 进行管道中的下一个钩子. 如果全部钩子执行网, 则导航状态就是confirmed( 确认 )\n>   - next( false ): 中断当前的导航. 如果浏览器的URL改变了, 可能是用户手动或者浏览器后退按钮, URL地址会重置到from 路由对应的地址\n>   - next('/') 或 next({ path: '/' })  : 跳转到一个不同的地址, 当前的导航被中断, 然后进行一个新的导航\n>     - 且可以设置replace: true, name: 'home'等\n>   - next(error) : (2.4.0+) 如果传入next 的参数是一个Error 实例, 则导航会被终止且该错误会被传递给rotuer.onError()注册过的回调\n\n```js\nrouter.beforeEach((to, from, next) => {\n if ( to.name !== 'Login' && !isAuthenticated ) next({ name: 'Login '}) \n //如果用户未能验证用户 , 则 next 会被调用两次\n  next()\n})\n```\n\n### 全局解析守卫\n\n> 2.3.0+\n>\n> - router.beforeResolve 注册一个全局守卫,\n>   - 和router.beforeEach类似\n>   - 区别\n>     - 在导航确认之前, 同时在所有组件内守卫和异步路由组件被解析之后, 解析守卫就被调用\n\n### 全局后置钩子\n\n```js\nrouter.afterEach((to, from) =>{\n // ...\n})  \n```\n\n### 路由独享的守卫\n\n> 直接在路由配置直接定义beforeEnter守卫\n\n```js\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/foo',\n      component: Foo,\n      beforeEnter: (to, from, next) => {\n        // ...\n      }\n    }\n  ]\n})\n```\n\n### 组件内的守卫\n\n> - beforeRouteEnter\n> - beforeRouteUpdate (2.2+)\n> - beforeRouteLeave\n\n```js\nconst Foo = {\n  template: `...`,\n  beforeRouteEnter (to, from, next) {\n    // 在渲染该组件的对应路由被 confirm 前调用\n    // 不！能！获取组件实例 `this`\n    // 可以通过next(vm => {/* 通过`vm` 访问实例 */})\n    // 因为当守卫执行前，组件实例还没被创建\n  },\n  beforeRouteUpdate (to, from, next) {\n    // 在当前路由改变，但是该组件被复用时调用\n    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n    // 可以访问组件实例 `this`\n  },\n  beforeRouteLeave (to, from, next) {\n    // 导航离开该组件的对应路由时调用\n    // 可以访问组件实例 `this`\n  }\n}\n```\n\n### 完整导航解析流程\n\n> 1. 导航被触发\n> 2. 在失活的组件调用 beforeRouteLeave 守卫\n> 3. 调用全局的 beforeEach 守卫\n> 4. 在重用的组件里面调用 beforeRouteUpdate 守卫 (2.2+)\n> 5. 在路由配置里调用 beforeEnter\n> 6. 解析异步路由组件\n> 7. 在被激活的组件里面调用 beforeRouteEnter\n> 8. 调用全局的 beforeResolve 守卫(2.5+)\n> 9. 导航被确认\n> 10. 调用全局afterEach 钩子\n> 11. 触发DOM 更新\n> 12. 调用 beforeRouteEnter 守卫中传给 next 的回调函数, 创建好的组件实例会作为调用函数的参数传入\n\n## 路由元信息\n\n> 定义路由的时候可以通过配置meta字段\n\n```js\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/foo',\n      component: Foo,\n      children: [\n        {\n          path: 'bar',\n          component: Bar,\n          // a meta field\n          meta: { requiresAuth: true }\n        }\n      ]\n    }\n  ]\n})\n```\n\n```js\nrouter.beforeEach((to, from, next) => {\n  if (to.matched.some(record => record.meta.requiresAuth)) {\n    // this route requires auth, check if logged in\n    // if not, redirect to login page.\n    if (!auth.loggedIn()) {\n      next({\n        path: '/login',\n        query: { redirect: to.fullPath }\n      })\n    } else {\n      next()\n    }\n  } else {\n    next() // 确保一定要调用 next()\n  }\n})\n```\n\n## 过渡特效\n\n```html\n//使用动态的 transition name\n<transition :name=\"transitionName\">\n  <router-view></router-view>\n</transition>\n\n// 接着在父组件内\n// watch $route 决定使用哪种过渡\nwatch: {\n  '$route' (to, from) {\n    const toDepth = to.path.split('/').length\n    const fromDepth = from.path.split('/').length\n    this.transitionName = toDepth < fromDepth ? 'slide-right' : 'slide-left'\n  }\n}\n```\n\n## 数据获取\n\n### 导航完成后获取数据\n\n```html\n<template>\n  <div class=\"post\">\n    <div v-if=\"loading\" class=\"loading\">\n      Loading...\n    </div>\n\n    <div v-if=\"error\" class=\"error\">\n      {{ error }}\n    </div>\n\n    <div v-if=\"post\" class=\"content\">\n      <h2>{{ post.title }}</h2>\n      <p>{{ post.body }}</p>\n    </div>\n  </div>\n</template>\n```\n\n```js\nexport default {\n  data () {\n    return {\n      loading: false,\n      post: null,\n      error: null\n    }\n  },\n  created () {\n    // 组件创建完后获取数据，\n    // 此时 data 已经被 observed 了\n    this.fetchData()\n  },\n  watch: {\n    // 如果路由有变化，会再次执行该方法\n    '$route': 'fetchData'\n  },\n  methods: {\n    fetchData () {\n      this.error = this.post = null\n      this.loading = true\n      // replace getPost with your data fetching util / API wrapper\n      getPost(this.$route.params.id, (err, post) => {\n        this.loading = false\n        if (err) {\n          this.error = err.toString()\n        } else {\n          this.post = post\n        }\n      })\n    }\n  }\n}\n```\n\n### 导航完成前获取数据\n\n```js\nexport default {\n  data () {\n    return {\n      post: null,\n      error: null\n    }\n  },\n  beforeRouteEnter (to, from, next) {\n    getPost(to.params.id, (err, post) => {\n      next(vm => vm.setData(err, post))\n    })\n  },\n  // 路由改变前，组件就已经渲染完了\n  // 逻辑稍稍不同\n  beforeRouteUpdate (to, from, next) {\n    this.post = null\n    getPost(to.params.id, (err, post) => {\n      this.setData(err, post)\n      next()\n    })\n  },\n  methods: {\n    setData (err, post) {\n      if (err) {\n        this.error = err.toString()\n      } else {\n        this.post = post\n      }\n    }\n  }\n}\n```\n\n## 滚动行为\n\n> - 只支持history.pushState 的浏览器中可用\n\n```js\nconst router = new VueRouter({\n  routes: [...],\n  scrollBehavior (to, from, savedPosition) {\n    // savePosition 当且仅当 popsate导航到 (浏览器 的前进/后退 按钮触发) 时才可用\n    // return 期望滚动到哪个的位置 \n       //{ x: number, y: number }\n    //{ selector: string, offset? : { x: number, y: number }} (offset 只在 2.6.0+ 支持)\n  }\n})\n```\n\n```js\n//异步滚动\nscrollBehavior (to, from, savedPosition) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve({ x: 0, y: 0 })\n    }, 500)\n  })\n}\n```\n\n## 路由懒加载\n\n> - 当路由被访问的时候才加载对应组件, 这样子就更加高效\n\n结合Vue的异步组件和Webpack 的代码分割功能\n\n```\nconst Foo =() => Promise.resolve({ /* 组件定义对象 */});\n//Webpack 2中, 动态import 语法来一定代码分块点(split point)\nimport('./Foo.vue')\n```\n\n> 注: 使用Babel 需要添加syntax-dynamic-import 插件, 才能使 Babel 可以正确地解析语法\n\n```\nconst Foo = ()  => import('./Foo.vue')\n\n\nconst router = new VueRouter({\n routes: [\n  { path: '/foo ', component: Foo }\n ]\n})\n```\n\n### 把组件按组分块\n\n有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用 [命名 chunk](https://webpack.js.org/guides/code-splitting-require/#chunkname)，一个特殊的注释语法来提供 chunk name (需要 Webpack > 2.4)。\n\n```js\nconst Foo = () => import(/* webpackChunkName: \"group-foo\" */ './Foo.vue')\nconst Bar = () => import(/* webpackChunkName: \"group-foo\" */ './Bar.vue')\nconst Baz = () => import(/* webpackChunkName: \"group-foo\" */ './Baz.vue')\n```\n\nWebpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中。\n","children":[]},{"name":"vuex.md","path":"../guanruihua.github.io/Front-End/框架/vue","data":"# vuex\n\n> 状态管理模式来纪中管理状态或信息\n\n## 使用vuex\n\nstore.js\n\n```js\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n  state: {\n    count : 1,\n    msg: 'msg',\n  },\n  mutations: {\n    \n  }, \n  action: {\n    \n  }\n})\n```\n\napp.js\n\n```js\nexport default {\n  data(){\n    return ({\n      msg: 'hello',\n    })\n  },\n  computed: {\n    count() {\n      return this.$store.state.count;//获取单个状态\n    }\n  }\n}\n```\n\n## State\n\nstore.js\n\n```js\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nVue.use(Vuex);\n\nexport default new Vuex.Store({\n  state: {\n    count: 0,\n    msg: 'msg'\n  }\n})\n```\n\napp.vue\n\n```js\nimport { mapState } from 'vuex'\nexport defualt {\n  data(){\n    msg: 'grh',\n  }\n  //方法一\n  computed: mapState({\n    msg() {\n     return this.msg + 'hello'; \n    },\n    msg2(state) {\n      return state.msg;\n    }\n  })\n   //方法二: 使用解构符号...\n    computed: {\n     ...mapState(['count','msg']);\n    }\n}\n```\n\n## Getter\n\nstore.js\n\n```js\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nVue.use(Vuex);\n\nexport default new Vuex.Store({\n  state: {\n    count: 0,\n    msg: 'msg',\n    list: [1, 2, 3, 4]\n  },\n  getters: {\n    modifyArr(state) {\n      return state.list.filter((item, index, arr) =>{\n       return item % 2 == 0;\n      })\n    }\n  }\n})\n```\n\napp.js\n\n```js\nexport default {\n  //方法一\n   computed: {\n     list() {\n       return this.$store.getters.modifyArr;\n     }\n   }\n  //方法二 : mapGetters\n  computed: {\n   ...mapGetters(['modifyArr'])\n    ...mapGetters({getList:'modifyArr'})//指定别名\n }\n}\n```\n\n## Mutation\n\n> - 可以修改store里面的状态\n>\n> - 必须是**同步函数**\n>\n> - 最好在store中先初始化所需要的属性\n>\n> - 当需要添加属性时, 使用Vue.set(obj, 'newProp', 123)或用新的对象替换老对象\n>\n>   - ```js\n>     mutation: {\n>       addNewState(state, payload){\n>         Vue.set(state, 'newProp', '添加一个新的值');\n>         //另外一个种\n>         this.replaceStae({...state, newProp: '添加一个新值! ' })\n>       }\n>     }\n>     \n>     methods: {\n>       addNewProp() {\n>         this.$store.commit('addNewState', {});\n>       }\n>       newMsg() {\n>         return this.$store.state.newProp || '还没有添加新值';\n>       }\n>     }\n>     ```\n\n```js\nimport { mapMutation } from 'vuex'\nmethods: {\n  add() {\n    this.$store.commit('add');\n  },\n  reduce() {\n    this.$store.commit('reduce');\n  },\n  loadAdd() {\n    \n    this.$store.commit('loadAdd', 100)\n    this.$store.commit('loadAdd', {\n     extraCount: 100\n    })//传输额外的参数\n    \n    this.$store.commit({\n      type:'addLoad'\n      extraCount: 100\n    },{}) //将多个写在一个上                  \n  },\n    \n  //mapMutation using\n  ...mapMutations([\n    'increment',//将`this.increment`映射为'this.$store.commit(increment)'\n    'incrementBy',//将'this.incrementBy(amount)'映射为'this.$store.commit('incrementBy', amount)'\n  ])\n  // 取别名\n  ...mapMutations([\n    add: 'increment',\n    get: 'incrementBy',\n  ])\n  \n}\n\n//store.js\nmutations: {\n  add(state) {\n    state.count++;\n  },\n  reduce(state) {\n    state.count--;\n  },\n  loadAdd(state, payload) {  // 提交载荷，额外参数\n    state.count += payload;\n  },\n},\n\n\n```\n\n## Action\n\n> - 可以自行异步操作,\n> - 类似于Mutation\n> - 不可以直接修改state\n\n```js\nactions: {\n  changeProduct(context, payload) { // 这个context是一个与 store 实例具有相同方法和属性的对象\n    // 调用mutation里的changeProduct方法\n    // context.commit('changeProduct', {change: 'ship'});\n    // 改成异步方式\n    // setTimeout(() => {\n    //   context.commit('changeProduct', {change: 'ship'});\n    // }, 1500)\n    // 使用载荷\n    let temp = 'ship+' + payload.extraInfo; \n    setTimeout(() => {\n      context.commit('changeProduct', {change: temp});\n    }, 1500)\n  }\n}\n\n\nmethods: {\n  selectProduct() {\n    // this.$store.dispatch('changeProduct')\n    // 载荷方式分发\n    // this.$store.dispatch('changeProduct', {\n    //   extraInfo: 'sportcar'\n    // })\n    // 或者这种\n    this.$store.dispatch({\n      type: 'changeProduct',\n      extraInfo: '->sportcar'\n    })\n  }\n},\n```\n\n利用Promise\n\n```js\nstate: {\n userInfo: {\n   name: 'guan',\n    age:23,\n  }\n},\nmutation: {\n changeInfo(state, payload) {\n    state.userInfo.name = 'ruihua'\n  }\n},\nactions: {\n changeInfo(context, payload) {\n    return new Promise( (resolve, reject) => {\n      setTimeout(() => {\n        context.commit('changeInfo');\n        resolove();\n      },2000)\n    })\n  }\n}\n  \n//app.js\n  \ndata() {\n  return {\n    status: 'no changed',\n  }\n},\nmethods: {\n  modifyInfo() {\n  this.$store.dispatch('changeInfo')\n  }\n}\n```\n\naction可以相互调用\n\n```js\nactions: {\n  actionA ({ commit }) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        commit('someMutation')\n        resolve()\n      }, 1000)\n    })\n  },\n  actionB ({ dispatch, commit }) {\n    return dispatch('actionA').then(() => {//调用了actionA\n      commit('someOtherMutation')\n    })\n  }\n}\n\n```\n\n## Module\n\n### 分模块管理方法\n\n```js\n//先定义两个模块\nconst moduleA = {\n state: {\n   name: 'guan',\n    age: '23'\n  },\n  mutations: {},\n  getters: {},\n  action: {},\n}\n\nconst moduleB = {\n state: {\n   name: 'rui',\n    age: '22'\n  },\n  mutations: {},\n  getters: {},\n  action: {},\n}\n\n//在Vuex里面声明模块\nexport default new Vuex.Store({\n modules: {\n   ma: moduleA,\n    mb: moduleB\n  },\n  state: {\n    ...//其他状态\n  },\n})\n  \n  \n//app.vue\ncompute: {\n msg() {\n  return this.$store.mb; //{name: 'rui', age: '22'} \n }\n}\n```\n\n### 命名空间模块\n\n```js\nexport const moduleC = {\n  namespaced: true,\n  state: {\n    name: 'moduleC',\n    desc: '这是模块C，用来测试命名空间的！',\n    list: [1, 2, 3, 4]\n  },\n  getters: {\n    filterList(state) {\n      return state.list.filter((item, index, arrSelf) => {\n        return item % 2 !== 0;\n      });\n    }\n  },\n  mutations: {\n    modifyName(state, payload) {\n      state.name = payload.newName;\n    }\n  },\n  actions: {\n    \n  }\n}\n//store.js\nimport { moduleC } from './module_c.js';\n\nexport default new Vuex.Store({\n  modules: {\n    mc: moduleC\n  },\n})\n\nmethods: {\n  modify() {\n    // this.$store.commit('mc/modifyName', {\n    //   newName: '命名空间模块C'\n    // })\n    this.$store.commit({\n      type: 'mc/modifyName',\n      newName: '命名空间模块C'\n    })\n  }\n}\n\n\n//命名空间发生改变后,mapState,mapGetters, mapMutations, mapActions用法改变\n// 1.\n...mapState('mc', ['name', 'age']);\n...mapState('mc', {\n name(state) {\n    return state.name;\n  },\n  age(state) {\n    return state.age;\n  }\n})\n// 2. 使用createNamespacedHelpers创建基于某个命名空间辅助函数\nimport { createNamespacedHelpers } from 'vuex';\nconst { mapState, mapMutations } = createNamespacedHelpers('mc');\n```\n\n```vue\n<script>\n\nimport { mapGetters, mapState, mapMutations, mapActions } from 'vuex'\n\nexport default {\n computed:{\n  ...mapState('loginStore',['text', 'num']),\n },\n methods: {\n    // 这里的loginStore 是 命名空间\n  ...mapGetters('loginStore', ['getData']),\n  ...mapMutations('loginStore',['add']),\n  ...mapActions('loginStore', ['addAction']),\n\n}\n</script>\n```\n\n## vuex与v-model对数据处理\n\n```js\n <input v-model=\"message\">\n computed: {\n  message: {\n    get () {\n      return this.$store.state.obj.message\n    },\n    set (value) {\n      this.$store.commit('updateMessage', value)\n    }\n  }\n}\n\n\nmutations: {\n  updateMessage (state, message) {\n    state.obj.message = message\n  }\n}\n\n```\n","children":[]},{"name":"文件相关","path":"../guanruihua.github.io/Front-End/框架/vue","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Front-End/框架/vue/文件相关","data":"# 文件相关\n\n> [Vue项目导入导出csv文件](https://www.cnblogs.com/wjw1014/p/13150412.html)\n>\n> [前端 vue表格数据导出Excel 文件实现](https://www.cnblogs.com/zhaoxiaobei/p/10912432.html)","children":[]}]}]},{"name":"微前端","path":"../guanruihua.github.io/Front-End/框架","data":"","children":[{"name":"Garfish.md","path":"../guanruihua.github.io/Front-End/框架/微前端","data":"# Carfish\r\n\r\n<https://www.garfishjs.org/guide>\r\n","children":[]},{"name":"icestark.md","path":"../guanruihua.github.io/Front-End/框架/微前端","data":"# icestark\r\n\r\n<https://micro-frontends.ice.work/docs/guide>\r\n","children":[]},{"name":"qiankun","path":"../guanruihua.github.io/Front-End/框架/微前端","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Front-End/框架/微前端/qiankun","data":"# qiankun\r\n\r\n<https://github.com/umijs/qiankun/discussions/1378>\r\n","children":[]}]}]},{"name":"错误","path":"../guanruihua.github.io/Front-End/框架","data":"","children":[{"name":"npm错误.md","path":"../guanruihua.github.io/Front-End/框架/错误","data":"# npm错误\n\n## npm WARN build `npm build` called with no arguments. Did you mean to `npm run-script build`\n\n> 把指令`npm run` 换成`npm run build`\n\n## 执行 npm 命令时报错：Allocation failed - JavaScript heap out of memory\n\n法一：添加参数 --max_old_space_size=4096\n\nnpm run start --max_old_space_size=4096\n\n法二：修改cmd文件\n\n在目录node_modules/.bin下打开ng.cmd和ngc.cmd文件，添加 --max_old_space_size=4096\n\n![img](https://img-blog.csdnimg.cn/20201030160512476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODg4MzMzOA==,size_16,color_FFFFFF,t_70)\n","children":[]},{"name":"sockjs-node.md","path":"../guanruihua.github.io/Front-End/框架/错误","data":"# <http://localhost:8080/sockjs-node/info?t=1556418283950> net:: ERR_CONNECTION_REFUSED\n\n> sockjs-node 是一个JavaScript库，提供跨浏览器JavaScript的API，创建了一个低延迟、全双工的浏览器和web服务器之间通信通道。\n>\n> 服务端：sockjs-node（<https://github.com/sockjs/soc>…）\n> 客户端：sockjs-client（<https://github.com/sockjs/soc>…）\n>\n> 开发时，如果变更网络环境（如切换wifi导致开发服务器的IP地址更换），服务器不知道如何确定访问源，就有可能造成上述情况\n>\n\n## 方法一\n\n> 找到/node_modules/sockjs-client/dist/sockjs.js\n> 找到代码的 1605行\n> self.xhr.send(payload);\n>\n> 可在代码开发完成后关闭，会同步关闭热加载\n\n## 方法二\n\n> /package-lock.json\n> 关闭开发环境时的 sockjs 接口\n> dev 设置为false\n","children":[]}]},{"name":"问题","path":"../guanruihua.github.io/Front-End/框架","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Front-End/框架/问题","data":"# vue 和 react 异同\n\n## 前言\n\nReact 是由 Facebook 创建的JavaScript UI框架，React推广了 Virtual DOM( 虚拟 DOM )并创造了 JSX 语法。JSX 语法的出现允许我们在 javascript 中书写 HTML 代码。\n\nVUE 是由尤雨溪开发的，VUE 使用了模板系统而不是JSX，因其实模板系统都是用的普通的 HTML，所以对应用的升级更方便、更容易，而不需要整体重构。\n\nVUE 相较于 React 更容易上手，如果是一个有一定开发经验的开发者，甚至都不需要花额外的时间去学习，直接一遍开发一遍查文挡即可。\n\n## VUE 与 React 区别\n\nReact 的思路是 HTML in JavaScript 也可以说是 All in JavaScript，通过 JavaScript 来生成 HTML，所以设计了 JSX 语法，还有通过 JS 来操作 CSS，社区的styled-component、JSS等。\n\nVue 是把 HTML，CSS，JavaScript 组合到一起，用各自的处理方式，Vue 有单文件组件，可以把 HTML、CSS、JS 写到一个文件中，HTML 提供了模板引擎来处理。\n\n如下是两者的生命周期对比：\n\n**React 生命周期**\n\n![img](Untitled.assets/v2-6ee99a888a64a8ca3791619ba0c78404_720w.jpg)\n\n**VUE生命周期**\n\n![img](Untitled.assets/v2-ec66c24f04704fa6eb569a5e27bf40f6_720w.jpg)\n\nReact 整体是函数式的思想，在 React 中是单向数据流，推崇结合 immutable 来实现数据不可变。而 Vue 的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立 Watcher 来监听，当属性变化的时候，响应式的更新对应的虚拟 DOM。\n\n如上，所以 React 的性能优化需要手动去做，而Vue的性能优化是自动的，但是Vue的响应式机制也有问题，就是当 state 特别多的时候，Watcher 会很多，会导致卡顿。\n\n## React 与 VUE 共同点\n\nReact 与 Vue 存在很多共同点，例如他们都是 JavaScript 的 UI 框架，专注于创造前端的富应用。不同于早期的 JavaScript 框架“功能齐全”，Reat 与 Vue 只有框架的骨架，其他的功能如路由、状态管理等是框架分离的组件。\n\n## 优势\n\n**React**\n\n- 灵活性和响应性：它提供最大的灵活性和响应能力。\n- 丰富的JavaScript库：来自世界各地的贡献者正在努力添加更多功能。\n- 可扩展性：由于其灵活的结构和可扩展性，React已被证明对大型应用程序更好。\n- 不断发展： React得到了Facebook专业开发人员的支持，他们不断寻找改进方法。\n- Web或移动平台： React提供React Native平台，可通过相同的React组件模型为iOS和Android开发本机呈现的应用程序。\n\n**Vue**\n\n- 易于使用： Vue.js包含基于HTML的标准模板，可以更轻松地使用和修改现有应用程序。\n- 更顺畅的集成：无论是单页应用程序还是复杂的Web界面，Vue.js都可以更平滑地集成更小的部件，而不会对整个系统产生任何影响。\n- 更好的性能，更小的尺寸：它占用更少的空间，并且往往比其他框架提供更好的性能。\n- 精心编写的文档：通过详细的文档提供简单的学习曲线，无需额外的知识; HTML和JavaScript将完成工作。\n- 适应性：整体声音设计和架构使其成为一种流行的JavaScript框架。它提供无障碍的迁移，简单有效的结构和可重用的模板。\n\n## 总结\n\n如上所说的 Vue 的响应式机制也有问题，当 state 特别多的时候，Watcher 会很多，会导致卡顿，所以大型应用（状态特别多的）一般用 React，更加可控。可对于易用性来说，VUE 是更容易上手的，对于项目来说新人更容易接手。\n\n使用 Reac 的公司：Facebook，Instagram，Netflix，纽约时报，雅虎，WhatsApp，Codecademy，Dropbox，Airbnb，Asana，微软等。\n\n使用 Vue 的公司：Facebook，Netflix，Adobe，Grammarly，Behance，小米，阿里巴巴，Codeship，Gitlab和Laracasts等。\n\n所以，技术没有哪个更好或者是更优秀，只要适合自己的才是最合适的。\n","children":[]}]}]},{"name":"浏览器","path":"../guanruihua.github.io/Front-End","data":"","children":[{"name":"favicon.md","path":"../guanruihua.github.io/Front-End/浏览器","data":"# favicon\n\n> [Favicon & App Icon Generator (favicon-generator.org)](https://www.favicon-generator.org/)\n","children":[]},{"name":"meta.md","path":"../guanruihua.github.io/Front-End/浏览器","data":"# Meta\n\n> [Meta Tags](https://metatags.io/) 编辑生成用于社交网络等站点的元标签，并预览效果","children":[]},{"name":"seo.md","path":"../guanruihua.github.io/Front-End/浏览器","data":"# SEO\r\n\r\n## 1.使用HTTPS\r\n\r\n谷歌曾发公告表示，使用安全加密协议（HTTPS），是搜索引擎排名的一项参考因素。\r\n所以，在域名相同情况下，HTTPS站点比HTTP站点，能获得更好的排名。\r\n在网络渠道分发或合作上，有优势。比如微信、QQ等渠道平台，链接是否是HTTPS协议，是第一道关卡，必须满足才行。\r\n一个网站，如果不设置HTTPS，基本可以判断该网站的流量完全依赖搜索引擎。\r\n导致的问题是，网站无法最大价值化，流量来源局限性大，网站盈利几率大打折扣。\r\n另外，还有以下好处：\r\n\r\n- 有利于保护搜索快照，增加快照被篡改的难度\r\n- 增加被仿站镜像的难度\r\n- 增加被抄袭文章内容的难度\r\n- 防止被轻易篡改页面内容\r\n- 用户体验感更好，不会被提示为不安全网站\r\n\r\n## 2.确保页面快速加载\r\n\r\n从2010年起，谷歌一直把页面速度作为排名因素（将网速列为网页搜索排名因素）。\r\n如果网站加载缓慢，会损害站点的搜索排名。\r\n推荐使用PageSpeed Insights 对站点进行全方位的体检，以满足搜索引擎的要求。\r\n以下是我的电子手册网站的体检结果：\r\n\r\n## 3.设置好有流量潜力的关键词\r\n\r\n关键词是SEO中非常重要的一部分。高频命中用户搜索的单词和短语，可以让站点提升排名，带来更多目标流量。\r\n技术上的实现，是在head中，加入keywords：\r\n\r\n```html\r\n<head>\r\n <meta name=\"keywords\" content=\"快速排序,quick sort\" data-rh=\"true\">\r\n</head>\r\n```\r\n\r\n## 4、使用简明扼要的URL\r\n\r\n使用精确的目标关键词作为URL是一个不错的方法。\r\n看链接就可以知道是相关内容\r\n\r\n这样，对用户体验友好，增加点击率。\r\n\r\n## 5、编写一个引人注目的标题和描述\r\n\r\n为什么要写好标题和描述，一个重要的原因是：它会显示在搜索结果中：\r\n\r\n这样，用户可以从搜索结果的页面中，可以快速获知页面内容。从而吸引潜在用户，点击当前页面进行浏览。\r\n技术上的实现如下:\r\n\r\n```html\r\n\r\n<head>\r\n  <title>快速排序 | 前端面试手册</title>\r\n  <meta name=\"description\" content=\"使用快速排序，对数组进行排序\" data-rh=\"true\">\r\n  <meta property=\"og:title\" content=\"快速排序 | 前端面试手册\" data-rh=\"true\">\r\n  <meta property=\"og:description\" content=\"使用快速排序，对数组进行排序\" data-rh=\"true\">\r\n</head>\r\n```\r\n\r\n## 6、加入内链\r\n\r\n内链指的是：从你的网站的一个页面指向另外一个页面。\r\n一般来说，页面从内部和外部，获得的链接越多，则页面的搜索排名，会更高。\r\n这也可以说明，很多博客类网站，会在外链设置`rel=\"nofollow\"`的原因：避免页面的权重被外链分散。\r\n\r\n## 7、获取更多的外链\r\n\r\n外链是谷歌算法的基础，并且是最重要的排名要素之一。\r\n谷歌认为，其他知名的网站都链接到该页面，则表明该页面的内容是高质量的。\r\n外链的好处：\r\n\r\n- 提升网站的权重\r\n- 增加网站的信任度\r\n- 吸引爬虫抓取网站\r\n- 提升网站页面收录情况\r\n- 提升关键词排名\r\n- 给网站带来流量\r\n","children":[]},{"name":"URL.md","path":"../guanruihua.github.io/Front-End/浏览器","data":"# URL\n\n## 获取URL?后的参数\n\n```js\n/**\n   * 获取url后的 id 文章id\n   */\n  function getUrlData() {\n    var url = window.location.search; //url中?之后的部分\n    url = url.substring(1); //去掉?\n    var dataObj = {};\n    if (url.indexOf('&') > -1) {\n      url = url.split('&');\n      for (var i = 0; i < url.length; i++) {\n        var arr = url[i].split('=');\n        dataObj[arr[0]] = arr[1];\n      }\n    } else {\n      url = url.split('=');\n      dataObj[url[0]] = url[1];\n    }\n    /**\n     * 获取url id的值\n     */\n    if (dataObj.id) {\n      return dataObj.id;\n    }else{\n        return \"没有这个属性\"\n    }\n  }\n  console.log(getUrlData());\n```\n","children":[]},{"name":"User Agent Stylesheet.md","path":"../guanruihua.github.io/Front-End/浏览器","data":"# User Agent Stylesheet\n\n> - Gecko (Firefox):\n>   https://searchfox.org/mozilla-central/source/layout/style/res/html.css\n>\n> - Chromium (Chrome):\n>   https://chromium.googlesource.com/chromium/src/third_party/+/master/blink/renderer/core/html/resources/html.css\n>\n> - WebKit (Safari):\n>   https://trac.webkit.org/browser/trunk/Source/WebCore/css/html.css\n\n","children":[]},{"name":"Web Api","path":"../guanruihua.github.io/Front-End/浏览器","data":"","children":[{"name":"localStorage.md","path":"../guanruihua.github.io/Front-End/浏览器/Web Api","data":"# LocalStorage\n\n> - 长度:\n>   - 10M的字节数\n>   - 5M，单位就是字符串的长度，而不是字符数。\n>\n> - localStorage 存储的键和值始终采用 UTF-16 DOMString 格式，每个字符使用两个字节。与对象一样，整数键将自动转换为字符串。\n>   - 每个字符使用两个字节，是有前提条件的，就是码点小于`0xFFFF`(65535)， 大于这个码点的是四个字节。\n>\n- 特点:\n\n1. 存储到浏览器的会话中, localStorage的数据可以长期保存\n2. localStorage的键值对是以字符串的形式存储\n3. localStorage 目前是支持IE8以上的浏览器\n4. 解决了cookie存储空间不足的问题 cookie最大4k localStorage 最大为5M\n5. 特定于页面的协议\n\n- 添加&&修改\n\n```js\n/*\n * key存在时, 则是修改key对应的value\n */\nlocalStorage.setItem('test','this is a test');\n```\n\n- 读取\n\n```\nlocalStorage.getItem('test');\n```\n\n- 删除\n\n```\nlocalStorage.removeItem('test');\n```\n\n- 删除全部 localStorage\n\n```\nlocalStorage.clear();\n```\n","children":[]},{"name":"location.md","path":"../guanruihua.github.io/Front-End/浏览器/Web Api","data":"# Location\n\n## 属性\n\n### ancestorOrigins\n\n> [Location](https://developer.mozilla.org/zh-CN/docs/Web/API/Location)接口的 **`ancestorOrigins`** 只读属性是一个静态的[DOMStringList](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMStringList)，倒序排列了此[Location](https://developer.mozilla.org/zh-CN/docs/Web/API/Location)接口的 **`ancestorOrigins`** 只读属性是一个静态的[`DOMStringList`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMStringList)，倒序排列了此[Location](https://developer.mozilla.org/zh-CN/docs/Web/API/Location)对象所属文档先前所有浏览上下文的来源。\n>\n> 你可以在脚本中使用`location.ancestorOrigins`来检测你的网页是否被你不希望的对象嵌入了。你也可以使用它让网页在被特定站点嵌入时做出不同的表现。\n\n```js\nconst ancestors = location.ancestorOrigins;\n```\n\n### hash\n\n> Location 接口的 hash 属性返回一个 USVString，其中会包含URL标识中的 '#' 和 后面URL片段标识符。\n>\n> 这里 fragment 不会经过百分比编码（URL编码）。如果 URL 中没有 fragment，该属性会包含一个空字符串，\"\"\n\n```js\n// string = object.hash;\n// object.hash = string;\n\n<a id=\"myAnchor\" href=\"/en-US/docs/Location.href#Examples\">Examples</a>\n<script>\n  var anchor = document.getElementById(\"myAnchor\");\n  console.log(anchor.hash); // 返回'#Examples'\n</script>\n```\n\n### host\n\n> Location 接口的 host 属性是包含了主机的一段 USVString，其中包含：主机名，如果 URL 的端口号是非空的，还会跟上一个 ':' ，最后是 URL 的端口号。\n\n```js\n\n// string = object.host;\n// object.host = string;\n\nvar anchor = document.createElement(\"a\");\n\nanchor.href = \"https://developer.mozilla.org/en-US/Location.host\"\nanchor.host == \"developer.mozilla.org\"\n\nanchor.href = \"https://developer.mozilla.org:443/en-US/Location.host\"\nanchor.host == \"developer.mozilla.org\"\n// 这里 host 中没有包含端口号，因为 443 是 https协议的默认端口号\n\nanchor.href = \"https://developer.mozilla.org:4097/en-US/Location.host\"\nanchor.host == \"developer.mozilla.org:4097\"\n```\n\n### hostname\n\n> Location的 hostname 属性是包含了域名的一段 USVString。\n\n```js\n// string = object.hostname;\n// object.hostname = string;\n\n// 在文档流中声明了一个元素： <a id=\"myAnchor\" href=\"https://developer.mozilla.org/en-US/docs/Location.hostname\">\nvar anchor = document.getElementById(\"myAnchor\");\nvar result = anchor.hostname; // Returns:'developer.mozilla.org'\n```\n\n### href\n\n> Location 接口的 href 属性是一个字符串化转换器(stringifier), 返回一个包含了完整 URL 的 USVString 值, 且允许 href 的更新.\n\n```js\n// string = object.href;\n// object.href = string;\n\n// 假设文档中包含标签： <a id=\"myAnchor\" href=\"https://developer.mozilla.org/en-US/Location/href\">\nvar anchor = document.getElementById(\"myAnchor\");\nvar result = anchor.href; // 返回: 'https://developer.mozilla.org/en-US/Location/href'\n```\n\n### origin\n\n> The origin read-only property of the Location interface is a USVString containing the Unicode serialization of the origin of the represented URL.\n>\n> - for URL using the http or https, the scheme followed by '://', followed by the domain, followed by ':', followed by the port (the default port, 80 and 443 respectively, if explicitly specified);\n> - for URL using file: scheme, the value is browser dependant;\n> - for URL using the blob: scheme, the origin of the URL following blob:. E.g \"blob:<https://mozilla.org>\" will have \"https://mozilla.org\".\n> - Note: This feature is available in Web Workers\n\n```js\n// string = object.origin;\n// Copy to Clipboard\n// On this page, returns the origin\nvar result = window.location.origin; // Returns:'https://developer.mozilla.org'\n```\n\n### password\n\n> Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.\n>\n> The password property of the Location interface is a USVString containing the password specified before the domain name.\n>\n> If it is set without first setting the username property, it silently fails.\n\n```js\n// string = object.password;\n// object.password = string;\n// Let's <a id=\"myAnchor\" href=\"https://anonymous:flabada@developer.mozilla.org/en-US/docs/location.username\"> be in the document\nvar anchor = document.getElementByID(\"myAnchor\");\nvar result = anchor.password; // Returns:'flabada'\n```\n\n### pathname\n\n> The pathname property of the Location interface is a USVString containing the path of the URL for the location, which will be the empty string if there is no path.\n\n```js\n// string = object.pathname;\n// object.pathname = string;\n// Let's an <a id=\"myAnchor\" href=\"/en-US/docs/Location.pathname\"> element be in the document\nvar anchor = document.getElementById(\"myAnchor\");\nvar result = anchor.pathname; // Returns:'/en-US/docs/Location.pathname'\n```\n\n### port\n\n> The port property of the Location interface is a USVString containing the port number of the URL. If the URL does not contain an explicit port number, it will be set to ''.\n\n```js\n// string = object.port;\n// object.port = string;\n// Let's an <a id=\"myAnchor\" href=\"https://developer.mozilla.org:443/en-US/docs/Location.port\"> element be in the document\nvar anchor = document.getElementByID(\"myAnchor\");\nvar result = anchor.port; // Returns:'443'\n```\n\n### protocol\n\n> The protocol property of the Location interface is a USVString representing the protocol scheme of the URL, including the final ':'.\n\n```js\n// string = object.protocol;\n// object.protocol = string;\n// Let's an <a id=\"myAnchor\" href=\"https://developer.mozilla.org/en-US/Location.protocol\"> element be in the document\nvar anchor = document.getElementById(\"myAnchor\");\nvar result = anchor.protocol; // Returns:'https:'\n```\n\n### search\n\n> The search property of the Location interface is a search string, also called a query string; that is, a USVString containing a '?' followed by the parameters of the URL.\n>\n> Modern browsers provide URLSearchParams and URL.searchParams to make it easy to parse out the parameters from the querystring.\n\n```js\nstring = object.search;\nobject.search = string;\n// Let an <a id=\"myAnchor\" href=\"/en-US/docs/Location.search?q=123\"> element be in the document\nvar anchor = document.getElementById(\"myAnchor\");\nvar queryString = anchor.search; // Returns:'?q=123'\n// Further parsing:\nlet params = new URLSearchParams(queryString);\nlet q = parseInt(params.get(\"q\")); // is the number 123\n```\n\n### username\n\n> Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.\n>\n> The username property of the Location interface is a USVString containing the username specified before the domain name.\n\n```js\nstring = object.username;\nobject.username = string;\n// Let's <a id=\"myAnchor\" href=\"https://anonymous:flabada@developer.mozilla.org/en-US/docs/Location.username\"> be in the document\nvar anchor = document.getElementByID(\"myAnchor\");\nvar result = anchor.username; // Returns:'anonymous'\n```\n\n## 方法\n\n### location.assign()\n\n> Location.assign() 方法会触发窗口加载并显示指定的URL的内容。\n> 如果由于安全原因无法执行跳转，那么会抛出一个 SECURITY_ERROR 类型的 DOMException。当调用此方法的脚本来源和页面的 Location 对象中定义的来源隶属于不同域的时候，就会抛出上述错误。\n> 如果传入了一个无效的 URL，则会抛出一个 SYNTAX_ERROR 类型的 DOMException。\n\n```js\nlocation.assign(url);\n// 跳转到 Location.reload() 这篇文章\n  document.location.assign('https://developer.mozilla.org/zh-CN/docs/Web/API/Location/reload');\n```\n\n### Location.reload()\n\n> Location.reload() 方法用来刷新当前页面。该方法只有一个参数，当值为 true 时，将强制浏览器从服务器加载页面资源，当值为 false 或者未传参时，浏览器则可能从缓存中读取页面。\n> 该方法在跨域调用（执行该方法的脚本文件的域和 Location 对象所在页面的跨不同）时，将会抛出 DOMException 异常。\n\n```js\nobject.reload(forcedReload);\n\n// 无缓存刷新页面（但页面引用的资源还是可能使用缓存，\n// 大多数浏览器可以通过设置在打开开发者工具时禁用缓存实现无缓存需求）\nwindow.location.reload(true);\n// forcedReload 可选\n// 该参数要求为 布尔 (en-US) 类型，当取值为 true 时，将强制浏览器从服务器重新获取当前页面资源，而不是从浏览器的缓存中读取，如果取值为 false 或不传该参数时，浏览器则可能会从缓存中读取当前页面。\n```\n\n### Location.replace()\n\n> Location.replace() 方法以给定的URL来替换当前的资源。 与assign() 方法 不同的是，调用 replace() 方法后，`当前页面不会保存到会话历史`中（session History），这样，用户点击回退按钮时，将不会再跳转到该页面。\n> 因违反安全规则导致的赋值失败，浏览器将会抛出类型为 SECURITY_ERROR 的 DOMException 异常。当调用该方法的脚本所属的源与拥有 Location 对象所属源不同时，通常情况会发生这种异常,此时通常该脚本是存在不同的域下。\n> 如果 URL 无效，浏览器也会抛出 SYNTAX_ERROR 类型的 DOMException 异常。\n\n```JS\n// object.replace(url);\n// 参数\n// url\n//  DOMString 类型，指定所导航到的页面的 URL 地址。\n// 示例\n// Navigate to the Location.reload article by replacing this page\nwindow.location.replace('https://developer.mozilla.org/en-US/docs/Web/API/Location/reload');\n```\n\n### Location: toString()\n\n> toString()Location接口的stringifier方法返回包含整个URL的USVString}。它是Location.href的只读版本。\n\n```js\n// string = object.toString();\n// 例子\n// Let's imagine an <a id=\"myAnchor\" href=\"https://developer.mozilla.org/en-US/docs/Location/toString\"> element is in the document\nvar anchor = document.getElementById(\"myAnchor\");\nvar result = anchor.toString(); // Returns: 'https://developer.mozilla.org/en-US/docs/Location/toString'\n```\n","children":[]},{"name":"postMessage.md","path":"../guanruihua.github.io/Front-End/浏览器/Web Api","data":"# PostMessage\n\n> `window.postMessage()` 方法可以安全地实现跨源通信。\n>\n> 通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机 (两个页面的模数 [`Document.domain`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/domain)设置为相同的值) 时，这两个脚本才能相互通信。\n>\n> `window.postMessage()`方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。\n\n从广义上讲，一个窗口可以获得对另一个窗口的引用（比如 `targetWindow = window.opener`），然后在窗口上调用 `targetWindow.postMessage()` 方法分发一个  [`MessageEvent`](https://developer.mozilla.org/zh-CN/docs/Web/API/MessageEvent) 消息。接收消息的窗口可以根据需要自由[处理此事件 (en-US)](https://developer.mozilla.org/en-US/docs/Web/Events)。传递给 window.postMessage() 的参数（比如 message ）将[通过消息事件对象暴露给接收消息的窗口](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage#The_dispatched_event)。\n\n## [语法](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage#syntax)\n\n```js\notherWindow.postMessage(message, targetOrigin, [transfer]);\n```\n\n- `otherWindow`\n\n  其他窗口的一个引用，比如iframe的contentWindow属性、执行[window.open](https://developer.mozilla.org/en-US/docs/Web/API/Window/open)返回的窗口对象、或者是命名过或数值索引的[window.frames](https://developer.mozilla.org/en-US/docs/Web/API/Window/frames)。\n\n- `message`\n\n  将要发送到其他 window的数据。它将会被[结构化克隆算法](https://developer.mozilla.org/en-US/docs/DOM/The_structured_clone_algorithm)序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。[[1](https://developer.mozilla.org/en-US/docs/)]\n\n- `targetOrigin`\n\n  通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串\"*\"（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的origin属性完全一致，来防止密码被恶意的第三方截获。**如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是\\*。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。**\n\n- `transfer` 可选\n\n  是一串和message 同时传递的 [Transferable](https://developer.mozilla.org/zh-CN/docs/Web/API/Transferable) 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。\n\n## [The dispatched event](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage#the_dispatched_event)\n\n执行如下代码, 其他window可以监听分发的message:\n\n```js\nwindow.addEventListener(\"message\", receiveMessage, false);\n\nfunction receiveMessage(event){\n  // For Chrome, the origin property is in the event.originalEvent\n  // object.\n  // 这里不准确，chrome没有这个属性\n  // var origin = event.origin || event.originalEvent.origin;\n  var origin = event.origin\n  if (origin !== \"http://example.org:8080\")\n    return;\n  // ...\n}\n```\n\nCopy to Clipboard\n\n message 的属性有:\n\n- `data`\n\n  从其他 window 中传递过来的对象。\n\n- `origin`\n\n  调用 `postMessage` 时消息发送方窗口的 [origin](https://developer.mozilla.org/en-US/docs/Origin) . 这个字符串由 协议、“://“、域名、“ : 端口号”拼接而成。例如 “`https://example.org` (隐含端口 `443`)”、“`http://example.net` (隐含端口 `80`)”、“`http://example.com:8080`”。请注意，这个origin不能保证是该窗口的当前或未来origin，因为postMessage被调用后可能被导航到不同的位置。\n\n- `source`\n\n  对发送消息的[窗口](https://developer.mozilla.org/en-US/docs/Web/API/Window)对象的引用; 您可以使用此来在具有不同origin的两个窗口之间建立双向通信。\n\n\n\n## [安全问题](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage#security_concerns)\n\n**如果您不希望从其他网站接收message，请不要为message事件添加任何事件侦听器。** 这是一个完全万无一失的方式来避免安全问题。\n\n如果您确实希望从其他网站接收message，请**始终使用origin和source属性验证发件人的身份**。 任何窗口（包括例如http://evil.example.com）都可以向任何其他窗口发送消息，并且您不能保证未知发件人不会发送恶意消息。 但是，验证身份后，您仍然应该**始终验证接收到的消息的语法**。 否则，您信任只发送受信任邮件的网站中的安全漏洞可能会在您的网站中打开跨网站脚本漏洞。\n\n**当您使用postMessage将数据发送到其他窗口时，始终指定精确的目标origin，而不是\\*。** 恶意网站可以在您不知情的情况下更改窗口的位置，因此它可以拦截使用postMessage发送的数据。\n\n## [示例](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage#example)\n\n```js\n/*\n * A窗口的域名是<http://example.com:8080>，以下是A窗口的script标签下的代码：\n */\n\nvar popup = window.open(...popup details...);\n\n// 如果弹出框没有被阻止且加载完成\n// 这行语句没有发送信息出去，即使假设当前页面没有改变location（因为targetOrigin设置不对）\npopup.postMessage(\"The user is 'bob' and the password is 'secret'\",\n                  \"https://secure.example.net\");\n\n// 假设当前页面没有改变location，这条语句会成功添加message到发送队列中去（targetOrigin设置对了）\npopup.postMessage(\"hello there!\", \"http://example.org\");\n\nfunction receiveMessage(event){\n  // 我们能相信信息的发送者吗?  (也许这个发送者和我们最初打开的不是同一个页面).\n  if (event.origin !== \"http://example.org\")\n    return;\n\n  // event.source 是我们通过window.open打开的弹出页面 popup\n  // event.data 是 popup发送给当前页面的消息 \"hi there yourself!  the secret response is: rheeeeet!\"\n}\nwindow.addEventListener(\"message\", receiveMessage, false);\n```\n\nCopy to Clipboard\n\n```js\n/*\n * 弹出页 popup 域名是<http://example.org>，以下是script标签中的代码:\n */\n\n//当A页面postMessage被调用后，这个function被addEventListener调用\nfunction receiveMessage(event){\n  // 我们能信任信息来源吗？\n  if (event.origin !== \"http://example.com:8080\")\n    return;\n\n  // event.source 就当前弹出页的来源页面\n  // event.data 是 \"hello there!\"\n\n  // 假设你已经验证了所受到信息的origin (任何时候你都应该这样做), 一个很方便的方式就是把event.source\n  // 作为回信的对象，并且把event.origin作为targetOrigin\n  event.source.postMessage(\"hi there yourself!  the secret response \" +\n                           \"is: rheeeeet!\",\n                           event.origin);\n}\n\nwindow.addEventListener(\"message\", receiveMessage, false);\n```\n\nCopy to Clipboard\n\n### [**注意**](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage#notes)\n\n> - 任何窗口可以在任何其他窗口访问此方法，在任何时间，无论文档在窗口中的位置，向其发送消息。 因此，用于接收消息的任何事件监听器**必须**首先使用origin和source属性来检查消息的发送者的身份。 **这不能低估：无法检查origin和source属性会导致跨站点脚本攻击。**\n>\n> - 与任何异步调度的脚本（超时，用户生成的事件）一样，postMessage的调用者不可能检测到侦听由postMessage发送的事件的事件处理程序何时抛出异常。\n>\n> - 分派事件的origin属性的值不受调用窗口中document.domain的当前值的影响。\n>\n> - 仅对于IDN主机名，origin属性的值不是始终为Unicode或punycode; 在使用此属性时，如果您期望来自IDN网站的消息，则最大程度地兼容性检查IDN和punycode值。 这个值最终将始终是IDN，但现在你应该同时处理IDN和punycode表单。\n>\n> - 当发送窗口包含 `javascript:` 或 `data:` URL时，origin属性的值是加载URL的脚本的\n\n### [在扩展中使用window.postMessage](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage#在扩展non-standard_inline中使用window.postmessage)\n\n`window.postMessage`可用于以chrome代码运行的JavaScript（例如，在扩展和特权代码中），但是分派事件的source属性总是为空作为安全限制。 （其他属性具有其期望值。）发送到位于chrome：URL的窗口的消息的`targetOrigin`参数当前被错误解释，使得将导致发送消息的唯一值为`“*”`。 由于此值是不安全的，当目标窗口可以导航到其他地方的恶意网站，建议postMessage不用于与chrome：页面的沟通; 使用不同的方法（如打开窗口时的查询字符串）与chrome窗口进行通信。 最后，在文件中向页面发布消息：URL当前要求`targetOrigin`参数为`“*”`。` file://`不能用作安全限制; 这个限制可能会在将来被修改。\n\n## Eg\n\n> 原理\n> 利用postMessage不能和服务端交换数据，只能在两个窗口（iframe）之间交换数据\n> 两个窗口能通信的前提是，一个窗口以iframe的形式存在于另一个窗口，或者一个窗口是从另一个窗口通过window.open()或者超链接的形式打开的（同样可以用window.opener获取源窗口）\n\n\n\n\n### index.html\n\n\n\n```html\n\n<!doctype html>\n<html>\n\n<head>\n    <meta charset=\"UTF-8\">\n</head>\n<body>\n\n    <form id=\"form\">\n        <input type=\"text\" placeholder=\"Enter message\" name=\"message\" autocomplete=\"off\">\n        <input type=\"submit\" value=\"Click to send\">\n    </form>\n     \n    <iframe src=\"./iframe.html\" id=\"iframe\" style=\"display:block;height:300px\"></iframe>\n     \n    <script>\n        form.onsubmit = function () {\n            iframe.contentWindow.postMessage(this.message.value, 'http://localhost:3000/iframe.html');\n            return false;\n        };\n    </script>\n\n</body>\n</html>\n\n```\n### iframe.html\n\n```html\n<!doctype html>\n<html>\n\n\n<head>\n    <meta charset=\"UTF-8\">\n</head>\n\n\n<body>\n\n    <div id=\"showhere\"></div>\n    Receiving iframe.\n    <script>\n        window.addEventListener('message', function (event) {\n            console.log(`Received ${event.data} from ${event.origin}`);\n            document.getElementById('showhere').innerHTML += event.data;\n        });\n    </script>\n\n</body>\n\n</html>\n```\n\n\n\n\n\n\n\n","children":[]},{"name":"requestAnimationFrame.md","path":"../guanruihua.github.io/Front-End/浏览器/Web Api","data":"# window.requestAnimationFrame\n\n> `window.requestAnimationFrame()` 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。\n>\n> 该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行\n\n```js\n(() => {\n  let n = 0\n  function test() {\n    n++\n    console.log(`🚀🚀hello ~ requestAnimationFrame ${n}`);\n    if (n < 11) requestAnimationFrame(test)\n  }\n  requestAnimationFrame(test)\n})()\n```\n","children":[]}]},{"name":"web点击劫持X-Frame-Options.md","path":"../guanruihua.github.io/Front-End/浏览器","data":"# Web 点击劫持X-Frame-Options\n\n### 原理解释\n\n> 点击劫持，[clickjacking](https://baike.baidu.com/item/clickjacking)，也被称为UI-覆盖攻击。这个词首次出现在2008年，是由[互联网](https://baike.baidu.com/item/互联网)安全专家罗伯特·汉森和耶利米·格劳斯曼首创的。\n\n它是通过覆盖不可见的框架误导受害者点击。\n\n虽然受害者点击的是他所看到的网页，但其实他所点击的是被黑客精心构建的另一个置于原网页上面的透明页面。\n\n这种攻击利用了HTML中`<iframe>`标签的透明属性。\n\n就像一张图片上面铺了一层透明的纸一样，你看到的是黑客的页面，但是其实这个页面只是在底部，而你真正点击的是被黑客透明化的另一个网页。一个简单的点击劫持例子，就是当你点击了一个不明链接之后，自动关注了某一个人的博客或者订阅了视频。\n\n假如我在优酷发布了很多视频，想让更多的人关注它，于是我们准备了一个页面：\n\n```html\n<!DOCTYPE html>\n<html>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<head>\n<title>点击劫持 POC</title>\n<style>\niframe {\n  width: 1440px;\n  height: 900px;\n  position: absolute;\n  top: -0px;\n  left: -0px;\n  z-index: 2;\n  -moz-opacity: 0;\n  opacity: 0;\n  filter: alpha(opacity=0);\n}\n\nbutton {\n  position: absolute;\n  top: 270px;\n  left: 1150px;\n  z-index: 1;\n  width: 90px;\n  height:40px;\n}\n</style>\n</head>\n<body>\n  <button>美女图片</button>\n  <img src=\"http://pic1.win4000.com/wallpaper/2018-03-19/5aaf2bf0122d2.jpg\">\n  <iframe src=\"http://i.youku.com/u/UMjA0NTg4Njcy\" scrolling=\"no\"></iframe>\n</body>\n</html>\n\n```\n\n当然真正的页面肯定会更精致一些，不会这么简陋。\n\n然而这个页面只是表象而已，我们把iframe的透明度改成0.3以后再看看\n\n![img](web点击劫持X-Frame-Options.assets/20180319164653726)\n\n当你点击按钮以后，真正的点击的其实是隐藏的那个页面的订阅按钮，然后就会在你不知情的情况下订阅了\n\n![img](web点击劫持X-Frame-Options.assets/20180319164951941)\n\n当然点击劫持的危害可大可小，并不仅仅是关注订阅之类的东西，但是原理类似。\n\n### 解决方案\n\nX-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在 <frame>, </iframe> 或者 <object> 中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌套到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。\n\nX-Frame-Options三个参数:\n\n1、DENY\n\n表示该页面不允许在frame中展示，即便是在相同域名的页面中嵌套也不允许。\n\n2、SAMEORIGIN\n\n表示该页面可以在相同域名页面的frame中展示。\n\n3、ALLOW-FROM uri\n\n表示该页面可以在指定来源的frame中展示。\n\n换一句话说，如果设置为DENY，不光在别人的网站frame嵌入时会无法加载，在同域名页面中同样会无法加载。另一方面，如果设置为SAMEORIGIN，那么页面就可以在同域名页面的frame中嵌套。正常情况下我们通常使用SAMEORIGIN参数。\n\nApache配置\n\n需要把下面这行添加到 'site' 的配置中\n\n```bash\nHeader always append X-Frame-Options SAMEORIGIN\n```\n\nnginx配置\n\n需要添加到 ‘http’, ‘server’ 或者 ‘location’ 的配置项中，个人来讲喜欢配置在‘server’ 中\n\n正常情况下都是使用SAMEORIGIN参数，允许同域嵌套\n\n```bash\nadd_header X-Frame-Options SAMEORIGIN;\n```\n\n允许单个域名iframe嵌套\n\n```bash\nadd_header X-Frame-Options ALLOW-FROM http://whsir.com/; \n```\n\n允许多个域名iframe嵌套，注意这里是用**逗号**分隔\n\n```bash\nadd_header X-Frame-Options \"ALLOW-FROM http://whsir.com/,https://cacti.org.cn/\";\n```\n\nIIS配置\n\n添加下面的配置到 ‘Web.config’文件中\n\n```xml\n<system.webServer>\n  ...\n  <httpProtocol>\n    <customHeaders>\n      <add name=\"X-Frame-Options\" value=\"SAMEORIGIN\" />\n    </customHeaders>\n  </httpProtocol>\n  ...\n</system.webServer>\n```\n\nHAProxy配置\n\n添加下面这行到 ‘front-end, listen, or backend’配置中\n\n```bash\nrspadd X-Frame-Options:\\ SAMEORIGIN\n```\n\nTomcat配置\n\n在 ‘conf/web.xml’填加以下配置\n\n```xml\n<filter>\n        <filter-name>httpHeaderSecurity</filter-name>\n        <filter-class>org.apache.catalina.filters.HttpHeaderSecurityFilter</filter-class>\n        <init-param>\n            <param-name>antiClickJackingOption</param-name>\n            <param-value>SAMEORIGIN</param-value>\n        </init-param>\n        <async-supported>true</async-supported>\n    </filter>\n<filter-mapping>\n        <filter-name>httpHeaderSecurity</filter-name>\n        <url-pattern>/*</url-pattern>\n    <dispatcher>REQUEST</dispatcher>\n    <dispatcher>FORWARD</dispatcher>\n</filter-mapping>\n```\n\n配置后如何确定X-Frame-Options是否已生效呢？我这里以Google浏览器为例，打开网站按F12键，选择Network，找到对应的Headers，如下图所示\n\n![img](web点击劫持X-Frame-Options.assets/aHR0cHM6Ly9jZG4ud2hzaXIuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE5LzAzL1gtRnJhbWUtT3B0aW9uc19IZWFkZXJzLnBuZw)\n","children":[]},{"name":"window","path":"../guanruihua.github.io/Front-End/浏览器","data":"","children":[{"name":"closed.md","path":"../guanruihua.github.io/Front-End/浏览器/window","data":"# window.closed\r\n>\r\n> - 只读\r\n> - 表示所引用的窗口是\r\n>\r\n```js\r\nisClosed = windowRef.closed;\r\n```\r\n\r\n`isClosed`:\r\n\r\n- `true`: 窗口已被关闭\r\n- `false`: 窗口是打开的\r\n\r\n## example\r\n\r\n### 更改一个弹出窗口的 URL\r\n\r\n> 下面的示例演示怎样更改一个已打开的弹出窗口的 URL。尝试更改 URL 之前，它使用 `window.opener` 属性来检查有窗口被打开，并且该窗口没有关闭\r\n\r\n```js\r\n// Check that an opener exists and is not closed\r\nif (window.opener && !window.opener.closed) {\r\n  window.opener.location.href = \"http://www.mozilla.org\";\r\n}\r\n```\r\n\r\n> 请注意，弹出窗口只能访问打开他们的窗口。\r\n\r\n### 刷新先前打开的弹出窗口\r\n\r\n> 在这个例子中，函数 `refreshPopupWindow()` 调用重载方法的弹出的位置要刷新其数据的对象\r\n> 如果弹出窗口尚未打开，或者用户已关闭它打开一个新窗口\r\n\r\n```js\r\nvar popupWindow = null;\r\n\r\nfunction refreshPopupWindow() {\r\n  if (popupWindow && !popupWindow.closed) {\r\n    // popupWindow is open, refresh it\r\n    popupWindow.location.reload(true);\r\n  } else {\r\n    // Open a new popup window\r\n    popupWindow = window.open(\"popup.html\",\"dataWindow\");\r\n  }\r\n}\r\n```\r\n","children":[]},{"name":"content.md","path":"../guanruihua.github.io/Front-End/浏览器/window","data":"# content\r\n\r\n> - 不属于 W3C 规范\r\n> - 返回主内容窗口的Window 对象.该属性只在包含有属性type=\"content-primary\"的`<browser>` (或者 `tabbrowser` 或者 `<iframe>`) 标签的 XUL 窗口下才会用到。最常用到的地方就是 Firefox 的主窗口，browser.xul. 在这种情况下，content 返回一个浏览器中的当前页面的Window 对象的引用.相当于browserRef.contentWindow 的快捷方式.\r\n\r\n- 在一个非特权的内容窗口中 (网页), content 等同于普通的 top (除非网页是在侧边栏中加载的，content仍然会指向当前标签页中的Window 对象).\r\n\r\n- 一些旧的代码示例中使用了 _content 而不是 content.该形式的属性名已经被废弃很久了，你应该在新的代码中使用content.\r\n\r\n```js\r\n\r\nvar windowObject = window.content;\r\n```\r\n\r\n## example\r\n\r\n在一个拥有`<browser type=\"content-primary\"/>`标签的chrome XUL 窗口下运行下面的代码。会在浏览器当前显示的页面上的第一个 div 标签上添加一个红色的边框：\r\n\r\n```js\r\ncontent.document.getElementsByTagName[\"div\"](0).style.border = \"solid red 1px\";\r\n```\r\n","children":[]},{"name":"customElements.md","path":"../guanruihua.github.io/Front-End/浏览器/window","data":"# customElements\r\n\r\n> `customElements` 是Window对象上的一个只读属性，接口返回一个`CustomElementRegistry` 对象的引用，可用于注册新的 `custom elements`，或者获取之前定义过的自定义元素的信息\r\n\r\n## example\r\n\r\n> 这个属性最常用的例子是用来获取使用`CustomElementRegistry.define()`方法定义和注册的自定义元素\r\n\r\n```js\r\nlet customElementRegistry = window.customElements;\r\ncustomElementRegistry.define('my-custom-element', MyCustomElement);\r\n```\r\n\r\n通常缩写：\r\n\r\n```js\r\ncustomElements.define('element-details',\r\n  class extends HTMLElement {\r\n    constructor() {\r\n      super();\r\n      const template = document\r\n        .getElementById('element-details-template')\r\n        .content;\r\n      const shadowRoot = this.attachShadow({mode: 'open'})\r\n        .appendChild(template.cloneNode(true));\r\n  }\r\n});\r\n```\r\n","children":[]},{"name":"devicePixelRatio.md","path":"../guanruihua.github.io/Front-End/浏览器/window","data":"# [devicePixelRatio](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/devicePixelRatio)\r\n\r\n> - `Window` 接口的 `devicePixelRatio` 返回当前显示设备的物理像素分辨率与CSS 像素分辨率之比。\r\n> - 可解释为像素大小的比率：一个 CSS 像素的大小与一个物理像素的大小。简单来说，它告诉浏览器应使用多少屏幕实际像素来绘制单个 CSS 像素\r\n>\r\n> - 当处理标准显示器与 HiDPI 或 Retina 显示器之间的差异时，这很有用，后者使用更多的屏幕像素绘制相同的对象，从而获得更清晰的图像\r\n>\r\n> - 可以使用`window.matchMedia()` 检查`devicePixelRatio`的值是否发生更改（例如，如果用户将窗口拖动到带有 不同的像素密度）\r\n\r\n```js\r\nvalue = window.devicePixelRatio\r\n```\r\n\r\n## 值 Value\r\n\r\n一个双精度浮点值，指示显示器的物理像素分辨率与 CSS 像素分辨率之比\r\n\r\n- 值 1 表示经典 96 DPI（在某些平台上为 76 DPI）显示\r\n- 对于 HiDPI / Retina 显示屏则期望值为 2。在异常低分辨率的显示器中\r\n- 当屏幕的像素深度比简单地将 96 或 76 DPI 的标准分辨率提高一倍时，可能还会返回其他值。\r\n\r\n## 在 `<canvas>` 中更正分辨率\r\n\r\n> `<canvas>`可能在视网膜屏幕上显得太模糊\r\n> 使用`window.devicePixelRatio`确定应添加多少额外的像素密度以使图像更清晰\r\n\r\n```html\r\n<canvas id=\"canvas\"></canvas>\r\n```\r\n\r\n```js\r\n var canvas = document.getElementById('canvas');\r\nvar ctx = canvas.getContext('2d');\r\n\r\n// Set display size (css pixels).\r\nvar size = 200;\r\ncanvas.style.width = size + \"px\";\r\ncanvas.style.height = size + \"px\";\r\n\r\n// Set actual size in memory (scaled to account for extra pixel density).\r\nvar scale = window.devicePixelRatio; // Change to 1 on retina screens to see blurry canvas.\r\ncanvas.width = Math.floor(size *scale);\r\ncanvas.height = Math.floor(size* scale);\r\n\r\n// Normalize coordinate system to use css pixels.\r\nctx.scale(scale, scale);\r\n\r\nctx.fillStyle = \"#bada55\";\r\nctx.fillRect(10, 10, 300, 300);\r\nctx.fillStyle = \"#ffffff\";\r\nctx.font = '18px Arial';\r\nctx.textAlign = 'center';\r\nctx.textBaseline = 'middle';\r\n\r\nvar x = size / 2;\r\nvar y = size / 2;\r\n\r\nvar textString = \"I love MDN\";\r\nctx.fillText(textString, x, y);\r\n```\r\n\r\n![](./__assets__/devicePixelRatio-2022-12-09-10-46-05.png)\r\n\r\n## 监视屏幕分辨率或缩放级别的更改\r\n\r\n> 在此示例中，我们将设置一个媒体查询并观看它以查看设备分辨率何时更改，以便我们可以检查`devicePixelRatio`的值来处理所需的任何更新\r\n\r\n> JavaScript 代码创建媒体查询，以监控设备分辨率并在每次更改时检查`devicePixelRatio`的值\r\n\r\n```js\r\nlet pixelRatioBox = document.querySelector(\".pixel-ratio\");\r\nlet mqString = `(resolution: ${window.devicePixelRatio}dppx)`;\r\n\r\nconst updatePixelRatio = () => {\r\n  let pr = window.devicePixelRatio;\r\n  let prString = (pr * 100).toFixed(0);\r\n  pixelRatioBox.innerText = `${prString}% (${pr.toFixed(2)})`;\r\n}\r\n\r\nupdatePixelRatio();\r\n\r\nmatchMedia(mqString).addListener(updatePixelRatio)\r\n```\r\n\r\n> 字符串`mqString`设置为媒体查询本身。媒体查询以`(resolution: 1dppx)`（对于标准显示）或`(resolution: 2dppx)`（对于 `Retina` / `HiDPI` 显示）开始，检查当前显示分辨率是否与每个像素px的实际设备像素点匹配\r\n\r\n> `updatePixelRatio()`函数获取`devicePixelRatio`的当前值，然后将`pixelRatioBox`的 `innerText`设置为一个字符串，该字符串同时显示百分比和原始十进制值比率，最多两位小数\r\n\r\n> 调用`updatePixelRatio()`函数一次以显示起始值，然后使用`matchMedia()` 和 `addEventListener()`来将updatePixelRatio()设置为change事件的处理程序\r\n\r\n> HTML 将创建包含说明的框和将显示当前像素比率信息的pixel-ratio 框。\r\n\r\n```html\r\n<div class=\"container\">\r\n  <div class=\"inner-container\">\r\n    <p>This example demonstrates the effect of zooming the page in\r\n       and out (or moving it to a screen with a different scaling\r\n       factor) on the value of the property <code>Window.devicePixelRatio</code>.\r\n       Try it and watch what happens!</p>\r\n  </div>\r\n    <div class=\"pixel-ratio\"></div>\r\n</div>\r\n```\r\n\r\n```css\r\nbody {\r\n  font: 22px arial, sans-serif;\r\n}\r\n\r\n.container {\r\n  top: 2em;\r\n  width: 22em;\r\n  height: 14em;\r\n  border: 2px solid #22d;\r\n  margin: 0 auto;\r\n  padding: 0;\r\n  background-color: #a9f;\r\n}\r\n\r\n.inner-container {\r\n  padding: 1em 2em;\r\n  text-align: justify;\r\n  text-justify: auto;\r\n}\r\n\r\n.pixel-ratio {\r\n  position: relative;\r\n  margin: auto;\r\n  height: 1.2em;\r\n  text-align: right;\r\n  bottom: 0;\r\n  right: 1em;\r\n  font-weight: bold;\r\n}\r\n```\r\n\r\n![](./__assets__/devicePixelRatio-2022-12-09-10-52-02.png)\r\n> > `devicePixelRatio`=1 时候\r\n","children":[]},{"name":"document","path":"../guanruihua.github.io/Front-End/浏览器/window","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Front-End/浏览器/window/document","data":"# [`document`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/document)\r\n\r\n> `window.document` 返回当前窗口内的文档节点 [`document`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document)\r\n","children":[]}]},{"name":"frameElement.md","path":"../guanruihua.github.io/Front-End/浏览器/window","data":"# [`frameElement`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/frameElement)\r\n\r\n> 返回嵌入当前window对象的元素 (比如 `<iframe>` 或者 `<object>`),如果当前window对象已经是顶层窗口，则返回`null`\r\n\r\n```js\r\nvar frameEl = window.frameElement\r\n```\r\n\r\n## example\r\n\r\n```js\r\nvar frameEl = window.frameElement;\r\n// 如果当前窗口被包含在一个框架里面，则将该框架的地址跳到'http://mozilla.org/'\r\nif (frameEl)\r\n  frameEl.src = 'http://mozilla.org/';\r\n```\r\n\r\n> 虽然该属性名为frameElement,但该属性也会返回其他类型比如 `<object>` 或者其他可嵌入窗口的元素\r\n\r\n## 相关链接\r\n\r\n- `window.frames` 返回一个类数组对象，返回当前窗口的所有子框架元素\r\n- `window.parent` 返回当前窗口的父窗口，也就是说，包含当前窗口所在的frameElement元素的窗口\r\n","children":[]},{"name":"frames.md","path":"../guanruihua.github.io/Front-End/浏览器/window","data":"# [`frames`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/frames)\r\n\r\n> 返回当前窗口，一个类数组对象，列出了当前窗口的所有直接子窗口\r\n\r\n```js\r\nframeList = window.frames\r\n```\r\n\r\n- frameList 是一个 frame 对象的集合，它类似一个数组，有 length 属性且可以使用索引（[i]）来访问\r\n- frameList === window 计算结果为 true\r\n- 在 window.frames 类数组中的每一项都代表了窗口对应给定对象的`<frame>`或`<iframe>`的内容，而不是 `(i)frame DOM` 元素（即 `window.frames[0]` 与 `document.getElementsByTagName[\"iframe\"](0).contentWindow` 是相同的）\r\n\r\n```js\r\nvar frames = window.frames; // 或 // var frames = window.parent.frames;\r\nfor (var i = 0; i < frames.length; i++) {\r\n  // 在这对 frames 的一个 frame 做点什么\r\n  frames[i].document.body.style.background = \"red\";\r\n}\r\n```\r\n","children":[]},{"name":"history.md","path":"../guanruihua.github.io/Front-End/浏览器/window","data":"# [`history`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/history)\r\n\r\n- `Window.history` 是一个只读属性，用来获取`History` 对象的引用，`History` 对象提供了操作浏览器会话历史（浏览器地址栏中访问的页面，以及当前页面中通过框架加载的页面）的接口\r\n\r\n- `History` 对象有如下方法：参见 [`Manipulating the browser history`](https://developer.mozilla.org/zh-CN/docs/Web/API/History_API) 中的示例和详情。尤其指出的是文章里解释了在使用 `pushState()` 和 `replaceState()` 方法前，你需要了解的安全问题\r\n\r\n```js\r\nvar historyObj = window.history;\r\nhistory.back();     // 等同于点击浏览器的回退按钮\r\nhistory.go(-1);     //等同于 history.back();\r\n```\r\n\r\n## 附注\r\n\r\n- 在顶层页面中，浏览器的回退和前进按钮旁的下拉菜单显示了可以通过History对象访问到的页面会话历史（session history）列表。\r\n\r\n- 出于安全考虑，History 对象不允许未授权代码访问会话历史（session History）中其它页面的 URLs，但可以导航到其它会话历史（session History）指向的页面。\r\n\r\n- 未授权代码无法清除会话历史（session History），也不能禁用回退/前进功能。最快捷的可用方式是使用location.replace()方法，提供指定的 URL 来替换当前的会话历史（session history）。\r\n","children":[]},{"name":"innerHeight.md","path":"../guanruihua.github.io/Front-End/浏览器/window","data":"# [`innerHeight`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/innerHeight)\r\n\r\n> - 浏览器窗口的视口（viewport）高度（以像素为单位）；如果有水平滚动条，也包括滚动条高度\r\n> - 任何窗口对象，如 window、frame、frameset 或 secondary window 都支持 innerHeight 属性\r\n\r\n```js\r\nvar intViewportHeight = window.innerHeight;\r\n```\r\n\r\n- `intViewportHeight` 为浏览器窗口的视口的高度\r\n\r\n- `window.innerHeight` 属性为只读，且没有默认值\r\n\r\n有一个算法用来获取不包括水平滚动条的视口高度。\r\n\r\n## Example\r\n\r\n> frameset\r\n\r\n```js\r\n\r\nvar intFrameHeight = window.innerHeight; // or\r\n\r\nvar intFrameHeight = self.innerHeight;\r\n// 返回 frameset 里面的 frame 视口的高度\r\n\r\nvar intFramesetHeight = parent.innerHeight;\r\n// 返回上一级 frameset 的视口的高度\r\n\r\nvar intOuterFramesetHeight = top.innerHeight;\r\n// 返回最外部 frameset 的视口的高度\r\n```\r\n\r\n{{todo(\"link to an interactive demo here\")}}\r\n\r\n改变一个窗口的大小，可以查看 `window.resizeBy()` 和 `window.resizeTo()`\r\n\r\n想获取窗口的外层高度（outer height），即整个浏览器窗口的高度，请查看 `window.outerHeight`\r\n","children":[]},{"name":"innerWidth.md","path":"../guanruihua.github.io/Front-End/浏览器/window","data":"# [innerWidth](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/innerWidth)\r\n\r\n> - 只读的 Window 属性 innerWidth 返回以像素为单位的窗口的内部宽度\r\n> - 如果垂直滚动条存在，则这个属性将包括它的宽度\r\n>\r\n> `innerWidth` 返回窗口的 `layout viewport (en-US)` 的宽度。窗口的内部高度——布局视口的高度——可以从 `innerHeight` 属性中获取到\r\n\r\n```js\r\nlet intViewportWidth = window.innerWidth\r\n```\r\n\r\n- 一个整数型的值表示窗口的布局视口宽度是以像素为单位的。这个属性是只读的，并且没有默认值。\r\n\r\n- 若要更改窗口的宽度，请使用 `Window` 的方法来调整窗口的大小，例如`resizeBy()` 或者 `resizeTo()`\r\n\r\n使用说明\r\n\r\n- 如果你需要获取除去滚动条和边框的窗口宽度，请使用根元素 `<html>` 的clientWidth 属性\r\n\r\n- `innerWidth` 属性在任何表现类似于窗口的任何窗口或对象（例如框架或选项卡）上都是可用的\r\n\r\n```js\r\n// 返回视口的宽度\r\nvar intFrameWidth = window.innerWidth;\r\n\r\n// 返回一个框架集内的框架的视口宽度\r\nvar intFrameWidth = self.innerWidth;\r\n\r\n// 返回最近的父级框架集的视口宽度\r\nvar intFramesetWidth = parent.innerWidth;\r\n\r\n// 返回最外层框架集的视口宽度\r\nvar intOuterFramesetWidth = top.innerWidth;\r\n```\r\n","children":[]},{"name":"length.md","path":"../guanruihua.github.io/Front-End/浏览器/window","data":"# [`window.length`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/length)\r\n\r\n> 返回当前窗口中包含的框架数量 (框架包括`frame`和`iframe`两种元素)\r\n","children":[]},{"name":"localStorage.md","path":"../guanruihua.github.io/Front-End/浏览器/window","data":"# [`localStorage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage)\r\n\r\n> 只读的localStorage 属性允许你访问一个Document 源（origin）的对象 `Storage`；存储的数据将保存在浏览器会话中。localStorage 类似 sessionStorage，但其区别在于：\r\n> 存储在 localStorage 的数据可以长期保留；\r\n> 而当页面会话结束——也就是说，当页面被关闭时，存储在 sessionStorage 的数据会被清除。\r\n\r\n应注意，无论数据存储在 localStorage 还是 sessionStorage ，它们都特定于页面的协议。\r\n\r\n> localStorage 中的键值对总是以字符串的形式存储。 (需要注意，和 js 对象相比，键值对总是以字符串的形式存储意味着数值类型会自动转化为字符串类型)\r\n\r\n```js\r\nmyStorage = localStorage;\r\n```\r\n\r\n> 一个可被用于访问当前源（origin）的本地存储空间的 Storage 对象。\r\n\r\n## 异常\r\n\r\n## `SecurityError`\r\n\r\n> 请求违反了一个策略声明，或者源（origin）不是 一个有效的 scheme/host/port tuple （例如如果 origin 使用 file: 或者 data: 形式将可能发生）。比如，用户可以有禁用允许对指定的 origin 存留数据的浏览器配置。\r\n\r\n## 示例\r\n\r\n下面的代码片段访问了当前域名下的本地 Storage 对象，并通过 Storage.setItem() 增加了一个数据项目。\r\n\r\n`localStorage.setItem('myCat', 'Tom')`\r\n\r\n该语法用于读取 localStorage 项，如下：\r\n\r\n`let cat = localStorage.getItem('myCat')`\r\n\r\n该语法用于移除 localStorage 项，如下：\r\n\r\n`localStorage.removeItem('myCat')`\r\n\r\n该语法用于移除所有的 localStorage 项，如下：\r\n\r\n// 移除所有\r\nlocalStorage.clear();\r\n","children":[]},{"name":"location.md","path":"../guanruihua.github.io/Front-End/浏览器/window","data":"# [`location`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/location)\r\n","children":[]},{"name":"open.md","path":"../guanruihua.github.io/Front-End/浏览器/window","data":"## 开启一个新弹框\r\n\r\n```js\r\nwindow.open ('page.html', 'newwindow', 'height=100, width=400, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, resizable=no,location=n o, status=no')\r\n```\r\n\r\n【1、最基本的弹出窗口代码】\r\n\r\n<SCRIPT LANGUAGE=”javascript”>\r\n<!–\r\nwindow.open (‘page.html’)\r\n–>\r\n</SCRIPT>\r\n\r\n因为这是一段javascripts代码，所以它们应该放在<SCRIPT LANGUAGE=”javascript”>标签和</script>之间。<!– 和 –>是对一些版本低的浏览器起作用，在这些老浏览器中不会将标签中的代码作为文本显示出来。要养成这个好习惯啊。window.open (‘page.html’) 用于控制弹出新的窗口page.html，如果page.html不与主窗口在同一路径下，前面应写明路径，绝对路径(<http://)和相对路径(../)均可。用单引号和双引号都可以，只是不要混用。这一段代码可以加入HTML>的任意位置，<head>和</head>之间可以，<body>间</body>也可以，越前越早执行，尤其是页面代码长，又想使页面早点弹出就尽量往前放。\r\n\r\n【2、经过设置后的弹出窗口】\r\n\r\n下面再说一说弹出窗口的设置。只要再往上面的代码中加一点东西就可以了。我们来定制这个弹出的窗口的外观，尺寸大小，弹出的位置以适应该页面的具体情况。\r\n\r\n<SCRIPT LANGUAGE=”javascript”>\r\n<!–\r\nwindow.open (‘page.html’, ‘newwindow’, ‘height=100, width=400, top=0, left=0, toolbar=no, menubar=no, scrollbars=no, resizable=no,location=n o, status=no’) //这句要写成一行\r\n–>\r\n</SCRIPT>\r\n\r\n参数解释：\r\n\r\n<SCRIPT LANGUAGE=”javascript”> js脚本开始；\r\nwindow.open 弹出新窗口的命令；\r\n‘page.html’ 弹出窗口的文件名；\r\n‘newwindow’ 弹出窗口的名字（不是文件名），非必须，可用空”代替；\r\nheight=100 窗口高度；\r\nwidth=400 窗口宽度；\r\ntop=0 窗口距离屏幕上方的象素值；\r\nleft=0 窗口距离屏幕左侧的象素值；\r\ntoolbar=no 是否显示工具栏，yes为显示；\r\nmenubar，scrollbars 表示菜单栏和滚动栏。\r\nresizable=no 是否允许改变窗口大小，yes为允许；\r\nlocation=no 是否显示地址栏，yes为允许；\r\nstatus=no 是否显示状态栏内的信息（通常是文件已经打开），yes为允许；\r\n</SCRIPT> js脚本结束\r\n\r\n【3、用函数控制弹出窗口】\r\n\r\n下面是一个完整的代码。\r\n<html>\r\n<head>\r\n<script LANGUAGE=”JavaScript”>\r\n<!–\r\nfunction openwin() {\r\nwindow.open (“page.html”, “newwindow”, “height=100, width=400, toolbar =no, menubar=no, scrollbars=no, resizable=no, location=no, status=no”) //写成一行\r\n}\r\n//–>\r\n</script>\r\n</head>\r\n<body οnlοad=”openwin()”>\r\n任意的页面内容…\r\n</body>\r\n</html>\r\n\r\n这里定义了一个函数openwin(),函数内容就是打开一个窗口。在调用它之前没有任何用途。怎么调用呢？\r\n\r\n方法一：<body οnlοad=”openwin()”> 浏览器读页面时弹出窗口；\r\n方法二：<body οnunlοad=”openwin()”> 浏览器离开页面时弹出窗口；\r\n方法三：用一个连接调用：\r\n<a href=”#” οnclick=”openwin()”>打开一个窗口</a>\r\n注意：使用的“#”是虚连接。\r\n方法四：用一个按钮调用：\r\n<input type=”button” οnclick=”openwin()” value=”打开窗口”>\r\n\r\n【4、同时弹出2个窗口】\r\n\r\n对源代码稍微改动一下：\r\n\r\n<script LANGUAGE=”JavaScript”>\r\n<!–\r\nfunction openwin() {\r\nwindow.open (“page.html”, “newwindow”, “height=100, width=100, top=0, left=0,toolbar=no, menubar=no, scrollbars=no, resizable=no, location=n o, status=no”)//写成一行\r\nwindow.open (“page2.html”, “newwindow2″, “height=100, width=100, top=1 00, left=100,toolbar=no, menubar=no, scrollbars=no, resizable=no, loca tion=no, status=no”)//写成一行\r\n}\r\n//–>\r\n</script>\r\n为避免弹出的2个窗口覆盖，用top和left控制一下弹出的位置不要相互覆盖即可 。最后用上面说过的四种方法调用即可。\r\n注意：2个窗口的name(newwindows和newwindow2)不要相同，或者干脆全部为空。\r\n\r\n【5、主窗口打开文件1.htm，同时弹出小窗口page.html】\r\n\r\n如下代码加入主窗口<head>区：\r\n<script language=”javascript”>\r\n<!–\r\nfunction openwin() {\r\nwindow.open(“page.html”,””,”width=200,height=200″)\r\n}\r\n//–>\r\n</script>\r\n加入<body>区：\r\n<a href=”1.htm” οnclick=”openwin()”>open</a>即可。\r\n\r\n【6、弹出的窗口之定时关闭控制】\r\n\r\n下面我们再对弹出的窗口进行一些控制，效果就更好了。如果我们再将一小段 代码加入弹出的页面(注意是加入page.html的HTML中，不是主页面中)，让它10秒后自动关闭是不是更酷了？\r\n首先，将如下代码加入page.html文件的<head>区：\r\n<script language=”JavaScript”>\r\nfunction closeit()\r\n{\r\nsetTimeout(“self.close()”,10000) //毫秒\r\n}\r\n</script>\r\n然后，再用<body οnlοad=”closeit()”> 这一句话代替page.html中原有的<BODY>这一句就可以了。(这一句话千万不要忘记写啊！这一句的作用是调用关闭窗口的代码，10秒钟后就自行关闭该窗口。)\r\n","children":[]}]},{"name":"兼容开发","path":"../guanruihua.github.io/Front-End/浏览器","data":"","children":[{"name":"IE8.md","path":"../guanruihua.github.io/Front-End/浏览器/兼容开发","data":"# IE8\r\n\r\n## IE在input内回车关闭自动触发button\r\n\r\n<https://www.qttc.net/393-ie-enter-trigger-button-click.html>\r\n\r\n> 在IE中有一个现象，当你在input内敲回车时，IE会自动寻找第一个button标签并且触发它。\r\n\r\nindex.html:\r\n\r\n```html\r\n<p><button onclick=\"console.log('from button click');\">button</button></p>\r\n<p><input type=\"text\" value=\"在这里回车就触发提交按钮\" style=\"width:300px;\" /></p>\r\n```\r\n\r\n> 使用IE打开，并且在input内回车，就会执行button的onclick事件，如果你有两个button，只会触发第一个，如\r\n\r\n```html\r\n<p><button onclick=\"console.log('from button click1');\">button1</button></p>\r\n<p><button onclick=\"console.log('from button click2');\">button2</button></p>\r\n<p><input type=\"text\" value=\"在这里回车就触发提交按钮\" style=\"width:300px;\" /></p>\r\n```\r\n\r\n> 回车后只会触发button1的onclick，但可笑的如果你把button标签换成input然后在把type设置为button却不会发生这个奇怪的事，虽然效果是一样。\r\n\r\n```html\r\n<p><input type=\"button\" onclick=\"console.log('from button click1');\" value=\"button1\" /></p>\r\n<p><button onclick=\"console.log('from button click2');\">button2</button></p>\r\n<p><input type=\"text\" value=\"在这里回车就触发提交按钮\" style=\"width:300px;\" /></p>\r\n```\r\n\r\n> 回车会避开button1，执行button2。\r\n> 如果你不想在input内执行回车就被执行button的onclick事件可以在页面顶部添加一个button，毕竟在input内敲回车是一种经常犯的毛病。如:\r\n\r\n```html\r\n<p><button>禁止input回车触发的button</button></p>\r\n<p><button onclick=\"console.log('from button click1');\">button1</button></p>\r\n<p><button onclick=\"console.log('from button click2');\">button2</button></p>\r\n<p><input type=\"text\" value=\"在这里回车就触发提交按钮\" style=\"width:300px;\" /></p>\r\n```\r\n\r\n> 这样第一个button就劫持了input的回车事件，防止了后面功能onclick被意外触发的可能性，但页面不美观\r\n> 但不能把button设置display:none给隐藏，或者visibility:hidden占位隐藏，否则不能起到劫持input内回车事件，如\r\n\r\n```html\r\n<p><button style=\"display:none;\">禁止input回车触发的button</button></p>\r\n<p><button onclick=\"console.log('from button click1');\">button1</button></p>\r\n<p><button onclick=\"console.log('from button click2');\">button2</button></p>\r\n<p><input type=\"text\" value=\"在这里回车就触发提交按钮\" style=\"width:300px;\" /></p>\r\n```\r\n\r\n> 以上代码在input回车仍然会找到button1并执行onclick事件，如果要隐藏它，但又能保持劫持input回车事件的功能，可以把在button外面再套一层父标签并且把父标签设置为宽与高为0即可\r\n\r\n### 解决\r\n\r\n#### 方法一: 使用`input[type='text']` 替代\r\n\r\n```html\r\n<div style=\"display:block; width:0; height:0; overflow:hidden;\">\r\n  <button>禁止input回车触发的button</button>\r\n</div>\r\n<p><button onclick=\"console.log('from button click1');\">button1</button></p>\r\n<p><button onclick=\"console.log('from button click2');\">button2</button></p>\r\n<p><input type=\"text\" value=\"在这里回车就触发提交按钮\" style=\"width:300px;\" /></p>\r\n```\r\n\r\n> 这样就相当于把button隐藏了，并且还保住了功能，如果嫌麻烦可以直接把button改成input[type=button]或者使用a标签代替\r\n\r\n#### 方法二: 添加 `type='text'`\r\n\r\n> 给button标签 添加 `type='text'`属性\r\n\r\n#### 方法三: 使用`a`标签替换\r\n","children":[]},{"name":"var.md","path":"../guanruihua.github.io/Front-End/浏览器/兼容开发","data":"# var\r\n\r\n## var 在for循环问题\r\n\r\n### 问题分析\r\n\r\n> 1.for循环是同步的，内部事件处理函数是异步的，所以等到异步事件触发的时候，同步代码已经跑完，因此i也加完了（这就是为什么i固定为最大值不变的原因）。\r\n>\r\n> 2.处理的核心思想就是在他跑完前就立即记录i的值，以备异步事件处理函数使用。\r\n>\r\n> 3.说白了就是利用var只有函数作用域，制造独立空间，让每个i都是独立的。\r\n>\r\n> var 只有函数作用域, 没有块级作用域\r\n\r\n### 解决方法\r\n\r\n#### 添加自启动函数\r\n\r\n> 思路: 固定i\r\n>\r\n> - 制作属性进行固定\r\n> - 利用标签属性进行固定\r\n\r\n```js\r\nfor (var i=0; i < btn.length; i++) {\r\n  btn[i].onclick=function(){\r\n   console.log(i)\r\n  }\r\n}\r\n```\r\n","children":[]}]},{"name":"分析页面","path":"../guanruihua.github.io/Front-End/浏览器","data":"","children":[{"name":"分析页面加载时间.md","path":"../guanruihua.github.io/Front-End/浏览器/分析页面","data":"# chrome 分析页面加载时间\r\n\r\n## 在Network面板查看\r\n\r\n![](./__assets__/分析页面加载时间-2022-11-28-17-13-14.png)\r\n\r\n- finish：页面最后一个请求截止的时间，如果页面加载完成后，触发了ajax请求，那么该时间会变更。\r\n- DOMContentLoaded：dom内容加载并解析完成的时间，即页面白屏时间\r\n- load：页面所有的资源（图片、音频、视频等）加载完成的时间。\r\n\r\n当页面的初始的标记被解析完成时，会触发DOMContentLoaded，它在Network面板上的两个位置显示：\r\n\r\n- 在Overview窗格中的蓝色垂直线表示这个事件。\r\n- 在Summary窗格中，可以查看这个事件的确切耗时。\r\n\r\n当页面完全加载时触发load事件，它显示在三个地方：\r\n\r\n- 在Overview窗格的红色垂直线表示这个事件。\r\n- 在Request Table中的红色垂直线也表示这个事件。\r\n- 在Summary中，可以查看该事件的确切时间。\r\n\r\n## 查看网络时序\r\n\r\n> 点击Timing选项卡可以查看单个资源的请求生命周期的明细分类。\r\n\r\n![](./__assets__/分析页面加载时间-2022-11-28-17-15-11.png)\r\n\r\n- Queuing 队列\r\n- Stalled 停滞\r\n- DNS lookup DNS查找\r\n- initial connection 初始连接\r\n- SSL handshake SSL握手\r\n- Request sent 请求发送\r\n- Waiting 等待，具体指到开始下载第一个字节的时间（TTFB：time for first byte）\r\n- Content Download 内容下载\r\n\r\n## 资源加载时序\r\n\r\n> 所有网络请求都被视为资源，当它们通过网络检索时，分为不同的生命周期。\r\n\r\n一个完整请求生命周期的主要阶段如下\r\n\r\n### Redirect 重定向\r\n\r\n- 立即开始 startTime\r\n- 如果发生重定向，redirectStart也会开始计时\r\n- 如果重定向发生在此阶段结束，那么redirectEnd被采用\r\n\r\n### App Cache 应用程序缓存\r\n\r\n- 如果浏览器有缓存，将采用fetchStart时间\r\n\r\n### DNS\r\n\r\n- domainLookupStart 记录DNS请求开始时间\r\n- domainLookupEnd记录DNS请求结束的时间\r\n\r\n### TCP\r\n\r\n- connectStart 记录开始连接到服务器的时间\r\n- 如果用了TLS或者SSL，secureConnectionStart记录开始连接时间\r\n- connectEnd记录连接完毕时间\r\n\r\n### Request 请求\r\n\r\n- requestStart记录请求发生到服务器的时间\r\n\r\n### Response 响应\r\n\r\n- responeseStart记录最开始的响应时间\r\n- responseEnd记录响应结束时间\r\n\r\n![](./__assets__/分析页面加载时间-2022-11-28-17-17-36.png)\r\n\r\n## timing面板信息详解\r\n\r\n## Queuing 排队 如果一个请求排队，则表明\r\n\r\n- 请求被渲染引擎推迟，因为它比关键资源（如脚本/样式）的优先级低。例如，images。\r\n- 这个请求被搁置，在等待一个即将被释放的不可用的TCP socket\r\n- 这个请求被搁置，因为浏览器限制。在HTTP 1协议中，每个源上只能有6个TCP连接。\r\n- 正在生成磁盘缓存条目（通常非常快）\r\n\r\n## Stalled/Blocking 停止/阻塞\r\n\r\n- 发送请求之前的等待时间。它可能因为进入队列的任意原因而被阻塞。这个时间包括代理协商的时间。\r\n\r\n### Proxy Negotiation 代理协商\r\n\r\n- 与代理服务器连接协商花费的时间\r\n\r\n### DNS Lookup DNS查找\r\n\r\n- 执行DNS查找所用的时间。页面上的每个新域都需要完整的往返（roundtrip）才能进行DNS查找。\r\n\r\n### Initial Connection/Connecting 初始连接/连接\r\n\r\n- 连接连接所需的时间，包括TCP握手/重试和协商SSL。\r\n\r\n### SSL\r\n\r\n- 完成SSL握手所用的时间\r\n\r\n### Request Sent/Sending 请求已经发送/正在发送\r\n\r\n- 发出网络请求所花费的时间，通常是几分之一毫秒\r\n\r\n### Waiting（TTFB） 等待\r\n\r\n- 等待初始响应所花费的时间。这个时间包含：等待服务器传递响应花费的时间、捕获到服务器发送数据的延迟时间\r\n\r\n### Content Download/Downloading 内容下载/下载\r\n\r\n- 接收响应数据所花费的时间：从接收到第一个字节开始，到下载完最后一个字节结束。\r\n\r\n## Network面板诊断网络问题\r\n\r\n- 排队或者阻塞：很多个请求队列被阻塞。这表示单个客户端检索的资源太多。在HTTP 1.0/1.1连接协议中，Chrome限制每个域名最多执行6个TCP连接。\r\n\r\n  - 解决方法：分域，即用多个字域名提供服务资源，将资源拆分到多个子域中，均匀分配。\r\n  - HTTP2，TCP连接支持多路复用，消除了HTTP 1的6个连接限制，并且可以通过单个连接同时传输多个资源。\r\n\r\n- 接收到第一个字节的时间很慢：很多绿色。\r\n\r\n解决方法：1、尽量减少网络连接。理想情况下，在本地托管应用程序（部署在本地）。2、优化应用程序的响应速度\r\n\r\n- 加载缓慢：很多蓝色。\r\n\r\n解决方法：减少响应的字节。例如，优化图片\r\n","children":[]}]},{"name":"开启手机控制台.md","path":"../guanruihua.github.io/Front-End/浏览器","data":"# 开启手机控制台\n\n```js\n  // 开启手机控制台\n  <script src=\"//cdn.jsdelivr.net/npm/eruda\"></script>\n <script>eruda.init();</script>\n```\n\n```html\n<script src=\"https://cdn.bootcss.com/vConsole/3.2.0/vconsole.min.js\"></script>\n  <script>\n  //初始化一下就可以了，\n  let vConsole = new VConsole();\n  //你打印的数据 比如\n  console.log('test');\n  //就可像小程序一样的看了和调试了。\n  </script>\n```\n\n```shell\n//如果是在vue中要先安装包\n npm install vconsole\n //然后引入\n import Vconsole from 'vconsole';\n //然后在created 或者mounted 生命周期中初始化一下\n let vConsole = new VConsole();\n //在手机上 就可以像上面一样的效果了\n```\n","children":[]},{"name":"怪异模式.md","path":"../guanruihua.github.io/Front-End/浏览器","data":"# 浏览器的怪异模式和标准模式\n\n- 怪异模式的产生: 早起没有固定的标准, 导致浏览器都是自己写自己, 没有固定的标准\n\n|| 标准模式| 怪异模式|\n| --------------- | ----------------------- | --------- |\n| 解析方式        | 按照W3C标准解析         | 使用浏览器自己的方式解析                                     |\n| 盒模型          | W3C的标准模型           | IE盒子模型                                                   |\n| Table元素中字体 | font 属性可以继承       | 不可以从父级继承                                             |\n| 内联元素的尺寸  | 无法定义自己的宽度      | 定义width 和height 都可以影响到与拿书的尺寸                  |\n| 元素溢出        | overflow默认值为visible | 元素大小由内容界定, 溢出不会裁剪,<br>元素框自动调整, 包括溢出内容 |\n","children":[]},{"name":"标签.md","path":"../guanruihua.github.io/Front-End/浏览器","data":"# 标签\n\n## 标签相关\n\nhtml中定义六个属性\n\n```js\n1. async 属性: 表示立即下载脚本，但不会影响页面的其他操作。[规定脚本将被异步执行]\n2. charset 属性: 规定在外部脚本把文件中使用的编码不同。\n3. defer 属性: 表示脚本可以延迟到文档被解析和显示之后再执行。只有对外部脚本有效。\n4. src 属性: 表示包含要执行代码的外部文件。\n5. type 属性: 规定了脚本的MIME属性[内容属性]\n6. language 属性: 已废弃。\n```\n","children":[]},{"name":"浏览器多进程&JS单线程.md","path":"../guanruihua.github.io/Front-End/浏览器","data":"# 浏览器多进程 & JS单进程\n\n[从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 ](https://segmentfault.com/a/1190000012925872)\n\n> - 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）\n> - 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）\n\n\n\n## 浏览器\n\n> - 浏览器是多进程的\n> - 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）\n> - 简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。\n\n\n\n### 浏览器主要进程\n\n> 1. Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有\n>    - 负责浏览器界面显示，与用户交互。如前进，后退等\n>    - 负责各个页面的管理，创建和销毁其他进程\n>    - 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上\n>    - 网络资源的管理，下载等\n> 2. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建\n> 3. GPU进程：最多一个，用于3D绘制等\n> 4. 浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为\n>    - 页面渲染，脚本执行，事件处理等\n\n\n\n### 浏览器内核\n\n> 浏览器内核包括\n\n![image-20210812144930799](浏览器多进程&JS单线程.assets/image-20210812144930799-16287509744381.png)\n\n","children":[]},{"name":"浏览器插件","path":"../guanruihua.github.io/Front-End/浏览器","data":"","children":[{"name":"manifest.md","path":"../guanruihua.github.io/Front-End/浏览器/浏览器插件","data":"# manifest.json 配置文件\n\n> manifest.json是扩展的配置文件，指明了扩展的各种信息。\n\n一个manifest.json格式如下：\n\n```js\n\n{\n    // 必须的字段3个\n    \"name\": \"MyExtension\", // 扩展名称\n    \"version\": \"1.0\", // 版本。由1到4个整数构成。多个整数间用\".\"隔开\n    \"manifest_version\": 2, // manifest文件版本号。Chrome18开始必须为2\n    // 建议提供的字段3个\n\n    \"description\": \"\",   // 描述。132个字符以内\n\n    \"icons\": {\n\n       \"16\": \"image/icon-16.png\",\n\n       \"48\": \"image/icon-48.png\",\n\n       \"128\": \"image/icon-128.png\"\n\n    }, //扩展图标。推荐大小16，48，128\n\n    \"default_locale\": \"en\", // 国际化\n\n    // 以下字段多选一，或者都不提供\n\n    \"browser_action\": {\n       \"default_icon\": \"image/icon-128.png\",\n        \"default_title\": \"My Test\",\n       \"default_popup\": \"html/browser.html\"\n    }, //地址栏右侧图标管理。含图标及弹出页面的设置等\n    \"page_action\": {\n        \"default_icon\": \"image/icon-48.png\",\n        \"default_title\": \"My Test\",\n        \"default_popup\": \"html/page.html\"\n    }, //地址栏最后附加图标。含图标及行为等\n    \"theme\": {}, // 主题，用于更改整个浏览器的外观\n    \"app\": {}, // 指定扩展需要跳转到的URL\n    // 根据需要提供\n    \"background\": {\n       \"scripts\": [\n           \"lib/jquery-3.3.1.min.js\",\n           \"js/background.js\"\n\n       ] ,\n\n        \"page\":\"html/background.html\"\n\n    }, // 指定扩展进程的background运行环境\n\n    \"chrome_url_overrides\": {\n\n       \"pageToOverride\": \"html/overrides.html\"\n\n    }, //替换页面。详见注释1\n    \"content_scripts\": [{\n      \"matches\": [\"https://www.baidu.com/*\"],\n      \"css\": [\"css/mystyles.css\"],\n      \"js\": [\"lib/jquery-3.3.1.min.js\", \"js/content.js\"]\n    }], // 指定在web页面运行的脚本。详见注释2\n\n    \"content_security_policy\": \"\",  // 安全策略\n\n    \"file_browser_handlers\": [],   \n\n    \"homepage_url\": \"http://xxx\", // 扩展的官方主页\n\n    \"incognito\": \"spanning\", // 或\"split\"。详见注释3\n\n    \"intents\": {}, // 用户操作意图描述\n\n    \"key\": \"\", // 扩展唯一标识。不需要人为指定\n\n    \"minimum_chrome_version\": \"1.0\", // 扩展所需chrome的最小版本\n\n    \"nacl_modules\": [],  // 消息与本地处理模块映射\n\n    \"offline_enabled\": true, // 是否允许脱机运行\n\n    \"omnibox\": {\n\n       \"keyword\": \"myKey\"\n\n    }, //ominbox即地址栏。用于响应地址栏的输入事件\n\n    \"options_page\": \"aFile.html\", // 选项页。用于在扩展管理页面跳转到选项设置\n\n    \"permissions\": [\n\n       \"https://www.baidu.com/*\",\n\n       \"background\",\n\n       \"tabs\"\n\n    ], //权限。详见注释4\n\n    \"plugins\": [{\n\n       \"path\": \"extension_plugin.dll\",\n\n       \"public\": true\n\n    }], // 扩展。可调用第三方扩展\n\n    \"requirements\": {}, // 指定所需要的特殊技术。目前只支持\"3D\"\n\n    \"update_url\": \"http://path/to/updateInfo.xml\",   // 自动升级\n\n    \"web_accessible_resources\": [] // 指定资源路径，为String数组\n\n}\n```\n\n## 注释\n\n### chrome_url_overrides\n\n> 替换页面。用于将原定显示的页面替换为自定义的页面。其取值有4个：\n\n①   pageToOverride：页面。\n\n②   bookmarks：书签。\n\n③   history：历史。\n\n④   newtab：新标签页。\n\n### content_scripts\n\n> 指定要向Web页面内注入的脚本。可注入多个css与js。\n\n扩展本身的运行环境为background，而background与web页面的运行环境是相互独立的。若希望在扩展中对web页面进行修改，那就需要使用content_scripts。\n\ncontent_scripts运行在一个隔离环境中，即与background和web页面运行环境都独立。但content_scripts共享了web页面的DOM，所以content_scripts可以对web页面DOM进行操作。然而共享仅限于DOM，不包括任何js变量与函数。同理，web页面的js也不能访问content_scripts中的js变量与函数。于是，二者引入的库也不能共享，各自使用各自的库。\n\n借助事件的监听与触发，content_scripts可以与web页面的js进行通信。\n\ncontent_scripts格式如下：\n\n```js\n\n\"content_scripts\": [{\n\n      \"matches\": [\"https://www.baidu.com/*\"],\n\n      \"css\": [\"mystyles.css\"],\n\n      \"js\": [\"lib/jquery-3.3.1.min.js\", \"js/content.js\"],\n\n      \"run_at\": \"document_idle\"\n\n}],\n```\n\n其数组元素的字段有：\n\n①   matches：String数组，必须。定义content_scripts对哪些页面生效。其规则符合permissions的模式匹配。\n\n②   css：String数组，可选。定义哪些css文件在web页面DOM创建前注入到web页面中。\n\n③   js：String数组，可选。定义哪些js文件注入到web页面中。其js文件的注入顺序与数组中定义的顺序相同。至于这些js与web页面中所定义js的顺序关系，取决于run_at字段。\n\n④   run_at：String，可选。定义content_scripts的注入时机，从而影响到js与web页面所定义js的顺序关系。取值有：\n\n·document_start：所有css加载完毕，但DOM尚未创建时。\n\n·document_end：DOM创建完成，但图片及frame等子资源尚未加载时。\n\n·document_idle：document_end之后，window.onload之前。\n\n      默认是document_idle，也就是content_scripts的js都罗列在web页面的js之后。\n\n⑤   all_frames：boolean，可选。是否运行在页面所有的frame中。若为false，则只运行在最上层的frame中。默认为false。\n\n⑥   include_globs：String数组，可选。用于规定页面匹配的白名单。一个URL，必须同时满足：匹配matches，匹配include_globs白名单，不匹配exclude_globs黑名单这三个条件才可以。注意include_globs和exclude_globs中的匹配语法与permissions和matches所用的匹配模式不同。\n\n⑦   exclude_globs：String数组，可选。用于规定页面匹配的黑名单。同⑥。\n\n### incognito\n\n> 取值为：”spanning”/“split”。指定当浏览器处于隐身模式下时，扩展如何响应。默认为”spanning”。\n\n①   spanning：扩展会运行在共享进程中。标签页的事件和消息会发送给这个进程，来源通过incognito标志区分。\n\n②   split：扩展运行在独立的进程中。每个进程都只能看到自己的事件和消息，各进程间不能通信。\n\n### permissions\n\n>扩展所需要的权限。permissions是一个String数组，每一个权限都使用String来表示。某些权限在安装前会告知用户。\n\n特别注意permissions中若有不可识别的配置项，那么所有permissions配置项都会失效，即使其他的permissions配置项是正确的。\n\npermissions部分常用值如下：\n\n①   模式配匹：用于指定扩展会在哪些URL中生效。例如：\n\nhttp://*/*：匹配任何http协议的URL。\n\n*://*/*：匹配任何http/https协议的URL。\n\n<http://127.0.0.1/*：匹配任何本地请求URL>。\n\n<https://www.baidu.com/*：匹配https://www.baidu.com/开头的所有URL>。\n\n<all_urls>：匹配所有url。\n\n使用模式匹配时，直接将匹配规则字符串添加到permissions即可。\n\n可添加多个匹配规则字符串，匹配效果是这些规则的并集。\n\n若不添加匹配规则字符串，则默认对所有URL生效。\n\n②   background：启用扩展后端环境。即在浏览器运行期始终运行，与单个页面无关。可以在这里调用浏览器的API，通常在这里进行扩展主要逻辑的开发。配合manifest.json的background字段使用。\n\n③   bookmarks：启用书签权限。\n\n④   contextMenus：启用右键菜单权限。可针对不同文档单独定制。\n\n⑤   cookies：启用cookies权限。\n\n⑥   experimental：启用chrome的实验功能API。\n\n⑦   geolocation：允许扩展使用HTML5的地理位置API，无论用户是否有该权限。\n\n⑧   history：启用history权限。\n\n⑨   idle：启用延迟加载。\n\n⑩   management：启用管理权限。用于管理已安装和正在运行的扩展。\n\n⑪   notifications：启用桌面通知权限。不同平台下表现不同，但往往都是一个小弹窗。\n\n⑫   tabs：启用标签权限。用于管理chrome浏览器的标签栏，例如创建，修改，重新排列标签等，以及修改chrome窗体。\n\n实际上，大部分的chrome.tabs.API不需要任何权限就可以使用。tab的url、title和favIconUrl属性必须具有tabs权限才可以使用；tabs.captureVisibleTab必须有<all_urls>或activeTab权限才能使用。\n\n⑬   activeTab：启用活动标签权限。通常来说，tabs更多是用于操作tab标签和窗体属性的。对那些可以与当前web页面交互的API，往往都需要activeTab权限。例如，tabs.executeScript（向页面临时注入js并执行）和tabs.insertCSS（向页面临时注入css并执行），执行浏览器按钮，执行页面按钮，执行右键菜单项，通过命令API执行键盘快捷键等。\n","children":[]},{"name":"插件.md","path":"../guanruihua.github.io/Front-End/浏览器/浏览器插件","data":"# Edge 浏览器插件开发\n\n> 开发模板:  [chrome-extension-boilerplate-react](https://github.com/lxieyang/chrome-extension-boilerplate-react)\n\n## 文件目录介绍\n\npages里面的模块\n\n- Popup : 点击插件显示的弹框\n- Newtab : 新页面显示的页面\n- Panel: 控制台里面的tap页\n- Options: 插件的设置界面\n\n## Newtab重写\n\n`index.html` : 真正的入口文件\n`index.jsx`: 开发的入口文件\n`Newtab.jsx`: 开发的模板文件\n`Newtab.scss`: 开发模板文件的样式文件\n\n## permissions权限声明\n\n- `chrome`浏览器声明权限列表以及权限描述\n\n|权限 | 描述 |\n|:----|:----|\n|`activeTab` | 请求根据activeTab规范授予扩展名权限。 |\n|`alarms` | 扩展程序访问chrome.alarms API。 |\n|`background` | 具有后台权限，可以在后台运行，直到退出chrome；通常，“背景”权限与背景页面，事件页面或背景窗口一起使用。 |\n|`bookmarks` | 扩展程序访问chrome.bookmarks API的权限。 |\n|`browsingData` | 扩展程序可以访问chrome.browsingData API。 |\n|`certificateProvider` | 扩展程序授予chrome.certificateProvider API的访问权限。 |\n|`clipboardRead` | 如果扩展程序或应用程序使用，则为必填document.execCommand(‘paste’)。 |\n|`clipboardWrite` | 表示扩展程序或应用程序使用document.execCommand(‘copy’)或document.execCommand(‘cut’)。 |\n|`contentSettings` | 扩展程序访问chrome.contentSettings API。 |\n|`contextMenus` | 扩展程序访问chrome.contextMenus API。 |\n|`cookies` | 扩展程序访问chrome.cookies API。 |\n|`debugger` | 扩展程序访问chrome.debugger API。 |\n|`declarativeContent` | 扩展程序访问chrome.declarativeContent API的权限。 |\n|`declarativeNetRequest` | 扩展程序访问chrome.declarativeNetRequest API的权限。 |\n|`declarativeNetRequestFeedback` | 授予扩展程序对chrome.declarativeNetRequest API中的事件和方法的访问权限。 |\n|`declarativeWebRequest` | 扩展程序对chrome.declarativeWebRequest API的访问权限。 |\n|`desktopCapture` | 扩展程序可以访问chrome.desktopCapture API。 |\n|`displaySource` | 扩展程序授予chrome.displaySource API的访问权限。 |\n|`dns` | 扩展程序访问chrome.dns API。 |\n|`documentScan` | 扩展程序访问chrome.documentScan API的权限。 |\n|`downloads` | 扩展程序访问chrome.downloads API。 |\n|`enterprise`.deviceAttributes | 扩展程序访问chrome.enterprise.deviceAttributes API。 |\n|`enterprise`.hardwarePlatform | 扩展程序访问chrome.enterprise.hardwarePlatform API。 |\n|`enterprise`.networkingAttributes | 扩展程序访问chrome.enterprise.networkingAttributes API。 |\n|`enterprise`.platformKeys | 扩展程序访问chrome.enterprise.platformKeys API。 |\n|`experimental` | 扩展程序或应用程序使用任何chrome.experimental.* API，则为必填项。 |\n|`fileBrowserHandler` | 扩展程序授予chrome.fileBrowserHandler API的访问权限。 |\n|`fileSystemProvider` | 扩展程序访问chrome.fileSystemProvider API的权限。 |\n|`fontSettings` | 扩展程序访问chrome.fontSettings API。 |\n|`gcm` | 扩展程序访问chrome.gcm API。 |\n|`geolocation` | 扩展程序或应用程序使用建议的HTML5地理位置API，而无需提示用户进行许可。 |\n|`history` | 扩展程序访问chrome.history API。 |\n|`identity` | 扩展程序访问chrome.identity API。 |\n|`idle` | 扩展程序可以访问chrome.idle API。 |\n|`idltest` | 扩展程序可以访问chrome.idltest API。 |\n|`login` | 扩展程序可以访问chrome.login API。 |\n|`loginScreenStorage` | 扩展程序访问chrome.loginScreenStorage API的权限。 |\n|`loginState` | 扩展程序对chrome.loginState API的访问权限。 |\n|`management` | 扩展程序访问chrome.management API。 |\n|`nativeMessaging` | 扩展程序可以访问本机消息传递API。 |\n|`notifications` | 扩展程序访问chrome.notifications API。 |\n|`pageCapture` | 扩展程序可以访问chrome.pageCapture API。 |\n|`platformKeys` | 扩展程序可以访问chrome.platformKeys API。 |\n|`power` | 扩展程序访问chrome.power API。 |\n|`printerProvider` | 扩展程序访问chrome.printerProvider API的权限。 |\n|`printing` | 扩展程序访问chrome.printing API。 |\n|`printingMetrics` | 扩展程序可以访问chrome.printingMetrics API。 |\n|`privacy` | 扩展程序访问chrome.privacy API。 |\n|`processes` | 扩展程序可以访问chrome.processes API。 |\n|`proxy` | 扩展程序可以访问chrome.proxy API。 |\n|`scripting` | 扩展程序可以访问chrome.scripting API。 |\n|`search` | 扩展程序可以访问chrome.search API。 |\n|`sessions` | 扩展程序访问chrome.sessions API。 |\n|`signedInDevices` | 扩展程序可以访问chrome.signedInDevices API。 |\n|`storage` | 扩展程序可以访问chrome.storage API。 |\n|`system`.cpu | 扩展程序访问chrome.system.cpu API。 |\n|`system`.display | 扩展程序访问chrome.system.display API。 |\n|`system`.memory | 扩展程序访问chrome.system.memory API。 |\n|`system`.storage | 扩展程序访问chrome.system.storage API。 |\n|`tabCapture` | 扩展程序访问chrome.tabCapture API。 |\n|`tabGroups` | 扩展程序访问chrome.tabGroups API的权限。 |\n|`tabs` | 扩展程序可以访问Tab包括chrome.tabs和chrome.windows在内的多个API使用的对象的特权字段。在许多情况下，您的扩展程序无需声明\"tabs\"使用这些API的权限。 |\n|`topSites` | 扩展程序访问chrome.topSites API。 |\n|`tts` | 扩展程序可以访问chrome.tts API。 |\n|`ttsEngine` | 扩展程序访问chrome.ttsEngine API的权限。 |\n|`unlimitedStorage` | 提供无限的配额来存储HTML5客户端数据，例如数据库和本地存储文件。没有此许可，扩展程序或应用程序仅限于5 MB本地存储。 |\n|`vpnProvider` | 扩展程序访问chrome.vpnProvider API的权限。 |\n|`wallpaper` | 扩展程序访问chrome.wallpaper API。 |\n|`webNavigation` | 扩展程序访问chrome.webNavigation API的权限。 |\n|`webRequest` | 扩展程序可以访问chrome.webRequest API |\n|`webRequestBlocking` | 扩展程序以阻止方式使用chrome.webRequest API，则为必填。 |\n","children":[]}]},{"name":"缓存","path":"../guanruihua.github.io/Front-End/浏览器","data":"","children":[{"name":"http缓存.md","path":"../guanruihua.github.io/Front-End/浏览器/缓存","data":"# http 缓存\r\n\r\n## 分类\r\n\r\n> `强制缓存` 和 `协商缓存`\r\n\r\n![](./__assets__/http缓存-2022-11-14-16-29-49.png)\r\n\r\n## 强缓存\r\n\r\n> 强制缓存\r\n\r\n### `Expires`\r\n\r\n![](./__assets__/http缓存-2022-11-14-16-32-24.png)\r\n\r\n> - `Expires`字段的作用是，设定一个强缓存时间。在此时间范围内，则从内存（或磁盘）中读取缓存返回。\r\n>   - 比如说将某一资源设置响应头为:`Expires:new Date(\"2022-7-30 23:59:59\")`\r\n那么，该资源在`2022-7-30 23:59:59` 之前，都会去本地的磁盘（或内存）中读取，不会去服务器请求\r\n但是，Expires已经被废弃了。对于强缓存来说，Expires已经不是实现强缓存的首选\r\n> - `Expires`判断强缓存是否过期的机制是:获取本地时间戳，并对先前拿到的资源文件中的`Expires`字段的时间做比较。来判断是否需要对服务器发起请求。这里有一个巨大的漏洞：“如果我本地时间不准咋办？”\r\n> `Expires`过度依赖本地时间，如果本地与服务器时间不同步，就会出现资源无法被缓存或者资源永远被缓存的情况。所以，`Expires`字段几乎不被使用了。现在的项目中，我们并不推荐使用`Expires`，强缓存功能通常使用`cache-control`字段来代替`Expires`字段\r\n\r\n### `Cache-control`\r\n\r\n> 替代`Expires`的强缓存实现方法\r\n> `Cache-control`这个字段在`http1.1`中被增加，`Cache-control`完美解决了Expires本地时间和服务器时间不同步的问题。是当下的项目中实现强缓存的最常规方法。\r\n> `Cache-control`的使用方法页很简单，只要在资源的响应头上写上需要缓存多久就好了，单位是秒\r\n\r\n```js\r\n//往响应头中写入需要缓存的时间\r\nres.writeHead(200,{\r\n  'Cache-Control':'max-age=10'\r\n});\r\n```\r\n\r\n> 在该资源第一次返回的时候开始, 往后10秒内, 如果该资源背再次请求, 则从缓存中读取\r\n\r\n![](./__assets__/http缓存-2022-11-14-16-43-20.png)\r\n\r\n`Cache-Control`:\r\n\r\n- `max-age=N`: `N`就是需要缓存的秒数, 从第一次请求资源开始, 往后N秒内, 资源若再次请求, 则直接从磁盘(或内存中读取), 不与服务器交互\r\n- `max-age`: 决定客户端资源被缓存多久\r\n- `s-maxage`: 决定代理服务器缓存的时长\r\n- `no-cache` : 强制进行协商缓存\r\n- `no-store` : 禁止任何缓存策略\r\n- `public` : 资源即可以被浏览器缓存也可以被代理服务器缓存\r\n- `private` : 资源只能被浏览器缓存\r\n\r\n补充:\r\n\r\n- `no-cache` 和 `no-store` 为互斥属性, 不可同时出现在`Cache-Control`中\r\n\r\n#### `public` 和 `private`\r\n\r\n> 一般请求\r\n\r\n![](./__assets__/http缓存-2022-11-14-17-05-32.png)\r\n\r\n> 出现代理服务器\r\n\r\n![](./__assets__/http缓存-2022-11-14-17-05-40.png)\r\n\r\n`public`: 表示资源在客户端和代理服务器都可以被缓存\r\n`private`:\r\n\r\n- 表示资源只能在客户端被缓存, 拒绝资源在代理服务器缓存\r\n- 两值没有设置, 默认是`private`\r\n\r\n> `public` 和 `private` 是互斥属性, 不可同时出现\r\n\r\n### `max-age` 和 `s-maxage`\r\n\r\n- max-age表示的时间资源在客户端缓存的时长，而s-maxage表示的是资源在代理服务器可以缓存的时长。\r\n在一般的项目架构中max-age就够用。\r\n- s-maxage因为是代理服务端的缓存时长，他必须和上面说的public属性一起使用（public属性表示资源可以在代理服务器中缓存）。\r\n\r\n> `max-age`和`s-maxage`不互斥\r\n\r\n`Cache-control`如何设置多个值呢？用逗号分割: `Cache-control:max-age=10000,s-maxage=200000,public`\r\n\r\n> `Cache-control`是`Expires`的完全替代品，但是如果要考虑向下兼容的话，在`Cache-control`不支持的时候，还是要使用`Expires`\r\n\r\n## 协商缓存\r\n\r\n基于last-modified的协商缓存实现方式是:\r\n\r\n1. 首先需要在服务器端读出文件修改时间\r\n2. 将读出来的修改时间赋给响应头的last-modified字段\r\n3. 最后设置Cache-control:no-cache\r\n\r\n![](./__assets__/http缓存-2022-11-23-15-37-36.png)\r\n\r\n> - 第一行，读出修改时间\r\n> - 第二行，给该资源响应头的last-modified字段赋值修改时间\r\n> - 第三行，给该资源响应头的Cache-Control字段值设置为:no-cache.(上文有介绍，Cache-control:no-cache的意思是跳过强缓存校验，直接进行协商缓存。)\r\n\r\n当客户端读取到last-modified的时候，会在下次的请求标头中携带一个字段:If-Modified-Since\r\n\r\n![](./__assets__/http缓存-2022-11-23-15-42-11.png)\r\n\r\n而这个请求头中的If-Modified-Since就是服务器第一次修改时候给他的时间，也就是上图中的\r\n\r\n![](./__assets__/http缓存-2022-11-23-15-43-00.png)\r\n\r\n> 那么之后每次对该资源的请求，都会带上If-Modified-Since这个字段，而务端就需要拿到这个时间并再次读取该资源的修改时间，让他们两个做一个比对来决定是读取缓存还是返回新的资源\r\n\r\n![](./__assets__/http缓存-2022-11-23-15-44-14.png)\r\n\r\n![](./__assets__/http缓存-2022-11-23-15-44-32.png)\r\n\r\n使用以上方式的协商缓存已经存在两个非常明显的漏洞。这两个漏洞都是基于文件是通过比较修改时间来判断是否更改而产生的。\r\n\r\n1. 因为是更具文件修改时间来判断的，所以，在文件内容本身不修改的情况下，依然有可能更新文件修改时间（比如修改文件名再改回来），这样，就有可能文件内容明明没有修改，但是缓存依然失效了。\r\n2. 当文件在极短时间内完成修改的时候（比如几百毫秒）。因为文件修改时间记录的最小单位是秒，所以，如果文件在几百毫秒内完成修改的话，文件修改时间不会改变，这样，即使文件内容修改了，依然不会\r\n返回新的文件。\r\n为了解决上述的这两个问题。从http1.1开始新增了一个头信息，ETag(Entity 实体标签)\r\n\r\n## 基础ETag 的协商缓存\r\n\r\n> - `ETag`就是将原先协商缓存的比较时间戳的形式修改成了比较文件指纹\r\n> - `文件指纹`: 根据文件内容计算出的唯一哈希值, 文件一旦改变则指纹改变\r\n\r\n### 流程\r\n\r\n1. 第一次请求某资源的时候，服务端读取文件并计算出文件指纹，将文件指纹放在响应头的`etag`字段中跟资源一起返回给客户端。\r\n2. 第二次请求某资源的时候，客户端自动从缓存中读取出上一次服务端返回的ETag也就是文件指纹。并赋给请求头的`if-None-Match`字段，让上一次的文件指纹跟随请求一起回到服务端。\r\n3. 服务端拿到请求头中的is-None-Match字段值（也就是上一次的文件指纹），并再次读取目标资源并生成文件指纹，两个指纹做对比。如果两个文件指纹完全吻合，说明文件没有被改变，则直接返回304状态码和一个空的响应体并return。如果两个文件指纹不吻合，则说明文件被更改，那么将新的文件指纹重新存储到响应头的ETag中并返回给客户端\r\n\r\n![](./__assets__/http缓存-2022-11-23-15-55-20.png)\r\n\r\n![](./__assets__/http缓存-2022-11-23-15-55-31.png)\r\n\r\n### ETag也有缺点\r\n\r\n> ETag需要计算文件指纹这样意味着，服务端需要更多的计算开销。\r\n> 如果文件尺寸大，数量多，并且计算频繁，那么ETag的计算就会影响服务器的性能。显然，ETag在这样的场景下就不是很适合。\r\n\r\n> ETag有强验证和弱验证，所谓将强验证，ETag生成的哈希码深入到每个字节。哪怕文件中只有一个字节改变了，也会生成不同的哈希值，它可以保证文件内容绝对的不变。但是，强验证非常消耗计算量。\r\n> ETag还有一个弱验证，弱验证是提取文件的部分属性来生成哈希值。因为不必精确到每个字节，所以他的整体速度会比强验证快，但是准确率不高。会降低协商缓存的有效性。\r\n\r\n> 值得注意的一点是，不同于cache-control是expires的完全替代方案(说人话:能用`cache-control`就不要用`expires`)。ETag并不是`last-modified`的完全替代方案。而是`last-modified`的补充方案（说人话：项目中到底是用`ETag`还是`last-modified`完全取决于业务场景，这两个没有谁更好谁更坏）\r\n","children":[]},{"name":"web缓存.md","path":"../guanruihua.github.io/Front-End/浏览器/缓存","data":"# web缓存\r\n\r\n## 浏览器缓存\r\n\r\n> 主要是 `localStorage` 和 `sessionStorage`, `Cookie`\r\n\r\n## [http 缓存](/Front-End/浏览器/缓存/http缓存.md)\r\n\r\n> - web 缓存核心\r\n> - 可以自动保存常见文档副本的`HTTP`设备, 当 `Web` 请求抵达缓存时, 若本地有\"已缓存\"的副本, 就可以从本地存储设备而不是原始服务器提取\r\n\r\n> 解决问题:\r\n>\r\n> - 减少不必要的网络传输, 节约带宽\r\n> - 增加页面加载速度\r\n> - 减少服务器复制\r\n>\r\n> 缺点:\r\n>\r\n> - 占用内存\r\n","children":[]}]},{"name":"调试.md","path":"../guanruihua.github.io/Front-End/浏览器","data":"# 前端调试\n\n**1. 开启开发者工具的实验性功能**\n\n你可以到`chrome://flags`页面，然后开启`Developer Tools experiments`选项。\n\n当开启后，在开发者工具的设置页面，可以发现多了一个`Experiments`选项。如果我使用的一些功能你没有看到，那么请到`Experiments`窗口打开。\n\n**2.超级实验性功能**\n\n如果我使用到的功能在`Experiments`列表没有，那么它可能是一个WIP功能(WIP指working in progress)。你可以这样开启：页面处在`Experiments`界面，连续敲击`shift`键6次来开启WIP功能。\n\n[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f23f2b36f2bb~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Fwip.gif)\n\n### **Console**\n\n当Debug的时候，我们绝大部分时间是在和Console打交道。我们往往在代码中插入很多Console logs，通过打印变量值来debug。鉴于Console对于我们这么重要，很有必要了解所有开发者工具提供的相关的APIs和快捷键。\n\n**3. 总是打印对象**\n\n我的第一个建议其实和开发者工具没有关系，而是我一直使用的一个技巧。在使用`console.log();`的时候，不仅仅打印变量，而是要打印对象，用大括号(`{}`)将变量包围起来。这样的优点是不仅会把变量的值打印，同时还会将变量名打印出来。\n\n[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f23f2b52f08d~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Flogvar.png)\n\n[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f23f2f062636~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Flogobj.png)\n\n**4. 使用console.table来打印多条目数据**\n\n如果你要打印的变量是一个数组，每一个元素都是一个对象。我建议你使用`console.table`来打印，其表格化的呈现更加美观易读。\n\n[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f23f49221722~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Flogtable.png)\n\n**5. 给log加点颜色**\n\nlog有时候变得非常多，包含你自己的、一些第三方扩展或者浏览器的logs。除了使用过滤器(filter)以外，你还可以使用颜色来更好地区分。\n\n[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f2400f11e811~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Flogcolor.png)\n\n**6. $ 和 ?**\n\n如果你在console下没有任何库使用`$`和`?`，那么你可以使用它们分别作为`document.querySelector()` 和 `document.querySelectorAll()`的快捷键。\n\n除了提供了一个更加快捷的方式外，还有一个好处，`?`返回一个数组，而不是[array-like](https://link.juejin.cn?target=http%3A%2F%2F2ality.com%2F2013%2F05%2Fquirk-array-like-objects.html)的[NodeList](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FNodeList). 所以你可以直接使用[map](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FArray%2Fmap),    [reduce](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FArray%2Freduce)和[filter](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FArray%2Ffilter) 函数。\n\n你可以使用`?`检查页面中的无效链接：\n\n```js\nPromise\n  .all(\n    ?('a')\n      .map(link => link.href)\n      .map(href => fetch(href))\n  )\n  .then(() => console.log('All links working'))\n  .catch(() => console.error('Some links are broken'));\n\n```\n\n**7. $0**\n\n如果你想引用某个DOM元素，使用`$0`。`$0`指向你当前在Element中选中的元素。如果指定了`$0`，`$1`指向之前选中的元素。以此类推，直到`$4`都可以使用。\n\n**8. $_**\n\n`$_`记录了最后一次在Console计算的表达式。\n\n**9. getEventListeners()**\n\n`getEventListeners(domElement)` 返回在DOM元素上注册的所有的事件。请看下面的例子：\n\n[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f8f28abfc96f~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2FgeteventListeners.gif)\n\n你也许注意到了，当我在console里输入表达式的时候，其结果立即被计算出来了。你可以看到我并没有敲击Enter键，而结果已经显示出来。这个是金丝雀版本的一个新功能，叫做”Eager Evaluation”。\n\n[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f240125356e4~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Feager.png)\n\n**10. debug(fn)**\n\n在上面的例子中，如果你想在点击按钮后的执行过程中暂停，你可以使用`debug`函数。`debug(fn)`接收一个函数作为参数，当每次该函数被调用时，Debugger就会在该函数的第一行中断执行。\n\n想象一下你要debug一个按钮的问题，但是你不知道这个按钮对应的事件函数在代码中什么位置。除了去大量的源代码中慢慢寻找之外，还有一个巧妙的方法。使用`getEventListeners`函数，然后将`debug`方法注入进去。这样，当你点击按钮的时候，就会在该函数的第一行停下来。\n\n**11. copy(obj)**\n\n`copy(anything)` 是一个很有用的工具函数方便你将任何东西拷贝到系统的粘贴板暂存。\n\n给`copy`函数传入一个没有格式的JSON，会返回格式化的结果：\n\n[![img](https://blog.fundebug.com/2018/08/22/art-of-debugging-with-chrome-devtools/copy.gif)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Fcopy.gif)\n\n**12. Top-level await**\n\n`async/await` 使得异步操作变得更加容易和可读。唯一的问题在于`await`需要在async函数中使用。如果我们要在DevTools的控制台使用，需要一些特殊的处理，使用**I**mmediately **I**nvoked **A**sync **F**unction **E**xpression (IIAFE).    一点都不方便。好在DevTools已经支持直接使用await了。\n\n[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f2409dfbbab4~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Fawait.png)\n\n### Debugging in the Sources panel\n\n在source面板，使用breakpoints，stepping-into, stepping-over等方式，你可以很好地掌控程序的执行状态，来发现代码问题。接下里我不会介绍大家都知道的基础内容，而是一些我经常使用的建议和技巧。\n\n**13. 开启 auto-pretty print**\n\n在金丝雀版本的实验模式下，你可以开启自动美化代码模式。\n\n[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f241045dadf7~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Fpp.png)\n\n**14. 使用条件断点在生产环境中注入console logs**\n\n断点是一个很棒的功能。但还有一个更棒的：条件断点。只有当设定的条件满足的时候，中断才会执行。也就是说DevTools并不会每次都中断程序的执行，而只是在你想要它中断的时候才中断。想了解更多：查看[这里](https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Fupdates%2F2015%2F07%2Fset-a-breakpoint-based-on-a-certain-condition).\n\n在生产环境下，因为不能修改源代码，我喜欢使用条件断点来注入console.log。如果我的断点仅仅是一个console.log，DevTools不会中断，因为console.log返回undefined,，是一个false的值。但是它会执行我注入的表达式，可以看到输出结果。\n\n[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f241a92dd8af~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Fcb.gif)\n\n为什么不直接使用普通的断点，并且查看变量呢？有时候我并不想这样做。比如，当我在分析那些频繁执行的操作，例如触摸或则滑动。我并不想每一次都导致Debugger触发程序中断，但是我想看到程序输出的结果。\n\n**15. 暂停UI在Hover状态下的展示结果**\n\n我们很难去检查一个只有在Hover状态下展示的元素。比如，如何去检查一个tooltip？如果你右键并选择检查，元素已经消失了。那么有办法吗？\n\n我是这么操作的：\n\n1. 打开sources面板\n2. 显示tooltip\n3. 使用快捷键来暂停脚本执行(将鼠标停留在暂停的图标上查看快捷键)\n4. 回到Elements面板，然后像通常一样去检查元素\n\n[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f241aa9f5f88~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Ftooltip.gif)\n\n**16. XHR breakpoints**\n\n如果想要理解一个请求是如何执行的，可以使用sources面板的XHR breakpoints。\n\n**17. 使用DevTools作为IDE**\n\nDevTools的source面板可以说相当强大。你可以快速查找，跳转到某一行，某个函数，执行一段代码，使用多行光标等等。这些功能在[这篇medium文章中有详细描述](https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fgoogle-developers%2Fdevtools-tips-for-sublime-text-users-cdd559ee80f8)。\n\n既然如此，为啥不把整个开发都搬到这里呢。这样就不需要浪费时间切换IDE和浏览器了。\n\n如果你有一个使用[create-react-app](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Fcreate-react-app)或则[vue-cli](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue-cli)构建的项目，你可以直接把整个文件夹拖到Sources面板下。DevTools会自动对所有文件做映射。所以，你可以在DevTools下修改文件并立即查看。这样，整个开发效率，特别是Debugging效率绝对提高了。\n\n[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f242a31a96c7~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Fdevtoolsaside.gif)\n\n**18. 使用network overrides来简单调试生产代码**\n\n如果你正在Debugging一个生产环境下面的bug，你可以使用`network overrides`来调试，而不用在本地搭建整个配置。\n\n你可以很容易将任何远程的资源下载一份本地的版本，然后可以在DevTools下编辑，并且DevTools会更新展示你编辑后的文件。\n\n[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f242e18f67e7~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Flocalcopy.gif)\n\n在生产环境下，也可以很容易Debugging，并且做一些性能上的测试也变得容易。\n\n### **19. Nodejs debugging**\n\n如果你想使用DevTools的Debugger来debug Node.js应用，你可以使用`--inspect-brk` flag来开启：\n\n```\nnode --inspect-brk script.js\n\n```\n\n跳转到`chrome://inspect`页面，在`Remote Target`选项，可以看到Node程序。\n\n并且，在DevTools中你会看到一个绿色的Node图标，点击图标会打开针对Node的Chrome Debugger。\n\n[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f2441a2b4ca7~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Fnodedebug.gif)\n\n如果你想要用DevTools Debugger来debug你的单元测试，你需要这样调用：\n\n```\nnode --inspect-brk ./node_modules/.bin/jest\n\n```\n\n不过这样做其实很麻烦，我们需要自己找到相应的路径。 GoogleChromeLabs 最近发布了一个新的工具非常好用，叫做：[ndb](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FGoogleChromeLabs%2Fndb)。使用ndb，你只需要：\n\n```\nndb npx jest\n\n```\n\n如果你有一个自定义的脚本，你可以这样调用：\n\n```\nndb npm run unit\n\n```\n\n更妙的是，如果你在一个有配置`package.json`的项目下调用`ndb`，他甚至会自动分析package.json中的脚本，方便你直接使用DevTools。\n\n**20. 使用Snippets来辅助Debugging**\n\nDevTools提供了一个可以创建和保存小段代码的工具，我很喜欢用它们来加速我的工作。比如lodashify — 可以快速给任何应用添加lodash。\n\n```\n(function () {\n    'use strict';\n\n    var element = document.createElement('script');\n    element.src = \"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.15.0/lodash.min.js\";\n    element.type = \"text/javascript\";\n    document.head.appendChild(element);\n})();\n\n```\n\n另一个小的工具函数式用来增强对象的属性，每次被访问或则修改，它都会提供给我充分的信息，比如谁访问了，谁更改了它。在Debugging的时候，非常有用。\n\n```\nconst traceProperty = (object, property) => {\n  let value = object[property];\n  Object.defineProperty(object, property, {\n    get () {\n      console.trace(`${property} requested`);\n      return value;\n    },\n    set (newValue) {\n      console.trace(`setting ${property} to `, newValue);\n      value = newValue;\n    },\n  })\n};\n\n```\n\n[![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/22/1655f2441a3c692c~tplv-t2oaga2asx-watermark.awebp)](https://link.juejin.cn?target=https%3A%2F%2Fblog.fundebug.com%2F2018%2F08%2F22%2Fart-of-debugging-with-chrome-devtools%2Fsnippet.gif)\n\n还有很多非常有用的[devtools代码片段](https://link.juejin.cn?target=http%3A%2F%2Fbgrins.github.io%2Fdevtools-snippets%2F)，你可以直接拿去使用。\n","children":[]}]},{"name":"问题","path":"../guanruihua.github.io/Front-End","data":"","children":[{"name":"内存.md","path":"../guanruihua.github.io/Front-End/问题","data":"# 内存\n\n## 内存泄露和和内存溢出\n\n内存溢出\n\n- 是一种程序运行出现的错误\n- 但程序运行所需内存超过计算机剩余内存时, 程序崩溃, 并报出内存溢出的错误\n\n内存泄露\n\n- 指内存被占用且没有及时释放\n- 内存泄露越多, 计算机剩余的内存就越小, 此时越容易发生内存溢出\n- 常见的内存泄露情况\n  - 意外的全局变量\n  - 未及时清理计时器或回调函数\n  - 闭包\n\n```js\nfunction x(){\n  a = 10;\n  //或者this.a = 10;\n  //或者window.a = 10;\n}\nx();\n//产生了一个意外的全局变量\n```\n\n```js\nvar intervald = setInterval(function (){\n console.log('----');\n},1000);\n//清除计时器\nclearInterval(intervalId);\n-----------------------------------------\nvar element = document.getElementById('button');\nfunction onClick(event) {\n element.innerHtml = 'text';\n}\nelement.addEventListener('click', onClick);\nelement.removeEventListener('click', onClick);\nelement.parentNode.removeChild(element);\n\n```\n\n```js\nfunction a(){\n  var x = 10;\n  function b(){\n    return x;\n  }\n  return b;\n}\nvar f = a();\nf();\n//将内部函数对象设置为垃圾对象\nf = null;\n\n```\n","children":[]},{"name":"同步和异步.md","path":"../guanruihua.github.io/Front-End/问题","data":"# 同步和异步\n\n```js\nfor(var i=0; i<4; i++){\n  setTimeout(function(){\n    console.log(i)\n  }, 0)\n}\n// 4 4 4 4\n```\n\n> for循环是同步任务, 会先执行完循环, 此时 i的值为4, 4ms后`console.log(i)`被一次放入任务队列, 此时如果执行栈中没有同步任务了,  就从任务队列中一次取出任务, 所以打印4个4\n\n输出1,  2, 3, 4的解决方法\n\n> 1. 把var换成let\n>\n>    - let 不会变量提升, 而且let有块级作用域\n>\n> 2. 使用立即执行函数\n>\n>    ```js\n>    for(let i=0; i<4; i++){\n>      (function(i){\n>        setTimeout(function(){\n>          console.log(i)\n>        }, 0)\n>      })(i)\n>    }\n>    ```\n>\n> 3. 加闭包\n>\n>    ```js\n>    for(let i = 0; i<4: i++){\n>     var a = function(){\n>       var j = i;\n>        setTimeout(function(){\n>         console.log(j)\n>        },0)\n>      }\n>      a();\n>    }\n>    ```\n\n```js\nsetTimeout(function(){\n    console.log(1)\n});\nnew Promise(function(resolve){\n    console.log(2);\n    for(var i = 0; i < 10000; i++){\n        i == 9999 && resolve();\n    }\n}).then(function(){\n    console.log(3)\n});\nconsole.log(4);\n执行结果：\n// 2， 4， 3， 1\n```\n\n> 1. setTimeout异步, 且是宏函数, 放到宏函数队列中\n> 2. new Promise是同步任务, 直接执行, 打印2, 并执行for循环\n> 3. promise.then是微任务, 放到微任务队列中\n> 4. console.log(4)是同步任务, 直接执行, 打印4\n> 5. 此时主线程执行完毕, 开始检查微任务队列中, 有promise.then, 执行微任务, 打印3;\n> 6. 微任务执行完毕, 第一次循环结束; 从宏任务队列中取出第一个宏任务到主线程执行, 打印1\n> 7. 结果: 2, 4, 3, 1\n>\n> 执行顺序: 同步任务 > 微任务 > 异步任务\n\n```js\nfunction add(x, y) {\n  console.log(1)\n  setTimeout(function() { // timer1\n    console.log(2)\n  }, 1000)\n}\nadd();\n\nsetTimeout(function() { // timer2\n  console.log(3)\n})\n\nnew Promise(function(resolve) {\n  console.log(4)\n  setTimeout(function() { // timer3\n    console.log(5)\n  }, 100)\n  for(var i = 0; i < 100; i++) {\n    i == 99 && resolve()\n  }\n}).then(function() {\n  setTimeout(function() { // timer4\n    console.log(6) \n  }, 0)\n  console.log(7)\n})\n\nconsole.log(8)\n\n执行结果\n//1，4，8，7，3，6，5，2\n```\n\n> 1. add()是同步任务, 直接执行打印1\n> 2. add()里面的setTimeout是异步任务且宏函数, 记做timer1放到宏函数队列\n> 3. add() 下的setTimeout是异步任务且宏函数, 记做timer2放到宏函数队列\n> 4. new Promise是同步任务, 直接执行, 打印4\n> 5. Promise里面的setTimeout是异步任务且为宏函数, 记做timer3 放到宏函数队列中\n> 6. Promise里面的for是同步任务直接执行\n> 7. Promise.then是微任务, 放到微任务队列\n> 8. console.log(8)是同步任务, 直接执行, 打印8\n> 9. 此时主线程任务执行完毕, 检查任务队列中, 有Promise.then, 执行微任务, 发现有setTimeout是异步函数, 记做timer4放到宏函数队列;\n> 10. 微任务中的console.log(7)是同步任务, 直接执行, 打印7\n> 11. 微任务执行完毕, 第一次循环结束\n> 12. 检查宏任务Event Table, 里面有timer1, timer2, timer3, timer4, 四个定时器宏任务, 按照定时器延迟时间得到可以执行顺序, 即Event Queue: timer2, timer4, timer3, timer1, 取出排在第一个的timer2\n> 13. 取出timer2执行, console.log(3)同步任务, 直接执行, 打印3\n> 14. 没有微任务, 第二次Event Loop结束\n> 15. 取出timer4执行, console.log(6) 同步任务, 直接执行, 打印6\n> 16. 没有微任务, 第三次Event Loop结束\n> 17. 取出timer3执行, 执行console.log(5)同步任务, 直接执行, 打印5\n> 18. 没有微任务, 第四次Event Loop结束\n> 19. 取出timer1执行, console.log(2)同步任务, 直接执行, 打印2\n> 20. 没有微任务, 也没有宏任务, 第五次Event Loop结束\n\n> 先执行同步任务,再执行该任务的微任务, 若有异步且为宏函数就放到宏函数队列\n>\n> 执行完该同步任务, 然后开始检查宏函数队列,然后按照对应的规则取出任务, 执行重复该过程\n","children":[]},{"name":"闭包.md","path":"../guanruihua.github.io/Front-End/问题","data":"\n# 闭包\n\n> 我的理解:  **闭包就是能够读取其他函数内部变量的函数**\n>\n> 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把**闭包简单理解成\"定义在一个函数内部的函数\"**。\n>\n> **闭包就是将函数内部和函数外部连接起来的一座桥梁。**\n\n- js垃圾回收机制：js 中的变量和函数不再使用后，会被自动js垃圾回收机制回收。\n\n- 形成闭包的条件：有函数/作用域的嵌套；内部函数引用外部函数的变量/参数。\n\n- 闭包的结果：内部函数的使用外部函数的那些变量和参数仍然会保存，使用`return`返回了此内部函数，上面的变量和参数不会被回收。\n\n- 闭包的原因：返回的函数并非孤立的函数，而是连同周围的环境（AO）打了一个包，成了一个封闭的环境包，共同返回出来 ---->闭包。\n\n- 我们在返回函数的时候，并不是单纯的返回了一个函数，我们把该函数连同他的AO链一起返回了。\n\n- 函数的作用域，取决于声明时而不取决于调用时。\n\n- 变量存储`function(){}`、`{}`、`[]`存储的是一个地址。\n\n### 闭包实现 : 每一秒输出一个数字\n\n- 问题 :\n\n```js\nfor(let i = 0; i<5;i++){\n    // 在此处写代码 实现每一秒输出一个数字\n}\n```\n\n- 解决:\n\n使用闭包\n\n```js\nfor(let i = 0; i<5;i++){\n    (function (i){\n      settimeout(()=>{\n          console.log(i);\n      })    \n    },(i+1)*1000)(i);\n}\n```\n\n## 给滚动事件添加deBounce(防抖)\n\n> 在操作结束后的一段时间内执行一次\n\n# 闭包\n\n```js\n\n/****************我是分割线********************/\nexport defalut ComponentDemo extends React.PureComponent{\n  constructor(props){\n    super(props);\n    this.debounce = this.debounce.bind(this);\n    this.scrollHandler = this.scrollHandler.bind(this);\n  }\n\n  debounce(func,time){\n    let timer = null;\n    return function(){\n      clearTimeOut(timer);\n      timer = settimeout(()=>{\n        func();\n      })\n    }\n  }\n  scrollHandler(){\n    /** 函数处理**/\n  }\n  componentDidMount(){\n    window.addEventListern('scroll',this.debounce(()=>this.scrollHandler()),300);\n  }\n  /** @desc 通常来说,添加了监听事件,就要移除滚动,如果是单页面就不需要移除 , 页面销毁后 , 监听事件也会被移除*/\n  componentWillUnmoun(){\n    window.removeEventListern('scroll',this.sdebounce(()=>this.scrollHandler(),300))\n  }\n}\n```\n","children":[]}]},{"name":"项目搭建","path":"../guanruihua.github.io/Front-End","data":"","children":[{"name":"esbuild","path":"../guanruihua.github.io/Front-End/项目搭建","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Front-End/项目搭建/esbuild","data":"# esbuild\n\n> 不支持转换为ES5, 暂时不学习\n","children":[]}]},{"name":"Gulp","path":"../guanruihua.github.io/Front-End/项目搭建","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Front-End/项目搭建/Gulp","data":"# Gulp\n\n> [官网](https://www.gulpjs.com.cn/docs/getting-started/quick-start/)\n","children":[]}]},{"name":"Rollup","path":"../guanruihua.github.io/Front-End/项目搭建","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Front-End/项目搭建/Rollup","data":"# Roadhog\n\n> [roadhog 介绍 - echo丶若梦 - 博客园 (cnblogs.com)](https://www.cnblogs.com/gaoht/p/9400386.html)\n\n## 安装\n\n`npm install rollup -g`\n\n## 插件\n\n### babel\n\n#### rollup-plugin-babel\n\n> 使用未被浏览器或node.js支持的js特性\n\n```js\n// rollup.config.js\nimport resolve from 'rollup-plugin-node-resolve';\nimport babel from 'rollup-plugin-babel';\n\nexport default {\n  input: 'src/main.js',\n  output: {\n    file: 'bundle.js',\n    format: 'cjs'\n  },\n  plugins: [\n    resolve(),\n    babel({\n      exclude: 'node_modules/**' // 只编译我们的源代码\n    })\n  ]\n};\n```\n\n```js\n// .babelrc\n{\n  \"presets\": [\n    [\"latest\", {\n      \"es2015\": {\n        \"modules\": false\n      }\n    }]\n  ],\n  \"plugins\": [\"external-helpers\"]\n}\n\n```\n\n### the-answer\n\n> 将commonjs 装换为ES2015\n\n### rollup-plugin-commonjs​\n\n> 导入es6模块\n\n### rollup-plugin-node-resolve​\n\n> 告诉Rollup如何查找外部模块\n\n```js\n// rollup.config.js\nimport resolve from 'rollup-plugin-node-resolve';\n\nexport default {\n  input: 'src/main.js',\n  output: {\n    file: 'bundle.js',\n    format: 'cjs'\n  },\n  plugins: [resolve({\n    // 将自定义选项传递给解析插件\n    customResolveOptions: {\n      moduleDirectory: 'node_modules'\n    }\n  })],\n  // 指出应将哪些模块视为外部模块\n  external: ['lodash']\n};\n```\n\n### json相关\n\n> 解析json文件\n> `rollup-plugin-json`\n> `@rollup/plugin-json` (推荐)\n\n```js\nimport json from \"rollup-plugin-json\"\n// 或\nimport json from \"@rollup/plugin-json\"\n\nexport default {\n // ...\n plugins:[json()]\n // 或\n // JSON文件可能会变得很大，您可能不需要所有内容。您可以将参数 compact 作为 传递，\n // 它将生成最少量的代码rue\n plugins:[ json({ compact: true })]\n}\n```\n\n## 配置文件\n\n```js\n// rollup.config.js\nexport default {\n  // 核心选项\n  input,     // 必须\n  external,\n  plugins,\n\n  // 额外选项\n  onwarn,\n\n  // danger zone\n  acorn,\n  context,\n  moduleContext,\n  legacy\n\n  output: {  // 必须 (如果要输出多个，可以是一个数组)\n    // 核心选项\n    file,    // 必须\n    format,  // 必须\n    name,\n    globals,\n\n    // 额外选项\n    paths,\n    banner,\n    footer,\n    intro,\n    outro,\n    sourcemap,\n    sourcemapFile,\n    interop,\n\n    // 高危选项\n    exports,\n    amd,\n    indent\n    strict\n  },\n};\n```\n\n### 使用配置文件\n\n> `--config` 简写 `-c`\n\n```shell\n# 默认使用rollup.config.js\n\n$ rollup --config\n\n# 或者, 使用自定义的配置文件，这里使用my.config.js作为配置文件\n\n$ rollup --config my.config.js\n```\n\n## rollup.watch\n\n> 检测某个模块已经改变, 就会重新构建文件束\n> `--watch` : 此函数会被内部使用\n\n```js\nconst rollup = require('rollup');\n\nconst watchOptions = {...};\nconst watcher = rollup.watch(watchOptions);\n\nwatcher.on('event', event => {\n  // event.code 会是下面其中一个：\n  //   START        — 监听器正在启动（重启）\n  //   BUNDLE_START — 构建单个文件束\n  //   BUNDLE_END   — 完成文件束构建\n  //   END          — 完成所有文件束构建\n  //   ERROR        — 构建时遇到错误\n  //   FATAL        — 遇到无可修复的错误\n});\n\n// 停止监听\nwatcher.close();\n```\n\n## 选项表\n\n### 监听参数 (watchOptions)\n>\n> - 输入(input -i/--input)​\n> - String 这个包的入口点 (例如：你的 main.js 或者 app.js 或者 index.js)\n>\n> - 文件(file -o/--output.file)​\n> - String 要写入的文件。也可用于生成 sourcemaps，如果适用\n>\n> - 格式(format -f/--output.format)​\n> - String 生成包的格式。 下列之一:\n>   - amd – 异步模块定义，用于像RequireJS这样的模块加载器\n>   - cjs – CommonJS，适用于 Node 和 Browserify/Webpack\n>   - esm – 将软件包保存为 ES 模块文件，在现代浏览器中可以通过 `<script type=module>` 标签引入\n>   - iife – 一个自动执行的功能，适合作为`<script>`标签。（如果要为应用程序创建一个捆绑包，您可能想要使用它，因为它会使文件大小变小。）\n>   - umd – 通用模块定义，以amd，cjs 和 iife 为一体\n>   - system - SystemJS 加载器格式\n>\n### 生成包名称(name -n/--name)​\n\nString 变量名，代表你的 iife/umd 包，同一页上的其他脚本可以访问它。\n\n```js\n// rollup.config.js\nexport default {\n  ...,\n  output: {\n    file: 'bundle.js',\n    format: 'iife',\n    name: 'MyBundle'\n  }\n};\n\n// -> var MyBundle = (function () {...\n```\n\n### 插件(plugins)​\n\n> 插件对象 数组 Array (或一个插件对象) – 有关详细信息请参阅 插件入门。记住要调用导入的插件函数(即 commonjs(), 而不是 commonjs).\n\n```js\n// rollup.config.js\nimport resolve from 'rollup-plugin-node-resolve';\nimport commonjs from 'rollup-plugin-commonjs';\n\nexport default {\n  entry: 'main.js',\n  plugins: [\n    resolve(),\n    commonjs()\n  ]\n};\n```\n\n### 外链(external -e/--external)​\n\n> 两者任一 Function 需要一个 id 并返回 true（外部引用）或 false（不是外部的引用）， 或者 Array 应该保留在bundle的外部引用的模块ID。ID应该是：\n\n外部依赖的名称\n一个已被找到路径的ID（像文件的绝对路径）\n\n```js\n// rollup.config.js\nimport path from 'path';\n\nexport default {\n  ...,\n  external: [\n    'some-externally-required-library',\n    path.resolve( './src/some-local-file-that-should-not-be-bundled.js' )\n  ]\n};\n\n```\n\n当作为命令行参数给出时，它应该是以逗号分隔的ID列表：\n\n`rollup -i src/main.js ... -e foo,bar,baz`\n\n全局模块(globals -g/--globals)​\nObject 形式的 id: name 键值对，用于umd/iife包。例如：在这样的情况下...\n\n```js\n\nimport $ from 'jquery';\n\n// ...我们想告诉 Rollup jquery 模块的id等同于 $ 变量:\n\n// rollup.config.js\nexport default {\n  ...,\n  format: 'iife',\n  name: 'MyBundle',\n  globals: {\n    jquery: '$'\n  }\n};\n\n/*\nvar MyBundle = (function ($) {\n  // 代码到这里\n}(window.jQuery));\n*/.\n```\n\n或者，提供将外部模块ID转换为全局模块的功能。\n\n当作为命令行参数给出时，它应该是一个逗号分隔的“id：name”键值对列表：\n\n`rollup -i src/main.js ... -g jquery:$,underscore:_`\n\n```js\nconst watchOptions = {\n  ...inputOptions,\n  output: [outputOptions],\n  watch: {\n    chokidar,\n    include,\n    exclude\n  }\n};\n```\n\n### 路径(paths)\n\n> Function，它获取一个ID并返回一个路径，或者id：path对的Object。\n> 在提供的位置，这些路径将被用于生成的包而不是模块ID，从而允许您（例如）从CDN加载依赖关系：\n\n```js\n// app.js\nimport { selectAll } from 'd3';\nselectAll('p').style('color', 'purple');\n// ...\n\n// rollup.config.js\nexport default {\n  input: 'app.js',\n  external: ['d3'],\n  output: {\n    file: 'bundle.js',\n    format: 'amd',\n    paths: {\n      d3: 'https://d3js.org/d3.v4.min'\n    }\n  }\n};\n\n// bundle.js\ndefine(['https://d3js.org/d3.v4.min'], function (d3) {\n\n  d3.selectAll('p').style('color', 'purple');\n  // ...\n\n});\n```\n\n### intro/outro​\n\n> String类似于 banner和footer，除了代码在内部任何特定格式的包装器(wrapper)\n\n```js\nexport default {\n  ...,\n  intro: 'var ENVIRONMENT = \"production\";'\n};\n```\n\n### 缓存(cache)​\n\n> Object 以前生成的包。使用它来加速后续的构建——Rollup只会重新分析已经更改的模块。\n\n### onwarn​\n\nFunction 将拦截警告信息。如果没有提供，警告将被复制并打印到控制台。\n\n警告是至少有一个code 和 message属性的对象，这意味着您可以控制如何处理不同类型的警告：\n\n```js\n\nonwarn (warning) {\n  // 跳过某些警告\n  if (warning.code === 'UNUSED_EXTERNAL_IMPORT') return;\n\n  // 抛出异常\n  if (warning.code === 'NON_EXISTENT_EXPORT') throw new Error(warning.message);\n\n  // 控制台打印一切警告\n  console.warn(warning.message);\n}\n```\n\n许多警告也有一个loc属性和一个frame，你可以定位到警告的来源：\n\n```js\n\nonwarn ({ loc, frame, message }) {\n  // 打印位置（如果适用）\n  if (loc) {\n    console.warn(`${loc.file} (${loc.line}:${loc.column}) ${message}`);\n    if (frame) console.warn(frame);\n  } else {\n    console.warn(message);\n  }\n}\n```\n\n### sourcemap -m/--sourcemap​\n\n> 如果 true，将创建一个单独的sourcemap文件。如果 inline，sourcemap将作为数据URI附加到生成的output文件中。\n\n### sourcemapFile​\n\n> String生成的包的位置。如果这是一个绝对路径，sourcemap中的所有源代码路径都将相对于它。 map.file属性是sourcemapFile的基本名称(basename)，因为sourcemap的位置被假定为与bundle相邻\n> 如果指定 output，sourcemapFile 不是必需的，在这种情况下，将通过给bundle输出文件添加 “.map” 后缀来推断输出文件名。\n\n### interop​\n\n> Boolean 是否添加'interop块'。默认情况下（interop：true），为了安全起见，如果需要区分默认和命名导出，则Rollup会将任何外部依赖项“default”导出到一个单独的变量。这通常只适用于您的外部依赖关系（例如与Babel）（如果您确定不需要它），则可以使用“interop：false”来节省几个字节。\n\n### Watch options​\n\n> 这些选项仅在运行 Rollup 时使用 --watch 标志或使用 rollup.watch 时生效。\n\n#### watch.chokidar​\n\n> 一个 Boolean 值表示应该使用 chokidar 而不是内置的 fs.watch，或者是一个传递给 chokidar 的选项对象。\n> 如果你希望使用它，你必须单独安装chokidar。\n\n#### watch.include​\n\n> 限制文件监控至某些文件\n\n```js\n\n// rollup.config.js\nexport default {\n  ...,\n  watch: {\n    include: 'src/**'\n  }\n};\n\n```\n\n#### watch.exclude​\n\n> 防止文件被监控：\n\n```js\n\n\n// rollup.config.js\nexport default {\n  ...,\n  watch: {\n    exclude: 'node_modules/**'\n  }\n};\n```\n\n## 命令行参数\n\n```shell\n-i, --input <filename>      要打包的文件（必须）\n-o, --file <output>         输出的文件 (如果没有这个参数，则直接输出到控制台)\n-f, --format <format>       输出的文件类型 (amd, cjs, esm, iife, umd)\n-e, --external <ids>        将模块ID的逗号分隔列表排除\n-g, --globals <pairs>       以`module ID:Global` 键值对的形式，用逗号分隔开 \n                              任何定义在这里模块ID定义添加到外部依赖\n-n, --name <name>           生成UMD模块的名字\n-h, --help                  输出 help 信息\n-m, --sourcemap             生成 sourcemap (`-m inline` for inline map)\n--amd.id                    AMD模块的ID，默认是个匿名函数\n--amd.define                使用Function来代替`define`\n--no-strict                 在生成的包中省略`\"use strict\";`\n--no-conflict               对于UMD模块来说，给全局变量生成一个无冲突的方法\n--intro                     在打包好的文件的块的内部(wrapper内部)的最顶部插入一段内容\n--outro                     在打包好的文件的块的内部(wrapper内部)的最底部插入一段内容\n--banner                    在打包好的文件的块的外部(wrapper外部)的最顶部插入一段内容\n--footer                    在打包好的文件的块的外部(wrapper外部)的最底部插入一段内容\n--interop                   包含公共的模块（这个选项是默认添加的）\n```\n","children":[]},{"name":"问题.md","path":"../guanruihua.github.io/Front-End/项目搭建/Rollup","data":"# 问题\r\n\r\n## Missing global variable names\r\n\r\n报错信息：\r\n\r\n```shell\r\n(!) Missing global variable name\r\nUse output.globals to specify browser global variable names corresponding to external modules\r\naxios (guessing 'axios')\r\n```\r\n\r\n解决方法：\r\n\r\n在配置文件增加 global\r\n\r\nrollup.config.js\r\n\r\n```js\r\n{\r\n  external: [\r\n    'react',\r\n    'react-dom',\r\n    'prop-types'\r\n  ],\r\n  output: {\r\n    globals: {\r\n      'axios': 'axios'\r\n    },\r\n    ...\r\n  },\r\n  ...\r\n}\r\n```\r\n\r\n参考资料：\r\n\r\n<https://github.com/rollup/rollup-plugin-babel/issues/162>\r\n\r\n## You have passed an unrecognized option\r\n\r\n报错信息：\r\n\r\n```shell\r\n(!) You have passed an unrecognized option\r\nUnknown input option: plugin. Allowed options: acorn, acornInjectPlugins, cache, chunkGroupingSize,  \r\ncontext, experimentalCacheExpiry, experimentalOptimizeChunks, experimentalTopLevelAwait, external,   \r\ninlineDynamicImports, input, manualChunks, moduleContext, onwarn, perf, plugins, preserveModules, \r\npreserveSymlinks, shimMissingExports, strictDeprecations, treeshake, watch\r\n```\r\n\r\n解决方法：\r\n\r\n我傻了，手残把配置文件中的 plugins 错打成 plugin (:з」∠)\r\n\r\n参考资料：\r\n\r\n<https://github.com/rollup/rollup/issues/2682>\r\n\r\n## Babel 7.0.0-beta.56 has dropped support for the ‘helpersNamespace’ utility\r\n\r\n报错信息：\r\n\r\n```shell\r\n[!] (plugin babel) Error: Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If \r\nyou are using @babel/plugin-external-helpers you will need to use a newer version than the one you \r\ncurrently have installed. If you have your own implementation, you'll want to explore using \r\n'helperGenerator' alongside 'file.availableHelper()'.\r\n```\r\n\r\n解决方法：\r\n\r\n方法 1.安装 babel 6.x\r\n\r\n`npm install --save-dev rollup-plugin-babel@3`\r\n安装了之后出现新的问题\r\n\r\n[!] Error: Cannot find module 'babel-core'\r\n继续安装 babel-core\r\n\r\n`npm install --save-dev babel-core`\r\n方法 2.安装 babel-upgrade\r\n\r\n`npm install --save-dev babel-upgrade`\r\n安装了之后出现新的问题\r\n\r\n```shell\r\n[!] (plugin babel) Error: Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If  \r\nyou are using @babel/plugin-external-helpers you will need to use a newer version than the one you \r\ncurrently have installed. If you have your own implementation, you'll want to explore using \r\n'helperGenerator' alongside 'file.availableHelper()'.\r\n```\r\n\r\n配置文件 rollup.config.js\r\n\r\n```js\r\nplugins: [\r\n    //...\r\n    babel(\r\n        babelrc({\r\n            addExternalHelpersPlugin: false,\r\n            exclude: /node_modules/,\r\n            runtimeHelpers: false\r\n        })\r\n    ),\r\n    //...\r\n]\r\n```\r\n\r\n有新的报错：\r\n\r\n`[!] (plugin babel) ReferenceError: Unknown option: .addExternalHelpersPlugin. Check out <https://babeljs.io/docs/en/babel-core/#options> for more information about options.`\r\n累了，放弃这个方法 (:з」∠)\r\n\r\n参考资料：\r\n\r\n<https://github.com/rollup/rollup-plugin-babel/issues/237>\r\n\r\n## Unexpected token (Note that you need rollup-plugin-json to import JSON files)\r\n\r\n报错信息：\r\n\r\n`[!] Error: Unexpected token (Note that you need rollup-plugin-json to import JSON files)`\r\n解决方法：\r\n\r\n这个错误看得懂，就安装一下 rollup-plugin-json\r\n\r\n`npm install --save-dev rollup-plugin-json`\r\n添加以下配置到配置文件 rollup.config.js\r\n\r\n```js\r\n\r\nimport json from 'rollup-plugin-json';\r\n\r\nexport default {\r\n  input: 'src/main.js',\r\n  output: {\r\n    file: 'dist/bundle.js',\r\n    format: 'iife'\r\n  },\r\n\r\n  plugins: [\r\n    json({\r\n      // 默认情况下将解析所有JSON文件,\r\n      // 但您可以专门包含/排除文件\r\n      include: 'node_modules/**',\r\n      exclude: [ 'node_modules/foo/**', 'node_modules/bar/**' ],\r\n\r\n      // 对于 tree-shaking, 属性将声明为\r\n      // 变量, 使用 `var` 或者 `const`\r\n      preferConst: true, // 默认是 false\r\n\r\n      // 为生成的默认导出指定缩进 —\r\n      // 默认为 't'\r\n      indent: '  ',\r\n\r\n      // 忽略缩进并生成最小的代码\r\n      compact: true, // 默认是 false\r\n\r\n      // 为JSON对象的每个属性生成一个命名导出\r\n      namedExports: true // 默认是 true\r\n    })\r\n  ]\r\n};\r\n\r\n```\r\n\r\n## Missing shims for Node.js built-ins\r\n\r\n报错信息：\r\n\r\n```shell\r\n(!) Missing shims for Node.js built-ins\r\nCreating a browser bundle that depends on 'http', 'https', 'url', 'assert', 'stream', 'tty', 'util', \r\n'os' and 'zlib'. You might need to include <https://www.npmjs.com/package/rollup-plugin-node-builtins>\r\n```\r\n\r\n解决方法：\r\n\r\n安装 rollup-plugin-node-builtins\r\n\r\n```shell\r\n\r\nnpm install --save-dev rollup-plugin-node-builtins\r\nimport builtins from 'rollup-plugin-node-builtins';\r\nimport globals from 'rollup-plugin-node-globals';\r\nrollup({\r\n  entry: 'main.js',\r\n  plugins: [\r\n    globals(),\r\n    builtins()\r\n  ]\r\n})\r\n```\r\n\r\n## Cannot find module ‘rollup-plugin-node-globals’\r\n\r\n报错信息：\r\n\r\n`[!] Error: Cannot find module 'rollup-plugin-node-globals'`\r\n解决方法：\r\n\r\n安装 rollup-plugin-node-globals\r\n\r\n`npm install --save-dev rollup-plugin-node-globals`\r\n\r\n## Plugin node-resolve: preferring built-in module ‘https’……\r\n\r\n报错信息：\r\n\r\n```shell\r\nPlugin node-resolve: preferring built-in module 'https' over local alternative at 'https', \r\npass 'preferBuiltins: false' to disable this behavior or 'preferBuiltins: true' to disable this warning\r\n```\r\n\r\n解决方法：\r\n\r\n```js\r\n\r\nplugins: [\r\n    //...\r\n        resolve({\r\n            preferBuiltins: true,\r\n            mainFields: ['browser']\r\n        }),\r\n    //...\r\n]\r\n\r\n```\r\n\r\n## Error: Unexpected character ‘@’ (Note that you need plugins to import files that are not JavaScript)\r\n\r\n报错信息：\r\n\r\n```shell\r\n\r\n[!] Error: Unexpected character '@' (Note that you need plugins to import files that are not JavaScript)\r\nnode_modulesanimate.cssanimate.css (1:0)\r\n1: @charset \"UTF-8\";\r\n   ^\r\n2:\r\n3: /*!\r\nError: Unexpected character '@' (Note that you need plugins to import files that are not JavaScript)\r\n    at error (E:mprojectarcgis3d-d3node_modulesrollupdistrollup.js:9419:30)\r\n    at Module.error (E:mprojectarcgis3d-d3node_modulesrollupdistrollup.js:13402:9)\r\n    at tryParse (E:mprojectarcgis3d-d3node_modulesrollupdistrollup.js:13315:16)\r\n    at Module.setSource (E:mprojectarcgis3d-d3node_modulesrollupdistrollup.js:13629:33)\r\n    at Promise.resolve.catch.then.then.then (E:mprojectarcgis3d-d3node_modulesrollupdistrollup.js:16423:20)\r\n    at <anonymous>\r\n```\r\n\r\n原因：\r\n\r\n不支持 css 文件的打包，需要安装相关的插件\r\n\r\n解决方法：\r\n\r\n安装 rollup-plugin-css-porter\r\n\r\n`npm install --save-dev rollup-plugin-css-porter`\r\n\r\n## (!) Use of eval is strongly discouraged\r\n\r\n报错信息：\r\n\r\n```shell\r\n\r\n(!) Use of eval is strongly discouraged\r\n<https://rollupjs.org/guide/en/#avoiding-eval>\r\npackageslocateManagerGeometryZoomCtrl.js\r\n53:         ext.xmin += wValue;\r\n54:         ext.xmax += wValue;\r\n55:         if (typeof eval(ext.expand) == \"function\") {\r\n                       ^\r\n56:             ext = ext.expand(_LocateManagerCtrl.locateManagerCtrl.factor);\r\n57:         }\r\n```\r\n\r\nrollup 强烈反对使用 eval，原因：\r\n\r\n```shell\r\n\r\nYou probably already know that ‘eval is evil’, at least according to some people. But it’s particularly \r\nharmful with Rollup, because of how it works – unlike other module bundlers, which wrap each module in a \r\nfunction, Rollup puts all your code in the same scope. That’s more efficient, but it means that the \r\nshared scope is ‘polluted’ whenever you use eval, whereas with a different bundler, modules that didn’t \r\nuse eval would not be polluted. A minifier can’t mangle variable names in polluted code, because it can’t \r\nguarantee that the code to be evaluated doesn’t reference those variable names. Furthermore, it poses a \r\nsecurity risk in that a malicious module could access another module’s private variables with eval\r\n('SUPER_SEKRIT').\r\n```\r\n\r\n简而言之，它会污染变量而且存在安全隐患。\r\n\r\n解决方法：\r\n\r\n```shell\r\n\r\neval2 = eval\r\nSimply ‘copying’ eval provides you with a function that does exactly the same thing, but which runs in the global scope rather than the local one:\r\nvar eval2 = eval;\r\n\r\n(function () {\r\n  var foo = 42;\r\n  eval('console.log(\"with eval:\",foo)');  // logs 'with eval: 42'\r\n  eval2('console.log(\"with eval2:\",foo)'); // throws ReferenceError\r\n})();\r\nnew Function\r\nUsing the Function constructor generates a function from the supplied string. Again, it runs in the global scope. If you need to call the function repeatedly, this is much, much faster than using eval.\r\n```\r\n\r\n## (!) this has been rewritten to undefined\r\n\r\n报错信息：\r\n\r\n```shell\r\n\r\n(!) `this` has been rewritten to `undefined`\r\n<https://rollupjs.org/guide/en/#error-this-is-undefined>\r\npackagesvisualizationesriClusterLayerEsriClusterLayer.js\r\n1:\r\n2: var __extends = this && this.__extends || function () {\r\n                   ^\r\n3:     var extendStatics = function (d, b) {\r\n4:         extendStatics = Object.setPrototypeOf || { **proto**: [] } instanceof Array && function (d, b) {\r\n...and 5 other occurrences\r\n```\r\n\r\n原因：\r\n\r\n为什么会出现这个问题，官方文档是说：\r\n\r\n```shell\r\nError: “this is undefined” In a JavaScript module, this is undefined at the top level (i.e., outside \r\nfunctions). Because of that, Rollup will rewrite any this references to undefined so that the resulting \r\nbehaviour matches what will happen when modules are natively supported. There are occasional valid \r\nreasons for this to mean something else. If you’re getting errors in your bundle, you can use options.\r\ncontext and options.moduleContext to change this behaviour.\r\n```\r\n\r\n我本身的情况是因为使用了 es6 中的 class，所以会出现 this，然后被替换成了 `undefined`。\r\n\r\n解决方法：\r\n\r\n添加以下配置到配置文件 `rollup.config.js`\r\n\r\n```js\r\n\r\nexport default {\r\n    entry: 'ng2-App/Bootstrapper/Components/main-aot.js',\r\n    ...\r\n    onwarn: function (warning) {\r\n        if (warning.code === 'THIS_IS_UNDEFINED') {\r\n            return;\r\n        }\r\n        console.error(warning.message);\r\n    },\r\n    plugins: [\r\n        ...\r\n    ]\r\n};\r\n```\r\n\r\n参考资料：\r\n\r\n<https://github.com/rollup/rollup/issues/794>\r\n\r\n## (plugin commonjs) TypeError [ERR_INVALID_ARG_TYPE]: The “path” argument must be of type string\r\n\r\n报错内容：\r\n\r\n[!] (plugin commonjs) TypeError [ERR_INVALID_ARG_TYPE]: The \"path\" argument must be of type string\r\nTypeError [ERR_INVALID_ARG_TYPE]: The \"path\" argument must be of type string\r\n解决方法：\r\n\r\nrollup.config.js 配置文件中的input字段输入有误，检查路径是否正确\r\n\r\n## [!] (plugin babel) SyntaxError\r\n\r\n报错内容：\r\n\r\n```shell\r\n\r\n[!] (plugin babel) SyntaxError: E:/mproject/oauth-login-package/node_modules/axios/package.json: Unexpected token, expected ; (2:9)\r\nnode_modulesaxiospackage.json (2:9)\r\nSyntaxError: E:/mproject/oauth-login-package/node_modules/axios/package.json: Unexpected token, expected ; (2:9)\r\n  1 | {\r\n> 2 |   \"_from\": \"axios@^0.19.0\",\r\n    |          ^\r\n  3 |   \"_id\": \"axios@0.19.0\",\r\n  4 |   \"_inBundle\": false,\r\n  5 |   \"_integrity\": \"sha1-jgm/89kSLhM/e4EByPvdAO09Krg=\",\r\n```\r\n\r\n解决方法：\r\n\r\n修改 rollup 配置文件中的 babel 配置\r\n\r\nrollup.config.js\r\n\r\n```js\r\nbabel({\r\n  exclude: 'node_modules/**',\r\n  runtimeHelpers: true,\r\n}),\r\n```\r\n\r\n## [!] (plugin uglify) Error: Unexpected token: punc «,»\r\n\r\n报错内容：\r\n\r\n```shell\r\n[!] (plugin uglify) Error: Unexpected token: punc «,»\r\nSyntaxError: Unexpected token: punc «,»\r\n```\r\n\r\n解决方法：\r\n\r\n这个错误定位后发现与 rollup-plugin-uglify 插件有关，rollup-plugin-uglify 不能压缩 es6 的代码文件。rollup-plugin-uglify 的官方文档是说\r\n\r\n> Note: uglify-js is able to transpile only es5 syntax. If you want to transpile es6+ syntax use terser instead\r\n顺着这个思路有两种解决方法，一只要把 es6 的代码用 babel 转换成 es5 即可。二使用rollup-plugin-terser插件代替 rollup-plugin-uglify\r\n\r\n安装 rollup-plugin-terser\r\n\r\n`yarn add rollup-plugin-terser --dev`\r\n使用 rollup-plugin-terser\r\n\r\n```js\r\n\r\nimport { rollup } from \"rollup\";\r\nimport { terser } from \"rollup-plugin-terser\";\r\n\r\nrollup({\r\n  input: \"main.js\",\r\n  plugins: [terser()]\r\n});\r\n```\r\n\r\n## preferring built-in module ‘http’ over local alternative at ‘http’, pass ‘preferBuiltins: false’ to disable this behavior or ‘preferBuiltins: true’ to disable this warning\r\n\r\n报错内容：\r\n\r\n```shell\r\n\r\n(!) Plugin node-resolve: preferring built-in module 'http' over local alternative at 'http', \r\npass 'preferBuiltins: false' to disable this behavior or 'preferBuiltins: true' to disable this warning\r\n(!) Plugin node-resolve: preferring built-in module 'https' over local alternative at 'https', \r\npass 'preferBuiltins: false' to disable this behavior or 'preferBuiltins: true' to disable this warning\r\n(!) Plugin node-resolve: preferring built-in module 'zlib' over local alternative at 'zlib', \r\npass 'preferBuiltins: false' to disable this behavior or 'preferBuiltins: true' to disable this warning\r\n```\r\n\r\n解决方法：\r\n\r\n设置 rollup.config.js\r\n\r\n```js\r\n\r\nplugins: [\r\n    ...\r\n    resolve({\r\n        preferBuiltins: true, //这一句是重点\r\n        mainFields: ['browser']\r\n    }),\r\n    ...\r\n],\r\n```\r\n\r\n或者可以这么做\r\n\r\n```js\r\n\r\nexport default {\r\n    ...\r\n    external: ['http', 'https', 'zlib'],\r\n    ...\r\n}\r\n```\r\n\r\n## (!) Circular dependency\r\n\r\n报错内容：\r\n\r\n```shell\r\n\r\n(!) Circular dependency: node_modulesrollup-plugin-node-builtinssrces6readable-streamduplex.js -> \r\nnode_modulesrollup-plugin-node-builtinssrces6readable-streamreadable.js -> \r\nnode_modulesrollup-plugin-node-builtinssrces6readable-streamduplex.js\r\n```\r\n\r\n解决方法：\r\n\r\n参考 <https://github.com/rollup/rollup/issues/1089>\r\n\r\n## [!] (plugin babel) TypeError: Cannot read property ‘length’ of undefined\r\n\r\n报错信息：\r\n\r\n```shell\r\n\r\n[!] (plugin babel) TypeError: Cannot read property 'length' of undefined\r\npackages/index.js\r\nTypeError: Cannot read property 'length' of undefined\r\n    at Object.transform$1 (/Users/dany/PROJECT/arcgis-npm-package/gismap4-pipe-package/node_modules/rollup-plugin-babel/dist/rollup-plugin-babel.cjs.js:148:21)\r\n    at Promise.resolve.then (/Users/dany/PROJECT/arcgis-npm-package/gismap4-pipe-package/node_modules/rollup/dist/rollup.js:16621:25)\r\n```\r\n\r\n解决方法： 安装 rollup-plugin-babel@4.0.0 以上版本的\r\n\r\n`npm install --save-dev rollup-plugin-babel@latest`\r\n参考资料：\r\n\r\n<https://github.com/rollup/rollup-plugin-babel/issues/172>\r\n\r\n## [!] (plugin babel) Error: Babel 7.0.0-beta.56 has dropped support for the ‘helpersNamespace’ utility\r\n\r\n报错信息：\r\n\r\n```shell\r\n\r\n[!] (plugin babel) Error: Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to explore using 'helperGenerator' alongside 'file.availableHelper()\r\n\r\nError: Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to explore using 'helperGenerator' alongside 'file.availableHelper()'.\r\n    at File.set (/Users/dany/PROJECT/arcgis-npm-package/gismap4-pipe-package/node_modules/@babel/core/lib/transformation/file/file.js:127:13)\r\n    at PluginPass.pre (/Users/dany/PROJECT/arcgis-npm-package/gismap4-pipe-package/node_modules/babel-plugin-external-helpers/lib/index.js:10:12)\r\n    at transformFile (/Users/dany/PROJECT/arcgis-npm-package/gismap4-pipe-package/node_modules/@babel/core/lib/transformation/index.js:78:27)\r\n    at runSync (/Users/dany/PROJECT/arcgis-npm-package/gismap4-pipe-package/node_modules/@babel/core/lib/transformation/index.js:45:3)\r\n    at transformSync (/Users/dany/PROJECT/arcgis-npm-package/gismap4-pipe-package/node_modules/@babel/core/lib/transform.js:43:38)\r\n    at Object.transform (/Users/dany/PROJECT/arcgis-npm-package/gismap4-pipe-package/node_modules/@babel/core/lib/transform.js:22:38)\r\n    at /Users/dany/PROJECT/arcgis-npm-package/gismap4-pipe-package/node_modules/rollup-plugin-babel/dist/rollup-plugin-babel.cjs.js:57:26\r\n    at Object.transform$1 (/Users/dany/PROJECT/arcgis-npm-package/gismap4-pipe-package/node_modules/rollup-plugin-babel/dist/rollup-plugin-babel.cjs.js:141:18)\r\n    at Promise.resolve.then (/Users/dany/PROJECT/arcgis-npm-package/gismap4-pipe-package/node_modules/rollup/dist/rollup.js:16621:25)\r\n```\r\n\r\n解决方法： 下载安装`@babel/plugin-external-helpers`\r\n\r\n`npm install --save-dev @babel/plugin-external-helpers`\r\n","children":[]}]},{"name":"vite","path":"../guanruihua.github.io/Front-End/项目搭建","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Front-End/项目搭建/vite","data":"# Vite\r\n\r\n- `node>12`\r\n","children":[]},{"name":"问题.md","path":"../guanruihua.github.io/Front-End/项目搭建/vite","data":"# vite 问题\r\n\r\n## Vetur(1192)\r\n\r\n- 将vscode vetur 插件切换为 volar\r\n\r\n## 启动无法通过IP+端口方法进行访问\r\n\r\n- 没有将服务暴露再局域网中\r\n\r\n### 解决\r\n\r\n#### 方法一\r\n\r\n```js\r\nexport default defineConfig({\r\n  plugins: [...],\r\n // 添加\r\n  server:{\r\n    host:'0.0.0.0'\r\n  }\r\n})\r\n\r\n```\r\n\r\n#### 方法二\r\n\r\n```js\r\n {\r\n  \"scripts\": {\r\n    \"dev\": \"vite --host 0.0.0.0\",\r\n    \"build\": \"vue-tsc --noEmit && vite build\",\r\n    \"preview\": \"vite preview\"\r\n  },\r\n }\r\n```\r\n","children":[]}]},{"name":"webpack","path":"../guanruihua.github.io/Front-End/项目搭建","data":"","children":[{"name":"Plugin","path":"../guanruihua.github.io/Front-End/项目搭建/webpack","data":"","children":[{"name":"EslintWebpackPlugin.md","path":"../guanruihua.github.io/Front-End/项目搭建/webpack/Plugin","data":"# EslintWebpackPlugin\n\n> eslint-webpack-plugin 3.0 仅支持 webpack 5。对于 webpack 4 请查看 2.x 分支。\n>\n> 该插件使用 eslint 来查找和修复 JavaScript 代码中的问题。\n\n## 开始\n\n> 首先，需要安装 eslint-webpack-plugin：\n\n`npm install eslint-webpack-plugin --save-dev`\n> 注意: 如果未安装 eslint >= 7 ，你还需先通过 npm 安装：\n\n`npm install eslint --save-dev`\n\n然后把插件添加到你的 webpack 配置。例如：\n\n```js\n\nconst ESLintPlugin = require('eslint-webpack-plugin');\n\nmodule.exports = {\n  // ...\n  plugins: [new ESLintPlugin(options)],\n  // ...\n};\n```\n\n## 选项\n\n> 你可以传入 eslint 参数。\n> 注意你提供的配置选项会传给 ESLint 类。 这是一组和你在 package.json 与 .eslintrc 所指定选项不同的选项。 查阅 eslint 文档 获取更多详情。\n> 警告: 在 eslint-webpack-plugin 1.x 版本中，配置项会传递给已废弃的 CLIEngine。\n\n### context\n\n> 类型：String\n> 默认值：compiler.context\n> 指定文件根目录，类型为字符串。\n\n### eslintPath\n\n> 类型：String\n> 默认值：eslint\n> 用于 linting 的 eslint 实例的路径。如果 eslintPath 是类似官方 eslint 的目录，或者指定了 formatter 选项，那么就不需要安装 eslint 了。\n\n### extensions\n\n> 类型：String|Array[String]\n> 默认值：'js'\n> 指定需要检查的扩展名。\n\n### exclude\n\n> 类型：String|Array[String]\n> 默认值：'node_modules'\n> 指定需要排除的文件及目录。必须是相对于 options.context 的相对路径。\n\n### files\n\n> 类型：String|Array[String]\n> 默认值：null\n> 指定目录、文件或 globs ，必须是相对于 options.context 的相对路径。 如果是目录则递归查找所有匹配 options.extensions 选项的文件。 如果是文件或 globs 则忽略 options.extensions 选项。\n\n### fix\n\n> 类型：Boolean\n> 默认值：false\n> 启用 ESLint 自动修复特性。\n\n小心: 该选项会修改源文件。\n\n### formatter\n\n> 类型：String|Function\n> 默认值：'stylish'\n> 接受一个有单一参数的函数：该参数为 eslint 消息（一个对象）的数组。函数必须返回字符串格式的 output。可以使用官方的 eslint formatters。\n\n### lintDirtyModulesOnly\n\n> 类型：Boolean\n> 默认值：false\n> 只对内容修改了的文件进行 lint，启动时跳过 lint 。\n\n### threads\n\n> 类型：Boolean | Number\n> 默认值：false\n> 以线程池方式运行 lint 。线程池大小是自动的，除非你指定一个数值。\n\n错误以及警告\n该插件默认会根据 eslint 错误/警告的数量自动调整错误报告（error reporting）。 你也可以通过 emitError 或 emitWarning 强制开启错误报告行为：\n\n### emitError\n\n> 类型：Boolean\n> 默认值：true\n> 总是发送发现的错误 ，设置为 false 以禁用。\n\n### emitWarning\n\n> 类型：Boolean\n> 默认值：true\n> 总是发送发现的警告，设置为 false 以禁用。\n\n### failOnError\n\n> 类型：Boolean\n> 默认值：true\n> 任何错误都会导致模块构建（module build）失败，设置为 false 禁用。\n\n### failOnWarning\n\n> 类型：Boolean\n> 默认值：false\n> 当设置为 true 时，任何警告都会导致模块构建（module build）失败。\n\n### quiet\n\n> 类型：Boolean\n> 默认值：false\n> 设置为 true 后，仅处理和报告错误，忽略警告。\n\n### outputReport\n\n> 类型：Boolean|Object\n> 默认值：false\n> 把错误输出到一个文件，例如在 Jenkins CI 使用 checkstyle xml 文件。\n\nfilePath 为绝对路径或者相对于 webpack 配置: output.path 的相对路径。 你可以为输出文件传入不同的 formatter 。 如果没有传入，则使用默认的或已配置的 formatter 。\n","children":[]}]},{"name":"question.md","path":"../guanruihua.github.io/Front-End/项目搭建/webpack","data":"# Webpack question\n\n##  查找对应包的版本\n\n> 去到对应webpack的版本的`package.json`, 查看对应的包的版本, 就是对应的包的版本\n\n\n\n\n\n","children":[]},{"name":"react-webpack-ts.md","path":"../guanruihua.github.io/Front-End/项目搭建/webpack","data":"# webpack5 手动搭建React TS项目\n\n## 1. 前言\n\n前段时间突发奇想，使用React这么长时间了，不是使用cra搭建项目就是使用antdpro， 都是基本上帮你配置好了所有的配置项，你只需要写业务代码就好了。所以闲下来的时间打算手动从0开始一步一步搭建一个基于webpack5的React Ts项目，于是就有了下面的实践，由于本人小白一名，所以有做得不对的地方欢迎大佬指正。\n\n## 2. 初始化项目\n\n找一个空白的目录然后执行下面代码:\n\n```bash\nmkdir webpack5-react-ts-tempalte\ncd webpack5-react-ts-tempalte\nnpm init -y\n\n```\n\n## 3. 初始化typeScript配置\n\n```bash\nnpm install --save-dev typescript ts-loader\n\n```\n\n新建一个`tsconfig.json`文件，我这里直接采用的是webpack官网的tsconfig配置， 可以通过查看[TypeScript官方文档](https://link.juejin.cn/?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2Ftsconfig-json.html)了解更多功能。\n\n```json\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist/\",\n    \"noImplicitAny\": true,\n    \"module\": \"es6\",\n    \"target\": \"es5\",\n    \"jsx\": \"react\",\n    \"allowJs\": true,\n    \"moduleResolution\": \"node\",\n    \"allowSyntheticDefaultImports\": true\n  }\n}\n\n```\n\n## 4.配置webpack相关\n\n```bash\nnpm i webpack webpack-cli webpack-merge html-webpack-plugin clean-webpack-plugin --dev\n\n```\n\n由于我们的项目基本上都是分为开发环境和生产环境的，所以对于webpack的配置，个人新建了三个文件来存放不同的配置。\n\n新建`config` 文件来存放webpack的配置文件：\n\n- `webpack.config.base.js` 存放webpack的基本配置\n- `webpack.config.dev.js` 存放webpack的开发环境配置\n- `webpack.config.prod.js` 存放webpack的生产环境配置\n\n```jsx\n//  config/webpack.config.base.js\nconst path = require('path\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n/**\n * @type {import('webpack').Configuration}\n */\n\nmodule.exports = {\n  entry: {\n    app: './src/index.tsx',\n  },\n  output: {\n    path: path.resolve(__dirname, '../dist'),\n    filename: '[name].[hash].js',\n  },\n  resolve: {\n    extensions: ['.ts', '.tsx', '.js', '.jsx'],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      title: '管理后台',\n      template: path.resolve(__dirname, '../index.html'),\n      filename: 'index.html',\n    }),\n    new CleanWebpackPlugin(),\n  ],\n}\n\n```\n\n### 合并配置项\n\n由于我们是分文件配置webpack，所以就会存在合并配置项这个操作。上面安装的`webpack-merge` 就是实现这个功能的插件。\n\n```jsx\n//   config/webpack.config.dev.js\n\nconst webpackMerge = require('webpack-merge')\nconst baseConfig = require('./webpack.config.base')\nconst path = require('path')\n\n/**\n * @type {import('webpack').WebpackOptionsNormalized}\n */\nconst devServer = {\n  port: 3000,\n  host: 'localhost',\n  contentBase: path.join(__dirname, '../publich'),\n  watchContentBase: true,\n  publicPath: '/',\n  compress: true,\n  historyApiFallback: true,\n  hot: true,\n  clientLogLevel: 'error',\n  // open: true,\n  watchOptions: {\n    ignored: /node_modules/,\n  },\n}\n\nconst devConfig = {\n  mode: 'development',\n  devServer: devServer,\n}\n\nmodule.exports = webpackMerge.merge(baseConfig, devConfig)\n\n//   config/webpack.config.prod.js\n\nconst webpackMerge = require('webpack-merge')\nconst baseConfig = require('./webpack.config.base')\n/**\n * @type {import('webpack').WebpackOptionsNormalized}\n */\nconst prodConfig = {\n  mode: 'production',\n}\n\nmodule.exports = webpackMerge.merge(baseConfig, prodConfig)\n\n```\n\n## 5. 配置babel\n\n安装依赖\n\n```bash\nnpm i babel-loader babel-plugin-import @babel/cli @babel/core @babel/preset-env @babel/preset-react @babel/preset-typescript --dev\n\n```\n\n在根目录新建`.babelrc` 文件\n\n```json\n{\n  \"presets\": [\n    \"@babel/preset-env\",\n    \"@babel/preset-react\"\n  ]\n}\n\n```\n\n`webpack.config.base.js`中添加mode配置\n\n```jsx\nmodule.exports = {\n    ...\n    module: {\n        rules: [\n              { test: /\\.(js|jsx)$/, loader: 'babel-loader', exclude: /node_modules/ },\n              { test: /\\.(ts|tsx)$/, loader: 'ts-loader', exclude: /node_modules/ },\n        ],\n    },\n};\n\n```\n\n## 6. 配置React\n\n### 安装依赖\n\n```bash\nnpm i react react-dom react-router-dom\nnpm i @types/react @types/react-dom @types/react-router-dom --dev\n\n```\n\n### 新建html文件\n\n根目录新建`index.html`\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>\n    <%= htmlWebpackPlugin.options.title %>\n  </title>\n</head>\n\n<body>\n  <div id=\"root\"></div>\n</body>\n\n</html>\n\n```\n\n### 新建工程入口文件\n\n新建`src` 目录下新建`App.tsx`  `index.tsx`\n\n```jsx\n// App.tsx\n\nimport React from 'react'\n\nconst App = () => {\n  return <div>1234</div>\n}\n\nexport default App\n\n// index.tsx\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\nReactDOM.render(<App />, document.getElementById('root'))\n\n```\n\n## 7. 功能性配置\n\n### 样式文件解析\n\n```bash\nnpm i style-loader sass-loader sass css-loader postcss-loader postcss-normalize autoprefixer postcss-preset-env -D\n\n```\n\n因为我们平时开发中不只是使用scss，也会使用到scss module，所以同时配置一下，安装依赖\n\n```bash\nnpm i react-dev-utils resolve-url-loader -D\n\n```\n\n`webpack.config.base.js`中添加mode配置,\n\n```jsx\nconst getCSSModuleLocalIdent = require('react-dev-utils/getCSSModuleLocalIdent')\n\nmodule.exports = {\n    ...\n    module: {\n        rules: [\n          ...\n          {\n            test: /\\.(css|scss)$/,\n            exclude: /\\.module\\.scss$/,\n            use: ['style-loader', 'css-loader', 'postcss-loader', 'sass-loader'],\n          },\n          {\n            test: /\\.module\\.scss$/,\n            use: [\n              'style-loader',\n              {\n                loader: 'css-loader',\n                options: {\n                  modules: {\n                    getLocalIdent: getCSSModuleLocalIdent,\n                  },\n                },\n              },\n              'postcss-loader',\n              'sass-loader',\n            ],\n          },\n        ],\n    },\n};\n\n\n```\n\n新增`postcss.config.js`文件并配置\n\n```jsx\nconst postcssNormalize = require('postcss-normalize')\n\nmodule.exports = {\n  plugins: [\n    [\n      'postcss-preset-env',\n      {\n        autoprefixer: {\n          flexbox: 'no-2009',\n        },\n        stage: 3,\n      },\n    ],\n    postcssNormalize(),\n    require('autoprefixer')({\n      overrideBrowserslist: ['last 2 version', '>1%', 'ios 7'],\n    }),\n  ],\n}\n\n```\n\n### 图片地址解析\n\nwebpack5 内置 assets 类型，我们不需要额外安装插件就可以进行图片等资源文件的解析，配置如下：\n\n```jsx\n{\n  test: /\\.(jpe?g|png|gif|svg|woff|woff2|eot|ttf|otf)$/i,\n  type: \"asset/resource\",\n},\n\n```\n\n## 8. 性能优化\n\nwebpack5 引入了缓存来提高二次构建速度，我们只需要在 webpack 配置文件中加入如下代码即可开心缓存\n\n```jsx\ncache: {\n  type: 'filesystem',\n  // 可选配置\n  buildDependencies: {\n    config: [__filename], // 当构建依赖的config文件（通过 require 依赖）内容发生变化时，缓存失效\n  },\n  name: 'development-cache',\n},\n\n```\n\n## 9. 完整配置\n\n### webpack.config.base.js\n\n```jsx\n// webpack.config.base.js\nconst path = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst getCSSModuleLocalIdent = require('react-dev-utils/getCSSModuleLocalIdent')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\n/**\n * @type {import('webpack').Configuration}\n */\n\nmodule.exports = {\n  entry: {\n    app: './src/index.tsx',\n  },\n  output: {\n    path: path.resolve(__dirname, '../dist'),\n    filename: '[name].[hash].js',\n  },\n  module: {\n    rules: [\n      { test: /\\.(js|jsx)$/, loader: 'babel-loader', exclude: /node_modules/ },\n      { test: /\\.(ts|tsx)$/, loader: 'ts-loader', exclude: /node_modules/ },\n      {\n        test: /\\.(css|scss)$/,\n        exclude: /\\.module\\.scss$/,\n        use: ['style-loader', 'css-loader', 'postcss-loader', 'sass-loader'],\n      },\n      {\n        test: /\\.module\\.scss$/,\n        use: [\n          'style-loader',\n          {\n            loader: 'css-loader',\n            options: {\n              modules: {\n                getLocalIdent: getCSSModuleLocalIdent,\n              },\n            },\n          },\n          'postcss-loader',\n          'sass-loader',\n        ],\n      },\n      {\n        test: /\\.(jpe?g|png|gif|svg|woff|woff2|eot|ttf|otf)$/i,\n        type: 'asset/resource',\n      },\n    ],\n  },\n  resolve: {\n    extensions: ['.tsx', '.ts', '.js', '.jsx'],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      title: '管理后台',\n      template: path.resolve(__dirname, '../index.html'),\n      filename: 'index.html',\n    }),\n    new CleanWebpackPlugin(),\n  ],\n  cache: {\n    type: 'filesystem',\n    // 可选配置\n    buildDependencies: {\n      config: [__filename], // 当构建依赖的config文件（通过 require 依赖）内容发生变化时，缓存失效\n    },\n    name: 'development-cache',\n  },\n}\n\n```\n\n### webpack.config.dev.js\n\n```jsx\nconst webpackMerge = require('webpack-merge')\nconst baseConfig = require('./webpack.config.base')\nconst path = require('path')\n\n/**\n * @type {import('webpack').WebpackOptionsNormalized}\n */\nconst devServer = {\n  port: 3000,\n  host: 'localhost',\n  contentBase: path.join(__dirname, '../publich'),\n  watchContentBase: true,\n  publicPath: '/',\n  compress: true,\n  historyApiFallback: true,\n  hot: true,\n  clientLogLevel: 'error',\n  // open: true,\n  watchOptions: {\n    ignored: /node_modules/,\n  },\n}\n\nconst devConfig = {\n  mode: 'development',\n  devServer: devServer,\n}\n\nmodule.exports = webpackMerge.merge(baseConfig, devConfig)\n\n```\n\n### webpack.config.prod.js\n\n```jsx\nconst webpackMerge = require('webpack-merge')\nconst baseConfig = require('./webpack.config.base')\n/**\n * @type {import('webpack').WebpackOptionsNormalized}\n */\n\nconst prodConfig = {\n  mode: 'production',\n}\n\nmodule.exports = webpackMerge.merge(baseConfig, prodConfig)\n\n```\n\n## 10. css提取成单独的打包文件\n\n上述配置中的css是打包到js中的，所以如果想要把css单独打包出来，就需要做一下配置，安装依赖\n\n```bash\nnpm install --save-dev mini-css-extract-plugin\n\n```\n\n修改`webpack.config.base.js` 中的配置\n\n```jsx\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\n\nmodule.exports = {\n\t...\n  plugins: [new MiniCssExtractPlugin({\n              filename: 'css/[name].[hash].css',\n\t})],\n  module: {\n    rules: [\n      {\n        test: /\\.css$/i,\n        use: [MiniCssExtractPlugin.loader, 'css-loader'],\n      },\n    ],\n  },\n}\n\n```\n\n## 11. 配置开发服务器\n\n安装依赖\n\n```bash\nnpm i webpack-dev-server --dev\n\n```\n\n`package.json` 中添加启动命令\n\n```json\n\"scripts\": {\n  \n    \"start\": \"webpack serve --config ./config/webpack.config.dev.js\",\n    \"build\": \"webpack --mode=production --config ./config/webpack.config.prod.js\"\n  },\n\n```\n\n## 12. 问题解决\n\n当完成上述的步骤的时候，当你运行的时候，可能会收到这么一个报错。\n\n```bash\nCannot find module './index.module.scss' or its corresponding type declarations.\n\n```\n\n因为是ts的项目，所以这个时候需要进行声明文件的书写。\n\n新建`declaration.d.ts`\n\n```tsx\ndeclare module '*.scss' {\n  const content: Record<string, string>\n  export default content\n}\n\n```\n\n## 13. 获取良好的css 代码提示\n\n需要使用到一个插件\n\n```bash\nnpm install -D typescript-plugin-css-modules\n\n```\n\n配置tsconfig.json\n\n```json\n{ \n    \"compilerOptions\": \n\t{ \n            \"plugins\": [{ \"name\": \"typescript-plugin-css-modules\" }]\n\t }\n}\n```\n\n如果你使用的是`vscode`，可以跟我一样配置一下\n\n根目录新建.`vscode`文件夹，然后新建`settings.json`\n\n在文件中写入\n\n```json\n\n{\n\t\"typescript.tsdk\": \"node_modules/typescript/lib\",\n\t\"typescript.enablePromptUseWorkspaceTsdk\":true\n}\n\n```\n\n从工作区设置`TypeScript`版本，从而读取`tsconfig.json`文件\n\n![Untitled.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45dfc10b082946dbafc95b0209605933~tplv-k3u1fbpfcp-watermark.image)\n\n然后就可以获得良好的代码提示了","children":[]},{"name":"webpack.md","path":"../guanruihua.github.io/Front-End/项目搭建/webpack","data":"# Webpack\n\n> 五个核心概念\n>\n> 1. Entry:入口指示webpack以哪个文件为入口起点开始打包, 分析构建内部依赖图\n> 2. Output: 输出指示webpack打包后的志愿bundles输出到哪里去, 以如何命名\n> 3. Loader: Loader让文本pack能够去除那些非javascript文件(webpack 自身只理解javascript)\n> 4. Plugins: 插件可以用于执行范围更广的任务, 插件的范围包括, 从打包优化和压缩, 一直重新定义环境中的变量\n> 5. Mode: 模式指示webpack使用相应模式的配置\n>    1. development: 开发模式, 能够让代码在本地调试, 会将proces.env.NODE_ENV的值设为development\n>    2. production: 产品模式, 能够让代码优化上线运行的环境, 会将process.env.NDOE_ENV的值设置为production\n\n## 初体验\n\n> 全局安装: `yarn global add webpack webpack-cli`\n>\n> 1. webpack能处理js/json资源, 不能处理css/ img等其他资源\n> 2. 生产环境和开发环境将ES6模块化编译成浏览器能识别的模块\n> 3. 生产环境比开发环境多一个压缩js代码, 注释也会删除\n\n```tex\nwebpack ./src/index.js -o ./build/built.js --mode=production\n./src/index.js  入口文件(Entry)\n./build/  输出路径(Output)\n--mode=development  打包模式, 还可以改成生产模式production\n```\n\n### 获取npm 命令参数\n\n### 命令行直接输入\n\n`npm run dev --aaa=/webpack/src`\n\n```js\nconst serverPath = process.env.npm_config_aaa;\nconsole.log(serverPath);  // 输出结果：/webpack/src\n```\n\n### 添加到package.json的script里面\n\n`npm run dev`\n\n```js\n// package.json\n\"scripts\": {\n     \"dev\": \"webpack-dev-server --config build/webpack.local --这里是自定义参数随便写\"\n }\n```\n\n```js\nconst arg = process.argv;\nconsole.log(process.argv);\n/**\n输出结果是个数组（需要什么）：\n[\n  '--config',\n  'build/webpack.local',\n  '--这里是自定义参数随便写'\n]\n**/\n```\n\n## loader的使用\n\n> 解决非js/json资源的解析\n>\n> 创建webpack.config.js webpack的配置文件: 指示webpack 的加载\n>\n> 配置好后, 使用`webpack`指令执行打包\n\n```js\n// resolve用来拼接绝对路径的方法\nconst { resolve } = require('path');\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    filename: 'main.js',\n    path: resolve(__dirname, 'build'),\n  },\n  // loader 配置\n  module:{\n    rules: [\n      // 详细配置\n      {\n        test: /\\.css$/,\n        use: [\n          // use数组中的loader执行顺序: 从左到右, 从上到下 依次执行\n          // 创建style标签, 将js中的样式资源引入进行, 添加到head中生效\n          'style-loader',\n          // 将css文件变成commonjs模块加载js中, 里面的内容是格式样式字符串\n          'css-loader'\n        ]\n      }, \n      {\n        test: /\\.less$/,\n        use:[\n          'style-loader',\n          'css-loader',\n          // 将less文件编译成css文件资源\n          'less-loader',\n        ]\n      }     \n    ]\n  },\n  plugins: [\n    // 详细配置 \n  ], \n  // 模式\n  // mode: 'development',\n  mode: 'production'\n}\n```\n\n## 打包资源\n\n### html资源\n\n> 在plugins : 配置打包的配置\n>\n> 使用html-webpack-plugin\n\n```js\n// resolve用来拼接绝对路径的方法\nconst { resolve } = require('path');\n\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    filename: 'main.js',\n    path: resolve(__dirname, 'build'),\n  },\n  // loader 配置\n  module:{\n    rules: [\n      // 详细配置\n      {\n        test: /\\.css$/,\n        use: [\n          // use数组中的loader执行顺序: 从左到右, 从上到下 依次执行\n          // 创建style标签, 将js中的样式资源引入进行, 添加到head中生效\n          'style-loader',\n          // 将css文件变成commonjs模块加载js中, 里面的内容是格式样式字符串\n          'css-loader'\n        ]\n      }, \n      {\n        test: /\\.less$/,\n        use:[\n          'style-loader',\n          'css-loader',\n          // 将less文件编译成css文件资源\n          'less-loader',\n        ]\n      }     \n    ]\n  },\n  plugins: [\n    // 详细配置 \n    // html-webpack-plugin\n    // 功能: 默认创建一个空的HTML, 动引入输出的所有资源(JS/CSS)\n    // 需求: 需要有结构的HTML文件\n    new HtmlWebpackPlugin({\n      // 复制 './src/index.hmlt' , 并自动引入打包输出的所有资源(JS/CSS)\n      template:'./src/index.html'\n    })\n  ], \n  // 模式\n  // mode: 'development',\n  mode: 'production'\n}\n```\n\n### 图片资源\n\n> 使用url-loader, file-loader, html-loader\n\n```js\n// resolve用来拼接绝对路径的方法\nconst { resolve } = require('path');\n\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nmodule:{\n    rules: [\n      {\n        // 问题: 默认处理不了html中img图片\n        // 处理图片资源\n        test: /\\.(jpg|png|gif)$/,\n        // 使用一个loader\n        // 下载url-loader file-loader\n        loader: 'url-loader', \n        options: {\n          /**\n           * 图片大小小于8kb, 就会被base64处理\n           * 优点: 减少请求数量(减轻服务器压力)\n           * 缺点: 图片体积会更大(文件请求速度会更加慢)\n           */\n          // limit: 8 * 1024,\n          /**\n           * 问题: 因为url-loader默认使用es6模块化解析, 而html-loader引入图片是commonjs\n           * 解析时会出现问题\n           * 解决: 关闭url-loader模块化, 使用commonjs解析\n           */\n          esModule:false,\n        }\n      },\n      {\n        test: /\\.html$/,\n        // 处理html文件中的img图片(负责引入img, 从而能被url-loader进行处理)\n        loader: 'html-loader'\n      }\n\n\n    ]\n  },\n  plugins: [\n    // 详细配置 \n    // html-webpack-plugin\n    // 功能: 默认创建一个空的HTML, 动引入输出的所有资源(JS/CSS)\n    // 需求: 需要有结构的HTML文件\n    new HtmlWebpackPlugin({\n      // 复制 './src/index.hmlt' , 并自动引入打包输出的所有资源(JS/CSS)\n      template:'./src/index.html'\n    })\n  ], \n  // 模式\n  // mode: 'development',\n  mode: 'production'\n}\n```\n\n### 其他资源\n\n> 这里排除的文件资源要看自己的有哪些\n\n```js\nmodule: {\n rules:[\n     // 打包其他资源(除了html/js/css资源以外的资源)\n      {\n        // 排除css/js/html资源\n        exclude: /\\.(css|js|html|json|less|jpg)$/,\n        loader: 'file-loader',\n      }\n\n  ]\n}\n```\n\n### devServer\n\n> 开发服务器 devServer: 用来自动化编译\n>\n> 特点: 只会在内存中打包编译, 不会有任何输出\n>\n> 启动devServer指令为:npx webpack-dev-server\n\n```js\nmodule: {\n rules:[\n    devServer: {\n      // 项目路径\n      contentBase: resolve(__dirname, 'build'),\n      // 启动gzip压缩\n      compress: true,\n      // 端口号\n      port: 3000,\n      // 自动打开(默认)浏览器\n      open: true,\n    }\n  ]\n}\n```\n\n### 分文件夹\n\n```js\n// resolve用来拼接绝对路径的方法\nconst { resolve } = require('path');\n\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nmodule.exports = {\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/main.js',\n    path: resolve(__dirname, 'build'),\n  },\n  // loader 配置\n  module:{\n    rules: [\n      // 详细配置\n      {\n        test: /\\.css$/,\n        use: [\n          // use数组中的loader执行顺序: 从左到右, 从上到下 依次执行\n          // 创建style标签, 将js中的样式资源引入进行, 添加到head中生效\n          'style-loader',\n          // 将css文件变成commonjs模块加载js中, 里面的内容是格式样式字符串\n          'css-loader'\n        ],\n      }, \n      {\n        test: /\\.less$/,\n        use:[\n          'style-loader',\n          'css-loader',\n          // 将less文件编译成css文件资源\n          'less-loader',\n        ],\n      },\n\n      {\n        // 问题: 默认处理不了html中img图片\n        // 处理图片资源\n        test: /\\.(jpg|png|gif)$/,\n        // 使用一个loader\n        // 下载url-loader file-loader\n        loader: 'url-loader', \n        options: {\n          // 设置输出文件夹\n          outputPath: 'image'\n          // name: '[hash:10].[ext]',\n          /**\n           * 图片大小小于8kb, 就会被base64处理\n           * 优点: 减少请求数量(减轻服务器压力)\n           * 缺点: 图片体积会更大(文件请求速度会更加慢)\n           */\n          // limit: 8 * 1024,\n          /**\n           * 问题: 因为url-loader默认使用es6模块化解析, 而html-loader引入图片是commonjs\n           * 解析时会出现问题\n           * 解决: 关闭url-loader模块化, 使用commonjs解析\n           */\n          // esModule:false,\n        }\n      },\n      {\n        test: /\\.html$/,\n        // 处理html文件中的img图片(负责引入img, 从而能被url-loader进行处理)\n        loader: 'html-loader'\n      },\n      // 打包其他资源(除了html/js/css资源以外的资源)\n      {\n        // 排除css/js/html资源\n        exclude: /\\.(css|js|html|json|less|jpg)$/,\n        loader: 'file-loader',\n        options: {\n          outputPath: 'media'\n        }\n      }\n\n\n    ]\n  },\n  plugins: [\n    // 详细配置 \n    // html-webpack-plugin\n    // 功能: 默认创建一个空的HTML, 动引入输出的所有资源(JS/CSS)\n    // 需求: 需要有结构的HTML文件\n    new HtmlWebpackPlugin({\n      // 复制 './src/index.hmlt' , 并自动引入打包输出的所有资源(JS/CSS)\n      template:'./src/index.html'\n    })\n  ], \n  // 模式\n  // mode: 'development',\n  mode: 'production',\n\n  // 开发服务器 devServer:用来自动化编译\n  // 特点: 只会在内存中打包编译, 不会有任何输出\n  // 启动devServer指令为:npx webpack-dev-server\n  devServer: {\n    // 项目路径\n    contentBase: resolve(__dirname, 'build'),\n    // 启动gzip压缩\n    compress: true,\n    // 端口号\n    port: 3000,\n    // 自动打开(默认)浏览器\n    open: true,\n  },\n  // 关闭webpack 的性能提示\n  performance: {\n    hints: false,\n  } \n}\n```\n\n### 提取css文件为单独css文件\n\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\n\nmodule.exports = {\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/built.js',\n    path: resolve(__dirname, 'build')\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          // 创建style标签，将样式放入\n          // 'style-loader', \n          // 这个loader取代style-loader。作用：提取js中的css成单独文件\n          MiniCssExtractPlugin.loader,\n          // 将css文件整合到js文件中\n          'css-loader'\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    }),\n    new MiniCssExtractPlugin({\n      // 对输出的css文件进行重命名\n      filename: 'css/built.css'\n    })\n  ],\n  mode: 'development'\n};\n\n```\n\n### css兼容性处理\n\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\n\n// 设置nodejs环境变量\n// process.env.NODE_ENV = 'development';\n\nmodule.exports = {\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/built.js',\n    path: resolve(__dirname, 'build')\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          MiniCssExtractPlugin.loader,\n          'css-loader',\n          /*\n            css兼容性处理：postcss --> postcss-loader postcss-preset-env\n\n            帮postcss找到package.json中browserslist里面的配置，通过配置加载指定的css兼容性样式\n\n            \"browserslist\": {\n              // 开发环境 --> 设置node环境变量：process.env.NODE_ENV = development\n              \"development\": [\n                \"last 1 chrome version\",\n                \"last 1 firefox version\",\n                \"last 1 safari version\"\n              ],\n              // 生产环境：默认是看生产环境\n              \"production\": [\n                \">0.2%\",\n                \"not dead\",\n                \"not op_mini all\"\n              ]\n            }\n          */\n          // 使用loader的默认配置\n          // 'postcss-loader',\n          // 修改loader的配置\n          {\n            loader: 'postcss-loader',\n            options: {\n              ident: 'postcss',\n              plugins: () => [\n                // postcss的插件\n                require('postcss-preset-env')()\n              ]\n            }\n          }\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    }),\n    new MiniCssExtractPlugin({\n      filename: 'css/built.css'\n    })\n  ],\n  mode: 'development'\n};\n```\n\n### 压缩css\n\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')\n\n// 设置nodejs环境变量\n// process.env.NODE_ENV = 'development';\n\nmodule.exports = {\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/built.js',\n    path: resolve(__dirname, 'build')\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          MiniCssExtractPlugin.loader,\n          'css-loader',\n          {\n            loader: 'postcss-loader',\n            options: {\n              ident: 'postcss',\n              plugins: () => [\n                // postcss的插件\n                require('postcss-preset-env')()\n              ]\n            }\n          }\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    }),\n    new MiniCssExtractPlugin({\n      filename: 'css/built.css'\n    }),\n    // 压缩css\n    new OptimizeCssAssetsWebpackPlugin()\n  ],\n  mode: 'development'\n};\n```\n\n### js语法检查\n\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/built.js',\n    path: resolve(__dirname, 'build')\n  },\n  module: {\n    rules: [\n      /*\n        语法检查： eslint-loader  eslint\n          注意：只检查自己写的源代码，第三方的库是不用检查的\n          设置检查规则：\n            package.json中eslintConfig中设置~\n              \"eslintConfig\": {\n                \"extends\": \"airbnb-base\"\n              }\n            airbnb --> eslint-config-airbnb-base  eslint-plugin-import eslint\n      */\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        loader: 'eslint-loader',\n        options: {\n          // 自动修复eslint的错误\n          fix: true\n        }\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    })\n  ],\n  mode: 'development'\n};\n\n```\n\n### js兼容性处理\n\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/built.js',\n    path: resolve(__dirname, 'build')\n  },\n  module: {\n    rules: [\n      /*\n        js兼容性处理：babel-loader @babel/core \n          1. 基本js兼容性处理 --> @babel/preset-env\n            问题：只能转换基本语法，如promise高级语法不能转换\n          2. 全部js兼容性处理 --> @babel/polyfill  \n            问题：我只要解决部分兼容性问题，但是将所有兼容性代码全部引入，体积太大了~\n          3. 需要做兼容性处理的就做：按需加载  --> core-js\n      */  \n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        loader: 'babel-loader',\n        options: {\n          // 预设：指示babel做怎么样的兼容性处理\n          presets: [\n            [\n              '@babel/preset-env',\n              {\n                // 按需加载\n                useBuiltIns: 'usage',\n                // 指定core-js版本\n                corejs: {\n                  version: 3\n                },\n                // 指定兼容性做到哪个版本浏览器\n                targets: {\n                  chrome: '60',\n                  firefox: '60',\n                  ie: '9',\n                  safari: '10',\n                  edge: '17'\n                }\n              }\n            ]\n          ]\n        }\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    })\n  ],\n  mode: 'development'\n};\n\n```\n\n### js压缩\n\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/built.js',\n    path: resolve(__dirname, 'build')\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    })\n  ],\n  // 生产环境下会自动压缩js代码\n  mode: 'production'\n};\n\n```\n\n### html压缩\n\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/built.js',\n    path: resolve(__dirname, 'build')\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html',\n      // 压缩html代码\n      minify: {\n        // 移除空格\n        collapseWhitespace: true,\n        // 移除注释\n        removeComments: true\n      }\n    })\n  ],\n  mode: 'production'\n};\n```\n\n### 生产环境配置\n\n```js\nconst { resolve } = require('path');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\n// 定义nodejs环境变量：决定使用browserslist的哪个环境\nprocess.env.NODE_ENV = 'production';\n\n// 复用loader\nconst commonCssLoader = [\n  MiniCssExtractPlugin.loader,\n  'css-loader',\n  {\n    // 还需要在package.json中定义browserslist\n    loader: 'postcss-loader',\n    options: {\n      ident: 'postcss',\n      plugins: () => [require('postcss-preset-env')()]\n    }\n  }\n];\n\nmodule.exports = {\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/built.js',\n    path: resolve(__dirname, 'build')\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [...commonCssLoader]\n      },\n      {\n        test: /\\.less$/,\n        use: [...commonCssLoader, 'less-loader']\n      },\n      /*\n        正常来讲，一个文件只能被一个loader处理。\n        当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序：\n          先执行eslint 在执行babel\n      */\n      {\n        // 在package.json中eslintConfig --> airbnb\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        // 优先执行\n        enforce: 'pre',\n        loader: 'eslint-loader',\n        options: {\n          fix: true\n        }\n      },\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        loader: 'babel-loader',\n        options: {\n          presets: [\n            [\n              '@babel/preset-env',\n              {\n                useBuiltIns: 'usage',\n                corejs: {version: 3},\n                targets: {\n                  chrome: '60',\n                  firefox: '50'\n                }\n              }\n            ]\n          ]\n        }\n      },\n      {\n        test: /\\.(jpg|png|gif)/,\n        loader: 'url-loader',\n        options: {\n          limit: 8 * 1024,\n          name: '[hash:10].[ext]',\n          outputPath: 'imgs',\n          esModule: false\n        }\n      },\n      {\n        test: /\\.html$/,\n        loader: 'html-loader'\n      },\n      {\n        exclude: /\\.(js|css|less|html|jpg|png|gif)/,\n        loader: 'file-loader',\n        options: {\n          outputPath: 'media'\n        }\n      }\n    ]\n  },\n  plugins: [\n    new MiniCssExtractPlugin({\n      filename: 'css/built.css'\n    }),\n    new OptimizeCssAssetsWebpackPlugin(),\n    new HtmlWebpackPlugin({\n      template: './src/index.html',\n      minify: {\n        collapseWhitespace: true,\n        removeComments: true\n      }\n    })\n  ],\n  mode: 'production'\n};\n\n```\n\n### webpack优化配置\n\n#### 开发环境性能优化\n\n##### 优化打包构建速度\n\n##### HMR\n\n```js\n/*\n  HMR: hot module replacement 热模块替换 / 模块热替换\n    作用：一个模块发生变化，只会重新打包这一个模块（而不是打包所有模块） \n      极大提升构建速度\n      \n      样式文件：可以使用HMR功能：因为style-loader内部实现了~\n      js文件：默认不能使用HMR功能 --> 需要修改js代码，添加支持HMR功能的代码\n        注意：HMR功能对js的处理，只能处理非入口js文件的其他文件。\n      html文件: 默认不能使用HMR功能.同时会导致问题：html文件不能热更新了~ （不用做HMR功能）\n        解决：修改entry入口，将html文件引入\n*/\n\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: ['./src/js/index.js', './src/index.html'],\n  output: {\n    filename: 'js/built.js',\n    path: resolve(__dirname, 'build')\n  },\n  module: {\n    rules: [\n      // loader的配置\n      {\n        // 处理less资源\n        test: /\\.less$/,\n        use: ['style-loader', 'css-loader', 'less-loader']\n      },\n      {\n        // 处理css资源\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader']\n      },\n      {\n        // 处理图片资源\n        test: /\\.(jpg|png|gif)$/,\n        loader: 'url-loader',\n        options: {\n          limit: 8 * 1024,\n          name: '[hash:10].[ext]',\n          // 关闭es6模块化\n          esModule: false,\n          outputPath: 'imgs'\n        }\n      },\n      {\n        // 处理html中img资源\n        test: /\\.html$/,\n        loader: 'html-loader'\n      },\n      {\n        // 处理其他资源\n        exclude: /\\.(html|js|css|less|jpg|png|gif)/,\n        loader: 'file-loader',\n        options: {\n          name: '[hash:10].[ext]',\n          outputPath: 'media'\n        }\n      }\n    ]\n  },\n  plugins: [\n    // plugins的配置\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    })\n  ],\n  mode: 'development',\n  devServer: {\n    contentBase: resolve(__dirname, 'build'),\n    compress: true,\n    port: 3000,\n    open: true,\n    // 开启HMR功能\n    // 当修改了webpack配置，新配置要想生效，必须重新webpack服务\n    hot: true\n  }\n};\n\n```\n\n##### 优化代码调试\n\n##### source-map\n\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: ['./src/js/index.js', './src/index.html'],\n  output: {\n    filename: 'js/built.js',\n    path: resolve(__dirname, 'build')\n  },\n  module: {\n    rules: [\n      // loader的配置\n      {\n        // 处理less资源\n        test: /\\.less$/,\n        use: ['style-loader', 'css-loader', 'less-loader']\n      },\n      {\n        // 处理css资源\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader']\n      },\n      {\n        // 处理图片资源\n        test: /\\.(jpg|png|gif)$/,\n        loader: 'url-loader',\n        options: {\n          limit: 8 * 1024,\n          name: '[hash:10].[ext]',\n          // 关闭es6模块化\n          esModule: false,\n          outputPath: 'imgs'\n        }\n      },\n      {\n        // 处理html中img资源\n        test: /\\.html$/,\n        loader: 'html-loader'\n      },\n      {\n        // 处理其他资源\n        exclude: /\\.(html|js|css|less|jpg|png|gif)/,\n        loader: 'file-loader',\n        options: {\n          name: '[hash:10].[ext]',\n          outputPath: 'media'\n        }\n      }\n    ]\n  },\n  plugins: [\n    // plugins的配置\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    })\n  ],\n  mode: 'development',\n  devServer: {\n    contentBase: resolve(__dirname, 'build'),\n    compress: true,\n    port: 3000,\n    open: true,\n    hot: true\n  },\n  devtool: 'eval-source-map'\n};\n\n/*\n  source-map: 一种 提供源代码到构建后代码映射 技术 （如果构建后代码出错了，通过映射可以追踪源代码错误）\n\n    [inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map\n\n    source-map：外部\n      错误代码准确信息 和 源代码的错误位置\n    inline-source-map：内联\n      只生成一个内联source-map\n      错误代码准确信息 和 源代码的错误位置\n    hidden-source-map：外部\n      错误代码错误原因，但是没有错误位置\n      不能追踪源代码错误，只能提示到构建后代码的错误位置\n    eval-source-map：内联\n      每一个文件都生成对应的source-map，都在eval\n      错误代码准确信息 和 源代码的错误位置\n    nosources-source-map：外部\n      错误代码准确信息, 但是没有任何源代码信息\n    cheap-source-map：外部\n      错误代码准确信息 和 源代码的错误位置 \n      只能精确的行\n    cheap-module-source-map：外部\n      错误代码准确信息 和 源代码的错误位置 \n      module会将loader的source map加入\n\n    内联 和 外部的区别：1. 外部生成了文件，内联没有 2. 内联构建速度更快\n\n    开发环境：速度快，调试更友好\n      速度快(eval>inline>cheap>...)\n        eval-cheap-souce-map\n        eval-source-map\n      调试更友好  \n        souce-map\n        cheap-module-souce-map\n        cheap-souce-map\n\n      --> eval-source-map  / eval-cheap-module-souce-map\n\n    生产环境：源代码要不要隐藏? 调试要不要更友好\n      内联会让代码体积变大，所以在生产环境不用内联\n      nosources-source-map 全部隐藏\n      hidden-source-map 只隐藏源代码，会提示构建后代码错误信息\n\n      --> source-map / cheap-module-souce-map\n*/\n\n```\n\n### 生产环境性能优化\n\n#### 优化打包构建速度\n\n##### oneOf\n\n```js\nconst { resolve } = require('path');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\n// 定义nodejs环境变量：决定使用browserslist的哪个环境\nprocess.env.NODE_ENV = 'production';\n\n// 复用loader\nconst commonCssLoader = [\n  MiniCssExtractPlugin.loader,\n  'css-loader',\n  {\n    // 还需要在package.json中定义browserslist\n    loader: 'postcss-loader',\n    options: {\n      ident: 'postcss',\n      plugins: () => [require('postcss-preset-env')()]\n    }\n  }\n];\n\nmodule.exports = {\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/built.js',\n    path: resolve(__dirname, 'build')\n  },\n  module: {\n    rules: [\n      {\n        // 在package.json中eslintConfig --> airbnb\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        // 优先执行\n        enforce: 'pre',\n        loader: 'eslint-loader',\n        options: {\n          fix: true\n        }\n      },\n      {\n        // 以下loader只会匹配一个\n        // 注意：不能有两个配置处理同一种类型文件\n        oneOf: [\n          {\n            test: /\\.css$/,\n            use: [...commonCssLoader]\n          },\n          {\n            test: /\\.less$/,\n            use: [...commonCssLoader, 'less-loader']\n          },\n          /*\n            正常来讲，一个文件只能被一个loader处理。\n            当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序：\n              先执行eslint 在执行babel\n          */\n          {\n            test: /\\.js$/,\n            exclude: /node_modules/,\n            loader: 'babel-loader',\n            options: {\n              presets: [\n                [\n                  '@babel/preset-env',\n                  {\n                    useBuiltIns: 'usage',\n                    corejs: {version: 3},\n                    targets: {\n                      chrome: '60',\n                      firefox: '50'\n                    }\n                  }\n                ]\n              ]\n            }\n          },\n          {\n            test: /\\.(jpg|png|gif)/,\n            loader: 'url-loader',\n            options: {\n              limit: 8 * 1024,\n              name: '[hash:10].[ext]',\n              outputPath: 'imgs',\n              esModule: false\n            }\n          },\n          {\n            test: /\\.html$/,\n            loader: 'html-loader'\n          },\n          {\n            exclude: /\\.(js|css|less|html|jpg|png|gif)/,\n            loader: 'file-loader',\n            options: {\n              outputPath: 'media'\n            }\n          }\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new MiniCssExtractPlugin({\n      filename: 'css/built.css'\n    }),\n    new OptimizeCssAssetsWebpackPlugin(),\n    new HtmlWebpackPlugin({\n      template: './src/index.html',\n      minify: {\n        collapseWhitespace: true,\n        removeComments: true\n      }\n    })\n  ],\n  mode: 'production'\n};\n\n```\n\n##### babel缓存\n\n```js\nconst { resolve } = require('path');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\n/*\n  缓存：\n    babel缓存\n      cacheDirectory: true\n      --> 让第二次打包构建速度更快\n    文件资源缓存\n      hash: 每次wepack构建时会生成一个唯一的hash值。\n        问题: 因为js和css同时使用一个hash值。\n          如果重新打包，会导致所有缓存失效。（可能我却只改动一个文件）\n      chunkhash：根据chunk生成的hash值。如果打包来源于同一个chunk，那么hash值就一样\n        问题: js和css的hash值还是一样的\n          因为css是在js中被引入的，所以同属于一个chunk\n      contenthash: 根据文件的内容生成hash值。不同文件hash值一定不一样    \n      --> 让代码上线运行缓存更好使用\n*/\n\n// 定义nodejs环境变量：决定使用browserslist的哪个环境\nprocess.env.NODE_ENV = 'production';\n\n// 复用loader\nconst commonCssLoader = [\n  MiniCssExtractPlugin.loader,\n  'css-loader',\n  {\n    // 还需要在package.json中定义browserslist\n    loader: 'postcss-loader',\n    options: {\n      ident: 'postcss',\n      plugins: () => [require('postcss-preset-env')()]\n    }\n  }\n];\n\nmodule.exports = {\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/built.[contenthash:10].js',\n    path: resolve(__dirname, 'build')\n  },\n  module: {\n    rules: [\n      {\n        // 在package.json中eslintConfig --> airbnb\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        // 优先执行\n        enforce: 'pre',\n        loader: 'eslint-loader',\n        options: {\n          fix: true\n        }\n      },\n      {\n        // 以下loader只会匹配一个\n        // 注意：不能有两个配置处理同一种类型文件\n        oneOf: [\n          {\n            test: /\\.css$/,\n            use: [...commonCssLoader]\n          },\n          {\n            test: /\\.less$/,\n            use: [...commonCssLoader, 'less-loader']\n          },\n          /*\n            正常来讲，一个文件只能被一个loader处理。\n            当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序：\n              先执行eslint 在执行babel\n          */\n          {\n            test: /\\.js$/,\n            exclude: /node_modules/,\n            loader: 'babel-loader',\n            options: {\n              presets: [\n                [\n                  '@babel/preset-env',\n                  {\n                    useBuiltIns: 'usage',\n                    corejs: { version: 3 },\n                    targets: {\n                      chrome: '60',\n                      firefox: '50'\n                    }\n                  }\n                ]\n              ],\n              // 开启babel缓存\n              // 第二次构建时，会读取之前的缓存\n              cacheDirectory: true\n            }\n          },\n          {\n            test: /\\.(jpg|png|gif)/,\n            loader: 'url-loader',\n            options: {\n              limit: 8 * 1024,\n              name: '[hash:10].[ext]',\n              outputPath: 'imgs',\n              esModule: false\n            }\n          },\n          {\n            test: /\\.html$/,\n            loader: 'html-loader'\n          },\n          {\n            exclude: /\\.(js|css|less|html|jpg|png|gif)/,\n            loader: 'file-loader',\n            options: {\n              outputPath: 'media'\n            }\n          }\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new MiniCssExtractPlugin({\n      filename: 'css/built.[contenthash:10].css'\n    }),\n    new OptimizeCssAssetsWebpackPlugin(),\n    new HtmlWebpackPlugin({\n      template: './src/index.html',\n      minify: {\n        collapseWhitespace: true,\n        removeComments: true\n      }\n    })\n  ],\n  mode: 'production',\n  devtool: 'source-map'\n};\n\n```\n\n#### 多进程打包\n\n```js\nconst { resolve } = require('path');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst WorkboxWebpackPlugin = require('workbox-webpack-plugin');\n\n/*\n  PWA: 渐进式网络开发应用程序(离线可访问)\n    workbox --> workbox-webpack-plugin\n*/\n\n// 定义nodejs环境变量：决定使用browserslist的哪个环境\nprocess.env.NODE_ENV = 'production';\n\n// 复用loader\nconst commonCssLoader = [\n  MiniCssExtractPlugin.loader,\n  'css-loader',\n  {\n    // 还需要在package.json中定义browserslist\n    loader: 'postcss-loader',\n    options: {\n      ident: 'postcss',\n      plugins: () => [require('postcss-preset-env')()]\n    }\n  }\n];\n\nmodule.exports = {\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/built.[contenthash:10].js',\n    path: resolve(__dirname, 'build')\n  },\n  module: {\n    rules: [\n      {\n        // 在package.json中eslintConfig --> airbnb\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        // 优先执行\n        enforce: 'pre',\n        loader: 'eslint-loader',\n        options: {\n          fix: true\n        }\n      },\n      {\n        // 以下loader只会匹配一个\n        // 注意：不能有两个配置处理同一种类型文件\n        oneOf: [\n          {\n            test: /\\.css$/,\n            use: [...commonCssLoader]\n          },\n          {\n            test: /\\.less$/,\n            use: [...commonCssLoader, 'less-loader']\n          },\n          /*\n            正常来讲，一个文件只能被一个loader处理。\n            当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序：\n              先执行eslint 在执行babel\n          */\n          {\n            test: /\\.js$/,\n            exclude: /node_modules/,\n            use: [\n              /* \n                开启多进程打包。 \n                进程启动大概为600ms，进程通信也有开销。\n                只有工作消耗时间比较长，才需要多进程打包\n              */\n              {\n                loader: 'thread-loader',\n                options: {\n                  workers: 2 // 进程2个\n                }\n              },\n              {\n                loader: 'babel-loader',\n                options: {\n                  presets: [\n                    [\n                      '@babel/preset-env',\n                      {\n                        useBuiltIns: 'usage',\n                        corejs: { version: 3 },\n                        targets: {\n                          chrome: '60',\n                          firefox: '50'\n                        }\n                      }\n                    ]\n                  ],\n                  // 开启babel缓存\n                  // 第二次构建时，会读取之前的缓存\n                  cacheDirectory: true\n                }\n              }\n            ]\n          },\n          {\n            test: /\\.(jpg|png|gif)/,\n            loader: 'url-loader',\n            options: {\n              limit: 8 * 1024,\n              name: '[hash:10].[ext]',\n              outputPath: 'imgs',\n              esModule: false\n            }\n          },\n          {\n            test: /\\.html$/,\n            loader: 'html-loader'\n          },\n          {\n            exclude: /\\.(js|css|less|html|jpg|png|gif)/,\n            loader: 'file-loader',\n            options: {\n              outputPath: 'media'\n            }\n          }\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new MiniCssExtractPlugin({\n      filename: 'css/built.[contenthash:10].css'\n    }),\n    new OptimizeCssAssetsWebpackPlugin(),\n    new HtmlWebpackPlugin({\n      template: './src/index.html',\n      minify: {\n        collapseWhitespace: true,\n        removeComments: true\n      }\n    }),\n    new WorkboxWebpackPlugin.GenerateSW({\n      /*\n        1. 帮助serviceworker快速启动\n        2. 删除旧的 serviceworker\n\n        生成一个 serviceworker 配置文件~\n      */\n      clientsClaim: true,\n      skipWaiting: true\n    })\n  ],\n  mode: 'production',\n  devtool: 'source-map'\n};\n\n```\n\n#### externals\n\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/built.js',\n    path: resolve(__dirname, 'build')\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    })\n  ],\n  mode: 'production',\n  externals: {\n    // 拒绝jQuery被打包进来\n    jquery: 'jQuery'\n  }\n};\n\n```\n\n#### dll\n\nwebpack.config.js\n\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/built.js',\n    path: resolve(__dirname, 'build')\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    })\n  ],\n  mode: 'production',\n  externals: {\n    // 拒绝jQuery被打包进来\n    jquery: 'jQuery'\n  }\n};\n```\n\nwebpack.dll.js\n\n```js\n/*\n  使用dll技术，对某些库（第三方库：jquery、react、vue...）进行单独打包\n    当你运行 webpack 时，默认查找 webpack.config.js 配置文件\n    需求：需要运行 webpack.dll.js 文件\n      --> webpack --config webpack.dll.js\n*/\n\nconst { resolve } = require('path');\nconst webpack = require('webpack');\n\nmodule.exports = {\n  entry: {\n    // 最终打包生成的[name] --> jquery\n    // ['jquery'] --> 要打包的库是jquery\n    jquery: ['jquery'],\n  },\n  output: {\n    filename: '[name].js',\n    path: resolve(__dirname, 'dll'),\n    library: '[name]_[hash]' // 打包的库里面向外暴露出去的内容叫什么名字\n  },\n  plugins: [\n    // 打包生成一个 manifest.json --> 提供和jquery映射\n    new webpack.DllPlugin({\n      name: '[name]_[hash]', // 映射库的暴露的内容名称\n      path: resolve(__dirname, 'dll/manifest.json') // 输出文件路径\n    })\n  ],\n  mode: 'production'\n};\n```\n\n#### 优化代码运行的性能\n\n#### 缓存(hash-chunkhash-contenthash)\n\n#### tree shaking\n\n```js\nconst { resolve } = require('path');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\n/*\n  tree shaking：去除无用代码\n    前提：1. 必须使用ES6模块化  2. 开启production环境\n    作用: 减少代码体积\n\n    在package.json中配置 \n      \"sideEffects\": false 所有代码都没有副作用（都可以进行tree shaking）\n        问题：可能会把css / @babel/polyfill （副作用）文件干掉\n      \"sideEffects\": [\"*.css\", \"*.less\"]\n*/\n\n// 定义nodejs环境变量：决定使用browserslist的哪个环境\nprocess.env.NODE_ENV = 'production';\n\n// 复用loader\nconst commonCssLoader = [\n  MiniCssExtractPlugin.loader,\n  'css-loader',\n  {\n    // 还需要在package.json中定义browserslist\n    loader: 'postcss-loader',\n    options: {\n      ident: 'postcss',\n      plugins: () => [require('postcss-preset-env')()]\n    }\n  }\n];\n\nmodule.exports = {\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/built.[contenthash:10].js',\n    path: resolve(__dirname, 'build')\n  },\n  module: {\n    rules: [\n      {\n        // 在package.json中eslintConfig --> airbnb\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        // 优先执行\n        enforce: 'pre',\n        loader: 'eslint-loader',\n        options: {\n          fix: true\n        }\n      },\n      {\n        // 以下loader只会匹配一个\n        // 注意：不能有两个配置处理同一种类型文件\n        oneOf: [\n          {\n            test: /\\.css$/,\n            use: [...commonCssLoader]\n          },\n          {\n            test: /\\.less$/,\n            use: [...commonCssLoader, 'less-loader']\n          },\n          /*\n            正常来讲，一个文件只能被一个loader处理。\n            当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序：\n              先执行eslint 在执行babel\n          */\n          {\n            test: /\\.js$/,\n            exclude: /node_modules/,\n            loader: 'babel-loader',\n            options: {\n              presets: [\n                [\n                  '@babel/preset-env',\n                  {\n                    useBuiltIns: 'usage',\n                    corejs: { version: 3 },\n                    targets: {\n                      chrome: '60',\n                      firefox: '50'\n                    }\n                  }\n                ]\n              ],\n              // 开启babel缓存\n              // 第二次构建时，会读取之前的缓存\n              cacheDirectory: true\n            }\n          },\n          {\n            test: /\\.(jpg|png|gif)/,\n            loader: 'url-loader',\n            options: {\n              limit: 8 * 1024,\n              name: '[hash:10].[ext]',\n              outputPath: 'imgs',\n              esModule: false\n            }\n          },\n          {\n            test: /\\.html$/,\n            loader: 'html-loader'\n          },\n          {\n            exclude: /\\.(js|css|less|html|jpg|png|gif)/,\n            loader: 'file-loader',\n            options: {\n              outputPath: 'media'\n            }\n          }\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new MiniCssExtractPlugin({\n      filename: 'css/built.[contenthash:10].css'\n    }),\n    new OptimizeCssAssetsWebpackPlugin(),\n    new HtmlWebpackPlugin({\n      template: './src/index.html',\n      minify: {\n        collapseWhitespace: true,\n        removeComments: true\n      }\n    })\n  ],\n  mode: 'production',\n  devtool: 'source-map'\n};\n```\n\n#### code split\n\ndemo1\n\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  // 单入口\n  // entry: './src/js/index.js',\n  entry: {\n    // 多入口：有一个入口，最终输出就有一个bundle\n    index: './src/js/index.js',\n    test: './src/js/test.js'\n  },\n  output: {\n    // [name]：取文件名\n    filename: 'js/[name].[contenthash:10].js',\n    path: resolve(__dirname, 'build')\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html',\n      minify: {\n        collapseWhitespace: true,\n        removeComments: true\n      }\n    })\n  ],\n  mode: 'production'\n};\n```\n\ndemo2\n\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  // 单入口\n  // entry: './src/js/index.js',\n  entry: {\n    index: './src/js/index.js',\n    test: './src/js/test.js'\n  },\n  output: {\n    // [name]：取文件名\n    filename: 'js/[name].[contenthash:10].js',\n    path: resolve(__dirname, 'build')\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html',\n      minify: {\n        collapseWhitespace: true,\n        removeComments: true\n      }\n    })\n  ],\n  /*\n    1. 可以将node_modules中代码单独打包一个chunk最终输出\n    2. 自动分析多入口chunk中，有没有公共的文件。如果有会打包成单独一个chunk\n  */\n  optimization: {\n    splitChunks: {\n      chunks: 'all'\n    }\n  },\n  mode: 'production'\n};\n```\n\ndemo3\n\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  // 单入口\n  entry: './src/js/index.js',\n  output: {\n    // [name]：取文件名\n    filename: 'js/[name].[contenthash:10].js',\n    path: resolve(__dirname, 'build')\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html',\n      minify: {\n        collapseWhitespace: true,\n        removeComments: true\n      }\n    })\n  ],\n  /*\n    1. 可以将node_modules中代码单独打包一个chunk最终输出\n    2. 自动分析多入口chunk中，有没有公共的文件。如果有会打包成单独一个chunk\n  */\n  optimization: {\n    splitChunks: {\n      chunks: 'all'\n    }\n  },\n  mode: 'production'\n};\n```\n\n#### 懒加载/预加载\n\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  // 单入口\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/[name].[contenthash:10].js',\n    path: resolve(__dirname, 'build')\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html',\n      minify: {\n        collapseWhitespace: true,\n        removeComments: true\n      }\n    })\n  ],\n  optimization: {\n    splitChunks: {\n      chunks: 'all'\n    }\n  },\n  mode: 'production'\n};\n\n```\n\n#### pwa\n\n```js\nconst { resolve } = require('path');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nconst OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst WorkboxWebpackPlugin = require('workbox-webpack-plugin');\n\n/*\n  PWA: 渐进式网络开发应用程序(离线可访问)\n    workbox --> workbox-webpack-plugin\n*/\n\n// 定义nodejs环境变量：决定使用browserslist的哪个环境\nprocess.env.NODE_ENV = 'production';\n\n// 复用loader\nconst commonCssLoader = [\n  MiniCssExtractPlugin.loader,\n  'css-loader',\n  {\n    // 还需要在package.json中定义browserslist\n    loader: 'postcss-loader',\n    options: {\n      ident: 'postcss',\n      plugins: () => [require('postcss-preset-env')()]\n    }\n  }\n];\n\nmodule.exports = {\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/built.[contenthash:10].js',\n    path: resolve(__dirname, 'build')\n  },\n  module: {\n    rules: [\n      {\n        // 在package.json中eslintConfig --> airbnb\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        // 优先执行\n        enforce: 'pre',\n        loader: 'eslint-loader',\n        options: {\n          fix: true\n        }\n      },\n      {\n        // 以下loader只会匹配一个\n        // 注意：不能有两个配置处理同一种类型文件\n        oneOf: [\n          {\n            test: /\\.css$/,\n            use: [...commonCssLoader]\n          },\n          {\n            test: /\\.less$/,\n            use: [...commonCssLoader, 'less-loader']\n          },\n          /*\n            正常来讲，一个文件只能被一个loader处理。\n            当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序：\n              先执行eslint 在执行babel\n          */\n          {\n            test: /\\.js$/,\n            exclude: /node_modules/,\n            loader: 'babel-loader',\n            options: {\n              presets: [\n                [\n                  '@babel/preset-env',\n                  {\n                    useBuiltIns: 'usage',\n                    corejs: { version: 3 },\n                    targets: {\n                      chrome: '60',\n                      firefox: '50'\n                    }\n                  }\n                ]\n              ],\n              // 开启babel缓存\n              // 第二次构建时，会读取之前的缓存\n              cacheDirectory: true\n            }\n          },\n          {\n            test: /\\.(jpg|png|gif)/,\n            loader: 'url-loader',\n            options: {\n              limit: 8 * 1024,\n              name: '[hash:10].[ext]',\n              outputPath: 'imgs',\n              esModule: false\n            }\n          },\n          {\n            test: /\\.html$/,\n            loader: 'html-loader'\n          },\n          {\n            exclude: /\\.(js|css|less|html|jpg|png|gif)/,\n            loader: 'file-loader',\n            options: {\n              outputPath: 'media'\n            }\n          }\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new MiniCssExtractPlugin({\n      filename: 'css/built.[contenthash:10].css'\n    }),\n    new OptimizeCssAssetsWebpackPlugin(),\n    new HtmlWebpackPlugin({\n      template: './src/index.html',\n      minify: {\n        collapseWhitespace: true,\n        removeComments: true\n      }\n    }),\n    new WorkboxWebpackPlugin.GenerateSW({\n      /*\n        1. 帮助serviceworker快速启动\n        2. 删除旧的 serviceworker\n\n        生成一个 serviceworker 配置文件~\n      */\n      clientsClaim: true,\n      skipWaiting: true\n    })\n  ],\n  mode: 'production',\n  devtool: 'source-map'\n};\n```\n\n## webpack配置详解\n\n### entry\n\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\n/*\n  entry: 入口起点\n    1. string --> './src/index.js'\n      单入口\n      打包形成一个chunk。 输出一个bundle文件。\n      此时chunk的名称默认是 main\n    2. array  --> ['./src/index.js', './src/add.js']\n      多入口\n      所有入口文件最终只会形成一个chunk, 输出出去只有一个bundle文件。\n        --> 只有在HMR功能中让html热更新生效~\n    3. object\n      多入口\n      有几个入口文件就形成几个chunk，输出几个bundle文件\n      此时chunk的名称是 key\n\n      --> 特殊用法\n        {\n          // 所有入口文件最终只会形成一个chunk, 输出出去只有一个bundle文件。\n          index: ['./src/index.js', './src/count.js'], \n          // 形成一个chunk，输出一个bundle文件。\n          add: './src/add.js'\n        }\n*/\n\nmodule.exports = {\n  entry: {\n    index: ['./src/index.js', './src/count.js'], \n    add: './src/add.js'\n  },\n  output: {\n    filename: '[name].js',\n    path: resolve(__dirname, 'build')\n  },\n  plugins: [new HtmlWebpackPlugin()],\n  mode: 'development'\n};\n\n```\n\n### output\n\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    // 文件名称（指定名称+目录）\n    filename: 'js/[name].js',\n    // 输出文件目录（将来所有资源输出的公共目录）\n    path: resolve(__dirname, 'build'),\n    // 所有资源引入公共路径前缀 --> 'imgs/a.jpg' --> '/imgs/a.jpg'\n    publicPath: '/',\n    chunkFilename: 'js/[name]_chunk.js', // 非入口chunk的名称\n    // library: '[name]', // 整个库向外暴露的变量名\n    // libraryTarget: 'window' // 变量名添加到哪个上 browser\n    // libraryTarget: 'global' // 变量名添加到哪个上 node\n    // libraryTarget: 'commonjs'\n  },\n  plugins: [new HtmlWebpackPlugin()],\n  mode: 'development'\n};\n\n```\n\n### module\n\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    filename: 'js/[name].js',\n    path: resolve(__dirname, 'build')\n  },\n  module: {\n    rules: [\n      // loader的配置\n      {\n        test: /\\.css$/,\n        // 多个loader用use\n        use: ['style-loader', 'css-loader']\n      },\n      {\n        test: /\\.js$/,\n        // 排除node_modules下的js文件\n        exclude: /node_modules/,\n        // 只检查 src 下的js文件\n        include: resolve(__dirname, 'src'),\n        // 优先执行\n        enforce: 'pre',\n        // 延后执行\n        // enforce: 'post',\n        // 单个loader用loader\n        loader: 'eslint-loader',\n        options: {}\n      },\n      {\n        // 以下配置只会生效一个\n        oneOf: []\n      }\n    ]\n  },\n  plugins: [new HtmlWebpackPlugin()],\n  mode: 'development'\n};\n\n```\n\n### resolve\n\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/[name].js',\n    path: resolve(__dirname, 'build')\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader']\n      }\n    ]\n  },\n  plugins: [new HtmlWebpackPlugin()],\n  mode: 'development',\n  // 解析模块的规则\n  resolve: {\n    // 配置解析模块路径别名: 优点简写路径 缺点路径没有提示\n    alias: {\n      $css: resolve(__dirname, 'src/css')\n    },\n    // 配置省略文件路径的后缀名\n    extensions: ['.js', '.json', '.jsx', '.css'],\n    // 告诉 webpack 解析模块是去找哪个目录\n    modules: [resolve(__dirname, '../../node_modules'), 'node_modules']\n  }\n};\n\n```\n\n### dev server\n\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/[name].js',\n    path: resolve(__dirname, 'build')\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader']\n      }\n    ]\n  },\n  plugins: [new HtmlWebpackPlugin()],\n  mode: 'development',\n  resolve: {\n    alias: {\n      $css: resolve(__dirname, 'src/css')\n    },\n    extensions: ['.js', '.json', '.jsx', '.css'],\n    modules: [resolve(__dirname, '../../node_modules'), 'node_modules']\n  },\n  devServer: {\n    // 运行代码的目录\n    contentBase: resolve(__dirname, 'build'),\n    // 监视 contentBase 目录下的所有文件，一旦文件变化就会 reload\n    watchContentBase: true,\n    watchOptions: {\n      // 忽略文件\n      ignored: /node_modules/\n    },\n    // 启动gzip压缩\n    compress: true,\n    // 端口号\n    port: 5000,\n    // 域名\n    host: 'localhost',\n    // 自动打开浏览器\n    open: true,\n    // 开启HMR功能\n    hot: true,\n    // 不要显示启动服务器日志信息\n    clientLogLevel: 'none',\n    // 除了一些基本启动信息以外，其他内容都不要显示\n    quiet: true,\n    // 如果出错了，不要全屏提示~\n    overlay: false,\n    // 服务器代理 --> 解决开发环境跨域问题\n    proxy: {\n      // 一旦devServer(5000)服务器接受到 /api/xxx 的请求，就会把请求转发到另外一个服务器(3000)\n      '/api': {\n        target: 'http://localhost:3000',\n        // 发送请求时，请求路径重写：将 /api/xxx --> /xxx （去掉/api）\n        pathRewrite: {\n          '^/api': ''\n        }\n      }\n    }\n  }\n};\n\n```\n\n### optimization\n\n```js\nconst { resolve } = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst TerserWebpackPlugin = require('terser-webpack-plugin')\n\nmodule.exports = {\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/[name].[contenthash:10].js',\n    path: resolve(__dirname, 'build'),\n    chunkFilename: 'js/[name].[contenthash:10]_chunk.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader']\n      }\n    ]\n  },\n  plugins: [new HtmlWebpackPlugin()],\n  mode: 'production',\n  resolve: {\n    alias: {\n      $css: resolve(__dirname, 'src/css')\n    },\n    extensions: ['.js', '.json', '.jsx', '.css'],\n    modules: [resolve(__dirname, '../../node_modules'), 'node_modules']\n  },\n  optimization: {\n    splitChunks: {\n      chunks: 'all'\n      // 默认值，可以不写~\n      /* minSize: 30 * 1024, // 分割的chunk最小为30kb\n      maxSiza: 0, // 最大没有限制\n      minChunks: 1, // 要提取的chunk最少被引用1次\n      maxAsyncRequests: 5, // 按需加载时并行加载的文件的最大数量\n      maxInitialRequests: 3, // 入口js文件最大并行请求数量\n      automaticNameDelimiter: '~', // 名称连接符\n      name: true, // 可以使用命名规则\n      cacheGroups: {\n        // 分割chunk的组\n        // node_modules文件会被打包到 vendors 组的chunk中。--> vendors~xxx.js\n        // 满足上面的公共规则，如：大小超过30kb，至少被引用一次。\n        vendors: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          // 优先级\n          priority: -10\n        },\n        default: {\n          // 要提取的chunk最少被引用2次\n          minChunks: 2,\n          // 优先级\n          priority: -20,\n          // 如果当前要打包的模块，和之前已经被提取的模块是同一个，就会复用，而不是重新打包模块\n          reuseExistingChunk: true\n        } \n      }*/\n    },\n    // 将当前模块的记录其他模块的hash单独打包为一个文件 runtime\n    // 解决：修改a文件导致b文件的contenthash变化\n    runtimeChunk: {\n      name: entrypoint => `runtime-${entrypoint.name}`\n    },\n    minimizer: [\n      // 配置生产环境的压缩方案：js和css\n      new TerserWebpackPlugin({\n        // 开启缓存\n        cache: true,\n        // 开启多进程打包\n        parallel: true,\n        // 启动source-map\n        sourceMap: true\n      })\n    ]\n  }\n};\n\n```\n","children":[]},{"name":"webpack重构.md","path":"../guanruihua.github.io/Front-End/项目搭建/webpack","data":"# webpack区分生产环境和开发环境\n\n> webpack 的配置一般写在webpack.config.js文件夹中, 但是生产环境的配置和开发环境不一样, 需要将两个环境分开\n\n## cross-env\n\n在node里，我们有一个process对象，它里面包括了node的一些信息，env和它的一个属性，但是并没有process.env.NODE_ENV，这是我们自己添加的一个用来区分环境的变量，我们通过这个来区分生产开发环境。\n\n但是不同电脑上设置的方式是不一样的，所以cross-env就来了，它可以跨平台设置环境和使用环境变量。\n\n我们需要在控制台执行：\n\n```shell\nyarn add cross-env -D\n```\n\n然后我们在package.json里配置：\n\n```shell\n\"build\": \"cross-env NODE_ENV=production webpack\",\n\"dev\": \"cross-env NODE_ENV=development webpack-dev-server\"\n```\n\n我们在webpack.config.js里添加：\n\n```shell\nconst NODE_ENV=process.env.NODE_ENV;\nconsole.log(\"--------\"+NODE_ENV+\"-----------\");\n```\n\n然后去控制台执行，当执行yarn run build时：\n\n![在这里插入图片描述](webpack重构.assets/16903cbe8ec23b4e)\n\n控制台打印出了我们设置的production。vim\n\n执行yarn run dev的时候：\n\n![在这里插入图片描述](webpack重构.assets/16903cbe8ed36e78)\n\n打印出了devlopment，说明我们已经设置完成了。\n\n## webpack-merge\n\n设置了环境之后我们需要将配置分开，我们先在根目录下新建==webpack.config.dev.js==（开发环境），==webpack.config.prod.js==（生产环境），将原本的webpack.config.js修改成==webpack.config.common.js==（公共）。\n\n分离开的环境需要和common里的代码合并使用，所以我们就需要用到webapck-merge插件，我们在控制台执行：\n\n```shell\nyarn add webpack-merge -D\n```\n\n下载好后先去package.json里修改配置：\n\n```shell\n//--config是可以设置我们执行哪个webpack文件，默认是执行webpack.config.js,但是我们现在修改文件名了，所以我们要设置一下\n\"build\": \"cross-env NODE_ENV=production webpack --config webpack.config.prod.js\",\n\"dev\": \"cross-env NODE_ENV=development webpack-dev-server --config webpack.config.dev.js\"\n```\n\n我们将一些开发环境用到的东西移到==webpack.config.dev.js==里：\n\n```js\nconst path=require('path');\nconst webpack=require('webpack');\nconst merge=require('webpack-merge');//这里引入merge\nconst common=require('./webpack.config.common.js');//这里引入公共代码\n\nmodule.exports=merge(common,{//注意这里的写法\n    mode:'development',\n    devtool:'cheap-module-eval-source-map',\n    module:{\n        rules:[\n\n        ]\n    },\n    devServer: {\n        contentBase: path.join(__dirname, \"dist\"),\n        compress: true,//开启gzip压缩\n        port: 8080,\n        open:true,\n        hot:true,\n        overlay:true,\n    },\n    plugins:[\n        new webpack.HotModuleReplacementPlugin(),\n    ]\n})\n```\n\n生产环境的移到==webpack.config.prod.js==：\n\n```js\nconst merge=require('webpack-merge');\nconst webpack=require('webpack');\nconst common=require('./webpack.config.common.js');\nconst MiniCssExtractPlugin=require('mini-css-extract-plugin');\nconst { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');\nconst UglifyJsPlugin = require(\"uglifyjs-webpack-plugin\");\nconst OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\");\nconst CleanWebpackPlugin  = require('clean-webpack-plugin');\n\nmodule.exports=merge(common,{\n    mode:'production',\n    module:{\n        rules:[\n\n        ]\n    },\n    plugins:[\n        new MiniCssExtractPlugin({//提取css\n            filename:'css/main.css'\n        }),\n        new CleanWebpackPlugin('./dist'),//删除dist目录下的文件\n        new BundleAnalyzerPlugin({ analyzerPort: 8090 }),\n\n    ]\n})\n```\n\n然后去==webpack.config.common.js==里将相关代码删除就行了。\n\n这里还有个注意点，在使用MiniCssExtractPlugin.loader的时候是不支持热更新的，所以我们需要根据环境来区分这个，我们在==webpack.config.common.js==里修改一下：\n\n```json\n//开发环境使用style-loader\n{\n loader:NODE_ENV===\"production\" ? MiniCssExtractPlugin.loader : \"style-loader\"\n}\n```\n","children":[]},{"name":"增量打包多页应用.md","path":"../guanruihua.github.io/Front-End/项目搭建/webpack","data":"# webpack增量打包多页应用\n\n其实webpack关于缓存方面的功能，提供了很多功能强大的插件，例如：\n\n- CommonsChunkPlugin可以用来在打包的时候提取公共js代码\n- ExtractTextPlugin可以用来从js中提出css，将其输出到一个独立的文件\n\n利用这两个插件，我们能够将我们打包的精度加以划分，将公共引用的部分打包为一个单独的文件\n\n如果公共引用的部分变为了一个单独的文件，再添加上hash进行缓存，当再次修改的时候只要更新hash，这样我们不就能够确定，究竟改动了哪个文件了吗\n\n**既然如此，我们一步一步进行探索：**\n\n## 1，首先使用CommonsChunkPlugin，提取公共js\n\n现在我们创建测试入口文件：\n\nsrc/one.js:\n\n```js\nimport jquery from 'jquery';\nconsole.log('one');\n```\n\nsrc/two.js:\n\n```js\nimport jquery from 'jquery';\nconsole.log('two');\n```\n\nwebpack.config.js\n\n```js\nvar path = require('path');\nmodule.exports = {\n    entry: {\n        one: \"./src/one.js\",\n        two: \"./src/two.js\"\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: \"[name].js\"\n    }\n};\n\n```\n\n执行webpack\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/161166363962adf3~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n输出了2个文件，大小都是271kb，这是因为one.js和two.js都引用了jquery，jquery打包了2次，分别打包到了两个文件中\n\n这样显然不是很友好，像jquery这种文件，显然平时不会改动，还是缓存起来比较好，修改webpack.config.js\n\n```js\nvar webpack = require(\"webpack\");\nvar path = require('path');\nmodule.exports = {\n    entry: {\n        one: \"./src/one.js\",\n        two: \"./src/two.js\"\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: \"[name].js\"\n    },\n    plugins:[\n        new webpack.optimize.CommonsChunkPlugin({\n            name: \"common\",\n        }),\n    ]\n};\n\n```\n\n现在我们添加了CommonsChunkPlugin插件，它的作用是提取公共js，再次执行webpack\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663639851705~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n可以看到one.js和two.js的大小已经不到1k了，而common则274k，可以看到jquery已经被打包到了common.js当中\n\n## 2，为文件添加hash\n\n```\nvar webpack = require(\"webpack\");\nvar path = require('path');\nmodule.exports = {\n    entry: {\n        one: \"./src/one.js\",\n        two: \"./src/two.js\"\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: \"[name].[hash:6].js\"\n    },\n    plugins:[\n        new webpack.optimize.CommonsChunkPlugin({\n            name: \"common\",\n        }),\n    ]\n};\n\n```\n\n上面修改了output的输出内容`[name].[hash].js`\n\n现在执行webpack：\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/161166363985ac91~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n可以看到打包的三个文件都有了hash，但需要主意，此时每个文件的hash都是一样的\n\n再次执行一遍webpack：\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663639be42d0~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n可以看到，两次构建输出的结果一致，这很好，因为没有修改文件，自然不希望hash发生改变\n\n那么接下来，修改一下文件：one.js\n\n```\nimport jquery from 'jquery';\nconsole.log('修改one');\n\n```\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663639e347e8~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n悲剧了，所有文件全部修改了hash，查看输出的结果：\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/161166363f936501~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n可以发现只修改一个文件，却修改了全部文件的hash，这个问题很严重，显然不是我们想要的\n\n## 3，使用chunkhash替代hash\n\nwebpack中关于缓存，提供了好几种添加hash的方法，其中就有chunkhash\n\nchunkhash简单来说，就是根据模块内容来添加hash，既然这样的话，只要文件没有改变，就不会生成新的hash\n\n```\nvar webpack = require(\"webpack\");\nvar path = require('path');\nmodule.exports = {\n    entry: {\n        one: \"./src/one.js\",\n        two: \"./src/two.js\"\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: \"[name].[chunkhash:8].js\"\n    },\n    plugins:[\n        new webpack.optimize.CommonsChunkPlugin({\n            name: \"common\",\n        }),\n    ]\n};\n\n```\n\n如上图，修改`filename:[name].[chunkhash:8]/js`\n\n执行webpack\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663691205305~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n可以看到这一次生成的hash是4897....\n\n但是输出的每个文件的hash却不是4897....\n\n很好，接下来再执行一次webpack：\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636947674a1~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n可以看到两次输出之间hash并没有发生变化\n\n现在，修改one.js,再执行webapck\n\n```\nimport jquery from 'jquery';\nconsole.log('使用chunkhash后修改one');\n\n```\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663694c7dc37~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n可以看到two.js的hash没有改变one.js的hash改变了，但common.js的hash竟然也改了...\n\n## 4，提取manifest\n\n前面用CommonsChunkPlugin提取代码后，公共的代码已经被抽离，但是他们之间肯定存在一个映射关系,例如\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663699342c1a~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n之所以commonjs的hash会变，是因为修改one.js生成了新的hash，而jquery又与one.js存在映射关系，`映射关系会更新`，也就是说common.js它要从新的one.js中提取了jquery\n\n而`manifest`就可以简单理解为模块映射关系的集合，而这个manifest将随着这些被分离出来的代码共同打包！！！\n\n所以现在分离manifest\n\n```\nvar webpack = require(\"webpack\");\nvar path = require('path');\nmodule.exports = {\n    entry: {\n        one: \"./src/one.js\",\n        two: \"./src/two.js\"\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: \"[name].[chunkhash:8].js\"\n    },\n    plugins:[\n        new webpack.optimize.CommonsChunkPlugin({\n            name: \"common\",\n        }),\n        new webpack.optimize.CommonsChunkPlugin({\n            name: 'manifest' // 用于提取manifest\n        })\n    ]\n};\n\n```\n\n这里主要是利用CommonsChunkPlugin的一个功能，通过默认的名字，来提取公共代码，因为webpack打包的是有有一个默认模块就是manifest，所以我们可以通过这个来实现\n\n现在我们执行webpack：\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663697055890~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n可以看到，多输出了一个manifest.js\n\n接下来，再修改one.js\n\n```\nimport jquery from 'jquery';\nconsole.log('分离manifest后修改one');\n\n```\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636b58469af~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n可以看到，现在只有one.js和manifest.js的hash发生了改变，common.js被成功缓存了\n\n使用代码对比工具，比较两次manifest之间的区别，可以看到确实是映射的chunkid发生了改变\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636ba6f6614~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n## 5，使用webpack-md5-hash插件\n\n前面我们输出了一个manifest.js，但这样还需要单独处理这个manifest.js，所以可以使用webpack的另一个插件webpack-md5-hash\n\n```\nvar webpack = require(\"webpack\");\nvar WebpackMd5Hash = require('webpack-md5-hash');\nvar path = require('path');\nmodule.exports = {\n    entry: {\n        one: \"./src/one.js\",\n        two: \"./src/two.js\"\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: \"[name].[chunkhash:8].js\"\n    },\n    plugins:[\n        new WebpackMd5Hash(),\n        new webpack.optimize.CommonsChunkPlugin({\n            name: \"common\",\n        }),\n    ]\n};\n\n\n```\n\n执行一次打包：\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636bab5627e~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n没有manifest输出，修改one.js\n\n```\nimport jquery from 'jquery';\nconsole.log('使用WebpackMd5Hash修改one');\n\n```\n\n再次打包：\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636bb68ae2e~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n这一次仅有one.js的hash发生了改变\n\n虽然webpack-md5-hash解决了我们的问题，但这也让打包的模块关系变成了黑盒，存在一定的未知风险，还需要仔细实践评估是否有问题\n\n## 6，打包修改频率超级低的库\n\n前面已经抽离出来了公共代码，但是还存在问题，假如这时候又需要引入lodash，那common的hash是否会改变？\n\n修改one.js\n\n```\nimport jquery from 'jquery';\nimport lodash from 'lodash';\nconsole.log('引入lodash修改one');\n\n```\n\n修改two.js\n\n```\nimport jquery from 'jquery';\nimport lodash from 'lodash';\nconsole.log('引入lodash修改two');\n\n```\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636c2194058~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n这一次，所有文件的hash都发生了改变，不仅如此，而且更显著的是common的体积增大了\n\n这就意味者lodash也被打进了common当中，但这本身是一个错误的行为，lodash和jquery，平时根本不会对其进行修改，既然如此，那还需要优化，把他们单独打包出去\n\n现在修改webapack.config.js\n\n```\nvar webpack = require(\"webpack\");\nvar WebpackMd5Hash = require('webpack-md5-hash');\nvar path = require('path');\nmodule.exports = {\n    entry: {\n        two: \"./src/two.js\",\n        one: \"./src/one.js\",\n        common:['jquery','lodash']\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: \"[name].[chunkhash:8].js\"\n    },\n    plugins:[\n        new WebpackMd5Hash(),\n        new webpack.optimize.CommonsChunkPlugin({\n            name: \"common\",\n        }),\n    ]\n};\n\n```\n\n这一次在入口处添加了一个common，common单独指向了jquery和lodash，这一次我们执行打包\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636e2efa2c9~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n此时，输出的内容没有明显变化，同样是3个文件,大小也完全一致，hash也没有问题\n\n可以看到，common的大小是817k\n\n如果这时，再应用了其他的包呢？例如引入react\n\n修改one.js\n\n```\nimport jquery from 'jquery';\nimport lodash from 'lodash';\nimport react from 'react';\nconsole.log('引入react修改one');\n\n```\n\n修改two.js\n\n```\nimport jquery from 'jquery';\nimport lodash from 'lodash';\nimport react from 'react';\nconsole.log('引入react修改one');\n\n```\n\n执行webpack\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636c3a62be8~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n问题来了，common的大小增加了，很显然react被打包进去了，但如果我们此时，只想永久缓存jquery和lodash呢，这该怎么办？\n\n修改webpack.config.js\n\n```\nvar webpack = require(\"webpack\");\nvar WebpackMd5Hash = require('webpack-md5-hash');\nvar path = require('path');\nmodule.exports = {\n    entry: {\n        two: \"./src/two.js\",\n        one: \"./src/one.js\",\n        common:['jquery','lodash']\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: \"[name].[chunkhash:8].js\"\n    },\n    plugins:[\n        new WebpackMd5Hash(),\n        new webpack.optimize.CommonsChunkPlugin({\n            name: 'common',\n            minChunks:Infinity\n        })\n    ]\n};\n\n```\n\n这一次，添加了一句话`minChunks:Infinity`\n\nminChunks属性的可以设置为2，意思是引用次数为2的模块就抽离出来，而`Infinity`则表示无限，无限就意味着不会有多余的被打包进来\n\n现在执行webpack打包\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636e2fe6346~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n可以看到现在common又恢复了816k，当然react也没有抽出来，还在两个文件当中，接下来继续抽离react\n\n```\nvar webpack = require(\"webpack\");\nvar WebpackMd5Hash = require('webpack-md5-hash');\nvar path = require('path');\nmodule.exports = {\n    entry: {\n        two: \"./src/two.js\",\n        one: \"./src/one.js\",\n        common:['jquery','lodash'],\n        react:['react','react-redux']\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: \"[name].[chunkhash:8].js\"\n    },\n    plugins:[\n        new webpack.optimize.CommonsChunkPlugin({\n            name: ['react','common'], // 用于提取manifest\n            minChunks:Infinity\n        }),\n        new WebpackMd5Hash(),\n    ]\n};\n\n```\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636e5784bd6~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n通过上面的构建，我们已经将不会改动的类库，单独打包并维持住了hash。\n\n## 7，引入HashedModuleIdsPlugin固定模块id\n\n前面看似完美，但如果我们现在改变一下入口的顺序\n\n```\nentry: {\n    react:['react','react-redux'],        \n    two: \"./src/two.js\",\n    one: \"./src/one.js\",\n    common:['jquery','lodash'],        \n}\n\n```\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636ebc1fed5~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n可以看到common和react公共库的hash又变了，这是因为，模块id是根据webpack的解析顺序增量的，如果变换解析顺序，那模块id也会随之改变。\n\n所以就需要HashedModuleIdsPlugin了，它是根据模块相对路径生成模块标识，如果模块没有改变，那模块标识也不会改变\n\n```\nvar webpack = require(\"webpack\");\nvar WebpackMd5Hash = require('webpack-md5-hash');\nvar path = require('path');\nmodule.exports = {\n    entry: {\n        common:['jquery','lodash'],                \n        react:['react','react-redux'],        \n        two: \"./src/two.js\",\n        one: \"./src/one.js\",\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: \"[name].[chunkhash:8].js\"\n    },\n    plugins:[\n        new webpack.optimize.CommonsChunkPlugin({\n            name: ['react','common'], // 用于提取manifest\n            minChunks:Infinity\n        }),\n        new webpack.HashedModuleIdsPlugin(),\n        new WebpackMd5Hash(),\n    ]\n};\n\n```\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116636eded9e7d~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n现在打包后，模块的标识不再是id了，而是一个四位的编码了，这样就可以固定住ip地址了。\n\n## 8，使用extract-text-webpack-plugin提取css文件\n\n在src下创建one.css:\n\n```\nbody{\n    color:blue;\n}\n\n```\n\ntwo.css\n\n```\nh1{\n    font-size:24px;\n}\n\n```\n\n修改one.js和two.js引入css\n\n```\nimport jquery from 'jquery';\nimport lodash from 'lodash';\nimport react from 'react';\nimport './one.css'\nconsole.log('引入css修改one');\n\n```\n\n修改webpack.config.js\n\n```\nvar webpack = require(\"webpack\");\nvar WebpackMd5Hash = require('webpack-md5-hash');\nvar path = require('path');\nvar ExtractTextPlugin = require(\"extract-text-webpack-plugin\");\nmodule.exports = {\n    entry: {\n        common: ['jquery', 'lodash'],\n        react: ['react', 'react-redux'],\n        two: \"./src/two.js\",\n        one: \"./src/one.js\",\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: \"[name].[chunkhash:8].js\"\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,\n                use: ExtractTextPlugin.extract({\n                    fallback: \"style-loader\",\n                    use: \"css-loader\"\n                })\n            }\n        ]\n    },\n    plugins: [\n        new webpack.optimize.CommonsChunkPlugin({\n            name: ['react', 'common'], // 用于提取manifest\n            minChunks: Infinity\n        }),\n        new ExtractTextPlugin(\"[name].[chunkhash:8].css\"),\n        new webpack.HashedModuleIdsPlugin(),\n        new WebpackMd5Hash()\n    ]\n};\n\n```\n\n执行webpack：\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/161166370b90f78c~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n可以看到，成功输出了js和css，但是有点疑问的是，one.css和one.js的hash是一样的，这样的话，如果我们改变one.css呢？\n\n修改one.css,再次打包：\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/161166370b8bb338~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n发现css的hash没有任何变化。\n\n接着再修改one.js,再次打包：\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663711ccaa40~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n这一次one.js和one.css的hash同时改变了。\n\n## 9，使用contenthash提取固定css的hash\n\n- When using the ExtractTextWebpackPlugin, use [contenthash] to obtain a hash of the extracted file (neither [hash] nor [chunkhash] work).\n\nwebpack output文档种有写，当提取css后，用contenthash添加hash\n\n```\nvar webpack = require(\"webpack\");\nvar WebpackMd5Hash = require('webpack-md5-hash');\nvar path = require('path');\nvar ExtractTextPlugin = require(\"extract-text-webpack-plugin\");\nmodule.exports = {\n    entry: {\n        common: ['jquery', 'lodash'],\n        react: ['react', 'react-redux'],\n        two: \"./src/two.js\",\n        one: \"./src/one.js\",\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: \"[name].[chunkhash:8].js\"\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,\n                use: ExtractTextPlugin.extract({\n                    fallback: \"style-loader\",\n                    use: \"css-loader\"\n                })\n            }\n        ]\n    },\n    plugins: [\n        new webpack.optimize.CommonsChunkPlugin({\n            name: ['react', 'common'], // 用于提取manifest\n            minChunks: Infinity\n        }),\n        new ExtractTextPlugin(\"[name].[contenthash:8].css\"),\n        new webpack.HashedModuleIdsPlugin(),\n        new WebpackMd5Hash()\n    ]\n};\n\n```\n\n这一次，只是修改了输出的hash，conenthash代表的是文本文件内容的hash值，也就是只有style文件的hash值。\n\n执行webpack：\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/161166372478e5cd~tplv-t2oaga2asx-watermark.awebp)\n\n\n\none.js和one.css的hash变的不一样了\n\n接下来，修改one.css\n\n```\nbody{\n    color:white;\n}\n\n```\n\n再次执行webpack：\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663729fbfe0f~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n至此，只有one.css发生了变化，准备工作基本就到这里了\n\n# 四，优化多页打包时间，稳定hash\n\n## 1,约束入口\n\n因为是多页应用，是通过扫入口文件来进行的打包，规则为js文件为入口文件，jsx为引用的资源不被识别为入口\n\n通过BundleAnalyzerPlugin插件分析，发现有部分组件被打包为了入口，梳理一遍后，重新打包，打包时间减少了2/3，当然这是在填以前的坑\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663733a477b4~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n生产打包时间是`74578ms`\n\n此时压缩和不压缩的打包时间也是3倍的关系：\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116637345283b8~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n开发打包时间是`24780ms`\n\n好的，围绕这两个时间，我们开始优化\n\n## 2,使用UglifyjsWebpackPlugin开启多线程打包\n\n首先要做的其实是稳定hash，但因为生产环境的打包速度太慢，所以我们先优化打包速度，webpack默认提供的打包是单线程的\n\n```\nconst UglifyJSPlugin = require('uglifyjs-webpack-plugin')\n\nmodule.exports = {\n  plugins: [\n    new UglifyJSPlugin({\n        parallel: true\n    })\n  ]\n}\n\n```\n\n这个插件是webpack3提供的，至于低版本webapck的话，需要谨慎处理，不过效果很明显\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663733b6ac46~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n现在生产打包时间是`51690ms`，比之前提速了1/3\n\n## 3,使用HappyPack多线程加速loader\n\n```\nvar HappyPack = require('happypack');\nvar os = require('os');\nvar happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length });\n\n...\nmodule: {\n        rules: [ {\n            test: /\\.js[x]?$/,\n            exclude: /(node_modules|bower_components)/,\n            loader: 'happypack/loader?id=happybabel',\n            include: path.join(__dirname, 'static/assets/js')\n        }\n    }\nplugins: [\n        new HappyPack({\n            id: 'happybabel',\n            loaders: ['babel-loader?cacheDirectory=true'],\n            threadPool: happyThreadPool,\n            cache: true,\n            verbose: true\n          }),\n\n```\n\n上面module的rules属性中loader原本事babel-loader，现在将它变成了一个任务，其中有一个id，id对应的就是plugins中的happyPack实例\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/161166373db390c7~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n此时，我们开启了babel-loader的多线程模式\n\n现在生产打包时间是`43855ms`，比之前又提速了1/9，这只是babel-loader，我们还可以为其它的loader开启\n\n接着处理less,css,style等loader，这些结合可以一口气搞定\n\n```\n    module: {\n        rules: [{\n            test: require.resolve('zepto'),\n            loader: 'exports-loader?window.Zepto!script-loader'\n        }, {\n            test: /\\.js[x]?$/,\n            exclude: /(node_modules|bower_components)/,\n            loader: 'happypack/loader?id=happybabel',\n            include: path.join(__dirname, 'static/assets/js')\n        }, {\n            test: /\\.less$/,\n            use: extractTextPlugin.extract({\n                fallback: \"style-loader\",\n                // use: [\"css-loader\" + (ENV ? '?minimize' : ''), \"less-loader\", \"postcss-loader\"]\n                use: [\"happypack/loader?id=postcss\"]\n            })\n        }]\n    }\nplugins: [\n        new HappyPack({\n            id: 'happybabel',\n            loaders: ['babel-loader?cacheDirectory=true'],\n            threadPool: happyThreadPool,\n            // cache: true,\n            verbose: true\n        }),\n        new HappyPack({\n            id: 'postcss',\n            loaders: [\"css-loader\" + (ENV ? '?minimize' : ''), \"less-loader\",'postcss-loader'],\n            threadPool: happyThreadPool,\n            // cache: true,\n            verbose: true\n        }),\n\n```\n\n这样，我们即处理了babel，同时也搞定了css，less，postcss这些loader\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663756ba4bc1~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n上图happy[任务名]，可以看到打包行为全都开启了多线程，效果显著\n\n现在生产打包时间是`35130ms`，此时已经比第一此非优化的时候，提升了一倍的速度\n\n## 4,使用dll拆分代码\n\n经过前面的过程，想必已经意识到了纯静态得库和组件都需要与打包环节分离开，这就需要dll技术了\n\ndll技术，其实就是将修改频率低或基本不修改且引用次数多的内容，单独打包\n\n因为设计dll后，config文件的数量剧增，所以需要重新整理目录结构\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116637542b3379~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n例如上图，将每一个webpack拆分出去，把所有配置文件分离开,例webpack.dev.js：\n\n```\nvar base = require('./webpack.base.js');\nvar config = {\n    entry: require('./dev/entry.js'),\n    output: require('./dev/output.js'),\n    plugins: require('./dev/plugins.js'),\n    devtool: 'eval-source-map'\n}\n//把配置文件暴露出去;\nmodule.exports = Object.assign(base,config);\n\n\n```\n\nok，基础拆分webpack完成后，我们创建一个webpack.dll.libs.js用于打包类库\n\n```\nmodule.exports = {\n    libs: [\n        'react',\n        'react-dom',\n        'react-motion',\n        'react-redux',\n        'redux',\n        'axios',\n        'prop-types',\n        'classnames',\n    ]\n}\n\n```\n\n修改plugins插件：\n\n```\nvar webpack = require('webpack');\nvar dirVars = require('../common/dir.js');\nvar path = require('path');\nvar UglifyJsPlugin = require('uglifyjs-webpack-plugin');//多线程打包\nvar getDefaultPlugins = require('../common/plugins.js').getDefaultPlugins;\nvar AssetsPlugin = require('assets-webpack-plugin');//输出映射表\n\nvar plugins =[\n    new webpack.DllPlugin({\n        path: dirVars.dllLibsManiFest,\n    }),\n    new UglifyJsPlugin({\n        parallel: true,\n        cache: true\n    }),\n    new AssetsPlugin({\n        filename: 'static/dll/libs-rev-manifest.json'\n    }),\n]\nmodule.exports = plugins.concat(getDefaultPlugins())\n\n```\n\n现在执行webpack\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663758664541~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n可以看到，只需要1s,就打包了所有的类库，接下来，修改webpack.prod.js\n\n在plugins中添加：\n\n```\nnew webpack.DllReferencePlugin({\n    manifest: 'static/dll/libs-rev-manifest.json'\n}),\n\n```\n\n此时当我们执行webpack.prod.js进行打包，当扫描到libs中的打包的内容时，就不会重复打包\n\n## 4,开始继续约束hash\n\n前面已经彻底搞定了打包，但破坏性很大，所以需要系统的验证hash是否存在问题\n\n**case1:\bjs改变**\n\n修改一个业务代码的js，添加一句注释，再次打包\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116637604c3f7c~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n可以看到文件hash发生了改变，但很不幸，vendor也发生了改变\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/161166377da4882b~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n**解决方案：添加webpack-md5-hash插件，使用之后，再次验证，发现vendorjs的hash不再发生变化**\n\n**case2:\bless改变**\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/161166376469ca3c~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n只有一个css的hash发生了变化，没问题\n\n**case3:修改一个入口下自己封装出去的公共方法**\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116637823fba5f~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n上面修改了一个入口内公共使用的tools插件，最终是入口的hash发生了改变，没问题\n\n**case4:修改公共方法组件js**\n\n主要是多个入口都会引用的组件\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611663786a27fcb~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n测试，只有单独打包出去的components的hash修改了\n\n**case5:修改公共方法组件less**\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/16116637a2d0f998~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n只有一个hash发生了改变\n\n**case6:添加一个公共组件**\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/161166378919dc87~tplv-t2oaga2asx-watermark.awebp)\n\n\n\n只有components的hash发生了改变\n\n未优化前打包时间180-200s\n\n优化：\n\n```\n1，约束入口，严格明确入口文件筛选条件后\n    生产打包：74578ms\n    开发打包：24780ms\n2，开启多线程压缩后\n    生产打包：51690ms\n3，开启多线程编译\n    生产打包：35130ms\n    开发打包：15031ms\n4，拆包\n    分解了打包过程，类库4s，组件4s，业务20s，总体30s左右\n\n```\n\n最终，流程变得可控，打包实现了定制化，hash得到了保持。","children":[]}]},{"name":"代码类型检查","path":"../guanruihua.github.io/Front-End/项目搭建","data":"","children":[{"name":"eslint.md","path":"../guanruihua.github.io/Front-End/项目搭建/代码类型检查","data":"# ESLint\n\n> [rules](http://eslint.cn/docs/rules/)\n> <https://juejin.cn/post/6955025103507849223>\n>\n> - root - 限定配置文件的使用范围\n> - parser - 指定eslint的解析器\n> - parserOptions - 设置解析器选项\n> - extends - 指定eslint规范\n> - plugins - 引用第三方的插件\n> - env - 指定代码运行的宿主环境\n> - rules - 启用额外的规则或覆盖默认的规则\n> - globals - 声明在代码中的自定义全局变量\n\n## 取消格式检查\n\n> 单行, 行末 添加 `// eslint-disable-line`\n> 单行指定忽略规则, 行末 添加 `// eslint-disable-line [这里添加规则(不用括号)]`\n> 单文件, 首行 添加 `/* eslint-disable */`\n> 单文件指定忽略规则, 首行 添加 `/* eslint-disable [这里添加规则(不用括号)] */`\n","children":[]},{"name":"prettierc.md","path":"../guanruihua.github.io/Front-End/项目搭建/代码类型检查","data":"# prettierc\n\n> [Options · Prettier](https://prettier.io/docs/en/options.html)\n> .prettierrc\n\n```json\n{\n \"printWidth\": 100, // 单行长度\n \"tabWidth\": 2,  // tab用两个空格替代\n \"useTabs\": false, // 使用空格代替tab\n \"semi\": false, // 不使用;\n \"singleQuote\": true, // 使用单双引号\n \"bracketSpacing\": true, // jsx标签闭合位置, 不开新一行\n \"jsxSingleQuote\": true, // jsx使用单引号\n \"htmlWhitespaceSensitivity\": \"ignore\", // 忽略无效的空格\n \"endOfLine\": \"auto\", // 保持现有换行\n \"trailingComma\": \"none\", // key和value到花括号之间有空格\n \"arrowParens\": \"avoid\" // 箭头函数括号可以省略的, 都省略\n}\n```\n","children":[]},{"name":"tslint.md","path":"../guanruihua.github.io/Front-End/项目搭建/代码类型检查","data":"# TSLint\n\n> 已经弃用, 建议使用eslint\n\n## 准备工作\n\n```shell\nnpm uninstall -g typescript\nnpm install -g typescript tslint\ntslint --init\ntslint --project\n```\n\n## 配置\n\n```js\n{\n defaultSeverity: error,\n extends: [\n  tslint:recommended\n ],\n rules: {\n  member-access: true, // 设置成员对象的访问权限&#xff08;public,private,protect)\n  member-ordering: [// 设置修饰符顺序\n    true,\n    {\n      order: [ \n        public-static-field,\n        public-static-method,\n        protected-static-field,\n        protected-static-method,\n        private-static-field,\n        private-static-method,\n        public-instance-field,\n        protected-instance-field,\n        private-instance-field,\n        public-constructor,\n        protected-constructor,\n        private-constructor,\n        public-instance-method,\n        protected-instance-method,\n        private-instance-method\n      ]\n    }\n  ],\n        // no-empty-interface:true,// 不允许空接口\n        no-parameter-reassignment:false,// 不允许修改方法输入参数\n        prefer-for-of:true,// 如果for循环中没有使用索引&#xff0c;建议是使用for-of\n\n        // 功能特性\n        no-namespace:false,\n        only-arrow-functions:false, //禁止使用传统&#xff08;非箭头&#xff09;函数表达式\n        no-shadowed-variable: true, // 不允许子作用域与外层作用域声明同名变量\n        no-string-literal:false,\n        ban-types: false,// 禁止内置原始类型\n        await-promise:true,// 不允许没有Promise的情况下使用await\n        curly:true,// if/for/do/while强制使用大括号\n        forin:false,// 使用for in语句时&#xff0c;强制进行hasOwnProperty检查\n        no-arg:true,// 不允许使用arguments.callee\n        no-bitwise:false, // 不允许使用特殊运算符 &amp;, &amp;&#61;, |, |&#61;, ^, ^&#61;, &lt;&lt;, &lt;&lt;&#61;, &gt;&gt;, &gt;&gt;&#61;, &gt;&gt;&gt;, &gt;&gt;&gt;&#61;, ~\n        no-conditional-assignment:true,// do while/for/if/while 语句中将会对例如if(a&#61;b)进行检查\n        no-console:true,// 不允许使用console对象\n        no-debugger:true,// 不允许使用debugger\n        no-duplicate-super:true,// 不允许super() 两次使用在构造函数中\n        no-empty:false,// 函数体不允许空\n        no-eval:true,// 不允许使用eval\n        no-for-in-array:true,// 不允许对Array使用for-in\n        no-invalid-template-strings:true,// 只允许在模板字符串中使用${\n        // no-invalid-this:true,// 不允许在class之外使用this\n        // no-null-keyword:true,// 不允许使用null,使用undefined代替null&#xff0c;指代空指针对象\n        no-sparse-arrays:true,// 不允许array中有空元素\n        no-string-throw:true,// 不允许throw一个字符串\n        no-switch-case-fall-through:true,// 不允许case段落中在没有使用breack的情况下&#xff0c;在新启一段case逻辑\n        no-unsafe-finally:true,// 不允许在finally语句中使用return/continue/break/throw\n        no-unused-expression:true,// 不允许使用未使用的表达式\n        no-use-before-declare:true,// 在使用前必须声明\n        no-var-keyword:true,// 不允许使用var\n        radix:false,// parseInt时&#xff0c;必须输入radix精度参数\n        // restrict-plus-operands:true,// 不允许自动类型转换&#xff0c;如果已设置不允许使用关键字var该设置无效\n        triple-equals:false,// 必须使用恒等号&#xff0c;进行等于比较\n        use-isnan:true,// 只允许使用isNaN方法检查数字是否有效\n\n        // 维护性功能\n        indent:[true, spaces, 4],// 每行开始以4个空格符开始\n        max-classes-per-file:[true,1],// 每个文件中可定义类的个数\n        max-file-line-count:[true,1000],// 定义每个文件代码行数\n        max-line-length:[true,300],// 定义每行代码数\n        no-default-export:true,// 禁止使用export default关键字&#xff0c;因为当export对象名称发生变化时&#xff0c;需要修改import中的对象名。https://github.com/palantir/tslint/issues/1182#issue-151780453\n        no-duplicate-imports:true,// 禁止在一个文件内&#xff0c;多次引用同一module\n\n        // 格式\n        align:[true,parameters,arguments,statements,members,elements],// 定义对齐风格\n        array-type:[true,array],// 建议使用T[]方式声明一个数组对象\n        class-name:false,// 类名以大驼峰格式命名\n        comment-format:[true, check-space],// 定义注释格式\n        encoding:false,// 定义编码格式默认utf-8\n        import-spacing:true,// import关键字后加空格\n        interface-name:[true,always-prefix],// interface必须以I开头\n        jsdoc-format:false,// 注释基于jsdoc风格\n        new-parens:true,// 调用构造函数时需要用括号\n        object-literal-sort-keys:false,\n        no-consecutive-blank-lines:[true,2],// 不允许有空行\n        // no-trailing-whitespace: [// 不允许空格结尾\n        //     true,\n        //     ignore-comments,\n        //     ignore-jsdoc\n        // ],\n        no-unnecessary-initializer:true,// 不允许没有必要的初始化\n  variable-name:[\n     false, check-format,// 定义变量命名规则\n  allow-leading-underscore,\n  allow-trailing-underscore,\n  ban-keywords\n      ]\n    },\n rulesDirectory: [],\n linterOptions: {\n  exclude: [\n   e2e/**/*\n  ]\n }\n}\n```\n","children":[]}]},{"name":"提交前置","path":"../guanruihua.github.io/Front-End/项目搭建","data":"","children":[{"name":"commitlint.md","path":"../guanruihua.github.io/Front-End/项目搭建/提交前置","data":"# commitlint\n\n> 约定式提交规范是一种基于提交信息的轻量级约定。\n> <https://www.conventionalcommits.org/zh-hans/v1.0.0/>\n","children":[]},{"name":"husky.md","path":"../guanruihua.github.io/Front-End/项目搭建/提交前置","data":"# husky\r\n\r\n## 效果\r\n\r\n### 正确提交 `git commit -m \"refactor: 描述\"`\r\n\r\n> `refactor`: 提交类型, 由[`commitlint.config.js`](#commitlint.config.js)配置\r\n\r\n### 错误提交 `git commit -m \"测试提交\"`\r\n\r\n![](./__assets__/husky-2022-11-02-14-59-06.png)\r\n\r\n## 安装\r\n\r\n```bash\r\nnpm install -D husky\r\nnpm install -D commitlint\r\nnpm install -D @commitlint/config-conventional\r\n```\r\n\r\n## 设置git hooks\r\n\r\n> 在 `package.json` 添加\r\n\r\n```jsonc\r\n{\r\n  \"scripts\": {\r\n  // add\r\n   \"commitlint\": \"commitlint -e\",\r\n   \"prepare\": \"husky install\"\r\n  },\r\n // add\r\n  \"husky\": {\r\n    \"hooks\": {\r\n      \"commit-msg\": \"commitlint -e $HUSKY_GIT_PARAMS\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n```shell\r\n# 生成.husky\r\nnpm run prepare\r\n```\r\n\r\n## 配置相关文件\r\n\r\n`.husky/commit-msg`\r\n\r\n```sh\r\n#!/usr/bin/env sh\r\n. \"$(dirname -- \"$0\")/_/husky.sh\"\r\n\r\nnpm run commitlint --edit $1\r\n```\r\n\r\n<code id=\"commitlint.config.js\">./commitlint.config.js</code>\r\n\r\n> [@commitlint/config-conventional](https://www.npmjs.com/package/@commitlint/config-conventional)\r\n\r\n```js\r\nmodule.exports = {\r\n  extends: ['@commitlint/config-conventional'],\r\n  rules: {\r\n    'type-enum': [\r\n      2,\r\n      'always',\r\n      [\r\n        'bug', // 此项特别针对bug号，用于向测试反馈bug列表的bug修改情况\r\n        'feat', // 新功能（feature）\r\n        'fix', // 修补bug\r\n        'docs', // 文档（documentation）\r\n        'style', // 格式（不影响代码运行的变动）\r\n        'refactor', // 重构（即不是新增功能，也不是修改bug的代码变动）\r\n        'test', // 增加测试\r\n        'chore', // 构建过程或辅助工具的变动\r\n        'revert', // feat(pencil): add ‘graphiteWidth’ option (撤销之前的commit)\r\n        'merge' // 合并分支， 例如： merge（前端页面）： feature-xxxx修改线程地址\r\n      ]\r\n    ]\r\n  }\r\n}\r\n```\r\n","children":[]}]},{"name":"案例.md","path":"../guanruihua.github.io/Front-End/项目搭建","data":"# 案例\n\n> [ts + rollup 搭建工具库](https://juejin.cn/post/6844904035309322254)\n","children":[]}]}]},{"name":"HTML","path":"../guanruihua.github.io","data":"","children":[{"name":"canvas","path":"../guanruihua.github.io/HTML","data":"","children":[{"name":"canvas.md","path":"../guanruihua.github.io/HTML/canvas","data":"# canvas\n\n> [Canvas API](https://www.canvasapi.cn/CanvasRenderingContext2D/arc#&introduction)\n> [Canvas - Web API 接口参考 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API)\n>\n> - 用于绘制图像, 通常用javascript绘制\n\n## canvas基本使用\n\n### canvas表示使用\n\n```html\n<canvas width=\"300\" height=\"150\">\n 不支持canvas标签会显示该内容\n</canvas>\n```\n\n### canvas方法检查支持性\n\n```js\nvar canvas = document.getElementById(\"target\")\nif ( canvas.getContext ) {\n  var ctx = canvas.getContext(\"2d\")\n}else{\n  console.log(\"该浏览器版本过低, 请更换\")\n}\n```\n\n## 样式添加\n\n```js\nfillStyle = color\nstrokeStyle = color \n//color 可以为颜色值、渐变对象(并非样式！！！！)\nlineWidth  = value  线宽\nlineCap = type （butt 、 round 、square）线条末端样式   依次是方形、圆形&突出、方形&突出\n```\n\n![canvas8](https://user-gold-cdn.xitu.io/2018/11/26/1674efc200a1fb4e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n```\nlineJoin = type （round 、bevel 、 miter）线条交汇处样式 依次是圆形、平角 、 三角形\n```\n\n![canvas9](https://user-gold-cdn.xitu.io/2018/11/26/1674efc203135b97?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n```\nctx.setLineDash([ 实际长度 , 间隙长度 ]) //虚线 setLineDash接受数组\nctx.lineDashOffet  //设置偏移量\n```\n\n### 渐变\n\n```\nvar gradient = ctx.createLinearGradient( x1 ,y1 ,x2 ,y2); //线性渐变\nvar gradient = ctx.createRadialGradient(x1 ,y1 ,r1 ,x2 ,y2 ,r2);//径向渐变\ngradient.addColorStop( position , color )// position:相对位置0~1    color:该位置下的颜色\n```\n\n### 透明度\n\n```\nctx.globalAlpha = value (0~1)\n```\n\n## 文本\n\n```\nfillText( text , x , y , [,maxWidth]) 在(x,y)位置绘制text文本  最大宽度为maxWidth(可选)\nstrokeText( text ,x ,y ,[,maxWidth]) 在(x,y)位置绘制text文本边框  最大宽度为maxWidth(可选)\n\nfont = value               eg:\"100px sans-serif\"  \n```\n\n## 绘制图片\n\n```\ndrawImage( image , x , y , width , height ) image为图片对象、从(x,y)处放置宽高分别为width height的图片\ndrawImage( image , sx , sy , swidth , sheight ,dx ,dy ,dwidth ,dheight) 切片前四个是定义图像源的切片位置和大小   后四个是定期切片的目标显示位置大小\n```\n\n## 动作\n\n```\ntranslate( x , y ) 将canvas原点的移动到 (x,y)     （save&restore保存初始状态！！！）\n\nrotate( angle ) 顺时针方向旋转坐标轴 angle弧度\n\nscale(x,y) 将图形横向缩放x倍、纵向缩放y倍   （ x、y大于1是放大  小于1为缩放！！！）\n```\n\n## 全局合成操作\n\nglobalCompositeOperation = type;\n\nsource-over\n\n<img src=\"https://user-gold-cdn.xitu.io/2018/11/26/1674efc2202ba9d7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"canvas11\" style=\"zoom:50%;\" />\n\nsource-in\n\n<img src=\"https://user-gold-cdn.xitu.io/2018/11/26/1674efc231836ca4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"canvas12\" style=\"zoom:50%;\" />\n\nsource-out\n\n<img src=\"https://user-gold-cdn.xitu.io/2018/11/26/1674efc230f9efee?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"canvas13\" style=\"zoom:50%;\" />\n\nsource-atop\n\n<img src=\"https://user-gold-cdn.xitu.io/2018/11/26/1674efc22fd95ad9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"canvas14\" style=\"zoom:50%;\" />\n\ndestination-over\n\n<img src=\"https://user-gold-cdn.xitu.io/2018/11/26/1674efc24023b46d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"canvas15\" style=\"zoom:50%;\" />\n\ndestination-in\n\n<img src=\"https://user-gold-cdn.xitu.io/2018/11/26/1674efc24bb0268a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"canvas16\" style=\"zoom:50%;\" />\n\ndestination-out\n\n<img src=\"https://user-gold-cdn.xitu.io/2018/11/26/1674efc257a9972a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"canvas17\" style=\"zoom:50%;\" />\n\ndestination-atop\n\n<img src=\"https://user-gold-cdn.xitu.io/2018/11/26/1674efc257bf9efd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"canvas18\" style=\"zoom:50%;\" />\n\nxor\n\n<img src=\"https://user-gold-cdn.xitu.io/2018/11/26/1674efc27398ea8a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"canvas19\" style=\"zoom:50%;\" />\n\ncopy\n\n<img src=\"https://user-gold-cdn.xitu.io/2018/11/26/1674efc272df1d1e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"canvas20\" style=\"zoom:50%;\" />\n\n## 裁剪\n\n```\nclip //只显示裁剪区域内部区域  (使用save & restore 存储canvas状态！！！)\n\n```\n\n## 动画\n\n```\nclearRect() 清空画布\n\nsave&restore 保存恢复canvas状态\n\n```\n\n## 定时执行\n\n- setInterval()\n- setTimeout()\n- requestAnimationFrame()\n","children":[]},{"name":"Demo","path":"../guanruihua.github.io/HTML/canvas","data":"","children":[{"name":"canvas转图片下载.md","path":"../guanruihua.github.io/HTML/canvas/Demo","data":"# Canvas转图片并下载\r\n\r\n> 临时保存, 后面再记录\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n <meta charset=\"UTF-8\">\r\n <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/rh-static@0.0.1/css/test-body.css\">\r\n <title>index</title>\r\n</head>\r\n\r\n<style>\r\n\r\n</style>\r\n\r\n<body>\r\n <canvas id=\"canvas\"></canvas>\r\n <button class=\"button-balanced\" id=\"save\" onclick=\"btnClick()\">save</button>\r\n <br />\r\n <a href=\"\" download=\"canvas_love.png\" id=\"save_href\">\r\n  <img src=\"\" id=\"save_img\" />\r\n </a>\r\n <script src=\"https://cdn.jsdelivr.net/npm/rh-static@0.0.1/js/addWindowSize.js\" defer></script>\r\n <script>\r\n  var c = document.getElementById(\"canvas\");\r\n  function drawLove(canvas) {\r\n   let ctx = canvas.getContext(\"2d\");\r\n   ctx.beginPath();\r\n   ctx.fillStyle = \"#E992B9\";\r\n   ctx.moveTo(75, 40);\r\n   ctx.bezierCurveTo(75, 37, 70, 25, 50, 25);\r\n   ctx.bezierCurveTo(20, 25, 20, 62.5, 20, 62.5);\r\n   ctx.bezierCurveTo(20, 80, 40, 102, 75, 120);\r\n   ctx.bezierCurveTo(110, 102, 130, 80, 130, 62.5);\r\n   ctx.bezierCurveTo(130, 62.5, 130, 25, 100, 25);\r\n   ctx.bezierCurveTo(85, 25, 75, 37, 75, 40);\r\n   ctx.fill();\r\n  }\r\n  drawLove(c);\r\n\r\n  function downLoad(url) {\r\n   var oA = document.createElement(\"a\");\r\n   oA.download = '';// 设置下载的文件名，默认是'下载'\r\n   oA.href = url;\r\n   document.body.appendChild(oA);\r\n   oA.click();\r\n   oA.remove(); // 下载之后把创建的元素删除\r\n  }\r\n\r\n  var butSave = document.getElementById(\"save\");\r\n  function btnClick() {\r\n   var svaeHref = document.getElementById(\"save_href\");\r\n   /*\r\n    * 传入对应想要保存的图片格式的mime类型\r\n    * 常见：image/png，image/gif, image/jpg, image/jpeg\r\n    */\r\n   var img = document.getElementById(\"save_img\");\r\n   var tempSrc = canvas.toDataURL(\"image/png\");\r\n   console.log(tempSrc)\r\n   svaeHref.href = tempSrc;\r\n   img.src = tempSrc;\r\n\r\n   // location.href = tempSrc\r\n   downLoad(tempSrc)\r\n  }; \r\n </script>\r\n</body>\r\n\r\n</html>\r\n```\r\n","children":[]}]},{"name":"图片","path":"../guanruihua.github.io/HTML/canvas","data":"","children":[{"name":"createImageData.md","path":"../guanruihua.github.io/HTML/canvas/图片","data":"# createImageData\r\n\r\n> 创建一个全新的空的ImageData对象。该对象中的所有像素信息都是透明黑\r\n\r\n```js\r\ncontext.createImageData(width, height); \r\ncontext.createImageData(imagedata);\r\n```\r\n\r\n返回值是ImageData对象，包含width，height和data这3个只读属性。参数具体含义如下：\r\n> `width { Number }` ImageData 对象包含的width值。如果ImageData对象转换成图像，则此width也是最终图像呈现的宽度\r\n> `height { Number }` ImageData 对象包含的height值。如果ImageData对象转换成图像，则此height也是最终图像呈现的高度\r\n> `imagedata { Object }` 一个存在的ImageData对象，只会使用该ImageData对象中的width和height值，包含的像素信息会全部转换为透明黑\r\n\r\n```html\r\n<canvas id=\"canvas\"></canvas>\r\n```\r\n\r\n```js\r\n// 绘制在Canvas上\r\nvar context = canvas.getContext('2d');\r\nvar imagedata = context.createImageData(300, 150);\r\n// 给对应坐标位置的数据设置色值为绿色\r\nfor (var x = 1; x <= 300; x+=5) {\r\n    for (var y = 1; y <= 150; y+= 5) {\r\n        var index = 4 * ((y - 1) * 300 + (x - 1));\r\n        // 变为绿色，色值依次是0, 128, 0, 256\r\n        imagedata.data[index] = 0;\r\n        imagedata.data[index + 1] = 128;\r\n        imagedata.data[index + 2] = 0;\r\n        imagedata.data[index + 3] = 256;\r\n    }\r\n}\r\n// 再重绘\r\ncontext.putImageData(imagedata, 0, 0);\r\n```\r\n\r\n![](/__assets__/img/2022-02-15-11-09-10.png)\r\n> 直接使用createImageData()方法创建一个图像，例如，所有位置是5的倍数的地方我们塞入一个绿色颜色值，这样可以得到一个点阵图效果\r\n","children":[]},{"name":"drawImage.md","path":"../guanruihua.github.io/HTML/canvas/图片","data":"# drawImage\r\n\r\n```js\r\ncontext.drawImage(image, dx, dy);\r\ncontext.drawImage(image, dx, dy, dWidth, dHeight);\r\ncontext.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\r\n```\r\n\r\n> `image { Object }`: 绘制在Canvas上的元素，可以是各类Canvas图片资源（见CanvasImageSource），如`<img>`图片，SVG图像，Canvas元素本身等\r\n> `dx { Number }`: 在Canvas画布上规划一片区域用来放置图片，dx就是这片区域的左上角横坐标\r\n> `dy { Number }`: 在Canvas画布上规划一片区域用来放置图片，dy就是这片区域的左上角纵坐标\r\n> `dWidth { Number }`: 在Canvas画布上规划一片区域用来放置图片，dWidth就是这片区域的宽度\r\n> `dHeight { Number }`: 在Canvas画布上规划一片区域用来放置图片，dHeight就是这片区域的高度\r\n> `sx { Number }`: 表示图片元素绘制在Canvas画布上起始横坐标\r\n> `sy { Number }`: 表示图片元素绘制在Canvas画布上起始纵坐标\r\n> `sWidth { Number }`: 表示图片元素从坐标点开始算，多大的宽度内容绘制Canvas画布上\r\n> `sHeight { Number }`: 表示图片元素从坐标点开始算，多大的高度内容绘制Canvas画布上\r\n\r\n`context.drawImage(image, 0, 0, 300, 150);`\r\n![](/__assets__/img/2022-02-15-14-17-29.png)\r\n> 原图: 500 * 333, 这样子设置会被压扁了些\r\n","children":[]},{"name":"index.md","path":"../guanruihua.github.io/HTML/canvas/图片","data":"# 图片\n\n## getImageData\n\n> `CanvasRenderingContext2D.getImageData()`返回一个`ImageData`对象，其中包含Canvas画布部分或完整的像素点信息\n> 对图像进行像素级处理\n> `getImageData()`方法可能会出现CORS跨域报错\n\n`context.getImageData(sx, sy, sWidth, sHeight)`\n\n|参数| 作用|\n|:----|:----|\n|`sxNumbe` | 需要返回的图像数据区域的起始横坐标|\n|`syNumber` | 需要返回的图像数据区域的起始纵坐标|\n|`sWidthNumber` | 需要返回的图像数据区域的宽度|\n|`sHeightNumber` | 需要返回的图像数据区域的高度|\n\n```html\n<canvas id=\"canvas\" width=\"250\" height=\"167\"></canvas>\n```\n\n```js\nvar img = new Image();\nimg.onload = function () {\n    var context = canvas.getContext('2d');\n    // 图片绘制\n    context.drawImage(this, 0, 0, 250, 167);\n    // 然后获取中间100*100区域数据\n    var imageData = context.getImageData(75, 34, 100, 100);\n    var length = imageData.data.length;\n    for (var index = 0; index < length; index += 4) {\n        var r = imageData.data[index];\n        var g = imageData.data[index + 1];\n        var b = imageData.data[index + 2];\n        // 计算灰度\n        var gray = r * 0.299 + g * 0.587 + b * 0.114;\n        imageData.data[index] = gray;\n        imageData.data[index + 1] = gray;\n        imageData.data[index + 2] = gray;\n    }\n    // 更新新数据\n    context.putImageData(imageData, 75, 34);\n};\nimg.src = './1.jpg';\n```\n\n![](./__assets__/index-2022-03-29-15-49-12.png)\n","children":[]},{"name":"putImageData.md","path":"../guanruihua.github.io/HTML/canvas/图片","data":"# putImageData\r\n\r\n> - 将ImageData对象的数据绘制到位图上\r\n> - 若提供举行, 则仅绘制矩形的像素\r\n> - 不受画布变换矩阵影响\r\n\r\n```js\r\n\r\ncontext.putImageData(imagedata, dx, dy);\r\ncontext.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);\r\n```\r\n\r\n参数| 类型| 作用\r\n|:----|:----|:----|\r\nimagedata| Object| 包含图像像素信息的ImageData对象\r\ndx |Number| 目标Canvas中被图像数据替换的起点横坐标\r\ndy | Number |目标Canvas中被图像数据替换的起点纵坐标\r\ndirtyX（可选）|Number |图像数据渲染区域的左上角横坐标。默认值是0\r\ndirtyY（可选）|Number| 图像数据渲染区域的左上角纵坐标。默认值是0\r\ndirtyWidth（可选）|Number| 图像数据渲染区域的宽度。默认值是imagedata图像的宽度\r\ndirtyHeight（可选）|Number| 图像数据渲染区域的高度。默认值是imagedata图像的高度\r\n\r\n> 3类参数：\r\n>\r\n> - 第1类: `imagedata`，就是用来替换当前已有的Canvas画布上的ImageData数据对象。\r\n>\r\n> - 第2类: `dx`，`dy`，这两个参数是作用在Canvas画布上的。imagedata你可以看成是一个即将贴在Canvas画布上“图片膏药”，究竟贴在什么位置呢？dx，dy参数就是告诉这个膏药，你的左上角位置就是这里。\r\n>\r\n> - 第3类: `dirtyX`, `dirtY`, `dirtyWidth`, `dirtyHeight`, 表示矩形的坐标喝尺寸, 这些参数是作用在`imageData`上, `imageData` 所有数据都参与替换, 同过这几个参数设置, 让其中部分数据用来替换\r\n>\r\n> 需要注意的是，其坐标系并没有发生任何变化。从效果表现上看，可以看成是脏矩形外面的像素被当做透明像素处理了。\r\n\r\n```html\r\n<img id=\"image1\" src=\"./1.jpg\" alt=\"目标图片\">\r\n<img id=\"image2\" src=\"./1.jpg\" alt=\"数据源图片\">\r\n\r\n<canvas id=\"canvas\" width=\"300\" height=\"200\"></canvas>\r\n```\r\n\r\n```js\r\n// 尺寸\r\nvar width = 300, height = 200;\r\n// 目标Canvas上下文\r\nvar context = canvas.getContext('2d');\r\n// 目标Canvas绘制\r\ncontext.drawImage(image1, 0, 0, width, height);\r\n// 获取覆盖图数据\r\nvar dirtyCanvas = document.createElement('canvas');\r\nvar dirtyContext = dirtyCanvas.getContext('2d');\r\n// 设置屏幕外Canvas尺寸\r\ndirtyCanvas.width = width;\r\ndirtyCanvas.height = height;\r\n// 绘制替换图\r\ndirtyContext.drawImage(image2, 0, 0, width, height);\r\n// 此时可以得到imagedata数据\r\nvar imagedata = dirtyContext.getImageData(0, 0, width, height);\r\n// 然后中间100*100区域替换目标Canvas\r\ncontext.putImageData(imagedata, 0, 0, 100, 50, 100, 100);\r\n```\r\n","children":[]}]},{"name":"圆","path":"../guanruihua.github.io/HTML/canvas","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/HTML/canvas/圆","data":"# 圆\n\n## 圆弧 & 正圆\n\n### arc\n\n> `context.arc(x, y, radius, startAngle, endAngle [, anticlockwise]);`\n>\n> `x { Number }`: 圆弧对应的圆心横坐标\n> `y { Number }`: 圆弧对应的圆心纵坐标\n> `radius { Number }`: 圆弧的半径大小。\n> `startAngle { Number }`: 圆弧开始的角度，单位是弧度。\n> `endAngle { Number }`: 圆弧结束的角度，单位是弧度。\n> `anticlockwise（可选）{ Boolean }`: 弧度的开始到结束的绘制是按照顺时针来算，还是按时逆时针来算。如何设置为`true`，则表示按照逆时针方向从`startAngle`绘制到`endAngle`。\n\n```js\n// 顺时针绘制0到1/4弧度圆弧\ncontext.beginPath();\ncontext.arc(150, 75, 50, 0, Math.PI / 2);\ncontext.stroke();\n```\n\n![](/__assets__/img/2022-02-15-10-04-26.png)\n\n### arcTo\n\n> - 正圆圆弧, 给路径添加圆弧\n> - 根据 两个控制点 (x1,y1) 和 (x2, y2)以及半径绘制弧线 同时连接两个控制点\n> `context.arcTo(x1, y1, x2, y2, radius);`\n>\n> `x1 { Number }`: 第1个控制点的横坐标\n> `y1 { Number }`: 第1个控制点的纵坐标\n> `x2 { Number }`: 第2个控制点的横坐标\n> `y2 { Number }`: 第2个控制点的纵坐标\n> `radius { Number }`: 圆弧的半径大小\n\n```js\ncontext.beginPath();\ncontext.moveTo(50, 50);\ncontext.arcTo(150, 100, 200, 40, 40);\ncontext.lineTo(200, 40);\ncontext.stroke();\n```\n\n![](/__assets__/img/2022-02-15-10-11-03.png)\n\n## 椭圆\n\n> 绘制椭圆\n> 不支持IE浏览器, Edge13+支持\n> `context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);`\n> `x { Number }`: 椭圆弧对应的 圆心横坐标\n> `y { Number }`: 椭圆弧对应的 圆心纵坐标\n> `radiusX { Number }`: 椭圆弧的长轴半径大小\n> `radiusY { Number }`: 椭圆弧的短轴半径大小\n> `rotation { Number }`: 椭圆弧的旋转角度，单位是弧度\n> `startAngle { Number }`: 圆弧开始的角度，角度从横轴开始算，单位是弧度\n> `endAngle { Number }`: 圆弧结束的角度，单位是弧度\n> `anticlockwise（可选）{ Boolean }`: 弧度的开始到结束的绘制是按照顺时针来算，还是按时逆时针来算。如何设置为true，则表示按照逆时针方向从 startAngle 绘制到 endAngle\n\n```js\n// 绘制椭圆\ncontext.ellipse(150, 75, 80, 40, Math.PI / 4, 0, 2 * Math.PI);\ncontext.stroke();\n```\n\n![](/__assets__/img/2022-02-15-14-35-03.png)\n","children":[]}]},{"name":"基础Api","path":"../guanruihua.github.io/HTML/canvas","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/HTML/canvas/基础Api","data":"# 基础Api\n\n## 图案对象\n\n> 创建图案对象, 指定平铺方式, 用来作为图案的类型\n> `context.createPattern(image, repetition)`\n> `return  CanvasPattern`\n> `imageObject`\n>\n> 用来平铺的CanvasImageSource图像。可以是下面的类型：\n>\n> - HTMLImageElement，也就是`<img>`元素。\n> - HTMLVideoElement，也就是`<video>`元素，例如捕获摄像头视频产生的图像信息。\n> - HTMLCanvasElement\n> - CanvasRenderingContext2D\n> - ImageBitmap\n> - ImageData\n> - Blob\n>\n> `repetition` `{ String }`\n> 图案的平铺方式，可以是下面的值：\n>\n> - `repeat`，水平和垂直平铺。当repetition属性值为空字符串''或者null，也会按照'repeat'进行渲染\n> - `repeat-x`，仅水平平铺\n> - `repeat-y`，仅垂直平铺\n> - `no-repeat`，不平铺\n\n```html\n<canvas id=\"canvas\" width=\"250\" height=\"167\"></canvas>\n```\n\n```js\n// 先绘制图片\nvar img = new Image();\nimg.onload = function () {\n // 我们创建一个Canvas元素\n var canvasCreated = document.createElement('canvas');\n canvasCreated.width = 50;\n canvasCreated.height = 34;\n canvasCreated.getContext('2d').drawImage(this, 0, 0, 50, 34);\n // 页面上需要呈现最终纹理的Canvas上下文\n var context = canvas.getContext('2d');\n // 创建纹理并填充，顺便测试null是否渲染为'repeat'\n var pattern = context.createPattern(canvasCreated, null);\n context.fillStyle = pattern;\n context.fillRect(0, 0, 250, 167);\n};\nimg.src = './1.jpg';\n```\n\n![](/__assets__/img/2022-02-15-11-23-51.png)\n> 图片缩小，并作为纹理显示。我们直接把`<img>`元素作为纹理图案是无法控制其尺寸的，我们可以将`<img>`元素绘制在大小可控的Canvas元素上，然后把这个Canvas元素作为图案进行平铺即可\n\n## 剪裁\n\n> 先绘制剪裁路径, 执行`clip()`方法, 在绘制内容, 就在这个剪裁路径中呈现\n\n```js\ncontext.clip();\ncontext.clip(fillRule);\ncontext.clip(path, fillRule);\n```\n\n> `fillRule { String }`: 填充规则。用来确定一个点实在路径内还是路径外。可选值包括：\n>\n> - `nonzero`：非零规则 (默认)\n> - `evenodd`：奇偶规则。\n>\n>`pathObject`: 指Path2D对象。\n\n```js\nlet context = canvas.getContext('2d');\n// 需要图片先加载完毕\nlet img = new Image();\nimg.onload = function () {\n    // 剪裁路径是三角形\n    context.beginPath();\n    context.moveTo(20, 20);\n    context.lineTo(200, 80);\n    context.lineTo(110, 150);\n    // 剪裁\n    context.clip();\n    // 填充图片\n    context.drawImage(img, 0, 0, 250, 167);\n};\nimg.src = './1.jpg';\n```\n\n![](/__assets__/img/2022-02-15-10-50-54.png)\n> 利用剪裁实现一个图案填充效果。实现图案填充，标准用法是创建一个Pattern对象，然后作为fillStyle进行路径填充。这里，我们还可以使用clip()剪裁实现，这样就不用new一个Pattern对象了。例如，实现一个三角形，里面是人物照片图案。\n\n## 清除画布\n\n> `context.clearRect(x, y, width, height)`\n> `x { Number }`: 矩形左上角x坐标\n> `y { Number }`: 矩形左上角y坐标\n> `width { Number }`: 被清除的矩形区域的高度\n> `height { Number }`: 被清除的矩形区域的宽度度\n\n```js\n// 先绘制图片\nvar img = new Image();\nimg.onload = function () {\n    context.drawImage(img, 0, 0, 250, 167);\n    // 中间开个方形的洞\n    context.clearRect(50, 50, 100, 66);\n};\nimg.src = './1.jpg';\n```\n\n![](/__assets__/img/2022-02-15-10-41-05.png)\n> 先把一张图片绘制在Canvas画布上，然后再把中间一块矩形区域的像素信息清除\n\n## 渐变\n\n### 渐变对象\n\n> 创建 渐变对象\n> `context.createLinearGradient(x0, y0, x1, y1);`\n> `x0 { Number }`:  渐变起始点横坐标\n> `y0 { Number }`:  渐变起始点纵坐标\n> `x1 { Number }`:  渐变结束点横坐标\n> `y1 { Number }`:  渐变结束点纵坐标\n> 线性渐变效果比较好脑补，就是从坐标点[x0, y0]到坐标点[x1, y1]的位置画一条线，然后整个渐变色带与与这条线垂直\n\n```js\nvar context = canvas.getContext('2d');\n// 创建渐变\nvar gradient = context.createLinearGradient(0, 0, 300, 0);\ngradient.addColorStop(0, 'red');\ngradient.addColorStop(1, 'green');\n// 设置填充样式为渐变\ncontext.fillStyle = gradient;\n// 左上角和右下角分别填充2个矩形\ncontext.fillRect(10, 10, 160, 60);\ncontext.fillRect(120, 80, 160, 60);\n```\n\n![](/__assets__/img/2022-02-15-11-15-04.png)\n\n### 径向渐变\n\n> 创建径向渐变\n> 不同于CSS3的径向渐变, Canvas中径向渐变的起始点由两个圆环坐标构成\n> `context.createRadialGradient(x0, y0, r0, x1, y1, r1)`\n> `return CanvasPattern对象`\n> `x0 { Number }`: 起始圆的横坐标\n> `y0 { Number }`: 起始圆的纵坐标\n> `r0 { Number }`: 起始圆的半径\n> `x1 { Number }`: 结束圆的横坐标\n> `y1 { Number }`: 结束圆的纵坐标\n> `r1 { Number }`: 结束圆的半径\n\n#### 标准径向渐变\n\n> 看似标准两色径向渐变的实现并不是理所当然，反而是需要一些技巧，技巧就是我们的起始圆半径设置为0，化作一个点。例如实现一个红绿渐变\n\n```html\n<canvas width=\"240\" height=\"120\"></canvas>\n```\n\n```js\nvar context = canvas.getContext('2d');\n// 创建一个起始圆半径为0的径向渐变对象\nvar gradient = context.createRadialGradient(120, 60, 0, 120, 60, 60);\n// 设置起止颜色\ngradient.addColorStop(0, 'red');\ngradient.addColorStop(1, 'green');\n// 矩形填充\ncontext.fillStyle = gradient;\ncontext.fillRect(0, 0, 240, 120);\n```\n\n![](/__assets__/img/2022-02-15-11-32-48.png)\n\n#### 色带分隔明显的色环\n\n> 同心五环效果\n\n```html\n<canvas width=\"150\" height=\"150\"></canvas>\n```\n\n```js\nvar context = canvas.getContext('2d');\n// 创建一个起始圆半径为0的径向渐变对象\nvar gradient = context.createRadialGradient(75, 75, 0, 75, 75, 75);\n// 设置起止颜色\ngradient.addColorStop(0, 'red');\ngradient.addColorStop(0.2, 'red');\ngradient.addColorStop(0.2, 'orange');\ngradient.addColorStop(0.4, 'orange');\ngradient.addColorStop(0.4, 'yellow');\ngradient.addColorStop(0.6, 'yellow');\ngradient.addColorStop(0.6, 'green');\ngradient.addColorStop(0.8, 'green');\ngradient.addColorStop(0.8, 'purple');\ngradient.addColorStop(1, 'purple');\ngradient.addColorStop(1, 'transparent');\n// 矩形填充\ncontext.fillStyle = gradient;\ncontext.fillRect(0, 0, 150, 150);\n```\n\n![](/__assets__/img/2022-02-15-11-36-09.png)\n> 不同浏览器还是有差异的，Chrome浏览器下的锯齿比较明显\n> 实际上，如果起始渐变圆的半径如果不是0，则在Firefox浏览器下，第5环会无法呈现，且也会出现明显锯齿，这个案例可参见CanvasGradient.addColorStop\n\n## 状态保存&恢复\n\n```js\nsave()// 状态存储\nrestore()// 恢复上一次状态\n```\n","children":[]},{"name":"isPointInPath.md","path":"../guanruihua.github.io/HTML/canvas/基础Api","data":"# isPointInPath\r\n\r\n> `CanvasRenderingContext2D.isPointInPath()`用来检测某个点是否在当前路径中\r\n\r\n```js\r\ncontext.isPointInPath(x, y);\r\ncontext.isPointInPath(x, y, fillRule);\r\n// 下面语法IE不支持\r\ncontext.isPointInPath(path, x, y);\r\ncontext.isPointInPath(path, x, y, fillRule);\r\n```\r\n\r\n> 此方法返回Boolean值。\r\n\r\n|参数 | 作用|\r\n|----|----|\r\n`x {Number}`| 用来检测的点的横坐标\r\n`y {Number}`|  用来检测的点的纵坐标\r\n`fillRule {String}`|  填充规则。用来确定一个点实在路径内还是路径外。<br/>可选值包括：<br> `nonzero`：非零规则(default)<br> `evenodd`：奇偶规则。\r\n`path { Object }`|  指Path2D对象。\r\n\r\n```js\r\n// 画一个圆\r\ncontext.arc(120, 120, 80, 0, Math.PI * 2);\r\ncontext.stroke();\r\n// 用来测试的点坐标们\r\nvar arrPoints = [{\r\n    x: 50,\r\n    y: 50\r\n}, point2 = {\r\n    x: 150,\r\n    y: 150\r\n}, point3 = {\r\n    x: 120,\r\n    y: 40\r\n}];\r\narrPoints.forEach(function (point) {\r\n    // 检测点是否在路径内\r\n    point.isPointInPath = context.isPointInPath(point.x, point.y);\r\n});\r\narrPoints.forEach(function (point) {\r\n    // 标记这几个点\r\n    context.fillStyle = 'red';\r\n    context.beginPath();\r\n    context.arc(point.x, point.y, 3, 0, Math.PI * 2);\r\n    context.fill();\r\n    // 检测结果以文本方式绘制\r\n    context.font = '14px arial';\r\n    context.fillText(point.isPointInPath, point.x + 5, point.y);\r\n});\r\n```\r\n\r\n![](./__assets__/isPointInPath-2022-03-29-16-21-20.png)\r\n\r\n> 在路径范围内和正好压在路径上，返回值都是true，在路径外返回值是false\r\n","children":[]},{"name":"isPointInStroke.md","path":"../guanruihua.github.io/HTML/canvas/基础Api","data":"# isPointInStroke\r\n\r\n> 检测是否在描边上\r\n\r\n```js\r\ncontext.isPointInStroke(x, y);\r\ncontext.isPointInStroke(path, x, y);\r\n```\r\n\r\n> 此方法返回Boolean值。\r\n\r\n|参数|类型 |作用|\r\n|:----|:----|:----|\r\n`x`| `Number`| 用来检测的点的横坐标|\r\n`y`| `Number`| 用来检测的点的纵坐标|\r\n`path`| `Object`| 指Path2D对象|\r\n\r\n```js\r\n// 画一个圆\r\ncontext.arc(120, 120, 80, 0, Math.PI * 2);\r\ncontext.lineWidth = 5;\r\ncontext.stroke();\r\n// 用来测试的点坐标们\r\nvar arrPoints = [{\r\n    x: 40,\r\n    y: 40\r\n}, point2 = {\r\n    x: 120,\r\n    y: 180\r\n}, point3 = {\r\n    x: 120,\r\n    y: 38\r\n}];\r\narrPoints.forEach(function (point) {\r\n    // 检测点是否在路径内\r\n    point.isPointInStroke = context.isPointInStroke(point.x, point.y);\r\n});\r\narrPoints.forEach(function (point) {\r\n    // 标记这几个点\r\n    context.fillStyle = 'red';\r\n    context.beginPath();\r\n    context.arc(point.x, point.y, 3, 0, Math.PI * 2);\r\n    context.fill();\r\n    // 检测结果以文本方式绘制\r\n    context.font = '14px arial';\r\n    context.fillText(point.isPointInStroke, point.x + 5, point.y);\r\n});\r\n```\r\n\r\n![](./__assets__/isPointInStroke-2022-03-29-16-29-43.png)\r\n\r\n> 只有检测点在描边路径上，才返回true，在描边路径外和描边路径内部都返回false\r\n","children":[]},{"name":"rotate.md","path":"../guanruihua.github.io/HTML/canvas/基础Api","data":"# rotate\r\n\r\n## 旋转\r\n\r\n`context.rotate(angle)`\r\n\r\n```js\r\n// 旋转45度\r\ncontext.rotate(45 * Math.PI / 180);\r\n// 字体填充\r\ncontext.font = '20px STHeiti, SimHei';\r\ncontext.fillText('旋转，跳跃，我闭着眼', 60, -40, 188);\r\n// 重置当前的变换矩阵为初始态\r\ncontext.setTransform(1, 0, 0, 1, 0, 0);\r\n```\r\n\r\n![](./__assets__/rotate-2022-03-29-17-36-28.png)\r\n","children":[]},{"name":"scale.md","path":"../guanruihua.github.io/HTML/canvas/基础Api","data":"# scale 缩放\r\n>\r\n> - 不会影响之前绘制好的\r\n> - 影响之后的绘制\r\n> - 默认缩放中心 (0, 0)\r\n\r\n## `context.scale(x, y)`\r\n\r\n参数 | 类型 | 作用\r\n|:----|:----|:----|\r\n`x` |`Number` | Canvas坐标系水平缩放的比例。支持小数，如果值是-1，表示水平翻转\r\n`y` |`Number` | Canvas坐标系垂直缩放的比例。支持小数，如果值是-1，表示垂直翻转\r\n\r\n```js\r\n// 显示绘制个正方形用来对比\r\ncontext.fillRect(10, 10, 10, 10);\r\n// 缩放\r\ncontext.scale(10, 3);\r\n// 再次绘制\r\ncontext.fillRect(10, 10, 10, 10);\r\n// 恢复坐标系\r\ncontext.setTransform(1, 0, 0, 1, 0, 0);\r\n```\r\n\r\n![](./__assets__/scale-2022-03-29-17-40-58.png)\r\n","children":[]},{"name":"setTransform.md","path":"../guanruihua.github.io/HTML/canvas/基础Api","data":"# setTransform\r\n\r\n> 设置矩阵变换当前\r\n> 此方法和transform()方法的区别在于，后者不会完全重置已有的变换，而是累加\r\n\r\n`context.setTransform(a, b, c, d, e, f)`\r\n参数| 类型 |作用\r\n|:----|:----|:----|\r\n`a`| `Number` |水平缩放\r\n`b`| `Number` |水平斜切\r\n`c`| `Number` |垂直斜切\r\n`d`| `Number` |垂直缩放\r\n`e`| `Number` |水平位移\r\n`f`| `Number` |垂直位移\r\n![](./__assets__/setTransform-2022-03-29-17-48-14.png)\r\n\r\n```js\r\ncontext.setTransform(1, 0, 1, 1, 0, 0);\r\ncontext.fillRect(10, 20, 100, 100);\r\n```\r\n\r\n![](./__assets__/setTransform-2022-03-29-17-50-49.png)\r\n","children":[]},{"name":"stroke_.md","path":"../guanruihua.github.io/HTML/canvas/基础Api","data":"\r\n# stroke_\r\n\r\n## stroke\r\n\r\n> 对路径进行描边\r\n\r\n```js\r\n\r\ncontext.stroke();\r\ncontext.stroke(path);\r\n```\r\n\r\n参数 `pathObject` :指Path2D对象(IE浏览器不支持)\r\n\r\n```js\r\ncontext.moveTo(50, 50);\r\ncontext.lineTo(250, 100);\r\n// 描边\r\ncontext.stroke();\r\n```\r\n\r\n![](./__assets__/index-2022-04-01-16-07-27.png)\r\n\r\n## strokeRect\r\n\r\n> 矩形描边\r\n\r\n```js\r\ncontext.strokeRect(x, y, width, height);\r\n```\r\n\r\n| 参数   | 类型   | 作用                 |\r\n| :----- | :----- | :------------------- |\r\n| x      | Number | 矩形的起点横坐标 |\r\n| y      | Number | 矩形的起点纵坐标 |\r\n| width  | Number | 矩形的宽度       |\r\n| height | Number | 矩形的高度       |\r\n\r\n```js\r\n// 像素宽矩形描边\r\ncontext.lineWidth = 2;\r\ncontext.strokeRect(75, 25, 150, 100);\r\n```\r\n\r\n![](./__assets__/stroke_-2022-04-01-16-11-44.png)\r\n\r\n## strokeText\r\n\r\n> 文字描边, 居中描边\r\n\r\n```js\r\ncontext.strokeText(text, x, y [, maxWidth]);\r\n```\r\n\r\n|参数| 类型 | 参数|\r\n|:----|:----|:----|\r\ntext | String 用来描边的文本信息。\r\nx | Number |描边文本的起点横坐标。\r\ny | Number |描边文本的起点纵坐标。\r\nmaxWidth | （可选）Number | 填充文本最大宽度 (超过最大宽度, 通过压缩每个文本宽度)\r\n\r\n```js\r\n// 文字描边\r\ncontext.font = '50px STHeiti, SimHei';\r\ncontext.strokeText('文字描边', 50, 90);\r\n```\r\n\r\n![](./__assets__/stroke_-2022-04-01-16-17-12.png)\r\n","children":[]},{"name":"transform.md","path":"../guanruihua.github.io/HTML/canvas/基础Api","data":"# transform\r\n\r\n> 对当前坐标进行进一步变换, 实现缩放, 旋转, 拉伸或位移效果\r\n> 与`setTransform` 区别在于, `setTransform`会重置已有的变换, `transform`是累加\r\n\r\n```js\r\ncontext.transform(a, b, c, d, e, f);\r\n```\r\n\r\n参数| 类型 |作用\r\n|:----|:----|:----|\r\n`a`| `Number` |水平缩放\r\n`b`| `Number` |水平斜切\r\n`c`| `Number` |垂直斜切\r\n`d`| `Number` |垂直缩放\r\n`e`| `Number` |水平位移\r\n`f`| `Number` |垂直位移\r\n![](./__assets__/setTransform-2022-03-29-17-48-14.png)\r\n\r\n```js\r\ncontext.transform(1, 0, 1, 1, 0, 0);\r\ncontext.fillRect(10, 20, 100, 100);\r\n```\r\n\r\n![](./__assets__/setTransform-2022-03-29-17-50-49.png)\r\n","children":[]},{"name":"translate.md","path":"../guanruihua.github.io/HTML/canvas/基础Api","data":"# translate\r\n\r\n> 对Canvas坐标进行整体位移, 实际开发中常用来改变其他变换的方法的变换中心点\r\n\r\n`context.translate(x, y);`\r\n\r\n|参数| 类型 |作用|\r\n|:----|:----|:----|\r\n|x| Number| 坐标系水平位移的距离|\r\n|y| Number| 坐标系垂直位移的距离|\r\n\r\n```html\r\n<canvas id=\"canvas\" width=\"300\" height=\"200\"></canvas>\r\n```\r\n\r\n```js\r\nvar img = new Image();\r\nimg.onload = function () {\r\n    var context = canvas.getContext('2d');\r\n    // 坐标位移\r\n    context.translate(150, 100);\r\n    // 旋转45度\r\n    context.rotate(45 * Math.PI / 180);\r\n    // 再位移回来\r\n    context.translate(-150, -100);\r\n    // 此时绘制图片就是中心旋转了\r\n    context.drawImage(this, 0, 0, 300, 200);\r\n\r\n    // 坐标系还原\r\n    context.setTransform(1, 0, 0, 1, 0, 0);\r\n};\r\nimg.src = './1.jpg';\r\n```\r\n\r\n![](./__assets__/translate-2022-04-01-16-30-05.png)\r\n","children":[]}]},{"name":"属性","path":"../guanruihua.github.io/HTML/canvas","data":"","children":[{"name":"canvas.md","path":"../guanruihua.github.io/HTML/canvas/属性","data":"# 属性\r\n\r\n属性名|描述|\r\n|:----|:----|\r\n`canvas(readOnly)`|可以反向放回当前上下文`Canvas`\r\n`fillStyle(default #000)`| 填充各种图形样式(支持`color色值`,`渐变填充`, `pattern:填充纹理(contextPattern.createPattern())`)\r\n`font(default 10px sans-serif)`| 设置字体\r\n`globalAlpha`|设置画布的全局透明度\r\n`globalCompositeOperation`| 设置Canvas图形的混合模式\r\n`lineCap`| 设置线条端点的样式(`buzz[default]`,`round圆弧`,`square:多出一个方框,宽度和线一直, 长为线宽一半`)\r\n`lineDashOffset` | 指定虚线绘制的偏移距离\r\n`lineJoin` | 线条转角样式(`miter(尖头)`,`round(圆头)`,`bevel(平头)`)\r\n`lineWidth` | 线宽\r\n`miterLimit` | 限制尖角长度范围\r\n`shadowBlur` | 阴影的模糊程度\r\n`shadowColor`| 阴影颜色\r\n`shadowOffsetX` | 阴影水皮偏移\r\n`shadowOffsetY` | 阴影垂直偏移\r\n`strokeStyle` | 描边样式\r\n`textAlign` | 文本水平对齐方式\r\n`textBaseline` | 文本对齐基线\r\n","children":[]}]},{"name":"文字","path":"../guanruihua.github.io/HTML/canvas","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/HTML/canvas/文字","data":"# 文字\r\n\r\n## fillText 填充文字\r\n\r\n> `CanvasRenderingContext2D.fillText()`: 用来填充文字，是Canvas绘制文本的主力方法\r\n>\r\n> `context.fillText(text, x, y [, maxWidth])`\r\n> `text {String}`: 用来填充的文本信息。\r\n> `x {Number}`: 填充文本的起点横坐标。\r\n> `y {Number}`: 填充文本的起点纵坐标。\r\n> `maxWidth（可选）{Number}`: 文本最大宽度(不是换行, 超过该长度会压缩文本宽度)\r\n\r\n```js\r\ncontext.font = '24px STheiti, SimHei';\r\ncontext.fillText('Canvas API中文网', 24, 66);\r\n```\r\n\r\n![](./__assets__/index-2022-03-29-14-54-54.png)\r\n\r\n## measureText 文字宽度\r\n\r\n> `CanvasRenderingContext2D.measureText()` 可以用来测量文本的一些数据，返回`TextMetrics`对象，包含字符宽度等信息。\r\n\r\n### `context.measureText(text)`\r\n\r\n> 返回值是TextMetrics对象\r\n> `text {String}` 被测量的文本\r\n\r\n```js\r\n// 设置字体字号\r\ncontext.font = '24px STHeiTi, SimHei';\r\n// 文本信息对象就有了\r\nvar textZh = context.measureText('帅');\r\nvar textEn = context.measureText('handsome');\r\n// 文字绘制\r\ncontext.fillText('帅', 60, 50);\r\ncontext.fillText('handsome', 60, 90);\r\n// 显示宽度\r\ncontext.font = '12px Arial';\r\ncontext.fillStyle = 'red';\r\ncontext.fillText('宽' + textZh.width, 62 + textZh.width, 40);\r\ncontext.fillText('宽' + textEn.width, 62 + textEn.width, 80);\r\n```\r\n\r\n![](./__assets__/index-2022-03-29-16-45-12.png)\r\n","children":[]}]},{"name":"矩形","path":"../guanruihua.github.io/HTML/canvas","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/HTML/canvas/矩形","data":"# 矩形\n\n## 矩形填充\n\n> 默认黑色\n`context.fillRect(x, y, width, height);`\n\n- `x { Number }`: 填充矩形的起点横坐标\n- `y { Number }`: 填充矩形的起点纵坐标\n- `width { Number }`: 填充矩形的宽度\n- `height { Number }`: 填充矩形的高度\n\n```js\nfillRect( x , y , width , height)  //填充以(x,y)为起点宽高分别为width、height的矩形 默认为黑色\n\nstrokeRect( x , y , width , height) //绘制一个空心以(x,y)为起点宽高分别为width、height的矩形\n\nclearRect( x, y , width , height ) // 清除以(x,y)为起点宽高分别为width、height的矩形 为透明\n```\n","children":[]},{"name":"rect.md","path":"../guanruihua.github.io/HTML/canvas/矩形","data":"# rect\r\n\r\n> `CanvasRenderingContext2D.rect()` 绘制矩形路径\r\n> `rect()`绘制出来的仅仅是路径，和`arc()`、`ellipse()`方法是一样的。需要你需要填充，还需要执行`fill()`方法，如果要描边，还需要执行`stroke()`方法。实际上，对于矩形，填充和描边有现成的方法，这个是为矩形独有的，为`fillRect()`和`strokeRect()`\r\n\r\n```js\r\ncontext.rect(x, y, width, height);\r\n```\r\n\r\n参数 | 类型 | 作用\r\n|:----|:----|:----|\r\n`x` | `Number`| 矩形路径的起点横坐标\r\n`y` | `Number`| 矩形路径的起点纵坐标\r\n`width` | `Number`| 矩形的宽度\r\n`height` | `Number`| 矩形的高度\r\n\r\n```js\r\n// 矩形\r\ncontext.rect(100, 25, 100, 100);\r\ncontext.stroke();\r\n```\r\n\r\n![](./__assets__/rect-2022-03-29-17-29-25.png)\r\n","children":[]}]},{"name":"线","path":"../guanruihua.github.io/HTML/canvas","data":"","children":[{"name":"曲线.md","path":"../guanruihua.github.io/HTML/canvas/线","data":"# 曲线\n\n## 一次贝塞尔曲线\n\n> - 没有控制点\n> - 就是一条直线\n\n## 二次贝塞尔曲线 quadraticCurveTo\n>\n> - 一个控制点\n\n```js\nquadraticCurveTo( cpx, cpy , x ,y )   // (cp1x,cp1y) 控制点    (x,y)结束点\n```\n\n参数| 类型 | 作用\n|:----|:----|:----|\n`cpx`| `Number`| 控制点的横坐标\n`cpy`| `Number`| 控制点的纵坐标\n`x`| `Number`| 结束点的横坐标\n`y`| `Number`| 结束点的纵坐标\n\n```js\n// 开始绘制\ncontext.beginPath();\ncontext.moveTo(50, 50);\ncontext.quadraticCurveTo(100, 100, 250, 100);\ncontext.stroke();\n```\n\n![](./__assets__/曲线-2022-03-29-17-23-46.png)\n\n## 三次贝塞尔曲线 bezierCurveTo\n>\n> - 两个控制点\n> - 绘制: 正圆, 椭圆, 曲线图像\n> `context.bezierCurveTo( cp1x, cp1y ,cp2x , cp2y ,x , y )`\n> `( cp1x, cp1y)`:  控制点1\n> `( cp2x, cp2y)`:  控制点2  \n> `( x, y)`: 结束点\n\n```js\ncontext.beginPath();\ncontext.moveTo(50, 50);\ncontext.bezierCurveTo(100, 100, 200, 40, 250, 100);\ncontext.stroke();\n```\n\n![](/__assets__/img/2022-02-15-10-30-35.png)\n> 灰色是起始点，红色是两个控制点\n> 其中有1个白点的是第1个控制点，有2个白点的是第2个控制点，绿色是结束点\n","children":[]},{"name":"线.md","path":"../guanruihua.github.io/HTML/canvas/线","data":"# 线\r\n\r\n## 获取虚线样式 getLineDash\r\n\r\n> `CanvasRenderingContext2D.getLineDash()`用来获取当前虚线的样式\r\n\r\n```js\r\ncontext.beginPath();\r\ncontext.moveTo(10, 60);\r\ncontext.lineTo(230, 60);\r\ncontext.setLineDash([5]);\r\ncontext.stroke();\r\n// 将getLineDash()结果绘制在画布上\r\nvar dash = context.getLineDash();\r\n// 绘制文本\r\ncontext.font = '16px arial';\r\ncontext.fillText(dash, 10, 48);\r\n// 控制台输出\r\nconsole.log(dash);\r\n```\r\n\r\n![](./__assets__/线-2022-03-29-16-09-48.png)\r\n\r\n## 设置虚线样式 setLineDash\r\n\r\n> `CanvasRenderingContext2D.setLineDash()`: 设置虚线样式\r\n\r\n### 　`ctx.setLineDash(segments)`\r\n\r\n`segmentsArray`: 数值列表数组。例如[5, 5]，表示虚线的实线和透明部分长度是5像素和5像素。如果此参数值适合空数组[]，则表示实线，常用来重置虚线设置。\r\n\r\n```js\r\ncontext.beginPath();\r\ncontext.setLineDash([5, 10, 15, 30]);\r\ncontext.moveTo(20, 70);\r\ncontext.lineTo(280, 70);\r\ncontext.stroke();\r\n```\r\n\r\n![](./__assets__/线-2022-03-29-17-44-55.png)\r\n","children":[]}]},{"name":"路径","path":"../guanruihua.github.io/HTML/canvas","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/HTML/canvas/路径","data":"# 路径\n\n## beginPath 新路径\n\n> `beginPath`\n> `type: ()=>void`\n> 新的路径, 和之前的路径分开\n\n```js\n// 开始路径\ncontext.beginPath();\ncontext.strokeStyle = 'blue';\ncontext.moveTo(60, 20);\ncontext.lineTo(220, 20);\ncontext.stroke();\n// 开始路径 again\ncontext.beginPath();\ncontext.strokeStyle = 'green';\ncontext.moveTo(60, 20);\ncontext.lineTo(160, 120);\ncontext.stroke();\n```\n\n![](/__assets__/img/2022-02-15-10-18-29.png)\n> 执行两次`beginPath()`\n\n## closePath 闭合路径\n\n> `closePath()`\n> `type: ()=> void`\n> 关闭该路径 将绘制指令重新转移到上下文\n\n```js\n// 绘制三角\ncontext.beginPath();\ncontext.moveTo(10, 10);\ncontext.lineTo(140, 70);\ncontext.lineTo(70, 140);\n// 不执行闭合，直接描边\ncontext.stroke();\n\n// 绘制另外一个三角\ncontext.beginPath();\ncontext.moveTo(160, 10);\ncontext.lineTo(290, 70);\ncontext.lineTo(220, 140);\n// 执行闭合，然后描边\ncontext.closePath();\ncontext.stroke();\n```\n\n![](/__assets__/img/2022-02-15-10-55-38.png)\n> 左侧图形没有执行`closePath()`，右侧执行了`closePath()`\n\n## fill 路径填充\n\n> 路径填充, 包含非零规则, 奇偶规则\n\n```js\ncontext.fill();\ncontext.fill(fillRule);\ncontext.fill(path, fillRule);\n```\n\n> `fillRule { String }`: 填充规则。用来确定一个点实在路径内还是路径外。可选值包括：\n>\n> - `nonzero`：非零规则，此乃默认规则\n> - `evenodd`：奇偶规则\n>\n> `path { Object }`: 指Path2D对象\n\n```html\n<canvas width=\"300\" height=\"300\" data-rule=\"nonzero\"></canvas>\n<canvas width=\"300\" height=\"300\" data-rule=\"evenodd\"></canvas>\n```\n\n```js\n// 2个三角的点坐标\nvar arrPoints = [[60,60], [240,100], [160,280], [60,60], [150,20], [260,260]];\nvar canvases = document.querySelectorAll('canvas');\n// 遍历\n[].slice.call(canvases).forEach(function (canvas, index) {\n    var rule = canvas.getAttribute('data-rule');\n    var context = canvas.getContext('2d');\n    // 开始绘制\n    context.beginPath();\n    context.moveTo(arrPoints[0][0], arrPoints[0][1]);\n    context.lineTo(arrPoints[1][0], arrPoints[1][1]);\n    context.lineTo(arrPoints[2][0], arrPoints[2][1]);    \n    context.lineTo(arrPoints[3][0], arrPoints[3][1]);\n    context.lineTo(arrPoints[4][0], arrPoints[4][1]);\n    context.lineTo(arrPoints[5][0], arrPoints[5][1]);\n    context.closePath();\n    context.fillStyle = '#0e65c5';\n    context.fill(rule);\n});\n```\n\n![](/__assets__/img/2022-02-15-14-44-30.png)\n\n## lineTo 连接\n\n> 绘制直线连接最后的子路径点喝lineTo()指定点\n\n`context.lineTo(x, y)`\n| 参数 | 类型     | 作用                     |\n| :--- | :------- | :----------------------- |\n| `x`  | `Number` | 绘制的直线的落点的横坐标 |\n| `y`  | `Number` | 绘制的直线的落点的纵坐标 |\n\n```js\ncontext.beginPath();\ncontext.moveTo(50, 20);\ncontext.bezierCurveTo(100, 100, 200, 40, 250, 120);\ncontext.lineTo(50, 120);\ncontext.stroke();\n```\n\n![](./__assets__/线-2022-03-29-16-41-16.png)\n\n## moveTo 绘制点移动\n\n### 　`context.moveTo(x, y);`\n\n| 参数 | 类型 | 作用 |\n| :--- | :--- | :--- |\n`x` | `Number`| 落点的横坐标\n`y` | `Number`| 落点的纵坐标\n\n```js\ncontext.beginPath();\ncontext.moveTo(50, 20);\ncontext.lineTo(200, 100);\ncontext.stroke();\n```\n\n![](./__assets__/index-2022-03-29-16-53-29.png)\n\n## drawFocusIfNeeded 路径高亮\n\n>\n> 路径处于focus状态\n> 兼容性差\n> 增强可访问性\n> 日常使用:\n>\n> - 用来增强高亮复杂路径\n> - 点选删除元素\n> - 复制移动工具类应用场景\n>\n```js\ncontext.drawFocusIfNeeded(element);\ncontext.drawFocusIfNeeded(path, element);\n```\n\n> `element { Object }` 用来检测当前是否处于focus状态的元素。此元素需要原本就是可聚焦的元素，例如按钮或者链接或者输入框等。然后，还需要放置在`<canvas>`标签中才有用\n> `path { Object }` 指Path2D对象\n\n```html\n<canvas id=\"canvas\" width=\"240\" height=\"120\">\n    <button id=\"button1\">按钮1</button>\n    <button id=\"button2\">按钮2</button>\n</canvas>\n```\n\n```js\n// 两个按钮元素\nvar button1 = document.getElementById('button1');\nvar button2 = document.getElementById('button2');\n// canvas元素和上下文\nvar canvas = document.querySelector('#canvas');\nvar context = canvas.getContext('2d');\nvar draw = function () {\n    context.clearRect(0, 0, 240, 120);\n    // 设置字体样式\n    context.font = '16px STHeiti, SimHei';\n    context.textAlign = 'center';\n    context.textBaseline = 'middle';\n    // 绘制两个圆和文字\n    context.beginPath();\n    context.arc(60, 60, 50, 0, Math.PI * 2);\n    context.fillStyle = 'red';\n    context.fill();\n    context.fillStyle = 'white';\n    context.fillText('按钮1', 60, 60);\n    context.drawFocusIfNeeded(button1);\n\n    context.beginPath();\n    context.arc(180, 60, 50, 0, Math.PI * 2);\n    context.fillStyle = 'green';\n    context.fill();\n    context.fillStyle = 'white';\n    context.fillText('按钮2', 180, 60);\n    context.drawFocusIfNeeded(button2);\n};\ndraw();\n\n// 点击canvas元素\ncanvas.addEventListener('click', function (event) {\n    // 通过点击位置判断点击是哪个圈圈\n    var x = event.clientX - canvas.getBoundingClientRect().left;\n    var y = event.clientY - canvas.getBoundingClientRect().top;\n    // 距离两个圈圈圆心的距离\n    var distance1 = Math.sqrt((60 - x) * (60 - x) + (60 - y) * (60 - y));\n    var distance2 = Math.sqrt((180 - x) * (180 - x) + (60 - y) * (60 - y));\n    // 根据距离和半径大小判断是否在圈内\n    if (distance1 <= 50) {\n        button1.focus();\n        draw();\n    } else if (distance2 < 50) {\n        button2.focus();\n        draw();\n    }\n});\n```\n\n![](/__assets__/img/2022-02-15-11-41-32.png)\n\n```js\nbeginPath() //新建一条路径一旦创建成功 绘制命令将转移到新建的路径上\nmoveTo( x, y )// 移动画笔到(x , y) 点开始后面的绘制工作\nclosePath()// 关闭该路径 将绘制指令重新转移到上下文\nstroke()// 将绘制的路径进行描边\nfill()// 将绘制的封闭区域进行填充\n```\n","children":[]}]}]},{"name":"favicon","path":"../guanruihua.github.io/HTML","data":"","children":[{"name":"添加favicon.md","path":"../guanruihua.github.io/HTML/favicon","data":"# 给网站添加 favicon\r\n\r\n```html\r\n<link href=\"favicon.ico\" mce_href=\"favicon.ico\" rel=\"bookmark\" type=\"image/x-icon\" />\r\n<link href=\"favicon.ico\" mce_href=\"favicon.ico\" rel=\"icon\" type=\"image/x-icon\" />\r\n<link href=\"favicon.ico\" mce_href=\"favicon.ico\" rel=\"shortcut icon\" type=\"image/x-icon\" />\r\n```\r\n\r\n注意：\r\n（1）这里的favicon必须是16*16或者32*32的，必须是8位色或者24位色的，格式必须是png或者ico或者gif。\r\n16*16/32*32 且 8位或24位色 且 png/ico/gif。\r\n\r\n（2）当favicon.ico被置于文档根目录时，将会被一些不处理link元件的浏览器找到，即使没有您的站点上没有指向它的链接。\r\n\r\n参数解释：\r\n\r\n- href：这是你网页图标的位置，建议放在服务器根目录下，图标必须是ico文件。\r\n\r\n- rel：用于解释 href 链接的对象和该网页有毛线关系用的，毕竟全称就是 relationship 。\r\n\r\n说明：\r\n\r\n1.bookmark和icon的区别\r\n\r\n- bookmark：在收藏夹下显示图标\r\n- icon：资源管理器窗口，还是浏览器的收藏夹\r\n\r\n2.shortcut icon和icon代码的区别\r\n\r\n过去，为保证favicon出现，网站设计者和开发者采用了多种方法。很难明确地保证favicon可以在所有电脑上显示，即使是用同一版本的一种浏览器。\r\n\r\n下列代码另一个局限就是它把favicon关联到了某个特定的HTML或XHTML文档上。为避免这一点，favicon.ico文件应置于根目录下。多数浏览器将自动检测并使用它。\r\n\r\n```html\r\n<link href=\"favicon.ico\" mce_href=\"favicon.ico\" rel=\"icon\" type=\"image/x-icon\" />\r\n<link href=\"favicon.ico\" mce_href=\"favicon.ico\" rel=\"shortcut icon\" type=\"image/x-icon\" />\r\n```\r\n\r\n> 只有第一行是必须的，因为“shortcut icon”字符串将被多数遵守标准的浏览器识别为列出可能的关键词（“shortcut”将被忽略，而仅适用“icon”）；而Internet Explorer将会把它作为一个单独的名称（“shortcut icon”）。这样做的结果是所有浏览器都可以理解此代码。只有当希望为新浏览器提供另一种备用图像（例如动画GIF）时，才有必要添加第二行。\r\n","children":[]},{"name":"防止favicon请求.md","path":"../guanruihua.github.io/HTML/favicon","data":"# 防止favicon请求\n\n- `<link rel=\"shortcut icon\" href=\"data:image/x-icon;,\" type=\"image/x-icon\">` 可以防止favicon请求\n","children":[]}]},{"name":"html.md","path":"../guanruihua.github.io/HTML","data":"# html\n\n***\n\n## 基础标签\n\n### a标签中href和tips\n\n```html\n<a href=\"http://www.one.com\" target=\"_blank\">\n\n在HTML文档中插入ID:\n<a id=\"tips\">有用的提示部分</a>\n\n在HTML文档中创建一个链接到\"有用的提示部分(id=\"tips\"）\"：\n<a href=\"#tips\">访问有用的提示部分</a>\n\n或者，从另一个页面创建一个链接到\"有用的提示部分(id=\"tips\"）\"：\n<a href=\"http://www.one.com/html/html-links.html#tips\">访问有用的提示部分</a>\n```\n\n### table\n\n#### 第一种\n\n```html\n<table border=\"1\"> \n    <caption>标题</caption>\n    <colgroup>\n        <!--定义前两列样式-->\n        <col span=\"2\" style=\"background-color:red\">\n        <!--定义第三列的颜色-->\n        <col style=\"background-color:yellow\">\n    </colgroup>\n    <th>\n        <td>表头</td> \n        <td>表头</td>\n        <td>表头</td> \n    </th>\n    <tr> \n        <td>row 1, cell 1</td> \n        <td>row 1, cell 2</td> \n        <td>row 1, cell 3</td> \n    </tr> \n    <tr> \n        <td>row 2, cell 1</td> \n        <td>row 2, cell 2</td> \n        <td>row 2, cell 3</td> \n    </tr> \n</table>\n```\n\n#### 第二种\n\n```html\n<table border=\"1\">\n    <!--表头(页眉)-->\n    <thead>\n        <tr>\n          <th>Month</th>\n          <th>Savings</th>\n        </tr>\n    </thead>\n    <!--页脚-->\n    <tfoot>\n        <tr>\n          <td>Sum</td>\n          <td>$180</td>\n        </tr>\n    </tfoot>\n    <!--主体-->\n    <tbody>\n        <tr>\n          <td>January</td>\n          <td>$100</td>\n        </tr>\n        <tr>\n          <td>February</td>\n          <td>$80</td>\n        </tr>\n    </tbody>\n</table>\n```\n\n### 表单form\n\n```html\n<form action=\"demo_form.php\" method=\"get\">\n<!--定义围绕表单的边框-->\n<fieldset>\n\n    <!--围绕边框的标题-->\n    <legend>Personalia:</legend>\n    \n    First name: <input type=\"text\" name=\"fname\"><br>\n    <label for=\"lastName\">Last name:</label> <input type=\"text\" name=\"lname\"><br>\n    \n    <!--文本框-->\n    <textarea name=\"textContext\" rows=\"10\" cols=\"30\">\n        我是一个文本框。\n    </textarea>\n    \n    <!--选择列表-->\n    <select>\n      <optgroup label=\"Swedish Cars\">\n        <option value=\"volvo\">Volvo</option>\n        <option value=\"saab\">Saab</option>\n      </optgroup>\n      <optgroup label=\"German Cars\">\n        <option value=\"mercedes\">Mercedes</option>\n        <option value=\"audi\">Audi</option>\n      </optgroup>\n    </select>\n    \n    <!--定义选择列表-->\n    <input list=\"browsers\" name=\"browser\">\n    <datalist id=\"browsers\">\n      <option value=\"Internet Explorer\">\n      <option value=\"Firefox\">\n      <option value=\"Chrome\">\n      <option value=\"Opera\">\n      <option value=\"Safari\">\n    </datalist>\n    <input type=\"submit\" value=\"提交\">\n</fieldset>\n</form>\n```\n\n### 框架\n\n```html\n<iframe src=\"//www.baidu.com\">\n  <p>您的浏览器不支持  iframe 标签。</p>\n</iframe>\n```\n\n### 图像\n\n#### img\n\n```html\n<!--图像-->\n<img src=\"https://images.gitee.com/uploads/images/2020/0310/232238_8efc4b0b_6545143.jpeg\" alt=\"Smiley face\" width=\"42\" height=\"42\">\n```\n\n#### map(图像映射)\n\n```html\n<!--图像映射-->\n<img src=\"planets.gif\" width=\"145\" height=\"126\" alt=\"Planets\" usemap=\"#planetmap\">\n<!--定义三片区域,点击这三个区域可以实现跳转-->\n<map name=\"planetmap\">\n  <area shape=\"rect\" coords=\"0,0,82,126\" alt=\"Sun\" href=\"sun.htm\">\n  <area shape=\"circle\" coords=\"90,58,3\" alt=\"Mercury\" href=\"mercur.htm\">\n  <area shape=\"circle\" coords=\"124,58,8\" alt=\"Venus\" href=\"venus.htm\">\n</map>\n```\n\n#### canvas(通过脚本绘制图像)\n\n```html\n<canvas id=\"myCanvas\">你的浏览器不支持 HTML5 canvas 标签。</canvas>\n\n<script>\nvar c=document.getElementById('myCanvas');\nvar ctx=c.getContext('2d');\nctx.fillStyle='#FF0000';\nctx.fillRect(0,0,80,100);\n</script>\n```\n\n#### figure(通过标签与元素组合)\n\n```html\n<figure>\n  <img src=\"img_pulpit.jpg\" alt=\"The Pulpit Rock\" width=\"304\" height=\"228\">\n  <!--定义img的标题,这个是在下-->\n  <figcaption>Fig1. - A view of the pulpit rock in Norway.</figcaption>\n</figure>\n```\n\n### audio/video\n\n#### audio\n\n```html\n<audio controls>\n    <!--浏览器支持则任意一个-->\n    <source src=\"horse.ogg\" type=\"audio/ogg\">\n    <source src=\"horse.mp3\" type=\"audio/mpeg\">\n  您的浏览器不支持 audio 元素。\n</audio>\n```\n\n#### track(字幕)\n\n```html\n<video width=\"320\" height=\"240\" controls>\n    <source src=\"forrest_gump.mp4\" type=\"video/mp4\">\n    <source src=\"forrest_gump.ogg\" type=\"video/ogg\">\n    <!--定义字幕-->\n    <track src=\"subtitles_en.vtt\" kind=\"subtitles\" srclang=\"en\"\n    label=\"English\">\n    <track src=\"subtitles_no.vtt\" kind=\"subtitles\" srclang=\"no\"\n    label=\"Norwegian\">\n</video>\n\n```\n\n#### video\n\n```html\n<video width=\"320\" height=\"240\" controls>\n    <source src=\"movie.mp4\" type=\"video/mp4\">\n    <source src=\"movie.ogg\" type=\"video/ogg\">\n    您的浏览器不支持 video 标签。\n</video>\n```\n\n### 链接\n\n```html\n<a href=\"url\">访问菜鸟教程!</a>\n\n<head>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"theme.css\">\n</head>\n\n<nav>\n    <a href=\"/html/\">HTML</a> |\n    <a href=\"/css/\">CSS</a> |\n    <a href=\"/js/\">JavaScript</a> |\n    <a href=\"/jquery/\">jQuery</a>\n</nav>\n```\n\n### 列表\n\n#### 无序列表\n\n```html\n<ul>\n    <li>Coffee</li>\n    <li>Tea</li>\n    <li>Milk</li>\n</ul>\n```\n\n#### 有序列表\n\n```html\n<ol start=\"1\">\n  <li>Coffee</li>\n  <li>Tea</li>\n  <li>Milk</li>\n</ol>\n```\n\n#### 定义列表\n\n```html\n<dl>\n  <dt>Coffee</dt>\n  <!--描述-->\n  <dd>Black hot drink</dd>\n  <dt>Milk</dt>\n  <dd>White cold drink</dd>\n</dl>\n```\n\n### 文档(article)\n\n```html\n<article>\n    <header>\n        文档头部\n    </header>\n    <section>\n        文档的某个区域\n    </section>\n    <aside>\n        所处内容之外的内容\n    </aside>\n    <footer>\n        文档底部\n    </footer>\n</article>\n```\n\n### 元信息\n\n- `<head>`:定义文档的信息\n- `<meta>`:关于HTML文档的原信息\n\n```html\n<meta name=\"author\" content=\"runoob\">\n<meta charset=\"UTF-8\">\n```\n\n- `<base>`:订阅页面所有链接的默认地址或默认目标\n\n```html\n<head>\n    <base href=\"url\" target=\"_blank\">\n</head>\n```\n\n### 嵌入flash动画片\n\n`<embed src=\"helloworld.swf\">`\n\n## base标签\n\n```html\n<head>\n    <base href=\"http://example.com/here/is/my/deeply/nested/set/of/images/\">\n   <base target=\"_blank\" />//还可以定义这个a标签的超链接方式\n</head>\n\n<img src=\"/here/is/my/deeply/nested/set/of/images/example-01.jpg\" alt=\"\">\n<img src=\"/here/is/my/deeply/nested/set/of/images/example-01.jpg\" alt=\"\">\n<img src=\"/here/is/my/deeply/nested/set/of/images/example-03.jpg\" alt=\"\">\n//就可以改成下面\n<img src=\"example-01.jpg\" alt=\"\">\n<img src=\"example-01.jpg\" alt=\"\">\n<img src=\"example-03.jpg\" alt=\"\">\n\n```\n","children":[]},{"name":"html5.md","path":"../guanruihua.github.io/HTML","data":"# HTML5\n\n## 表单\n\n### 输入类型\n\n#### email\n\n`E-mail: <input type=\"email\" name=\"user_email\" />`\n\n> ==验证email域==的值\n\n#### url\n\n`Homepage: <input type=\"url\" name=\"user_url\" />`\n\n> ==验证url域==的值\n\n#### number\n\n`Points: <input type=\"number\" name=\"points\" min=\"1\" max=\"10\" />`\n\n> 限制接受数字的范围\n>\n> max:最大值; min:最小值; step:间隔; value:默认值;\n\n#### range\n\n`<input type=\"range\" name=\"points\" min=\"1\" max=\"10\" />`\n\n> 包含一定范围数字值的输入域(类型为滑动条)\n\n#### Date pickers(date, month, week, time, datetime, datetime-local )(日期选择器)\n\n```html\nDate: <input type=\"date\" name=\"user_date\" />\n```\n\n> - date - 选取日、月、年\n> - month - 选取月、年\n> - week - 选取周和年\n> - time - 选取时间（小时和分钟）\n> - datetime - 选取时间、日、月、年（UTC 时间）\n> - datetime-local - 选取时间、日、月、年（本地时间）\n\n#### search\n\n> search 类型用于搜索域，比如站点搜索或 Google 搜索。\n>\n> search 域显示为常规的文本域。\n\n#### color\n\n> 选颜色\n\n### 表单元素\n\n#### datalist\n\n> datalist 元素规定输入域的选项列表。\n>\n> 列表是通过 datalist 内的 option 元素创建的。\n>\n> 如需把 datalist 绑定到输入域，请用输入域的 list 属性引用 datalist 的 id\n>\n> option里面的value一定要设置属性\n\n```html\nWebpage: <input type=\"url\" list=\"url_list\" name=\"link\" />\n<datalist id=\"url_list\">\n  <option label=\"W3School\" value=\"http://www.W3School.com.cn\" />\n  <option label=\"Google\" value=\"http://www.google.com\" />\n  <option label=\"Microsoft\" value=\"http://www.microsoft.com\" />\n</datalist>\n```\n\n#### keygen\n\n> keygen 元素的作用是提供一种验证用户的可靠方法。\n>\n> keygen 元素是密钥对生成器（key-pair generator）。当提交表单时，会生成两个键，一个是私钥，一个公钥。\n>\n> 私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。\n>\n> 目前，==浏览器对此元素的糟糕的支持度不足以使其成为一种有用的安全标准==。\n\n```html\n<form action=\"demo_form.asp\" method=\"get\">\n  Username: <input type=\"text\" name=\"usr_name\" />\n  Encryption: <keygen name=\"security\" />\n  <input type=\"submit\" />\n</form>\n```\n\n#### output\n\n> output 元素用于不同类型的输出，比如计算或脚本输出：\n\n<!DOCTYPE HTML>\n<html>\n<head>\n<script type=\"text/javascript\">\nfunction resCalc()\n{\nnumA=document.getElementById(\"num_a\").value;\nnumB=document.getElementById(\"num_b\").value;\ndocument.getElementById(\"result\").value=Number(numA)+Number(numB);\n}\n</script>\n</head>\n<body>\n<p>使用 output 元素的简易计算器：</p>\n<form onsubmit=\"return false\">\n <input id=\"num_a\" /> +\n <input id=\"num_b\" /> =\n <output id=\"result\" onforminput=\"resCalc()\"></output>\n</form>\n  </body>\n</html>\n### 表单属性\n\n#### 新的 form 属性\n\n##### autocomplete\n\n- > 相当于有记忆功能\n  >\n  > 适用于:<input> 标签：text, search, url, telephone, email, password, datepickers, range 以及 color。\n\n```html\n<form action=\"/example/html5/demo_form.asp\" method=\"get\" autocomplete=\"on\">\nFirst name:<input type=\"text\" name=\"fname\" /><br />\nLast name: <input type=\"text\" name=\"lname\" /><br />\nE-mail: <input type=\"email\" name=\"email\" autocomplete=\"off\" /><br />\n<input type=\"submit\" />\n</form>\n\n<p>请填写并提交此表单，然后重载页面，来查看自动完成功能是如何工作的。</p>\n<p>请注意，表单的自动完成功能是打开的，而 e-mail 域是关闭的。</p>\n```\n\n##### novalidate\n\n> novalidate 属性规定在提交表单时不应该验证 form 或 input 域。\n\n#### 新的 input 属性\n\n##### autofocus\n\n> 页面加载时,自动获得焦点\n\n```html\nUser name: <input type=\"text\" name=\"user_name\"  autofocus=\"autofocus\" />\n```\n\n##### form\n\n```html\n<form action=\"demo_form.asp\" method=\"get\" id=\"user_form\">\nFirst name:<input type=\"text\" name=\"fname\" />\n<input type=\"submit\" />\n</form>\n//这个不在form里面,但是form属性指向的form的id,可以把它和form标签绑定\nLast name: <input type=\"text\" name=\"lname\" form=\"user_form\" />\n```\n\n- 表单重写属性form overrides (formaction, formenctype, formmethod, formnovalidate, formtarget)\n\n  - formaction - 重写表单的 action 属性\n  - formenctype - 重写表单的 enctype 属性\n  - formmethod - 重写表单的 method 属性\n  - formnovalidate - 重写表单的 novalidate 属性\n  - formtarget - 重写表单的 target 属性\n\n  ```html\n  <form action=\"/example/html5/demo_form.asp\" method=\"get\" id=\"user_form\">\n      E-mail: <input type=\"email\" name=\"userid\" /><br />\n      <input type=\"submit\" value=\"Submit\" /><br />\n      <input type=\"submit\" formaction=\"/example/html5/demo_admin.asp\" value=\"Submit as admin\" /><br />\n      <input type=\"submit\" formnovalidate=\"true\" value=\"Submit without validation\" /><br />\n  </form>\n  ```\n\n##### height 和 width\n\n> height 和 width 属性只适用于 image 类型的 <input> 标签。\n\n```html\n<input type=\"image\" src=\"img_submit.gif\" width=\"99\" height=\"99\" />\n```\n\n##### list\n\n> 通过list属性实现和datalist绑定\n\n```html\n<form action=\"/example/html5/demo_form.asp\" method=\"get\">\nWebpage: <input type=\"url\" list=\"url_list\" name=\"link\" />\n<datalist id=\"url_list\">\n <option label=\"W3School\" value=\"http://www.w3school.com.cn\" />\n <option label=\"Google\" value=\"http://www.google.com\" />\n <option label=\"Microsoft\" value=\"http://www.microsoft.com\" />\n</datalist>\n<input type=\"submit\" />\n</form>\n```\n\n##### multiple\n\n> 可以选择多个文件\n\n```html\n <input type=\"file\" name=\"img\" multiple=\"multiple\" />\n```\n\n##### pattern (regexp)\n\n> pattern 属性规定用于验证 input 域的模式（pattern）。\n\n```html\n <input type=\"text\" name=\"country_code\"\npattern=\"[A-z]{3}\" title=\"Three letter country code\" />\n```\n\n##### placeholder\n\n> 提示输入值\n\n##### required\n\n>required 属性规定必须在提交之前填写输入域（不能为空）。\n\n```html\nName: <input type=\"text\" name=\"usr_name\" required=\"required\" />\n```\n\n## 视频/DOM\n\n### video支持的视频格式\n\n> - Ogg = 带有 Theora 视频编码和 Vorbis 音频编码的 Ogg 文件\n> - MPEG4 = 带有 H.264 视频编码和 AAC 音频编码的 MPEG 4 文件\n> - WebM = 带有 VP8 视频编码和 Vorbis 音频编码的 WebM 文件\n\n| 属性                                                         | 值       | 描述                                                         |\n| :----------------------------------------------------------- | :------- | :----------------------------------------------------------- |\n| [autoplay](https://www.w3school.com.cn/tags/att_video_autoplay.asp) | autoplay | 如果出现该属性，则视频在就绪后马上播放。                     |\n| [controls](https://www.w3school.com.cn/tags/att_video_controls.asp) | controls | 如果出现该属性，则向用户显示控件，比如播放按钮。             |\n| [height](https://www.w3school.com.cn/tags/att_video_height.asp) | *pixels* | 设置视频播放器的高度。                                       |\n| [loop](https://www.w3school.com.cn/tags/att_video_loop.asp)  | loop     | 如果出现该属性，则当媒介文件完成播放后再次开始播放。         |\n| [preload](https://www.w3school.com.cn/tags/att_video_preload.asp) | preload  | 如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 \"autoplay\"，则忽略该属性。 |\n| [src](https://www.w3school.com.cn/tags/att_video_src.asp)    | *url*    | 要播放的视频的 URL。                                         |\n| [width](https://www.w3school.com.cn/tags/att_video_width.asp) | *pixels* | 设置视频播放器的宽度。                                       |\n\n```html\n<video width=\"320\" height=\"240\" controls=\"controls\">\n  <source src=\"movie.ogg\" type=\"video/ogg\">\n  <source src=\"movie.mp4\" type=\"video/mp4\">\n Your browser does not support the video tag.\n</video>\n```\n\n### Video + DOM\n\n```html\n<div style=\"text-align:center;\">\n  <button onclick=\"playPause()\">播放/暂停</button> \n  <button onclick=\"makeBig()\">大</button>\n  <button onclick=\"makeNormal()\">中</button>\n  <button onclick=\"makeSmall()\">小</button>\n  <br /> \n  <video id=\"video1\" width=\"420\" style=\"margin-top:15px;\">\n    <source src=\"/example/html5/mov_bbb.mp4\" type=\"video/mp4\" />\n    <source src=\"/example/html5/mov_bbb.ogg\" type=\"video/ogg\" />\n    Your browser does not support HTML5 video.\n  </video>\n</div> \n\n<script type=\"text/javascript\">\nvar myVideo=document.getElementById(\"video1\");\n\nfunction playPause(){ \n  if (myVideo.paused) \n    myVideo.play(); \n  else \n    myVideo.pause(); \n} \n\nfunction makeBig(){ \n myVideo.width=560; \n} \n\nfunction makeSmall(){ \n myVideo.width=320; \n} \n\nfunction makeNormal(){ \n myVideo.width=420; \n} \n</script> \n\n```\n\n#### HTML5 <video> - 方法、属性以及事件\n\n下面列出了大多数浏览器支持的视频方法、属性和事件：\n\n| 方法        | 属性        | 事件           |\n| :---------- | :---------- | :------------- |\n| play()      | currentSrc  | play           |\n| pause()     | currentTime | pause          |\n| load()      | videoWidth  | progress       |\n| canPlayType | videoHeight | error          |\n|             | duration    | timeupdate     |\n|             | ended       | ended          |\n|             | error       | abort          |\n|             | paused      | empty          |\n|             | muted       | emptied        |\n|             | seeking     | waiting        |\n|             | volume      | loadedmetadata |\n|             | height      |                |\n|             | width       |                |\n\n**注释：**在所有属性中，只有 videoWidth 和 videoHeight 属性是立即可用的。在视频的元数据已加载后，其他属性才可用。\n\n## 音频\n\n```html\n<audio controls=\"controls\">\n  <source src=\"song.ogg\" type=\"audio/ogg\">\n  <source src=\"song.mp3\" type=\"audio/mpeg\">\nYour browser does not support the audio tag.\n</audio>\n```\n\n### <audio> 标签的属性\n\n| 属性                                                         | 值       | 描述                                                         |\n| :----------------------------------------------------------- | :------- | :----------------------------------------------------------- |\n| [autoplay](https://www.w3school.com.cn/tags/att_audio_autoplay.asp) | autoplay | 如果出现该属性，则音频在就绪后马上播放。                     |\n| [controls](https://www.w3school.com.cn/tags/att_audio_controls.asp) | controls | 如果出现该属性，则向用户显示控件，比如播放按钮。             |\n| [loop](https://www.w3school.com.cn/tags/att_audio_loop.asp)  | loop     | 如果出现该属性，则每当音频结束时重新开始播放。               |\n| [preload](https://www.w3school.com.cn/tags/att_audio_preload.asp) | preload  | 如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用 \"autoplay\"，则忽略该属性。 |\n| [src](https://www.w3school.com.cn/tags/att_audio_src.asp)    | *url*    | 要播放的音频的 URL。                                         |\n\n## 拖放\n\n> 抓取对象然后拖到另一个位置\n\n```html\n<!DOCTYPE HTML>\n<html>\n  <head>\n    <style type=\"text/css\">\n    #div1 {\n      width:198px;  \n      height:66px;\n      padding:10px;\n      border:1px solid #aaaaaa;\n    }\n    </style>\n    <script type=\"text/javascript\">\n    function allowDrop(ev){\n      //消除默认动作\n      ev.preventDefault();\n    }\n\n    function drag(ev){\n      //设置拖放元素的数据类型和值\n      //类型为\"Text\"\n      //元素的id(\"drag1\")\n      ev.dataTransfer.setData(\"Text\",ev.target.id);\n    }\n\n    function drop(ev){\n       ev.preventDefault();\n       var data=ev.dataTransfer.getData(\"Text\");         ev.target.appendChild(\n         document.getElementById(data));\n     }\n  </script>\n  </head>\n<body>\n\n<div \n     id=\"div1\"    \n     ondrop=\"drop(event)\"<!--放置被拖数据时，会发生 drop 事件-->\n     ondragover=\"allowDrop(event)\"<!--规定拖放到的数据-->\n     ></div>\n<img \n     id=\"drag1\" \n     src=\"img_logo.gif\" \n     draggable=\"true\" <!--是元素可以拖动-->\n     ondragstart=\"drag(event)\" \n     width=\"336\" height=\"69\"/>\n</body>\n</html>\n```\n\n## 画布\n\n### 创建Canvas\n\n```html\n<canvas id=\"myCanvas\" width=\"200\" height=\"100\">\n Your browser does not support the canvas elemen \n</canvas>\n```\n\n### 通过javaScript绘制\n\n#### 绘制矩形\n\n![](https://images.gitee.com/uploads/images/2020/0521/153506_a30b3390_6545143.png)\n\n```html\n<script type=\"text/javascript\">\n  var c=document.getElementById(\"myCanvas\");\n  var cxt=c.getContext(\"2d\");\n  cxt.fillStyle=\"#FF0000\";//设置画笔的颜色\n  cxt.fillRect(0,0,150,75);//绘制\n</script>\n```\n\n#### 绘制线条\n\n![](https://images.gitee.com/uploads/images/2020/0521/153518_417dc519_6545143.png)\n\n```html\n<script type=\"text/javascript\">\n  var c=document.getElementById(\"myCanvas\");\n  var cxt=c.getContext(\"2d\");\n  cxt.moveTo(10,10);\n  cxt.lineTo(150,50);\n  cxt.lineTo(10,50);\n  cxt.stroke();\n</script>\n```\n\n#### 圆形\n\n![](https://images.gitee.com/uploads/images/2020/0521/153530_441f2afe_6545143.png)\n\n```html\n<script type=\"text/javascript\">\n  var c=document.getElementById(\"myCanvas\");\n  var cxt=c.getContext(\"2d\");\n  cxt.fillStyle=\"#FF0000\";\n  cxt.beginPath();\n  cxt.arc(70,18,15,0,Math.PI*2,true);\n  cxt.closePath();\n  cxt.fill();\n</script>\n```\n\n#### 渐变\n\n![](https://images.gitee.com/uploads/images/2020/0521/153702_738cd56b_6545143.png)\n\n```html\n<script type=\"text/javascript\">\n  var c=document.getElementById(\"myCanvas\");\n  var cxt=c.getContext(\"2d\");\n  var grd=cxt.createLinearGradient(0,0,175,50);\n  grd.addColorStop(0,\"#FF0000\");\n  grd.addColorStop(1,\"#00FF00\");\n  cxt.fillStyle=grd;\n  cxt.fillRect(0,0,175,50);\n</script>\n```\n\n#### 图像\n\n![](https://images.gitee.com/uploads/images/2020/0521/153826_63883e4b_6545143.png)\n\n## SVG\n\n#### 简介\n\n> - SVG 指可伸缩矢量图形 (Scalable Vector Graphics)\n> - SVG 用于定义用于网络的基于矢量的图形\n> - SVG 使用 XML 格式定义图形\n> - SVG 图像在放大或改变尺寸的情况下其图形质量不会有损失\n> - SVG 是万维网联盟的标准\n\n#### 优点\n\n> 与其他图像格式相比（比如 JPEG 和 GIF），使用 SVG 的优势在于：\n>\n> - SVG 图像可通过文本编辑器来创建和修改\n> - SVG 图像可被搜索、索引、脚本化或压缩\n> - SVG 是可伸缩的\n> - SVG 图像可在任何的分辨率下被高质量地打印\n> - SVG 可在图像质量不下降的情况下被放大\n\n```html\n<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" height=\"190\">\n  <polygon points=\"100,10 40,180 190,60 10,60 160,180\"\n  style=\"fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;\" />\n</svg>\n```\n\n![](https://images.gitee.com/uploads/images/2020/0521/160322_cf31cb9f_6545143.png)\n\n## 画布vsSVG\n\n#### SVG\n\n> SVG 是一种使用 XML 描述 2D 图形的语言。\n>\n> SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。\n>\n> 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。\n\n> - 不依赖分辨率\n> - 支持事件处理器\n> - 最适合带有大型渲染区域的应用程序（比如谷歌地图）\n> - 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）\n> - 不适合游戏应用\n\n#### Canvas\n\n> Canvas 通过 JavaScript 来绘制 2D 图形。\n>\n> Canvas 是逐像素进行渲染的。\n>\n> 在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。\n\n> - 依赖分辨率\n> - 不支持事件处理器\n> - 弱的文本渲染能力\n> - 能够以 .png 或 .jpg 格式保存结果图像\n> - 最适合图像密集型的游戏，其中的许多对象会被频繁重绘\n\n## Web存储\n\n> 客户端存储数据的新方法：\n>\n> - localStorage - 没有时间限制的数据存储\n> - sessionStorage - 针对一个 session 的数据存储\n\n#### localStorage\n\n> localStorage 方法存储的数据==没有时间限制==。第二天、第二周或下一年之后，数据依然可用。\n\n```html\n<script type=\"text/javascript\">\n  localStorage.lastname=\"Smith\";\n  document.write(localStorage.lastname);\n</script>\n```\n\n#### sessionStorage\n\n> sessionStorage 方法针对一个 session 进行数据存储。当用户==关闭浏览器窗口后，数据会被删除==。\n\n```html\n<script type=\"text/javascript\">\n  sessionStorage.lastname=\"Smith\";\n  document.write(sessionStorage.lastname);\n</script>\n```\n\n## 应用缓存(Application Cache)\n\n> - 离线浏览 - 用户可在应用离线时使用它们\n> - 速度 - 已缓存资源加载得更快\n> - 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源\n\n```html\n<!DOCTYPE HTML>\n<html manifest=\"demo.appcache\">\n\n<body>\nThe content of the document......\n</body>\n\n</html>\n```\n\n> manifest 文件需要配置*正确的 MIME-type*，即 \"text/cache-manifest\"。必须在 web 服务器上进行配置\n\n#### Manifest文件\n\n> manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）\n>\n> manifest 文件可分为三个部分：\n>\n> - *CACHE MANIFEST* - 在此标题下列出的文件将在首次下载后进行缓存\n> - *NETWORK* - 在此标题下列出的文件需要与服务器的连接，且不会被缓存\n> - *FALLBACK* - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）\n\n##### CACHE MANIFEST(必需)\n\n> 文件会被缓存\n\n```txt\nCACHE MANIFEST\n/theme.css\n/logo.gif\n/main.js\n```\n\n##### *NETWORK*\n\n> 文件永远不会被缓存\n\n```txt\nNETWORK:\nlogin.asp\n\n或\nNETWORK:\n*\n#代表所有资源文件\n```\n\n##### *FALLBACK*\n\n> 规定如果无法建立因特网连接，则用 \"404.html\" 替代 /html5/ 目录中的所有文件：\n\n```txt\nFALLBACK:\n/html5/ /404.html\n```\n\n##### 更新缓存\n\n一旦应用被缓存，它就会保持缓存直到发生下列情况：\n\n- 用户清空浏览器缓存\n- manifest 文件被修改（参阅下面的提示）\n- 由程序来更新应用缓存\n\n##### Manifest 文件\n\n```txt\nCACHE MANIFEST\n# 2012-02-21 v1.0.0\n/theme.css\n/logo.gif\n/main.js\n\nNETWORK:\nlogin.asp\n\nFALLBACK:\n/html5/ /404.html\n```\n\n> **重要的提示：**以 \"#\" 开头的是注释行，但也可满足其他用途。应用的缓存会在其 manifest 文件更改时被更新。如果您编辑了一幅图片，或者修改了一个 JavaScript 函数，这些改变都不会被重新缓存。==更新注释行中的日期和版本号是一种使浏览器重新缓存文件的办法==。\n\n##### 关于应用程序缓存的注释\n\n请留心缓存的内容。\n\n一旦文件被缓存，则浏览器会继续展示已缓存的版本，即使您修改了服务器上的文件。为了确保浏览器更新缓存，您需要更新 manifest 文件。\n\n**注释：**浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。\n\n## Web Workers\n\n#### 简介\n\n>当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。\n\n> web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。\n\ndemo_worker.js\n\n```js\nvar i=0;\nfunction timedCount(){\n  i=i+1;\n  postMessage(i);\n  setTimeout(\"timedCount()\",500);\n}\n\ntimedCount();\n```\n\n```html\n<!DOCTYPE html>\n<html>\n<body>\n<p>Count numbers: <output id=\"result\"></output></p>\n<button onclick=\"startWorker()\">Start Worker</button>\n<button onclick=\"stopWorker()\">Stop Worker</button>\n<br /><br />\n\n<script>\nvar w;\nfunction startWorker(){\n  <!-- 检测是否支持Worker-->\nif(typeof(Worker)!==\"undefined\"){\n  if(typeof(w)==\"undefined\"){\n    w=new Worker(\"demo_workers.js\");\n    }\n  w.onmessage = function (event) {\n  document.getElementById(\"result\").innerHTML=event.data;\n  };\n}\nelse{\ndocument.getElementById(\"result\").innerHTML=\"Sorry, your browser\n does not support Web Workers...\";\n}\n}\n\nfunction stopWorker(){\nw.terminate();\n}\n</script>\n</body>\n</html>\n```\n\n## 服务器发送事件(**server-sent event**)\n\n> Server-Sent 事件指的是网页自动获取来自服务器的更新\n\n## 检测 Server-Sent 事件支持\n\n```js\nif(typeof(EventSource)!==\"undefined\"){\n  // Yes! Server-sent events support!\n  // Some code.....\n  }else{\n  // Sorry! No server-sent events support..\n  }\n```\n\n### 接收Server-Sent事件通知\n\n```js\nvar source=new EventSource(\"demo_sse.php\");\nsource.onmessage=function(event){\n  document.getElementById(\"result\").innerHTML+=event.data + \"<br />\";\n  };\n```\n\n> - 创建一个新的 EventSource 对象，然后规定发送更新的页面的 URL（本例中是 \"demo_sse.php\"）\n> - 每接收到一次更新，就会发生 onmessage 事件\n> - 当 onmessage 事件发生时，把已接收的数据推入 id 为 \"result\" 的元素中\n\n### EventSource 对象\n\n在上面的例子中，我们使用 onmessage 事件来获取消息。不过还可以使用其他事件：\n\n| 事件      | 描述                     |\n| :-------- | :----------------------- |\n| onopen    | 当通往服务器的连接被打开 |\n| onmessage | 当接收到消息             |\n| onerror   | 当错误发生               |\n","children":[]},{"name":"img.md","path":"../guanruihua.github.io/HTML","data":"# Img\n\n## 判断src是否有效\n\n- 通过onError事件来处理:\n\n- `<img src='url1' onError='imageError(this)'/>` `imageError是自定义的方法`\n\n ```js\n function imgerror(img){\n  img.src=\"images/default.jpg\";\n  img.οnerrοr=null;  //控制不要一直跳动\n }\n ```\n\n```js\nif(pic==null){\n  html='<img src=\"images/bg_test1.jpg\" width=\"320\" height=\"157\" />';\n}else{\n html='<img src=\"'+pic+'\" width=\"320\" height=\"157\" οnerrοr=\"imgerror(this)\" />';\n}\n\n\nfunction imgerror(img){\n img.src=\"images/default.jpg\";\n img.οnerrοr=null;   //控制不要一直跳动\n}\n```\n","children":[]},{"name":"meta.md","path":"../guanruihua.github.io/HTML","data":"# html meta属性（set-cookie和cache)\n\n- HTTP-EQUIV类似于HTTP的头部协议，它回应给浏览器一些有用的信息，以帮助正确和精确地显示网页内容。常用的HTTP-EQUIV类型有：\n\n## Content-Type和Content-Language （显示字符集的设定）\n\n- 设定页面使用的字符集，用以说明主页制作所使用的文字已经语言，浏览器会根据此来调用相应的字符集显示page内容。\n\n用法：\n\n```html\n<Meta http-equiv=\"Content-Type\" Content=\"text/html; Charset=gb2312\">\n<Meta http-equiv=\"Content-Language\" Content=\"zh-CN\">\n```\n\n- 注意：该META标签定义了HTML页面所使用的字符集为GB2132，就是国标汉字码。如果将其中的“charset=GB2312”替换成“BIG5”，则该页面所用的字符集就是繁体中文Big5码。当你浏览一些国外的站点时，IE浏览器会提示你要正确显示该页面需要下载xx语支持。这个功能就是通过读取HTML页面META标签的Content-Type属性而得知需要使用哪种字符集显示该页面的。如果系统里没有装相应的字符集，则IE就提示下载。其他的语言也对应不同的charset，比如日文的字符集是“iso-2022-jp ”，韩文的是“ks_c_5601”。\n\n- `Content-Type`的`Content`还可以是：`text/xml`等文档类型；\n\nCharset选项：ISO-8859-1（英文）、BIG5、UTF-8、SHIFT-Jis、Euc、Koi8-2、us-ascii， x-mac-roman， iso-8859-2， x-mac-ce， iso-2022-jp， x-sjis， x-euc-jp，euc-kr， iso-2022-kr， gb2312， gb_2312-80， x-euc-tw， x-cns11643-1，x-cns11643-2等字符集；Content-Language的Content还可以是：EN、FR等语言代码。\n\n## Refresh （刷新)\n\n- 让网页多长时间（秒）刷新自己，或在多长时间后让网页自动链接到其它网页。\n\n用法：\n\n```html\n<Meta http-equiv=\"Refresh\" Content=\"30\">\n<Meta http-equiv=\"Refresh\" Content=\"5; Url=http://www.xia8.net\">\n```\n\n- 注意：其中的5是指停留5秒钟后自动刷新到URL网址。\n\n## Expires （期限)\n\n- 指定网页在缓存中的过期时间，一旦网页过期，必须到服务器上重新调阅。\n\n用法：\n\n```html\n<Meta http-equiv=\"Expires\" Content=\"0\">\n<Meta http-equiv=\"Expires\" Content=\"Wed, 26 Feb 1997 08:21:57 GMT\">\n```\n\n注意：必须使用GMT的时间格式，或直接设为0（数字表示多少时间后过期）。\n\n## Pragma （cach模式）\n\n说明：禁止浏览器从本地机的缓存中调阅页面内容。\n\n用法：\n\n注意：网页不保存在缓存中，每次访问都刷新页面。这样设定，访问者将无法脱机浏览。\n\n## Set-Cookie （cookie设定）\n\n- 浏览器访问某个页面时会将它存在缓存中，下次再次访问时就可从缓存中读取，以提高速度。\n- 当你希望访问者每次都刷新你广告的图标，或每次都刷新你的计数器，就要禁用缓存了。\n- 通常HTML文件没有必要禁用缓存，对于ASP等页面，就可以使用禁用缓存，因为每次看到的页面都是在服务器动态生成的，缓存就失去意义。如果网页过期，那么存盘的cookie将被删除。\n\n用法：\n\n```html\n<Meta http-equiv=\"Set-Cookie\" Content=\"cookievalue=xxx; expires=Wednesday,21-Oct-98 16:14:21 GMT; path=/\">\n```\n\n注意：必须使用GMT的时间格式。\n\n## Window-target （显示窗口的设定）\n\n- 强制页面在当前窗口以独立页面显示。\n\n用法：\n\n```html\n<Meta http-equiv=\"Widow-target\" Content=\"_top\">\n```\n\n注意：这个属性是用来防止别人在框架里调用你的页面。Content选项：_blank、_top、_self、_parent.\n\n## Pics-label （网页RSAC等级评定）\n\n> 在IE的Internet选项中有一项内容设置，可以防止浏览一些受限制的网站，而网站的限制级别就是通过该参数来设置的。\n\n用法：\n\n```html\n<META http-equiv=\"Pics-label\" Contect=\"(PICS－1.1'http://www.rsac.org/ratingsv01.html'I gen comment 'RSACi North America Sever' by 'inet@microsoft.com'for 'http://www.microsoft.com' on '1997.06.30T14:21－0500' r(n0 s0 v0 l0))\">\n```\n\n注意：不要将级别设置的太高。RSAC的评估系统提供了一种用来评价Web站点内容的标准。用户可以设置Microsoft Internet Explorer（IE3.0以上）来排除包含有色情和暴力内容的站点。上面这个例子中的HTML取自Microsoft的主页。代码中的（n 0 s 0 v 0 l 0）表示该站点不包含不健康内容。级别的评定是由RSAC，即美国娱乐委员会的评级机构评定的，如果你想进一步了解RSAC评估系统的等级内容，或者你需要评价自己的网站，可以访问RSAC的站点：<http://www.rsac.org/>.\n\n## Page-Enter、Page-Exit （进入与退出）\n\n- 这个是页面被载入和调出时的一些特效。\n\n用法：\n\n```html\n<Meta http-equiv=\"Page-Enter\" Content=\"blendTrans(Duration=0.5)\">\n<Meta http-equiv=\"Page-Exit\" Content=\"blendTrans(Duration=0.5)\">\n```\n","children":[]},{"name":"README.md","path":"../guanruihua.github.io/HTML","data":"# [ruihuag](https://guanruihua.github.io/#/)\r\n\r\n<!-- ![](../__assets__/001.jpg) -->\r\n<!-- ![Metrics](https://metrics.lecoq.io/guanruihua?template=classic&isocalendar=1&languages=1&base=header%2C%20activity%2C%20community%2C%20repositories%2C%20metadata&base.indepth=false&base.hireable=false&base.skip=false&isocalendar=false&isocalendar.duration=half-year&languages=false&languages.limit=8&languages.threshold=0%25&languages.other=false&languages.colors=github&languages.sections=most-used&languages.indepth=false&languages.analysis.timeout=15&languages.categories=markup%2C%20programming&languages.recent.categories=markup%2C%20programming&languages.recent.load=300&languages.recent.days=14&config.timezone=Asia%2FShanghai) -->\r\n","children":[]},{"name":"script.md","path":"../guanruihua.github.io/HTML","data":"\n# script标签\n\n>   1. async 属性: 表示立即下载脚本，但不会影响页面的其他操作。[规定脚本将被异步执行], 只适合外部脚本, 下载完成后立即执行\n>   2. charset 属性: 规定在外部脚本把文件中使用的编码不同。\n>   3. defer 属性: 表示脚本可以延迟到文档被解析和显示之后再执行。只有对外部脚本有效。立即下载, 但是延迟执行\n>   4. src 属性: 表示包含要执行代码的外部文件。\n>   5. type 属性: 规定了脚本的MIME属性[内容属性]\n>   6. language 属性: 已废弃。\n\n## 异步加载\n\n```html\n<script src=\"...\" async><script>\n```\n\n## 延迟加载\n\n```html\n<script src = '' defer></script>\n```\n","children":[]},{"name":"svg.md","path":"../guanruihua.github.io/HTML","data":"# svg\n\n> 特点: 无论怎么样放大都不会失真\n>\n> [地图数据 (hcharts.cn)](https://img.hcharts.cn/mapdata/index.html)\n>\n> <https://img.hcharts.cn/mapdata/custom/world-robinson.geo.json>\n>\n> 默认填充颜色是黑色(没有设置fill属性时)\n>\n> 每一个线和图都可以分别指定class\n>\n> [SVG教程 - SVG | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial)\n\n## 使用方式\n\n1. `svg`标签 : `<svg>...</svg>`\n2. `img`标签 : `<img scr='文件名.svg'/>`\n3. `iframe`标签  : `<iframe src='文件名.svg'></iframe>`\n4. `object` 标签:  `<object data='文件名.svg' type='image/svg+xml>`\n5. `embed`标签: `<embed src='文件名.svg' type='image/svg+xml'>`\n\n## 属性\n\n- 宽度  width\n- 高度 height\n- css样式 style\n- 填充色 fill\n- 边框颜色 stroke\n- 边框宽度 stroke-width\n- 边框首尾 stroke-linecap\n- 线条样式 stroke-dasharray (需要填写线条宽度以及线条间隙  依据顺序填写一个循环)\n- 线条每一段的起始偏移量 stroke-dashoffet\n- 填充透明度 fill-opacity\n- 边框 stroke-opacity\n- 图形填充规则 fill-rule （nonzero evenodd）\n- 动作 transform （中心点为图像左上角,并且只支持2d变换\n\n- translate(10 ,10 ) or translate(10 10)\n- rotate(20) or rotate(20 , x  y)    x,y为旋转中心点 并且只能是默认deg单位\n- scale(x , y)\n\n## 基础语法\n\n> SVG默认 : 300px(宽)*150px(高)\n\n```html\n<svg width='100%' height='100%'>\n    <circle id=\"mycircle\" cx=\"50\" cy=\"50\" r='50' fill='red'></circle>\n</svg>\n```\n\n<svg width='100px' height='100px'>\n    <circle id=\"mycircle\" cx=\"50\" cy=\"50\" r='50' fill='red'></circle>\n</svg>\n\n### viewbox指定视图\n\n> `viewbox='50 50 50 50'`:前两是**横纵坐标**, 后两个数字是视图**高**和**宽**\n\n```html\n<svg width='100px' height='100px' viewbox='50 50 50 50'>\n    <circle id=\"mycircle\" cx=\"50\" cy=\"50\" r='50' fill='red'></circle>\n</svg>\n```\n\n<svg width='100px' height='100px' viewbox='50 50 50 50'>\n    <circle id=\"mycircle\" cx=\"50\" cy=\"50\" r='50' fill='red'></circle>\n</svg>\n### 圆圈`circle`\n\n> 画圆圈\n>\n> 可以通过class指定样式\n>\n> fill : 设置填充颜色\n>\n> stroke : 描边颜色\n>\n> stroke-width : 描边宽度\n\n```html\n<svg width='320' height='106'>\n  <circle id=\"mycircle\" cx=\"50\" cy=\"50\" r='50'  fill='red'></circle>\n <circle id=\"mycircle\" cx=\"160\" cy=\"53\" r='50' fill='pink' style=\"stroke: red; stroke-width: 3px;\"></circle>\n <circle id=\"mycircle\" cx=\"270\" cy=\"50\" r='50' fill='yellow'></circle>\n</svg>\n```\n\n<svg width='320' height='106'>\n  <circle id=\"mycircle\" cx=\"50\" cy=\"50\" r='50'  fill='red'></circle>\n <circle id=\"mycircle\" cx=\"160\" cy=\"53\" r='50' fill='pink' style=\"stroke: red; stroke-width: 3px;\"></circle>\n <circle id=\"mycircle\" cx=\"270\" cy=\"50\" r='50' fill='yellow'></circle>\n</svg>\n### 直线`line` & 折线 `polyline`\n\n> 绘制直线\n>\n> 设置两个坐标后, 然后设置stroke\n\n```html\n<svg width='200' height='83' >\n <line x1='10' y1='10' x2='10' y2='75' style=\"stroke:pink; stroke-width: 5px;\"></line>\n  <polyline points=\"40,40 40,80 120,80\" style=\"stroke:red; stroke-width: 2px;fill:none;\"></polyline>\n</svg>\n```\n\n<svg width='200' height='83' >\n <line x1='10' y1='10' x2='10' y2='75' style=\"stroke:pink; stroke-width: 5px;\"></line>\n  <polyline points=\"40,40 40,80 120,80\" style=\"stroke:red; stroke-width: 2px;fill:none;\"></polyline>\n</svg>\n### 矩形`rect`\n\n> 指定一个坐标和宽度和高度\n\n```html\n<svg width='300' height='180'>\n  <rect x='0' y='0' height='180' width='200' style=\"stroke: pink; fill:none; stroke-width: 3px;\"/>\n</svg>\n```\n\n<svg width='300' height='180'>\n  <rect x='0' y='0' height='180' width='200' style=\"stroke: pink; fill:none; stroke-width: 3px;\"/>\n</svg>\n\n### 椭圆ellipse\n\n> 指定圆心, 再指定水平宽度, 和垂直宽度\n\n```html\n<svg width='100' height='120'>\n  <ellipse cx='60' cy='60' rx='20' ry='40' style=\"fill: none;stroke: pink; stroke-width: 2px;\"></ellipse>\n</svg>\n```\n\n<svg width='100' height='120'>\n  <ellipse cx='60' cy='60' rx='20' ry='40' style=\"fill: none;stroke: pink; stroke-width: 2px;\"></ellipse>\n</svg>\n### 多边形`polygon`\n\n> 指定多个断点的坐标\n\n```html\n<svg width='400' height='400'>\n  <polygon points=\"50,50 200,180 150,250 100,200 50,50\" style=\"fill: none; stroke: pink; stroke-width: 2px;\"></polygon>\n</svg>\n```\n\n<svg width='400' height='300'>\n  <polygon points=\"50,50 200,180 150,250 100,200 50,50\" style=\"fill: none; stroke: pink; stroke-width: 2px;\"></polygon>\n</svg>\n\n### 绘制路径`path`\n\n> M : 移动到(moveto)\n>\n> L : 画直线(lineto)\n>\n> Z :  闭合路径\n\n- M = moveto    移动画笔\n- L = lineto  画线\n- H = horizontal lineto  水平线\n- V = vertical lineto 垂直线\n- C = curveto 曲线\n- S = smooth curveto 光滑曲线\n- Q = quadratic Bezier curve 贝塞尔曲线\n- T =  smooth quadratic Bezier curveto 光滑贝塞尔曲线\n- A = elliptical Arc 椭圆\n- Z = closepath  结束路径\n\n注意 ： 上面的命令大写表示绝对定位，小写表示相对定位\n\n```html\n<svg height='61' width='60'>\n  <path d=\"\n          M 18,3\n          L 46,3\n          L 46,40\n          L 61,40\n          L 32,48\n          L 3,40\n          L 18,40\n          Z\n           \" style=\"fill:none; stroke: pink; stroke-width: 2px;\"></path>\n</svg>\n```\n\n<svg height='61' width='60'>\n  <path d=\"\n          M 18,3\n          L 46,3\n          L 46,40\n          L 61,40\n          L 32,48\n          L 3,40\n          L 18,40\n          Z\n           \" style=\"fill:none; stroke: pink; stroke-width: 2px;\"></path>\n</svg>\n### 文本`text`\n\n> 绘制文本\n>\n> `x,y`指定文本基线 (`baseline` ) 起点\n>\n> 可以通过class或style来修改文字样式\n\n```html\n<svg width='300' height='30'>\n  <text x='50' y='25' fill='none' stroke='red' stroke-width='1px' style='text-shadow: 0 0 20px #333'>HELLO WORLD </text>\n</svg>\n```\n\n<svg width='300' height='30'>\n  <text x='50' y='25' fill='none' stroke='red' stroke-width='1px' style='text-shadow: 0 0 20px #333'>HELLO WORLD </text>\n</svg>\n### 复制`use`\n\n> use指定x, y是相对于原图形的相对位置\n\n```html\n<svg width='600' height='200'>\n <circle id=\"mycircle\" cx=\"50\" cy=\"50\" r='50' fill='red'></circle>\n  <use href='#mycircle' x='50' y='0' fill='blue'></use>\n</svg>\n```\n\n### 组`g`\n\n> 将多个图形合并成一个组, 方便复用\n\n```html\n// 简单例子, 只是一个思路\n<svg width='600' height='200'>\n <g id='myg'>\n    <circle id=\"mycircle\" cx=\"50\" cy=\"50\" r='50' fill='red'></circle>\n    <circle id=\"mycircle\" cx=\"50\" cy=\"50\" r='50' fill='red'></circle>\n    <circle id=\"mycircle\" cx=\"50\" cy=\"50\" r='50' fill='red'></circle>\n  </g>\n  <use href='#myg' x='50' y='0' fill='blue'></use>\n</svg>\n```\n\n声明`defs`\n\n> 直接声明不会显示, 只有引用才会显示\n\n```html\n<svg width='600' height='200'>\n  <defs id='mydefs'>\n    <g id='myg'>\n      <circle id=\"mycircle\" cx=\"50\" cy=\"50\" r='50' fill='red'></circle>\n      <circle id=\"mycircle\" cx=\"50\" cy=\"50\" r='50' fill='red'></circle>\n      <circle id=\"mycircle\" cx=\"50\" cy=\"50\" r='50' fill='red'></circle>\n   </g>\n  </defs>\n\n  <use href='#mydefs' x='50' y='0' fill='blue'></use>\n  <use href='#myg' x='50' y='0' fill='blue'></use>\n</svg>\n```\n\n### pattern\n\n> 平铺一个区域\n\n```html\n<svg width='500' height='500'>\n  <defs>\n   <pattern id='dots' x='0' y='0' width='100' height='100' patternUnits='userSpaceOnUse'>\n     <circle fill='#bee9e8' cx='50' cy='50' r='35'></circle>\n    </pattern>\n  </defs>\n  <rect  x='0'  y='0' width='100%' height='100%' fill='url(#dots)' ></rect>\n</svg>\n```\n\n<img src=\"https://images.gitee.com/uploads/images/2020/0914/233103_92022ed0_7984151.png\" style=\"zoom: 25%;\" />\n\n### 特效`animate`\n\n```html\n// 一个方块不断往右走  \n<svg width='500' height='50'>\n    <rect x='0' y='0' width='100' height='50' fill='orange' >\n      <animate attributeName='x' from='0' to='500' dur='2s' repeatCount='indefinite'></animate>\n    </rect>\n  </svg>\n```\n\n### `animateTransform`\n\n> `animate`不支持t`ransform`, 要使用 `animateTransform`\n\n```html\n// 一个方块围绕一个点旋转\n<svg width='5000' height='5000'>\n  <rect x='250' y='0' width='50' height='50' fill='orange' >\n    <animateTransform attributeName='transform' type='rotate' begin='0s'  dur='10s' from='0 200 200 ' to= '360 400 400'  repeatCount='indefinite'></animateTransform>\n  </rect>\n</svg>\n// from 和 to : 第一个数是旋转角度, 后两个是旋转中心 \n```\n\n## 拓展(js操作)\n\n## pao.svg源码\n\n```html\n<svg t=\"1600084741580\" class=\"icon\" viewBox=\"0 0 2303 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4565\" width=\"200\" height=\"200\">\n  <path d=\"M59.238716 644.951169l31.864078-5.365429-18.286258-98.548695-31.864078 5.365428a50.040837 50.040837 0 0 0-40.07647 58.472226 50.150336 50.150336 0 0 0 58.362728 40.07647z\" fill=\"#EB3D72\" p-id=\"4566\"></path>\n  <path d=\"M663.342217 532.934152C539.061362 532.934152 437.9942 637.724264 437.9942 766.494559s101.17666 233.450909 225.457515 233.450909S888.799731 895.264854 888.799731 766.494559s-101.067162-233.560407-225.457514-233.560407zM842.372346 744.594849H713.383054l92.307278-92.416776A187.790013 187.790013 0 0 1 842.372346 744.594849z m-157.349417-28.360124V581.113514a176.402164 176.402164 0 0 1 93.511762 41.718947z m-39.96697 0l-94.935243-94.935243A177.059156 177.059156 0 0 1 645.055959 580.347024z m0 96.577721v139.501153a176.402164 176.402164 0 0 1-97.344211-42.375939z m39.96697 138.077672V812.812446L780.505665 908.842674a176.511663 176.511663 0 0 1-95.592234 43.79942s0.109499-1.423481 0.109498-1.751976zM522.417583 650.207099L616.805333 744.594849h-132.493246a190.198982 190.198982 0 0 1 38.105496-94.38775z m-38.54349 134.354721h132.93124l-95.92073 95.92073a189.651489 189.651489 0 0 1-37.01051-95.92073z m323.458717 93.949756l-93.949756-93.949756H843.138836a189.213495 189.213495 0 0 1-35.806026 93.949756z\" fill=\"#684821\" p-id=\"4567\"></path>\n  <path d=\"M1630.214414 460.446112L344.263442 781.276863a235.093387 235.093387 0 0 1-273.746376-188.118509 234.764891 234.764891 0 0 1 188.118509-273.746375l1312.121126-179.139628z\" fill=\"#44286E\" p-id=\"4568\"></path>\n  <path d=\"M383.792418 644.403676A235.421883 235.421883 0 0 1 105.994597 419.712651a233.998402 233.998402 0 0 0-35.696528 173.445703 235.093387 235.093387 0 0 0 273.746375 188.118509l1285.950973-320.830751L1607.657713 339.450214z\" fill=\"#44286E\" opacity=\".4\" p-id=\"4569\"></path>\n  <path d=\"M1531.865131 59.038079m38.217356-7.103868l0.107655-0.020011q38.217356-7.103868 45.321224 31.113488l73.239881 394.015557q7.103868 38.217356-31.113488 45.321224l-0.107655 0.020011q-38.217356 7.103868-45.321224-31.113488l-73.23988-394.015557q-7.103868-38.217356 31.113487-45.321224Z\" fill=\"#EB3D72\" p-id=\"4570\"></path>\n  <path d=\"M376.346517 1023.049662H140.596138a21.89971 21.89971 0 1 1 0-42.704434H364.630172l133.369234-208.047246L386.529882 259.516272a21.89971 21.89971 0 0 1 41.828446-9.088379l113.330999 521.322597A21.89971 21.89971 0 0 1 538.732867 788.394269L394.19478 1013.194793a21.13322 21.13322 0 0 1-17.848263 9.854869z\" fill=\"#EB3D72\" p-id=\"4571\"></path>\n  <path d=\"M596.6576 574.215105C484.531084 574.215105 394.19478 667.945864 394.19478 784.342823s90.883797 210.127718 203.010312 210.127718S799.339416 900.411286 799.339416 784.342823s-90.664799-210.127718-202.681816-210.127718z m0 276.593338a66.46562 66.46562 0 1 1 64.16615-66.46562 65.69913 65.69913 0 0 1-64.16615 66.46562z\" fill=\"#684821\" p-id=\"4572\"></path>\n  <path d=\"M596.6576 1018.341224C472.267247 1018.341224 371.200085 913.113118 371.200085 784.342823s101.067162-233.450909 225.457515-233.450909 225.457515 104.680614 225.457514 233.450909S720.938454 1018.341224 596.6576 1018.341224z m0-420.255435C497.123417 597.538296 416.09449 681.304687 416.09449 784.342823s81.028927 186.804526 180.56311 186.804526S777.439706 886.942964 777.439706 784.342823s-81.357423-186.804526-180.782106-186.804527z\" fill=\"#A56F34\" p-id=\"4573\"></path>\n  <path d=\"M824.414584 430.662506c10.183365-2.189971 61.100191-21.242719 50.040837-71.72155s-54.749275-39.309979-54.749275-39.30998A32.849565 32.849565 0 1 0 834.050456 383.249634s-3.394455 7.445901-22.6662 10.949855-33.944551-11.825843-39.857472-38.433991c-5.365429-24.637174 13.796817-91.321791 102.600142-120.448405l-100.957664 13.687318c-32.849565 32.849565-47.960365 74.897008-39.200481 114.973478 15.986788 73.035533 80.152939 68.984087 90.445803 66.684617z\" fill=\"#EB3D72\" p-id=\"4574\"></path>\n  <path d=\"M2141.134649 160.639081m-145.085579 0a145.085579 145.085579 0 1 0 290.171158 0 145.085579 145.085579 0 1 0-290.171158 0Z\" fill=\"#212121\" p-id=\"4575\"></path>\n  <path d=\"M2147.704562 178.377847c6.241417-4.379942 35.149035-31.426084 13.468321-62.195177s-47.522371-10.949855-47.52237-10.949855a24.527675 24.527675 0 0 0-7.007907 33.835052 24.637174 24.637174 0 0 0 34.273046 5.036933s0 5.912922-12.154339 13.687319-26.170153 1.53298-37.558003-14.672806-17.410269-73.583026 48.507858-120.448405a78.619959 78.619959 0 0 1 6.898408-4.270443 31.864078 31.864078 0 0 0-36.134521-10.949855c-55.734762 45.3324-71.502553 109.49855-42.266441 151.217498a57.267742 57.267742 0 0 0 79.495948 19.709739z\" fill=\"#3F3F3F\" p-id=\"4576\"></path>\n  <path d=\"M1907.245746 168.960971l-120.776901 27.922131M1786.468845 212.431896a15.548794 15.548794 0 0 1-3.503954-30.769093l120.448406-27.812632a15.548794 15.548794 0 1 1 7.007907 30.331099l-120.448405 27.812631a13.358823 13.358823 0 0 1-3.503954 0.437995zM1908.888224 268.166658l-57.37724 13.906316M1851.510984 297.621768a15.548794 15.548794 0 0 1-3.722951-30.659594l57.486739-13.906316a15.548794 15.548794 0 1 1 7.336403 30.2216l-57.267742 13.906315a15.001301 15.001301 0 0 1-3.832449 0.437995z\" fill=\"#C6C5C4\" p-id=\"4577\"></path>\n  <path d=\"M578.261843 577.938056m14.015815 0l11.935341 0q14.015814 0 14.015815 14.015814l0 380.945456q0 14.015814-14.015815 14.015815l-11.935341 0q-14.015814 0-14.015815-14.015815l0-380.945456q0-14.015814 14.015815-14.015814Z\" fill=\"#A56F34\" p-id=\"4578\"></path>\n  <path d=\"M728.72802 623.635756m9.910677 9.910678l8.439561 8.439561q9.910677 9.910677 0 19.821355l-269.369115 269.369115q-9.910677 9.910677-19.821354 0l-8.439562-8.439561q-9.910677-9.910677 0-19.821355l269.369115-269.369115q9.910677-9.910677 19.821355 0Z\" fill=\"#A56F34\" p-id=\"4579\"></path>\n  <path d=\"M802.733871 762.333614m0 14.015815l0 11.935342q0 14.015814-14.015815 14.015814l-380.945455 0q-14.015814 0-14.015815-14.015814l0-11.935342q0-14.015814 14.015815-14.015815l380.945455 0q14.015814 0 14.015815 14.015815Z\" fill=\"#A56F34\" p-id=\"4580\"></path>\n  <path d=\"M757.041256 912.796584m-9.910677 9.910677l-8.439561 8.439561q-9.910677 9.910677-19.821355 0l-269.369115-269.369115q-9.910677-9.910677 0-19.821354l8.439561-8.439562q9.910677-9.910677 19.821355 0l269.369115 269.369115q9.910677 9.910677 0 19.821355Z\" fill=\"#A56F34\" p-id=\"4581\"></path><path d=\"M2141.134649 321.273454a160.634373 160.634373 0 1 1 160.634373-160.634373 160.85337 160.85337 0 0 1-160.634373 160.634373z m0-290.171157a129.536785 129.536785 0 1 0 129.427286 129.536784 129.755782 129.755782 0 0 0-129.427286-129.536784z\" fill=\"#3F3F3F\" p-id=\"4582\"></path>\n  <path d=\"M551.3252 784.342823a48.617356 46.974878 90 1 0 93.949756 0 48.617356 46.974878 90 1 0-93.949756 0Z\" fill=\"#BC7F42\" p-id=\"4583\"></path>\n  <path d=\"M576.290869 784.342823a22.775698 22.009209 90 1 0 44.018417 0 22.775698 22.009209 90 1 0-44.018417 0Z\" fill=\"#CE9663\" p-id=\"4584\"></path>\n  <path d=\"M1612.147153 491.215204a38.981484 38.981484 0 0 0 45.441899 31.207087 38.871985 38.871985 0 0 0 31.097588-45.3324l-28.031629-150.9985-75.663498 18.614753z\" fill=\"#D83269\" p-id=\"4585\"></path>\n  <path d=\"M2220.411599 209.037441m-15.439296 0a15.439296 15.439296 0 1 0 30.878592 0 15.439296 15.439296 0 1 0-30.878592 0Z\" fill=\"#FFFFFF\" p-id=\"4586\"></path>\n</svg>\n```\n\n<svg t=\"1600084741580\" class=\"icon\" viewBox=\"0 0 2303 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4565\" width=\"200\" height=\"200\"><path d=\"M59.238716 644.951169l31.864078-5.365429-18.286258-98.548695-31.864078 5.365428a50.040837 50.040837 0 0 0-40.07647 58.472226 50.150336 50.150336 0 0 0 58.362728 40.07647z\" fill=\"#EB3D72\" p-id=\"4566\"></path><path d=\"M663.342217 532.934152C539.061362 532.934152 437.9942 637.724264 437.9942 766.494559s101.17666 233.450909 225.457515 233.450909S888.799731 895.264854 888.799731 766.494559s-101.067162-233.560407-225.457514-233.560407zM842.372346 744.594849H713.383054l92.307278-92.416776A187.790013 187.790013 0 0 1 842.372346 744.594849z m-157.349417-28.360124V581.113514a176.402164 176.402164 0 0 1 93.511762 41.718947z m-39.96697 0l-94.935243-94.935243A177.059156 177.059156 0 0 1 645.055959 580.347024z m0 96.577721v139.501153a176.402164 176.402164 0 0 1-97.344211-42.375939z m39.96697 138.077672V812.812446L780.505665 908.842674a176.511663 176.511663 0 0 1-95.592234 43.79942s0.109499-1.423481 0.109498-1.751976zM522.417583 650.207099L616.805333 744.594849h-132.493246a190.198982 190.198982 0 0 1 38.105496-94.38775z m-38.54349 134.354721h132.93124l-95.92073 95.92073a189.651489 189.651489 0 0 1-37.01051-95.92073z m323.458717 93.949756l-93.949756-93.949756H843.138836a189.213495 189.213495 0 0 1-35.806026 93.949756z\" fill=\"#684821\" p-id=\"4567\"></path><path d=\"M1630.214414 460.446112L344.263442 781.276863a235.093387 235.093387 0 0 1-273.746376-188.118509 234.764891 234.764891 0 0 1 188.118509-273.746375l1312.121126-179.139628z\" fill=\"#44286E\" p-id=\"4568\"></path><path d=\"M383.792418 644.403676A235.421883 235.421883 0 0 1 105.994597 419.712651a233.998402 233.998402 0 0 0-35.696528 173.445703 235.093387 235.093387 0 0 0 273.746375 188.118509l1285.950973-320.830751L1607.657713 339.450214z\" fill=\"#44286E\" opacity=\".4\" p-id=\"4569\"></path><path d=\"M1531.865131 59.038079m38.217356-7.103868l0.107655-0.020011q38.217356-7.103868 45.321224 31.113488l73.239881 394.015557q7.103868 38.217356-31.113488 45.321224l-0.107655 0.020011q-38.217356 7.103868-45.321224-31.113488l-73.23988-394.015557q-7.103868-38.217356 31.113487-45.321224Z\" fill=\"#EB3D72\" p-id=\"4570\"></path><path d=\"M376.346517 1023.049662H140.596138a21.89971 21.89971 0 1 1 0-42.704434H364.630172l133.369234-208.047246L386.529882 259.516272a21.89971 21.89971 0 0 1 41.828446-9.088379l113.330999 521.322597A21.89971 21.89971 0 0 1 538.732867 788.394269L394.19478 1013.194793a21.13322 21.13322 0 0 1-17.848263 9.854869z\" fill=\"#EB3D72\" p-id=\"4571\"></path><path d=\"M596.6576 574.215105C484.531084 574.215105 394.19478 667.945864 394.19478 784.342823s90.883797 210.127718 203.010312 210.127718S799.339416 900.411286 799.339416 784.342823s-90.664799-210.127718-202.681816-210.127718z m0 276.593338a66.46562 66.46562 0 1 1 64.16615-66.46562 65.69913 65.69913 0 0 1-64.16615 66.46562z\" fill=\"#684821\" p-id=\"4572\"></path><path d=\"M596.6576 1018.341224C472.267247 1018.341224 371.200085 913.113118 371.200085 784.342823s101.067162-233.450909 225.457515-233.450909 225.457515 104.680614 225.457514 233.450909S720.938454 1018.341224 596.6576 1018.341224z m0-420.255435C497.123417 597.538296 416.09449 681.304687 416.09449 784.342823s81.028927 186.804526 180.56311 186.804526S777.439706 886.942964 777.439706 784.342823s-81.357423-186.804526-180.782106-186.804527z\" fill=\"#A56F34\" p-id=\"4573\"></path><path d=\"M824.414584 430.662506c10.183365-2.189971 61.100191-21.242719 50.040837-71.72155s-54.749275-39.309979-54.749275-39.30998A32.849565 32.849565 0 1 0 834.050456 383.249634s-3.394455 7.445901-22.6662 10.949855-33.944551-11.825843-39.857472-38.433991c-5.365429-24.637174 13.796817-91.321791 102.600142-120.448405l-100.957664 13.687318c-32.849565 32.849565-47.960365 74.897008-39.200481 114.973478 15.986788 73.035533 80.152939 68.984087 90.445803 66.684617z\" fill=\"#EB3D72\" p-id=\"4574\"></path><path d=\"M2141.134649 160.639081m-145.085579 0a145.085579 145.085579 0 1 0 290.171158 0 145.085579 145.085579 0 1 0-290.171158 0Z\" fill=\"#212121\" p-id=\"4575\"></path><path d=\"M2147.704562 178.377847c6.241417-4.379942 35.149035-31.426084 13.468321-62.195177s-47.522371-10.949855-47.52237-10.949855a24.527675 24.527675 0 0 0-7.007907 33.835052 24.637174 24.637174 0 0 0 34.273046 5.036933s0 5.912922-12.154339 13.687319-26.170153 1.53298-37.558003-14.672806-17.410269-73.583026 48.507858-120.448405a78.619959 78.619959 0 0 1 6.898408-4.270443 31.864078 31.864078 0 0 0-36.134521-10.949855c-55.734762 45.3324-71.502553 109.49855-42.266441 151.217498a57.267742 57.267742 0 0 0 79.495948 19.709739z\" fill=\"#3F3F3F\" p-id=\"4576\"></path><path d=\"M1907.245746 168.960971l-120.776901 27.922131M1786.468845 212.431896a15.548794 15.548794 0 0 1-3.503954-30.769093l120.448406-27.812632a15.548794 15.548794 0 1 1 7.007907 30.331099l-120.448405 27.812631a13.358823 13.358823 0 0 1-3.503954 0.437995zM1908.888224 268.166658l-57.37724 13.906316M1851.510984 297.621768a15.548794 15.548794 0 0 1-3.722951-30.659594l57.486739-13.906316a15.548794 15.548794 0 1 1 7.336403 30.2216l-57.267742 13.906315a15.001301 15.001301 0 0 1-3.832449 0.437995z\" fill=\"#C6C5C4\" p-id=\"4577\"></path><path d=\"M578.261843 577.938056m14.015815 0l11.935341 0q14.015814 0 14.015815 14.015814l0 380.945456q0 14.015814-14.015815 14.015815l-11.935341 0q-14.015814 0-14.015815-14.015815l0-380.945456q0-14.015814 14.015815-14.015814Z\" fill=\"#A56F34\" p-id=\"4578\"></path><path d=\"M728.72802 623.635756m9.910677 9.910678l8.439561 8.439561q9.910677 9.910677 0 19.821355l-269.369115 269.369115q-9.910677 9.910677-19.821354 0l-8.439562-8.439561q-9.910677-9.910677 0-19.821355l269.369115-269.369115q9.910677-9.910677 19.821355 0Z\" fill=\"#A56F34\" p-id=\"4579\"></path><path d=\"M802.733871 762.333614m0 14.015815l0 11.935342q0 14.015814-14.015815 14.015814l-380.945455 0q-14.015814 0-14.015815-14.015814l0-11.935342q0-14.015814 14.015815-14.015815l380.945455 0q14.015814 0 14.015815 14.015815Z\" fill=\"#A56F34\" p-id=\"4580\"></path><path d=\"M757.041256 912.796584m-9.910677 9.910677l-8.439561 8.439561q-9.910677 9.910677-19.821355 0l-269.369115-269.369115q-9.910677-9.910677 0-19.821354l8.439561-8.439562q9.910677-9.910677 19.821355 0l269.369115 269.369115q9.910677 9.910677 0 19.821355Z\" fill=\"#A56F34\" p-id=\"4581\"></path><path d=\"M2141.134649 321.273454a160.634373 160.634373 0 1 1 160.634373-160.634373 160.85337 160.85337 0 0 1-160.634373 160.634373z m0-290.171157a129.536785 129.536785 0 1 0 129.427286 129.536784 129.755782 129.755782 0 0 0-129.427286-129.536784z\" fill=\"#3F3F3F\" p-id=\"4582\"></path><path d=\"M551.3252 784.342823a48.617356 46.974878 90 1 0 93.949756 0 48.617356 46.974878 90 1 0-93.949756 0Z\" fill=\"#BC7F42\" p-id=\"4583\"></path><path d=\"M576.290869 784.342823a22.775698 22.009209 90 1 0 44.018417 0 22.775698 22.009209 90 1 0-44.018417 0Z\" fill=\"#CE9663\" p-id=\"4584\"></path><path d=\"M1612.147153 491.215204a38.981484 38.981484 0 0 0 45.441899 31.207087 38.871985 38.871985 0 0 0 31.097588-45.3324l-28.031629-150.9985-75.663498 18.614753z\" fill=\"#D83269\" p-id=\"4585\"></path><path d=\"M2220.411599 209.037441m-15.439296 0a15.439296 15.439296 0 1 0 30.878592 0 15.439296 15.439296 0 1 0-30.878592 0Z\" fill=\"#FFFFFF\" p-id=\"4586\"></path></svg>\n","children":[]},{"name":"temp.md","path":"../guanruihua.github.io/HTML","data":"# temp note\r\n\r\n## 允许链接跨域\r\n\r\n`<meta name=\"referrer\" content=\"no-referrer\"/>`\r\n","children":[]},{"name":"textArea.md","path":"../guanruihua.github.io/HTML","data":"# textArea\n\n- 其他常用设置:　　\n  - 去除右下角的三角形的图标 : `resize:none`\n\n| 属性 | 值  | 描述   |\n|---|---|---|\n|  cols | number  | 文本区的可见宽度  |\n|  rows | number | 文本可见行数   |\n|  readonly | readonly  | 规定文本区为只读  |\n|  disabled | disabled   | 禁用该文本区  |\n|  form | form_id  | 规定文本区域所属一个活多个表单  |\n|  maxlength | number  | 文本区域的最大字符数  |\n|  placeholder | text  | 提示文字  |\n|  required | required  | 文本域是必填  |\n| autofocus | autofocus | 页面加载后文本域自动获得焦点\n| wrap | hard sorf | 规定表单提交时, 文本区域中的文本如何换行\n\n- wrap属性\n  - wrap :文本区会包含一行文本，用户必须将光标移动到右边才能看到全部文本，这时将把一行文本传送给服务器。\n\n  - virtual : 文本区会包含两行文本，并在单词 \"makes\" 后面换行。但是只有一行文本被传送到服务器：没有嵌入新行字符。\n  - physical : 文本区会包含两行文本，并在单词 \"makes\" 后面换行，这时发送给服务器两行文本，单词 \"makes\" 后的新行字符将分隔这两行文本。\n","children":[]},{"name":"video.md","path":"../guanruihua.github.io/HTML","data":"# video\n\n> https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video\n>\n> [使用 JS 获取视频 Codec (jackpu.com)](https://jackpu.com/shi-yong-js-huo-qu-shi-pin-codec/)\n>\n> 素材[Download Sample Videos / Dummy Videos For Demo Use (sample-videos.com)](https://sample-videos.com/index.php#sample-mp4-video)\n\n## 使用\n\n```html\n<video width=\"320\" height=\"240\" controls>\n    <source src=\"movie.mp4\" type=\"video/mp4\">\n    <source src=\"movie.ogg\" type=\"video/ogg\">\n    您的浏览器不支持 video 标签。\n</video>\n```\n\n## 自带属性&方法\n\n| 属性 / 方法      | desc                                  |\n| ---------------- | ------------------------------------- |\n| currentTime      | 当前视频播放时间(s)                   |\n| duration         | 当前视频播放时长(s)                   |\n| volume           | 声音[0-1]                             |\n| paused           | 暂停                                  |\n| ended            | 结束                                  |\n| play()           | 播放                                  |\n| pause()          | 暂停                                  |\n| loadedmetadata() | 视频加载获取数据(获取duration)        |\n| timeupdate()     | 视频变化事件, (获取实时的currentTime) |\n| ended()          | 视频播放结束事件                      |\n| volumechange()   | 视频声音事件                          |\n\n","children":[]},{"name":"_sidebar.md","path":"../guanruihua.github.io/HTML","data":"* canvas\n  * [canvas](canvas/canvas.md)\n  * Demo\n    * [canvas转图片下载](canvas/Demo/canvas转图片下载.md)\n  * [图片](canvas/图片/index.md)\n    * [createImageData](canvas/图片/createImageData.md)\n    * [drawImage](canvas/图片/drawImage.md)\n    * [home](canvas/图片/index.md)\n    * [putImageData](canvas/图片/putImageData.md)\n  * [圆](canvas/圆/index.md)\n    * [home](canvas/圆/index.md)\n  * [基础Api](canvas/基础Api/index.md)\n    * [home](canvas/基础Api/index.md)\n    * [isPointInPath](canvas/基础Api/isPointInPath.md)\n    * [isPointInStroke](canvas/基础Api/isPointInStroke.md)\n    * [rotate](canvas/基础Api/rotate.md)\n    * [scale](canvas/基础Api/scale.md)\n    * [setTransform](canvas/基础Api/setTransform.md)\n    * [stroke_](canvas/基础Api/stroke_.md)\n    * [transform](canvas/基础Api/transform.md)\n    * [translate](canvas/基础Api/translate.md)\n  * 属性\n    * [canvas](canvas/属性/canvas.md)\n  * [文字](canvas/文字/index.md)\n    * [home](canvas/文字/index.md)\n  * [矩形](canvas/矩形/index.md)\n    * [home](canvas/矩形/index.md)\n    * [rect](canvas/矩形/rect.md)\n  * 线\n    * [曲线](canvas/线/曲线.md)\n    * [线](canvas/线/线.md)\n  * [路径](canvas/路径/index.md)\n    * [home](canvas/路径/index.md)\n* favicon\n  * [添加favicon](favicon/添加favicon.md)\n  * [防止favicon请求](favicon/防止favicon请求.md)\n* [html](html.md)\n* [html5](html5.md)\n* [img](img.md)\n* [meta](meta.md)\n* [script](script.md)\n* [svg](svg.md)\n* [temp](temp.md)\n* [textArea](textArea.md)\n* [video](video.md)\n* [邮件模板](邮件模板/index.md)\n  * [home](邮件模板/index.md)\n  * [垃圾邮件](邮件模板/垃圾邮件.md)\n","children":[]},{"name":"邮件模板","path":"../guanruihua.github.io/HTML","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/HTML/邮件模板","data":"# 邮件模板\r\n\r\n> 邮件模板是outlook等邮件系统支持html解析格式的条件下，利用前端技术通过编写HTML文件生成期望的邮件页面，从而辅助编写邮件的邮件编辑方式。\r\n>\r\n> 就是像写网页一样去写邮件。目前我们在163等邮箱中收到\r\n\r\n- 知乎等网站推送的订阅期刊\r\n- 京东等购物网站的流程通知\r\n- 51JOB等招聘网站的职位推送\r\n- LinkedIn等社交网站的人脉拓展\r\n\r\n这些都是通过邮件模板的方式实现的。\r\n\r\n当然邮件模板的使用分为\r\n\r\n- 手动改写（适用于固定内容群发）\r\n- 后台系统自动编辑分发（适用于即使反馈、内容随不同用户而变化的）\r\n- ...等多种方式\r\n\r\n![](./__assets__/邮件模板-2022-12-01-16-32-28.png)\r\n\r\n## 优势\r\n\r\n>\r\n> 1. 适用于排版复杂\r\n> 2. 可复月\r\n> 3. 兼容性好\r\n> 4. 样式鱼内容分分离开\r\n>\r\n\r\n## 问题\r\n\r\n### OutLook\r\n\r\n- 发送HTML邮件\r\n\r\n![](./__assets__/邮件模板-2022-12-01-17-11-44.png)\r\n> 无法直接编辑 HTML邮件, 要通过添加插件才可以发`HTML`的邮件\r\n\r\n- 插件获取> 获取加载项> 搜索框输入`HTML` > 选择下图的插件\r\n\r\n![](./__assets__/邮件模板-2022-12-01-17-13-42.png)\r\n\r\n- 通过插件发送HTML邮箱:\r\n\r\n![](./__assets__/邮件模板-2022-12-01-17-14-40.png)\r\n\r\n- 输入HTMl\r\n![](./__assets__/邮件模板-2022-12-01-17-15-05.png)\r\n\r\n> 问题: 当前方法发送的HTML邮件, 转发后, 邮件样式会丢失\r\n","children":[]},{"name":"垃圾邮件.md","path":"../guanruihua.github.io/HTML/邮件模板","data":"# 垃圾邮件\r\n\r\n## 垃圾邮件特征的范畴\r\n\r\n- 来自收件人从未发送过邮件的地址第一次发出的邮件，以及在该邮件未被收件人自定义为正常邮件的情况下随后从同一地址发送给收件人的其他邮件；\r\n- 来自被拒绝过接收邮件的地址所发给收件人的其他邮件；\r\n- 来自被收件人列入黑名单的邮件地址的邮件；\r\n- 内容包含可被反垃圾装置或可被邮件过滤器定义、归类为垃圾邮件的关键字段的邮件；\r\n- 带虚假、无效邮件头的邮件，带虚假、无效域名的邮件，经过技术处理的不显示任何邮件来源信息的邮件。带欺骗性地址信息的邮件；\r\n- 未经同意而使用、中继或通过第三方的互联网设备所发送的邮件；\r\n- 主题行或内容包含错误、误导或虚假信息的邮件；\r\n- 主题或内容带敏感字眼的、违反国家法律法规或QQ邮箱服务条款的邮件。\r\n\r\n## 如何避免邮件被当成垃圾邮件\r\n\r\n- 邮件标题带有敏感字可能被当作内容违规邮件（内容中避开使用敏感词、合理布局图文结构）\r\n- 触发式邮件容易被认定为垃圾广告或者钓鱼邮件\r\n- 如果是订阅邮件，在邮件中添加退订链接; （提醒收件方将你添加至白名单，及时处理退信）\r\n- 发送邮件所在的服务器的IP也很关键，可能会影响邮件服务提供商对你所发邮件的判断。\r\n- 当发送大量邮件时，有计划地少量多批次发送；\r\n\r\n有一些技术手段可以防止非垃圾邮件被认为是垃圾邮件。比如配置SPF, DKIM记录;\r\n","children":[]}]}]},{"name":"JavaScript","path":"../guanruihua.github.io","data":"","children":[{"name":"api","path":"../guanruihua.github.io/JavaScript","data":"","children":[{"name":"Buffer.md","path":"../guanruihua.github.io/JavaScript/api","data":"# Buffer\r\n\r\n> buffer 即缓存，是对二进制数据处理的一种方式\r\n\r\n## Uint*Array / ArrayBuffer\r\n\r\n> ArrayBuffer: 基础的二进制对象, 对固定长度的连续内存控件的引用\r\n> 视图: `Uint8Array`, `Uint16Array`,`Uint32Array`\r\n\r\n- Uint8Array 将 ArrayBuffer 中的每个字节视为一个单位。每个单位是 0 到 255 之间的数字。之所以是255，是因为每个单位最多是 8 位，即 2^8 次方。\r\n- Uint16Array 将 ArrayBuffer 中每 2 个字节视为一个单位。每个单位是 0 到 65535 之间的整数。原理同上。\r\n- Uint32Array 将 ArrayBuffer 中每 4 个字节视为一个单位。每个单位是 0 到 4294967295 之间的整数。原理同上。\r\n\r\n```js\r\n// 通过 BYTES_PER_ELEMENT 静态属性来得之视图单位的大小\r\nconst buf8 = new Uint8Array();\r\nconst buf16 = new Uint16Array();\r\nconst buf32 = new Uint32Array();\r\nconsole.log(buf8.BYTES_PER_ELEMENT); // 1\r\nconsole.log(buf16.BYTES_PER_ELEMENT); // 2\r\nconsole.log(buf32.BYTES_PER_ELEMENT); // 4\r\n```\r\n\r\n## Blob\r\n\r\n> 浏览器环境一种承载原始数据的二进制对象, 可以与`ArrayBuffer`相互转化\r\n\r\n## DataView\r\n\r\n> 一种底层,更灵活读取`ArrayBuffer`的视图\r\n\r\n```js\r\nconst buffer = new ArrayBuffer(16); // 分配一个内存空间\r\nconst view = new DataView(buffer); // 创建 DataView 视图\r\nview.setUint32(0, 4294967295); // 从第 0 个空间开始，以 32 位的形式写入数据\r\n\r\n// 有时候我想以 8 位的形式 “翻译” 这个内存空间，从偏移量 0 开始翻译\r\nconsole.log(view.getUint8(0)); // 255\r\n// 今天心情好，想以 16 位的形式 “翻译” 这个内存空间，从偏移量 0 开始读\r\nconsole.log(view.getUint16(0)); // 65535\r\n// 今天心情超好，想以 32 位的形式 “翻译” 这个内存空间，从偏移量 0 开始读\r\nconsole.log(view.getUint32(0)); // 4294967295\r\n```\r\n\r\n## Node 中 Buffer\r\n\r\n> <http://nodejs.cn/api/buffer.html>\r\n","children":[]},{"name":"console.md","path":"../guanruihua.github.io/JavaScript/api","data":"# console\n\n- <https://developer.mozilla.org/zh-CN/docs/Web/API/Console_API>\n\n## trace\n\n- 输出一个堆栈跟踪\n\n```js\n function foo() {\n   function bar() {\n    console.trace();\n   }\n   bar();\n  }\n  foo();\n```\n\n![](./__assets__/console-2022-07-11-16-43-10.png)\n\n## table\n\n- `console.table({ ... })`\n\n![](./__assets__/console-2022-07-15-14-33-25.png)\n\n## error\n\n- `console.err(“This is error”)`\n![](./__assets__/console-2022-07-15-14-33-40.png)\n\n## warn\n\n- `console.warn()`\n\n![](./__assets__/console-2022-07-15-14-34-00.png)\n\n## Time & timelog & timeEnd\n\n- `console.time()、console.timeLog()、console.timeEnd()`: 用来进行程序计时\n![](./__assets__/console-2022-07-15-14-34-11.png)\n\n## assert\n\n- `console.assert(assert_statement,message)` : 设定断言, 如果assert_statement 为false 显示message消息\n- 只有`assert_statement` 为true 的时候才会打印出来\n\n![](./__assets__/console-2022-07-15-14-34-19.png)\n\n## count & countReset\n\n- `console.count()` : 统计参数标签计数\n- `console.countReset()`: 重置对应标签的计数\n\n![](./__assets__/console-2022-07-15-14-34-27.png)\n\n### group & groupEnd\n\n- 给log用缩进进行分组\n\n```js\n let i = 9;\n  console.group()\n  while (i--) {\n   console.log(i);\n   if (i % 3 === 0) {\n    console.groupEnd();\n    console.group()\n   }\n  }\n```\n\n![](./__assets__/console-2022-07-11-16-47-56.png)\n\n## groupCollapsed & groupEnd\n\n- `groupCollapsed` 和 group类似, 默认分组是关闭的\n\n```js\n let i = 9;\n  console.groupCollapsed('group')\n  while (i--) {\n   console.log({ i });\n   if (i % 3 === 0) {\n    console.groupEnd();\n    console.groupCollapsed('group')\n   }\n  }\n```\n\n![](./__assets__/console-2022-07-11-16-52-39.png)\n\n## info &log\n\n- 控制台打印 信息\n- log: 打印日志\n- info: 打印信息\n\n### 拓展\n\n### CSS样式 格式化打印\n\n- 仅浏览器支持\n`console.log('123 %c 456','font-size:36px;color:red;');`\n![](./__assets__/console-2022-07-11-16-41-28.png)\n\n### 编码指定样式打印\n\n- 可以使用 [rh-color](https://www.npmjs.com/package/rh-color) 包来体验\n- 浏览器和终端均支持\n\n- 代码样例\n`console.log('\\033[42;30m DONE \\033[40;32m Compiled successfully in 19987ms\\033[0m')`\n- 输出结果\n\n  ![](./__assets__/console-2022-07-11-16-55-55.png)\n\n- 解释\n  - 用绿底（42）黑字（30）显示“DONE”\n  - 然后使用黑底（40）绿字（32）显示余下的信息，最后还原属性（`\\033[0m`）\n\n#### 示例\n\n##### 指定底色字体颜色\n\n- `console.log('\\033[42;30m DONE \\033[44;33m Compiled successfully in 19987ms\\033[0m')`\n- 等同: `console.log('\\033[42;30m DONE \\033[44;37m Compiled successfully in %dms\\033[0m',19987)`\n\n![](./__assets__/console-2022-07-13-10-23-47.png)\n\n### 常用属性\n\n- `\\033[42;30m` => `\\033[背景色编号;字色编号m`\n  - 字色编号：30黑，31红，32绿，33黄，34蓝，35紫，36深绿，37白色\n  - 背景编号：40黑，41红，42绿，43黄，44蓝，45紫，46深绿，47白色\n\n| 编码        | 描述                   |\n| :---------- | :--------------------- |\n| `\\033[0m`   | 关闭所有属性           |\n| `\\033[1m`   | 设置高亮度             |\n| `\\033[4m`   | 下划线                 |\n| `\\033[5m`   | 闪烁                   |\n| `\\033[7m`   | 反显                   |\n| `\\033[8m`   | 消隐                   |\n| `\\033[nA`   | 光标上移n行            |\n| `\\033[nB`   | 光标下移n行            |\n| `\\033[nC`   | 光标右移n列            |\n| `\\033[nD`   | 光标左移n列            |\n| `\\033[y;xH` | 设置光标位置（y列x行） |\n| `\\033[2J`   | 清屏                   |\n| `\\033[K`    | 清除从光标到行尾的内容 |\n\n### 占位符\n\n| 占位符  | 描述       |\n| ------- | ---------- |\n| `%s`    | 字符串     |\n| `%d %i` | 整数       |\n| `%f`    | 浮点数     |\n| `%o`    | DOM元素    |\n| `%O`    | object对象 |\n| `%c`    | css样式    |\n","children":[]},{"name":"Cookie.md","path":"../guanruihua.github.io/JavaScript/api","data":"# Cookie\n\n> Cookie是服务端发送到用户浏览器并且保存到本地的一小块数据，它会在浏览器下次向同一服务器发起请求时，被携带到服务器上\n> 作用:\n>\n> - 经常用来做一些用户会话状态管理、个性化设置等等\n> - 前端可以通过document.cookie来访问cookie\n> - cookie是跨域的，也就是在不同的域名中，访问的cookie的时候，只能访问对应的域名的cookie\n> 特性:\n> - http: 会自动懈怠Cookie\n> - 携带的Cookie, 还是请求所在域名的Cookie\n\n```js\nexport const setCookie = function setCookie(name, value) {\n    // var Days = 30; \n    var exp = new Date();\n    exp.setTime(exp.getTime() + 120 * 60 * 1000);\n    document.cookie = name + \"=\" + escape(value) + \";expires=\" + exp.toGMTString() + \";path=/\";\n}\n\n//读取cookies \nexport const getCookie = function getCookie(name) {\n    var arr, reg = new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\");\n    if (arr = document.cookie.match(reg))\n        return unescape(arr[2]);\n    else\n        return null;\n}\n\n//删除cookies \nexport const delCookie = function delCookie(name) {\n    var exp = new Date();\n    exp.setTime(exp.getTime() - 1);\n    var cval = getCookie(name);\n    if (cval != null)\n        document.cookie = name + \"=\" + cval + \";expires=\" + exp.toGMTString() + \";path=/brand\";\n    document.cookie = name + \"=\" + cval + \";expires=\" + exp.toGMTString() + \";path=/   \";\n\n}\n//使用示例 \n// setCookie(\"name\",\"hayden\"); \n// alert(getCookie(\"name\")); \n```\n\n## Cookie 和 CSRF\n\nCSRF，中文名叫跨站请求伪造，发生的场景就是，用户登陆了a网站，然后跳转到b网站，b网站直接发送一个a网站的请求，进行一些危险操作，就发生了CSRF攻击！\n这时候，懂得这个CSRF了吗？我认为一部分同学依然不懂，因为我看过太多这样的描述了！\n因为有这么一些疑惑，为什么在b网站可以仿造a网站的请求？Cookie不是跨域的吗？什么条件下，什么场景下，会发生这样的事情？\n这时候，我们要注意上面我对cookie的定义，在发送一个http请求的时候，携带的cookie是这个http请求域的地址的cookie。也就是我在b网站，发送a网站的一个请求，携带的是a网站域名下的cookie！很多同学的误解，就是觉得cookie是跨域的，b网站发送任何一个请求，我只能携带b网站域名下的cookie。\n当然，我们在b网站下，读取cookie的时候，只能读取b网站域名下的cookie，这是cookie的跨域限制。所以要记住，不要把http请求携带的cookie，和当前域名的访问权限的cookie混淆在一起。\n还要理解一个点：CSRF攻击，仅仅是利用了http携带cookie的特性进行攻击的，但是攻击站点还是无法得到被攻击站点的cookie。这个和XSS不同，XSS是直接通过拿到Cookie等信息进行攻击的。\n\n### 应对CSRF攻击\n\n#### 方案一：放弃Cookie、使用Token\n\n由于CSRF是通过Cookie伪造请求的方式，欺骗服务器，来达到自己的目的。那么我们采取的策略就是，不使用Cookie的方式来验证用户身份，我们使用Token！\nToken的策略，一般就是登陆的时候，服务端在response中，返回一个token字段，然后以后所有的通信，前端就把这个token添加到http请求的头部。\n这是当前，最常用的防御CSRF攻击的策略。\n\n#### 方案二：SameSite Cookies\n\n前端在发展，Cookie也在进化，Cookie有一个新的属性——SateSite。能够解决CSRF攻击的问题。\n它表示，只能当前域名的网站发出的http请求，携带这个Cookie。\n当然，由于这是新的cookie属性，在兼容性上肯定会有问题。\n\n#### 方案三：服务端Referer验证\n\n我们发送的http请求中，header中会带有Referer字段，这个字段代表的是当前域的域名，服务端可以通过这个字段来判断，是不是“真正”的用户请求。\n也就是说，如果b网站伪造a网站的请求，Referer字段还是表明，这个请求是b网站的。也就能辨认这个请求的真伪了。\n不过，目前这种方案，使用的人比较少。可能存在的问题就是，如果连Referer字段都能伪造，怎么办？\n\n## XSS\n\nXSS是由于不安全的数据引起的，有可能是表单提交的数据，有可能是页面路径的参数问题。\nCSRF是通过伪造http请求，来达到自己的攻击目的。但是XSS是通过盗取用户的敏感信息而达到攻击的目的。比如本地存储、用户密码、cookie等等。\n比如这个不安全的数据，是一个script标签，那这个script就可以链接任意的js文件，浏览器本地就会执行这个js，那通过js我们能做的东西就太多了：\n比如document.cookie，获取用户信息。\n比如通过localStorage，获取本地存储的敏感信息（token）。\n然后只要是这个页面展示的任何信息，我都可以获取。\n\n### 应对XSS攻击\n\n#### 方案一：http-only\n\nCookie有一个http-only属性，表示只能被http请求携带。\n假如你的网站遭受到XSS攻击，攻击者就无法通过document.cookie得到你的cookie信息。\n\n#### 方案二：正则校验\n\n我们了解到，XSS是由于不安全的数据引起的，这些数据的来源，一个重要的渠道就是提交表单，注入到数据库。所以针对前端，我们需要把表单数据进行正则验证，通过验证之后，才能提交数据。\n对于服务端，也应该对接受的数据，进行规则校验，不符合规则的数据不应该入库。从接口层面，保证数据安全。\n\n#### 方案三：数据转义\n\n如果无法保证数据库的数据都是安全的，前端能做的事情就是，把所有需要展示到页面的数据，进行转义，比如遇到script标签，直接replace处理。或者遇到标签标识‘<’以及‘>’这类特殊字符，添加‘\\’进行处理\n\n## Token\n\n1、cookie可以引起csrf攻击，token在保持用户会话的时候好一点。\n\n2、由于http请求携带cookie，当cookie过大的时候，会增大http请求的带宽。\n\n3、cookie的特性，导致了cookie面对CSRF攻击的时候，很不安全。\n","children":[]},{"name":"Math.md","path":"../guanruihua.github.io/JavaScript/api","data":"# Math\n\n## **Math扩展**\n\n- Math.trunc()\n  方法用于去除一个数的小数部分，返回整数部分。\n\n  ```js\n  console.log(Math.trunc(5.5)) // 5\n  console.log(Math.trunc(-5.5)) // -5\n  console.log(Math.trunc(true)) // 1\n  console.log(Math.trunc(false)) // 0\n  console.log(Math.trunc(NaN)) // NaN\n  console.log(Math.trunc(undefined)) // NaN\n  console.log(Math.trunc()) // NaN\n  ```\n\n- Math.sign()\n  方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。\n\n它会返回五种值。\n\n- 参数为正数，返回+1\n\n- 参数为负数，返回-1\n\n- 参数为 0，返回0\n\n- 参数为-0，返回-0\n\n- 其他值，返回NaN\n\n  ```js\n  console.log(Math.sign(5)) // 1\n  console.log(Math.sign(-5)) // -1\n  console.log(Math.sign(0)) // 0\n  console.log(Math.sign(NaN)) // NaN\n  console.log(Math.sign(true)) // 1\n  console.log(Math.sign(false)) // 0\n  ```\n\n- Math.cbrt()\n  方法用于计算一个数的立方根。\n\n  ```js\n  console.log(Math.cbrt(8)) // 2\n  \n  console.log(Math.cbrt('xx')) // NaN\n  ```\n","children":[]},{"name":"Reflect.md","path":"../guanruihua.github.io/JavaScript/api","data":"# Reflect\n\n> <https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect>\n>\n> - 拦截js操作的方法\n> - 与proxy 相同\n> - 不是函数对象, 不可以构造\n> - 不可通过new 运算符来调用\n> - 方法与Object相同\n\n## apply\n\n> `Reflect.apply(target, thisArgument, argumentsList)`\n>\n> - target: 目标函数\n> - thisArgument: target函数调用同事绑定的this对象\n> - argumentsList: 实参列表\n> 与`Function.prototype.apply()`方法类似\n\n```js\nconsole.log(Reflect.apply(Math.floor, undefined, [1.75]))\n// expected output: 1​\n\nconsole.log(Reflect.apply(String.fromCharCode, undefined, [104, 101, 108, 108, 111]))\n// expected output: \"hello\"\n\nconsole.log(Reflect.apply(RegExp.prototype.exec, /ab/, ['confabulation']).index)\n// expected output: 4\n\nconsole.log(Reflect.apply(''.charAt, 'ponies', [3]))\n// expected output: \"i\"\n```\n\n## construct\n\n> 行为有点像 new 操作符 构造函数 ， 相当于运行 new target(...args).\n> `Reflect.construct(target, argumentsList[, newTarget])`\n> target 被运行的目标构造函数\n> argumentsList 类数组，目标构造函数调用时的参数。\n> newTarget ? 作为新创建对象的原型对象的constructor属性， 参考 new.target 操作符，默认值为target。\n> return 以target（如果newTarget存在，则为newTarget）函数为构造函数，argumentList为其初始化参数的对象实例\n\n```js\nvar d = Reflect.construct(Date, [1776, 6, 4]);\nd instanceof Date; // true\nd.getFullYear(); // 1776\n```\n\n## defineProperty\n\n> `Reflect.defineProperty(target, propertyKey, attributes)`\n>\n> - target 目标对象\n> - propertyKey 要定义或修改的属性的名称\n> - attributes 要定义或修改的属性的描述\n> return Boolean 属性是否被成功定义。\n\n```js\nlet obj = {}\nReflect.defineProperty(obj, 'x', {value: 7})  // true\nobj.x\n// 检查属性是否被重新定义\nif (Reflect.defineProperty(target, property, attributes)) {\n  // 成功\n} else {\n  // 失败\n}\n```\n\n## deleteProperty\n>\n> - 静态方法 Reflect.deleteProperty() 允许用于删除属性\n> - 很像 delete operator ，但它是一个函数\n>\n> `Reflect.deleteProperty(target, propertyKey)`\n>\n> - 参数 target 删除属性的目标对象\n> - propertyKey 需要删除的属性的名称\n> return Boolean 值表明该属性是否被成功删除\n\n```js\nvar obj = { x: 1, y: 2 };\nReflect.deleteProperty(obj, \"x\"); // true\nobj; // { y: 2 }\n\nvar arr = [1, 2, 3, 4, 5];\nReflect.deleteProperty(arr, \"3\"); // true\narr; // [1, 2, 3, , 5]\n\n// 如果属性不存在，返回 true\nReflect.deleteProperty({}, \"foo\"); // true\n\n// 如果属性不可配置，返回 false\nReflect.deleteProperty(Object.freeze({foo: 1}), \"foo\"); // false\n```\n\n## get\n\n> 对象 (target[propertyKey]) 中读取属性类似，但它是通过一个函数执行来操作的\n> `Reflect.get(target, propertyKey[, receiver])`\n>\n> - target 需要取值的目标对象\n> - propertyKey 需要获取的值的键值\n> - receiver 如果target对象中指定了getter，receiver则为getter调用时的this值。\n> return any 属性的值\n>\n\n```js\n// Object\nvar obj = { x: 1, y: 2 };\nReflect.get(obj, \"x\"); // 1\n\n// Array\nReflect.get([\"zero\", \"one\"], 1); // \"one\"\n\n// Proxy with a get handler\nvar x = {p: 1};\nvar obj = new Proxy(x, {\n  get(t, k, r) { return k + \"bar\"; }\n});\nReflect.get(obj, \"foo\"); // \"foobar\"\n```\n\n## getOwnPropertyDescriptor\n\n> - 静态方法 `Reflect.getOwnPropertyDescriptor()` 与 `Object.getOwnPropertyDescriptor()` 方法相似\n> - 如果在对象中存在，则返回给定的属性的属性描述符。否则返回 undefined。\n> `Reflect.getOwnPropertyDescriptor(target, propertyKey)`\n>\n> - target 需要寻找属性的目标对象\n> - propertyKey 获取自己的属性描述符的属性的名称\n> return any 如果属性存在于给定的目标对象中，则返回属性描述符；否则，返回 undefined\n>\n\n```js\nReflect.getOwnPropertyDescriptor({x: \"hello\"}, \"x\");\n// {value: \"hello\", writable: true, enumerable: true, configurable: true}\n\nReflect.getOwnPropertyDescriptor({x: \"hello\"}, \"y\");\n// undefined\n\nReflect.getOwnPropertyDescriptor([], \"length\");\n// {value: 0, writable: true, enumerable: false, configurable: false}\n\n```\n\n### 与 Object.getOwnPropertyDescriptor() 的不同点\n\n> 如果该方法的第一个参数不是一个对象（一个原始值），那么将造成 TypeError 错误\n> 而对于 Object.getOwnPropertyDescriptor，非对象的第一个参数将被强制转换为一个对象处理\n\n```js\nReflect.getOwnPropertyDescriptor(\"foo\", 0);\n// TypeError: \"foo\" is not non-null object\n\nObject.getOwnPropertyDescriptor(\"foo\", 0);\n// { value: \"f\", writable: false, enumerable: true, configurable: false }\n```\n\n## getPrototypeOf\n>\n> - 静态方法 Reflect.getPrototypeOf() 与 Object.getPrototypeOf() 方法几乎是一样的\n> - 都是返回指定对象的原型（即内部的 [[Prototype]] 属性的值）\n> `Reflect.getPrototypeOf(target)`\n> - target 获取原型的目标对象\n> - return 给定对象的原型。如果给定对象没有继承的属性，则返回 null\n>\n```js\nReflect.getPrototypeOf({}); // Object.prototype\nReflect.getPrototypeOf(Object.prototype); // null\nReflect.getPrototypeOf(Object.create(null)); // null\n```\n\n### 与object.getPrototypeOf比较\n\n```js\n// 如果参数为 Object，返回结果相同\nObject.getPrototypeOf({})   // Object.prototype\nReflect.getPrototypeOf({})  // Object.prototype\n\n// 在 ES5 规范下，对于非 Object，抛异常\nObject.getPrototypeOf('foo')   // Throws TypeError\nReflect.getPrototypeOf('foo')  // Throws TypeError\n\n// 在 ES2015 规范下，Reflect 抛异常, Object 强制转换非 Object\nObject.getPrototypeOf('foo')   // String.prototype\nReflect.getPrototypeOf('foo')  // Throws TypeError\n\n// 如果想要模拟 Object 在 ES2015 规范下的表现，需要强制类型转换\nReflect.getPrototypeOf(Object('foo'))  // String.prototype\n```\n\n## has\n\n> 静态方法 Reflect.has() 作用与 in 操作符 相同\n>\n> `Reflect.has(target, propertyKey)`\n>\n> target 目标对象\n> propertyKey 属性名，需要检查目标对象是否存在此属性\n> return Boolean 是否存在此属性\n\n```js\nReflect.has({x: 0}, \"x\"); // true\nReflect.has({x: 0}, \"y\"); // false\n\n// 如果该属性存在于原型链中，返回true\nReflect.has({x: 0}, \"toString\");\n\n// Proxy 对象的 .has() 句柄方法\nobj = new Proxy({}, {\n  has(t, k) { return k.startsWith(\"door\"); }\n});\nReflect.has(obj, \"doorbell\"); // true\nReflect.has(obj, \"dormitory\"); // false\n\n```\n\n## isExtensible\n\n> 静态方法 Reflect.isExtensible() 判断一个对象是否可扩展 （即是否能够添加新的属性）\n> 与它 Object.isExtensible()\n> `Reflect.isExtensible(target)`\n>\n> - target 检查是否可扩展的目标对象。\n> return Boolean 是否可扩展。\n>\n```js\n// New objects are extensible.\nvar empty = {};\nReflect.isExtensible(empty); // === true\n\n// ...but that can be changed.\nReflect.preventExtensions(empty);\nReflect.isExtensible(empty); // === false\n\n// Sealed objects are by definition non-extensible.\nvar sealed = Object.seal({});\nReflect.isExtensible(sealed); // === false\n\n// Frozen objects are also by definition non-extensible.\nvar frozen = Object.freeze({});\nReflect.isExtensible(frozen); // === false\n\n```\n\n## 与 Object.isExtensible() 的不同点\n\n> 如果该方法的第一个参数不是一个对象（原始值），那么将造成一个 TypeError 异常\n> 对于 Object.isExtensible()，非对象的第一个参数会被强制转换为一个对象\n\n```js\nReflect.isExtensible(1);\n// TypeError: 1 is not an object\n\nObject.isExtensible(1);\n// false\n```\n\n## ownKeys\n\n> `Reflect.ownKeys(target)`\n> 静态方法 `Reflect.ownKeys()` 返回一个由目标对象自身的属性键组成的数组。\n\n```js\nReflect.ownKeys({z: 3, y: 2, x: 1}); // [ \"z\", \"y\", \"x\" ]\nReflect.ownKeys([]); // [\"length\"]\n\nvar sym = Symbol.for(\"comet\");\nvar sym2 = Symbol.for(\"meteor\");\nvar obj = {[sym]: 0, \"str\": 0, \"773\": 0, \"0\": 0,\n           [sym2]: 0, \"-1\": 0, \"8\": 0, \"second str\": 0};\nReflect.ownKeys(obj);\n// [ \"0\", \"8\", \"773\", \"str\", \"-1\", \"second str\", Symbol(comet), Symbol(meteor) ]\n// Indexes in numeric order,\n// strings in insertion order,\n// symbols in insertion order\n\n```\n\n## preventExtensions\n\n> `Reflect.preventExtensions(target)`\n>\n> - target: 阻止的目标对象\n> - return boolean 是否可以拓展\n> - 阻止新属性添加到对象 (例如：防止将来对对象的扩展被添加到对象中)\n> - 与 `Object.preventExtensions()` 相似\n>\n```js\n// Objects are extensible by default.\nvar empty = {};\nReflect.isExtensible(empty); // === true\n\n// ...but that can be changed.\nReflect.preventExtensions(empty);\nReflect.isExtensible(empty); // === false\n\n\nReflect.preventExtensions(1);\n// TypeError: 1 is not an object\n\nObject.preventExtensions(1);\n// 1\n\n```\n\n## set\n\n> - 在一个对象上设置一个属性\n> - 静态方法\n>\n> `Reflect.set(target, propertyKey, value[, receiver])`\n>\n> - target: 设置属性的目标对象\n> - propertyKey: 设置属性的名称\n> - value: 设置的值\n> - receiver ?  如果有setter, receiver则为setter调用时的this值\n> return boolean 是否设置成功\n\n```js\n// Object\nvar obj = {};\nReflect.set(obj, \"prop\", \"value\"); // true\nobj.prop; // \"value\"\n\n// Array\nvar arr = [\"duck\", \"duck\", \"duck\"];\nReflect.set(arr, 2, \"goose\"); // true\narr[2]; // \"goose\"\n\n// It can truncate an array.\nReflect.set(arr, \"length\", 1); // true\narr; // [\"duck\"];\n\n// With just one argument, propertyKey and value are \"undefined\".\nvar obj = {};\nReflect.set(obj); // true\nReflect.getOwnPropertyDescriptor(obj, \"undefined\");\n// { value: undefined, writable: true, enumerable: true, configurable: true }\n\n```\n\n## setPrototypeOf\n\n> 除了返回类型以外，静态方法 Reflect.setPrototypeOf() 与 Object.setPrototypeOf() 方法是一样的。\n> 它可设置对象的原型（即内部的 [[Prototype]] 属性）为另一个对象或 null，\n> 如果操作成功返回 true，否则返回 false。\n>\n> `Reflect.setPrototypeOf(target, prototype)`\n>\n> - target: 设置原型的目标对象\n> - prototype: 对象的新原型（一个对象或 null）\n> return boolean 是否成功设置\n>\n```js\nReflect.setPrototypeOf({}, Object.prototype); // true\n\n// It can change an object's [[Prototype]] to null.\nReflect.setPrototypeOf({}, null); // true\n\n// Returns false if target is not extensible.\nReflect.setPrototypeOf(Object.freeze({}), null); // false\n\n// Returns false if it cause a prototype chain cycle.\nvar target = {};\nvar proto = Object.create(target);\nReflect.setPrototypeOf(target, proto); // false\n\n```\n","children":[]},{"name":"window","path":"../guanruihua.github.io/JavaScript/api","data":"","children":[{"name":"getSelection.md","path":"../guanruihua.github.io/JavaScript/api/window","data":"# getSelection\r\n\r\n> 用户选择范围或光标的当前位置\r\n\r\n- 与 `Document.getSelection()` 等价\r\n- 值得注意的是，目前在 Firefox, Edge (非 Chromium 版本) 及 Internet Explorer 中，`getSelection()` 对 `<textarea>`及 `<input>` 元素不起作用。 `HTMLInputElement.setSelectionRange()` 或 `selectionStart` 及 `selectionEnd` 属性可用于解决此问题\r\n\r\n- 还要注意选择不同于焦点（详见 Selection 及输入焦点）。可使用`Document.activeElement` 来返回当前的焦点元素\r\n\r\n```js\r\nlet selObj = window.getSelection();\r\nconsole.log(selObj);\r\nlet selRange = selObj.getRangeAt(0);\r\n```\r\n\r\n![](./__assets__/getSelection-2022-10-24-16-34-36.png)\r\n\r\n## 术语\r\n\r\n- 锚点（anchor）\r\n\r\n> 锚指的是一个选区的起始点。当我们使用鼠标选择一个区域的时候，锚点就是我们鼠标按下瞬间的那个点。在用户拖动鼠标时，锚点是不会变的。\r\n\r\n- 焦点（focus）\r\n选区的焦点是该选区的终点，当您用鼠标框选一个选区的时候，焦点是你的鼠标松开瞬间所记录的那个点。随着用户拖动鼠标，焦点的位置会随着改变。\r\n\r\n- 范围（range）\r\n范围指的是文档中连续的一部分。一个范围包括整个节点，也可以包含节点的一部分，例如文本节点的一部分。用户通常下只能选择一个范围。“范围”会被作为range对象返回。Range对象也能通过DOM创建、增加、删减。\r\n\r\n## 属性\r\n\r\n- `anchorNode`: 返回该选区起点所在的节点\r\n\r\n- `anchorOffset`:\r\n  - 返回一个数字，表示该选区起点在anchorNode中的位置偏移量\r\n  - 如果 anchorNode 是文字节点，那么返回的就是从该文字节点的第一个字开始，直到被选中的第一个字之间的字数（如果第一个字就被选中，那么偏移量为零）\r\n  - 如果 anchorNode 是一个元素，那么返回的就是在选区第一个节点之前的同级节点总数。(这些节点都是 anchorNode 的子节点)\r\n- `focusNode`: 返回该选区终点所在的节点\r\n\r\n- `focusOffset`:\r\n  - 返回一个数字，表示该选区终点在focusNode中的位置偏移量\r\n  - 如果 focusNode 是文字节点，那么选区末尾未被选中的第一个字，在该文字节点中是第几个字（从0开始计），就返回它。\r\n  - 如果 focusNode 是一个元素，那么返回的就是在选区末尾之后第一个节点之前的同级节点总数\r\n\r\n- `isCollapsed`: 返回一个布尔值，用于判断选区的起始点和终点是否在同一位置\r\n\r\n- `rangeCount`: 返回一个数字，表示该选区所包含的连续范围的数量。一般为1，因为通常情况下用户只能选择一个范围\r\n\r\n## 方法\r\n\r\n- `getRangeAt`:\r\n  - 返回选区开始的节点（Node）\r\n  - 因为通常情况下用户只能选择一个范围，所以只有一个选区（range），此方法一般为getRangeAt(0)\r\n\r\n- `collapse`(光标落在的目标节点, offset): 将当前的选区折叠为一个点\r\n\r\n- `extend`: 将选区的焦点移动到一个特定的位置。\r\n\r\n- `modify`: 修改当前的选区\r\n\r\n- `collapseToStart`: 将当前的选区折叠到起始点\r\n\r\n- `collapseToEnd`: 将当前的选区折叠到最末尾的一个点\r\n\r\n- `selectAllChildren`: 将某一指定节点的子节点框入选区\r\n\r\n- `addRange`: 一个区域（Range）对象将被加入选区\r\n\r\n- `removeRange`: 从选区中移除一个区域\r\n\r\n- `removeAllRanges`: 将所有的区域都从选区中移除\r\n\r\n- `deleteFromDocument`: 从页面中删除选区中的内容\r\n\r\n- `selectionLanguageChange`: 当键盘的朝向发生改变后修改指针的Bidi优先级\r\n\r\n- `toString`: 返回当前选区的纯文本内容\r\n\r\n- `containsNode`: 判断某一个node是否为当前选区的一部分\r\n\r\n## 拓展\r\n\r\n### 替换选中\r\n\r\n- 待测试\r\n\r\n```js\r\n//替换选中文本内容，参数text为要替换的内容\r\nfunction repaceSelectionText(text) {\r\n    //非IE浏览器\r\n    if (window.getSelection) {\r\n        var sel = window.getSelection();\r\n        alert(sel.rangeCount); //选区个数, 通常为 1 .\r\n        sel.deleteFromDocument(); //清除选择的内容\r\n        var r = sel.getRangeAt(0); //即使已经执行了deleteFromDocument(), 这个函数仍然返回一个有效对象.\r\n        var selFrag = r.cloneContents(); //克隆选择的内容\r\n        var frag = selFrag.childNodes; //如果执行了deleteFromDocument(), 这个数组长度将会是 0 \r\n        for (var i = 0; i < frag.length; i++) {\r\n            alert(frag[i].nodeName); //枚举选择的对象\r\n        }\r\n        var h1 = document.createElement('H1'); //生成一个插入对象\r\n        h1.innerHTML = text; //设置这个对象的内容\r\n        r.insertNode(h1); //把对象插入到选区, 这个操作不会替换选择的内容, 而是追加到选区的后面, 所以如果需要普通粘贴的替换效果, 之前执行deleteFromDocument()函数.\r\n    }\r\n    else if (document.selection && document.selection.createRange) {\r\n        //IE浏览器\r\n        var sel = document.selection.createRange(); //获得选区对象\r\n        alert(sel.htmlText); //选择区的html文本.\r\n        sel.pasteHTML('<h1>标题</h1>'); //粘贴到选区的html内容, 会替换选择的内容.\r\n    }\r\n}\r\n```\r\n\r\n### 插入文字\r\n\r\n- 待测试\r\n\r\n```js\r\n function insertSelectionText(html)\r\n{\r\n  if(document.selection && document.selection.createRange)\r\n  {\r\n          /****这里需要解决IE丢失光标位置的问题，详见核心代码四**************/\r\n          document.selection.createRange().pasteHTML(html);\r\n        }else{\r\n          var selection = document.getSelection();\r\n          var range;\r\n          if (selection)\r\n           {\r\n            range = selection.getRangeAt(0);\r\n          }else {\r\n            range = iframeDocument.createRange();\r\n          }\r\n          var oFragment = range.createContextualFragment(html),\r\n          oLastNode = oFragment.lastChild ;\r\n          range.insertNode(oFragment) ;\r\n          range.setEndAfter(oLastNode ) ;\r\n          range.setStartAfter(oLastNode );\r\n          selection.removeAllRanges();//清除选择\r\n          selection.addRange(range);\r\n \r\n        }\r\n        \r\n }\r\n```\r\n","children":[]}]},{"name":"特殊标记.md","path":"../guanruihua.github.io/JavaScript/api","data":"# 特殊符号\r\n\r\n## ⇠  箭头类\r\n\r\n| 符号 | UNICODE | JS    | CSS  | 符号 | UNICODE | JS    | CSS  |\r\n| :--- | :------ | :---- | :--- | :--- | :------ | :---- | :--- |\r\n| ⇠    | &#8672  | u21E0 | 21E0 | ⇢    | &#8674  | u21E2 | 21E2 |\r\n| ⇡    | &#8673  | u21E1 | 21E1 | ⇣    | &#8675  | u21E3 | 21E3 |\r\n| ↞    | &#8606  | u219E | 219E | ↠    | &#8608  | u21A0 | 21A0 |\r\n| ↟    | &#8607  | u219F | 219F | ↡    | &#8609  | u21A1 | 21A1 |\r\n| ←    | &#8592  | u2190 | 2190 | →    | &#8594  | u2192 | 2192 |\r\n| ↑    | &#8593  | u2191 | 2191 | ↓    | &#8595  | u2193 | 2193 |\r\n| ↔    | &#8596  | u2194 | 2194 | ↕    | &#8597  | u2195 | 2195 |\r\n| ⇄    | &#8644  | u21C4 | 21C4 | ⇅    | &#8645  | u21C5 | 21C5 |\r\n| ↢    | &#8610  | u21A2 | 21A2 | ↣    | &#8611  | u21A3 | 21A3 |\r\n| ⇞    | &#8670  | u21DE | 21DE | ⇟    | &#8671  | u21DF | 21DF |\r\n| ↫    | &#8619  | u21AB | 21AB | ↬    | &#8620  | u21AC | 21AC |\r\n| ⇜    | &#8668  | u21DC | 21DC | ⇝    | &#8669  | u21DD | 21DD |\r\n| ↚    | &#8602  | u219A | 219A | ↛    | &#8603  | u219B | 219B |\r\n| ↮    | &#8622  | u21AE | 21AE | ↭    | &#8621  | u21AD | 21AD |\r\n| ⇦    | &#8678  | u21E6 | 21E6 | ⇨    | &#8680  | u21E8 | 21E8 |\r\n| ⇧    | &#8679  | u21E7 | 21E7 | ⇩    | &#8681  | u21E9 | 21E9 |\r\n| ▲    | &#9650  | u25B2 | 25B2 | ►    | &#9658  | u25BA | 25BA |\r\n| ▼    | &#9660  | u25BC | 25BC | ◄    | &#9668  | u25C4 | 25C4 |\r\n| ➔    | &#10132 | u2794 | 2794 | ➙    | &#10137 | u2799 | 2799 |\r\n| ➨    | &#10152 | u27A8 | 27A8 | ➲    | &#10162 | u27B2 | 27B2 |\r\n| ➜    | &#10140 | u279C | 279C | ➞    | &#10142 | u279E | 279E |\r\n| ➟    | &#10143 | u279F | 279F | ➠    | &#10144 | u27A0 | 27A0 |\r\n| ➤    | &#10148 | u27A4 | 27A4 | ➥    | &#10149 | u27A5 | 27A5 |\r\n| ➦    | &#10150 | u27A6 | 27A6 | ➧    | &#10151 | u27A7 | 27A7 |\r\n| ➵    | &#10165 | u27B5 | 27B5 | ➸    | &#10168 | u27B8 | 27B8 |\r\n| ➼    | &#10172 | u27BC | 27BC | ➽    | &#10173 | u27BD | 27BD |\r\n| ➺    | &#10170 | u27BA | 27BA | ➳    | &#10163 | u27B3 | 27B3 |\r\n| ↷    | &#8631  | u21B7 | 21B7 | ↶    | &#8630  | u21B6 | 21B6 |\r\n| ↻    | &#8635  | u21BB | 21BB | ↺    | &#8634  | u21BA | 21BA |\r\n| ↵    | &#8629  | u21B5 | 21B5 | ↯    | &#8623  | u21AF | 21AF |\r\n| ➾    | &#10174 | u27BE | 27BE |\r\n\r\n## ❤ 基本形状类\r\n\r\n| 符号 | UNICODE      | JS    | CSS  | 符号 | UNICODE | JS    | CSS  |\r\n| :--- | :----------- | :---- | :--- | :--- | :------ | :---- | :--- |\r\n| ❤    | &#10084      | u2764 | 2764 | ✈    | &#9992  | u2708 | 2708 |\r\n| ★    | &#9733       | u2605 | 2605 | ✦    | &#10022 | u2726 | 2726 |\r\n| ☀    | &#9728       | u2600 | 2600 | ◆    | &#9670  | u25C6 | 25C6 |\r\n| ◈    | &#9672 u25C8 | 25C8  | ▣    | &#   | 9635    | u25A3 | 25A3 |\r\n| ☻    | &#9787       | u263B | 263B | ☺    | &#9786  | u263A | 263A |\r\n| ☹    | &#9785       | u2639 | 2639 | ✉    | &#9993  | u2709 | 2709 |\r\n| ☎    | &#9742       | u260E | 260E | ☏    | &#9743  | u260F | 260F |\r\n| ✆    | &#9990       | u2706 | 2706 | �    | &#65533 | uFFFD | FFFD |\r\n| ☁    | &#9729       | u2601 | 2601 | ☂    | &#9730  | u2602 | 2602 |\r\n| ❄    | &#10052      | u2744 | 2744 | ☃    | &#9731  | u2603 | 2603 |\r\n| ❈    | &#10056      | u2748 | 2748 | ✿    | &#10047 | u273F | 273F |\r\n| ❀    | &#10048      | u2740 | 2740 | ❁    | &#10049 | u2741 | 2741 |\r\n| ☘    | &#9752       | u2618 | 2618 | ❦    | &#10086 | u2766 | 2766 |\r\n| ☕    | &#9749       | u9749 | 9749 | ❂    | &#10050 | u2742 | 2742 |\r\n| ☥    | &#9765       | u2625 | 2625 | ☮    | &#9774  | u262E | 262E |\r\n| ☯    | &#9775       | u262F | 262F | ☪    | &#9770  | u262A | 262A |\r\n| ☤    | &#9764       | u2624 | 2624 | ✄    | &#9988  | u2704 | 2704 |\r\n| ✂    | &#9986       | u2702 | 2702 | ☸    | &#9784  | u2638 | 2638 |\r\n| ⚓    | &#9875       | u2693 | 2693 | ☣    | &#9763  | u2623 | 2623 |\r\n| ⚠    | &#9888       | u26A0 | 26A0 | ⚡    | &#9889  | u26A1 | 26A1 |\r\n| ☢    | &#9762       | u2622 | 2622 | ♻    | &#9851  | u267B | 267B |\r\n| ♿    | &#9855       | u267F | 267F | ☠    | &#9760  | u2620 | 2620 |\r\n\r\n## ¥  货币类\r\n\r\n| 符号 | UNICODE | JS    | CSS  | 符号 | UNICODE | JS    | CSS   |\r\n| :--- | :------ | :---- | :--- | :--- | :------ | :---- | :---- |\r\n| $    | &#36    | u0024 | �024 | ¢    | &#162   | u00A2 | \\c0A2 |\r\n| £    | &#163   | u00A3 | �0A3 | ¤    | &#164   | u00A4 | �0A4  |\r\n| €    | &#8364  | u20AC | 20AC | ¥    | &#165   | u00A5 | �0A5  |\r\n| ₱    | &#8369  | u20B1 | 20B1 | ₹    | &#8377  | u20B9 | 20B9  |\r\n\r\n## ½  数学类\r\n\r\n| 符号 | UNICODE | JS    | CSS  | 符号 | UNICODE | JS    | CSS  |\r\n| :--- | :------ | :---- | :--- | :--- | :------ | :---- | :--- |\r\n| ½    | &#189   | u00BD | �0BD | ¼    | &#188   | u00BC | �0BC |\r\n| ¾    | &#190   | u00BE | �0BE | ⅓    | &#8531  | u2153 | 2153 |\r\n| ⅔    | &#8532  | u2154 | 2154 | ⅛    | &#8539  | u215B | 215B |\r\n| ⅜    | &#8540  | u215C | 215C | ⅝    | &#8541  | u215D | 215D |\r\n| ‰    | &#8240  | u2030 | 2030 | %    | &#37    | u0025 | �025 |\r\n| <    | &#60    | u003C | �03C | >    | &#62    | u003E | �03E |\r\n\r\n## ♫  音乐符号类\r\n\r\n| 符号 | UNICODE | JS    | CSS  | 符号 | UNICODE | JS    | CSS  |\r\n| :--- | :------ | :---- | :--- | :--- | :------ | :---- | :--- |\r\n| ♩    | &#9833  | u2669 | 2669 | ♪    | &#9834  | u266A | 266A |\r\n| ♫    | &#9835  | u266B | 266B | ♬    | &#9836  | u266C | 266C |\r\n| ♭    | &#9837  | u266D | 266D | ♯    | &#9839  | u266F | 266F |\r\n\r\n## ✖  对错号\r\n\r\n| 符号 | UNICODE | JS     | CSS   | 符号 | UNICODE | JS    | CSS  |\r\n| :--- | :------ | :----- | :---- | :--- | :------ | :---- | :--- |\r\n|      | &#160   | u00A0  | �0A0  | ☐    | &#9744  | u2610 | 2610 |\r\n| ☑    | &#9745  | u2611  | 2611  | ☒    | &#9746  | u2612 | 2612 |\r\n| ✓    | &#10003 | u2713  | 2713  | ✔    | &#10004 | u2714 | 2714 |\r\n| ✕    | &#10005 | u10005 | 10005 | ✖    | &#10006 | u2716 | 2716 |\r\n| ✗    | &#10007 | u2717  | 2717  | ✘    | &#10008 | u2718 | 2718 |\r\n\r\n## ★  全都是星星\r\n\r\n| 符号 | UNICODE | JS    | CSS  | 符号 | UNICODE | JS    | CSS  |\r\n| :--- | :------ | :---- | :--- | :--- | :------ | :---- | :--- |\r\n| ★    | &#9733  | u2605 | 2605 | ✭    | &#10029 | u272D | 272D |\r\n| ✮    | &#10030 | u272E | 272E | ☆    | &#9734  | u2606 | 2606 |\r\n| ✪    | &#10026 | u272A | 272A | ✡    | &#10017 | u2721 | 2721 |\r\n| ✯    | &#10031 | u272F | 272F | ✵    | &#10037 | u2735 | 2735 |\r\n| ✶    | &#10038 | u2736 | 2736 | ✸    | &#10040 | u2738 | 2738 |\r\n| ✹    | &#10041 | u2739 | 2739 | ✺    | &#10042 | u273A | 273A |\r\n| ✱    | &#10033 | u2731 | 2731 | ✲    | &#10034 | u2732 | 2732 |\r\n| ✴    | &#10036 | u2734 | 2734 | ✳    | &#10035 | u2733 | 2733 |\r\n| ✻    | &#10043 | u273B | 273B | ✽    | &#10045 | u273D | 273D |\r\n| ❋    | &#10059 | u274B | 274B | ❆    | &#10054 | u2746 | 2746 |\r\n| ❄    | &#10052 | u2744 | 2744 | ❅    | &#10053 | u2745 | 2745 |\r\n\r\n## ♒  星座类\r\n\r\n| 符号 | UNICODE | JS    | CSS  | 符号 | UNICODE | JS    | CSS  |\r\n| :--- | :------ | :---- | :--- | :--- | :------ | :---- | :--- |\r\n| ♈    | &#9800  | u2648 | 2648 | ♉    | &#9801  | u2649 | 2649 |\r\n| ♊    | &#9802  | u264A | 264A | ♋    | &#9803  | u264B | 264B |\r\n| ♌    | &#9804  | u264C | 264C | ♍    | &#9805  | u264D | 264D |\r\n| ♎    | &#9806  | u264E | 264E | ♏    | &#9807  | u264F | 264F |\r\n| ♐    | &#9808  | u2650 | 2650 | ♑    | &#9809  | u2651 | 2651 |\r\n| ♒    | &#9810  | u2652 | 2652 | ♓    | &#9811  | u2653 | 2653 |\r\n\r\n## ♚  国际象棋类\r\n\r\n| 符号 | UNICODE | JS    | CSS  | 符号 | UNICODE | JS    | CSS  |\r\n| :--- | :------ | :---- | :--- | :--- | :------ | :---- | :--- |\r\n| ♚    | &#9818  | u265A | 265A | ♛    | &#9819  | u265B | 265B |\r\n| ♜    | &#9820  | u265C | 265C | ♝    | &#9821  | u265D | 265D |\r\n| ♞    | &#9822  | u265E | 265E | ♟    | &#9823  | u265F | 265F |\r\n| ♔    | &#9812  | u2654 | 2654 | ♕    | &#9813  | u2655 | 2655 |\r\n| ♖    | &#9814  | u2656 | 2656 | ♗    | &#9815  | u2657 | 2657 |\r\n| ♘    | &#9816  | u2658 | 2658 | ♙    | &#9817  | u2659 | 2659 |\r\n\r\n## ♣  扑克牌类\r\n\r\n| 符号 | UNICODE | JS    | CSS  | 符号 | UNICODE | JS    | CSS  |\r\n| :--- | :------ | :---- | :--- | :--- | :------ | :---- | :--- |\r\n| ♠    | &#9824  | u2660 | 2660 | ♣    | &#9827  | u2663 | 2663 |\r\n| ♥    | &#9829  | u2665 | 2665 | ♦    | &#9830  | u2666 | 2666 |\r\n| ♤    | &#9828  | u2664 | 2664 | ♧    | &#9831  | u2667 | 2667 |\r\n| ♡    | &#9825  | u2661 | 2661 | ♢    | &#9826  | u2662 | 2662 |\r\n\r\n## Ω  希腊字母\r\n\r\n| 符号 | UNICODE | JS    | CSS  | 符号 | UNICODE | JS    | CSS  |\r\n| :--- | :------ | :---- | :--- | :--- | :------ | :---- | :--- |\r\n| Α    | &#913   | u0391 | �391 | Β    | &#914   | u0392 | �392 |\r\n| Γ    | &#915   | u0393 | �393 | Δ    | &#916   | u0394 | �394 |\r\n| Ε    | &#917   | u0395 | �395 | Ζ    | &#918   | u0396 | �396 |\r\n| Η    | &#919   | u0397 | �397 | Θ    | &#920   | u0398 | �398 |\r\n| Ι    | &#921   | u0399 | �399 | Κ    | &#922   | u039A | �39A |\r\n| Λ    | &#923   | u039B | �39B | Μ    | &#924   | u039C | �39C |\r\n| Ν    | &#925   | u039D | �39D | Ξ    | &#926   | u039E | �39E |\r\n| Ο    | &#927   | u039F | �39F | Π    | &#928   | u03A0 | �3A0 |\r\n| Ρ    | &#929   | u03A1 | �3A1 | Σ    | &#931   | u03A3 | �3A3 |\r\n| Τ    | &#932   | u03A4 | �3A4 | Υ    | &#933   | u03A5 | �3A5 |\r\n| Φ    | &#934   | u03A6 | �3A6 | Χ    | &#935   | u03A7 | �3A7 |\r\n| Ψ    | &#936   | u03A8 | �3A8 | Ω    | &#937   | u03A9 | �3A9 |\r\n\r\n## ☩  十字\r\n\r\n| 符号 | UNICODE | JS    | CSS  | 符号 | UNICODE | JS    | CSS  |\r\n| :--- | :------ | :---- | :--- | :--- | :------ | :---- | :--- |\r\n| ☨    | &#9768  | u2628 | 2628 | ☩    | &#9769  | u2629 | 2629 |\r\n| ✝    | &#10013 | u271D | 271D | ✞    | &#10014 | u271E | 271E |\r\n| ✟    | &#10015 | u271F | 271F | ✠    | &#10016 | u2720 | 2720 |\r\n| ✚    | &#10010 | u271A | 271A | †    | &#8224  | u2020 | 2020 |\r\n| ✢    | &#10018 | u2722 | 2722 | ✤    | &#10020 | u2724 | 2724 |\r\n| ✣    | &#10019 | u2723 | 2723 | ✥    | &#10021 | u2725 | 2725 |\r\n\r\n## ©  法律符号\r\n\r\n| 符号 | UNICODE | JS    | CSS  | 符号 | UNICODE | JS    | CSS  |\r\n| :--- | :------ | :---- | :--- | :--- | :------ | :---- | :--- |\r\n| ®    | &#174   | u00AE | �0AE | ©    | &#169   | u00A9 | �0A9 |\r\n| ℗    | &#8471  | u2117 | 2117 | ™    | &#153   | u0099 | �099 |\r\n| ℠    | &#8480  | u2120 | 2120 |\r\n\r\n## @  标点和符号\r\n\r\n| 符号 | UNICODE | JS    | CSS  | 符号 | UNICODE | JS    | CSS  |\r\n| :--- | :------ | :---- | :--- | :--- | :------ | :---- | :--- |\r\n| «    | &#171   | u00AB | �0AB | »    | &#187   | u00BB | �0BB |\r\n| ‹    | &#139   | u008B | �08B | ›    | &#155   | u009B | �09B |\r\n| “    | &#8220  | u201C | 201C | ”    | &#8221  | u201D | 201D |\r\n| ‘    | &#8216  | u2018 | 2018 | ’    | &#8217  | u2019 | 2019 |\r\n| •    | &#8226  | u2022 | 2022 | ◦    | &#9702  | u25E6 | 25E6 |\r\n| ¡    | &#161   | u00A1 | �0A1 | ¿    | &#191   | u00BF | �0BF |\r\n| ℅    | &#8453  | u2105 | 2105 | №    | &#8470  | u2116 | 2116 |\r\n| &    | &#38    | u0026 | �026 | @    | &#64    | u0040 | �040 |\r\n| ℞    | &#8478  | u211E | 211E | ℃    | &#8451  | u2103 | 2103 |\r\n| ℉    | &#8457  | u2109 | 2109 | °    | &#176   | u00B0 | �0B0 |\r\n|      | &#124   | u007C | �07C | ¦    | &#166   | u00A6 | �0A6 |\r\n| –    | &#8211  | u2013 | 2013 | —    | &#8212  | u2014 | 2014 |\r\n| …    | &#8230  | u2026 | 2026 | ¶    | &#182   | u00B6 | �0B6 |\r\n| ∼    | &#8764  | u223C | 223C | ≠    | &#8800  | u2260 | 2260 |\r\n总结归类：\r\n\r\n## 特别\r\n\r\n| 符号 | code       | desc                                                   |\r\n| :--- | :--------- | :----------------------------------------------------- |\r\n| ©    | `&copy;`   | © 版权标志                                             |\r\n| ·    | `&middot;` | · 圆点，有时被用来作为菜单分隔符                       |\r\n| ↑    | `&uarr;`   | ↑ 上箭头，常用作网页“返回页面顶部”标识                 |\r\n| €    | `&euro;`   | € 欧元标识                                             |\r\n| ²    | `&sup2;`   | ² 上标2，数学中的平方，在数字处理中常用到，例如：1000² |\r\n| ½    | `&frac12;` | ½ 二分之一                                             |\r\n| ♥    | `&hearts;` | ♥ 心型，用来表达你的心                                 |\r\n|      | `&nbsp;`   | 空格                                                   |\r\n| &    | `&amp;`    | & and符号，与                                          |\r\n| “    | `&quot;`   | “ 引号                                                 |\r\n| ©    | `&copy;`   | © 版权标志                                             |\r\n| ®    | `&reg;`    | » 注册标志                                             |\r\n| ™    | `&trade;`  | ™ 商标标志                                             |\r\n| “    | `&ldquo;`  | “ 左双引号                                             |\r\n| ”    | `&rdquo;`  | ” 右双引号                                             |\r\n| ‘    | `&lsquo;`  | ‘ 做单引号                                             |\r\n| ’    | `&rsquo;`  | ’ 右单引号                                             |\r\n| «    | `&laquo;`  | « 左三角双引号                                         |\r\n| »    | `&raquo;`  | » 右三角双引号                                         |\r\n| ‹    | `&lsaquo;` | ‹ 左三角单引号                                         |\r\n| ›    | `&rsaquo;` | › 右三角单引号                                         |\r\n| §    | `&sect;`   | § 章节标志                                             |\r\n| ¶    | `&para;`   | ¶ 段落标志                                             |\r\n| •    | `&bull;`   | • 列表圆点（大）                                       |\r\n| ·    | `&middot;` | · 列表圆点（中）                                       |\r\n| …    | `&hellip;` | … 省略号                                               |\r\n| ¦    | `&brvbar;` | ¦ 断的竖线                                             |\r\n| –    | `&ndash;`  | – 短破折号                                             |\r\n| —    | `&mdash;`  | — 长破折号                                             |\r\n| ¤    | `&curren;` | ¤ 一般货币符号                                         |\r\n| ¢    | `&cent;`   | ¢ 分                                                   |\r\n| £    | `&pound;`  | £ 英镑                                                 |\r\n| ¥    | `&yen;`    | ¥ 日元                                                 |\r\n| €    | `&euro;`   | € 欧元                                                 |\r\n| <    | `&lt;`     | < 小于号                                               |\r\n| >    | `&gt;`     | > 大于号                                               |\r\n| ≤    | `&le;`     | ≤ 小于等于号                                           |\r\n| ≥    | `&ge;`     | ≥ 大于等于号                                           |\r\n| ×    | `&times;`  | × 乘号                                                 |\r\n| ÷    | `&divide;` | ÷ 除号                                                 |\r\n| −    | `&minus;`  | − 减号                                                 |\r\n| ±    | `&plusmn;` | ± 加/减 号                                             |\r\n| ≠    | `&ne;`     | ≠ 不等于号                                             |\r\n| ¹    | `&sup1;`   | ¹ 上标1                                                |\r\n| ²    | `&sup2;`   | ² 上标2                                                |\r\n| ³    | `&sup3;`   | ³ 上标3                                                |\r\n| ½    | `&frac12;` | ½ 二分之一                                             |\r\n| ¼    | `&frac14;` | ¼ 四分之一                                             |\r\n| ¾    | `&frac34;` | ¾ 四分之三                                             |\r\n| ‰    | `&permil;` | ‰ 千分率                                               |\r\n| °    | `&deg;`    | ° 度                                                   |\r\n| √    | `&radic;`  | √ 平方根                                               |\r\n| ∞    | `&infin;`  | ∞ 无限大                                               |\r\n| ←    | `&larr;`   | ← 左箭头                                               |\r\n| ↑    | `&uarr;`   | ↑ 上箭头                                               |\r\n| →    | `&rarr;`   | → 右箭头                                               |\r\n| ↓    | `&darr;`   | ↓ 下箭头                                               |\r\n| ↔    | `&harr;`   | ↔ 左右箭头                                             |\r\n| ↵    | `&crarr;`  | ↵ 回车箭头                                             |\r\n| ⌈    | `&lceil;`  | ⌈ 左上限                                               |\r\n| ⌉    | `&rceil;`  | ⌉ 右上限                                               |\r\n| ⌊    | `&lfloor;` | ⌊ 左下限                                               |\r\n| ⌋    | `&rfloor;` | ⌋ 右下限                                               |\r\n| ♠    | `&spades;` | ♠ 黑桃                                                 |\r\n| ♣    | `&clubs;`  | ♣ 梅花                                                 |\r\n| ♥    | `&hearts;` | ♥ 红桃，心                                             |\r\n| ♦    | `&diams;`  | ♦ 方块牌                                               |\r\n| ◊    | `&loz;`    | ◊ 菱形                                                 |\r\n| †    | `&dagger;` | † 匕首                                                 |\r\n| ‡    | `&Dagger;` | ‡ 双剑号                                               |\r\n| ¡    | `&iexcl;`  | ¡ 反向感叹号                                           |\r\n| ¿    | `&iquest;` | ¿ 反向问号                                             |\r\n","children":[]}]},{"name":"Class","path":"../guanruihua.github.io/JavaScript","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/JavaScript/Class","data":"# Class\n\n## 声明类\n\n```js\nclass Animal {\n    constructor(type) {\n        this.type = type\n    }\n    walk() {\n        console.log( `I am walking` )\n    }\n}\nlet dog = new Animal('dog')\nlet monkey = new Animal('monkey')\n```\n\n\n\n## Setters & Getters\n\n> 可以直接在`constructor`中通过this直接定义, 还可以直接在类的顶层来定义\n\n```js\nclass Animal {\n    constructor(type, age) {\n        this.type = type\n        this._age = age\n    }\n    get age() {\n        return this._age\n    }\n    set age(val) {\n        this._age = val\n    }\n}\n```\n\n\n\n## 静态方法\n\n\n\n```js\nclass Animal {\n    constructor(type) {\n        this.type = type\n    }\n    walk() {\n        console.log( `I am walking` )\n    }\n    static eat() {\n        console.log( `I am eating` )\n    }\n}\n```\n\n\n\n## 继承\n\n\n\n```js\nclass Animal {\n    constructor(type) {\n        this.type = type\n    }\n    walk() {\n        console.log( `I am walking` )\n    }\n    static eat() {\n        console.log( `I am eating` )\n    }\n}\n\nclass Dog extends Animal {\n  constructor () {\n    super('dog')\n  }\n  run () {\n    console.log('I can run')\n  }\n}\n```\n\n","children":[]}]},{"name":"es6.md","path":"../guanruihua.github.io/JavaScript","data":"# es6\n\n## 数据类型\n\n> 前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）symbol(ES6新增)\n\n## let const\n\n### let\n\n> - 块级作用域:类似于局部变量,只在所处的代码块有效\n> - 不可以重复声明\n> - 不存在变量提升\n\n```js\n{\n  let a = 10;\n  var b = 1;\n}\n\na // ReferenceError: a is not defined.\nb // 1\n```\n\n> var 变量声明 window.variable === variable\n>\n> ```js\n> var age =14;\n> console.log(window.age) // 14\n> ```\n>\n> 这样会造成全局变量污染\n\ndemo\n\n```js\n// 生成十个按钮, 每次点击的时候弹出对应的数字\n\n// 传统方法\nvar i= 0;\nfor (i =1; i <= 10; i++) {\n  (function(i){\n    var btn = document.createElement('button');\n    btn.innerText = i;\n    btn.onclick = function() {\n      alert(i);\n    }\n    document.body.appendChild(btn);\n  })(i);\n}\n\n// 使用let 方法\nfor (let = 1; i<=10; i++){\n  var btn = document.createElement('button');\n  btn.innerText = i;\n  btn.onclick = function() {\n  alert(i)\n  }\n  document.body.appendChild(btn);\n}\n```\n\n### const\n\n> - 声明一个只读的常量,常量的值不可以改变\n>\n> - 一定要赋初值\n> - 对于符合类型的变量,变量不指向数据,而是指向数据所在的地址\n\n```js\n// 使变量不可以更改\nvar CST = { value: '张三' };\nObject.defineProperty(CST, 'value', {\n  writable: false\n})\n\nObject.seal(CST); // CST也不可以挂载任何变量/或拓展\n\nconst PI = 3.1415;\nPI // 3.1415\n\nPI = 3;\n// TypeError: Assignment to constant variable.\n```\n\n> cost变量还是可以赋值的\n\n```js\nconst foo = {};\nfoo.prop = 123;\n\nfoo.prop\n// 123\n\nconst a = [];\na.push('Hello'); // 可执行\na.length = 0;    // 可执行\na = ['Dave'];    // 报错\n```\n\n## 变量的解构赋值\n\n### 基本用法\n\n```js\nvar a = 1;\nvar b = 2;\nvar c = 3;\n//可以写成\nvar [a, b, c] = [1, 2, 3];\n//set结构\nlet [x, y, z] = new Set([\"a\", \"b\", \"c\"]);\n//默认值\n[x, y = 'b'] = ['a']; // x='a', y='b'\n[x, y = 'b'] = ['a', undefined]; // x='a', y='b'\n//对象\nvar { bar, foo } = { foo: \"aaa\", bar: \"bbb\" };\nfoo // \"aaa\"\nbar // \"bbb\"\n//字符串\nconst [a, b, c, d, e] = 'hello';\na // \"h\"\nb // \"e\"\nc // \"l\"\nd // \"l\"\ne // \"o\"\nlet {length : len} = 'hello';\nlen // 5\n```\n\n### 遍历map结构\n\n```js\nvar map = new Map();\nmap.set('first','hello');\nmap.set('second','world');\n\nfor(let [key, value] of map){\n  console.log(key+\"is\"+value);\n}\n\n//获取键名\nfor(let [key] of map){...}\n//获取键值\nfor(let [,value] of map){...}\n```\n\n### 输入模块的指定方法\n\n```js\nconst { SourceMapConsumer, SourceNode } = require(\"source-map\");\n```\n\n## 字符串拓展\n\n### 字符的Unicode表示法\n\n> `\\u0000`——`\\uFFFF`之间的字符。超出这个范围的字符，必须用两个双字节的形式表达\n\n```js\n\"\\uD842\\uDFB7\"\n// \"𠮷\"\n\"\\u20BB7\"\n// \" 7\"(这里js理解为\"\\u20BB+7\"=>空格+7)\n//放进化括号可以解决以上问题\n'\\u{1F680}' === '\\uD83D\\uDE80'\n// true\n```\n\n#### 六种方式表示一个字符\n\n```js\n'\\z' === 'z'  // true\n'\\172' === 'z' // true\n'\\x7A' === 'z' // true\n'\\u007A' === 'z' // true\n'\\u{7A}' === 'z' // true\n```\n\n### codePointAt()\n\n> 普通字符:2个字符(UTF-16格式)\n>\n> 特殊字符:4个字符(Unicode格式[Unicode码点>0xFFFF])\n\n```js\nvar s = \"𠮷\";//0xD842 0xDFB7\n\ns.length // 2\ns.charAt(0) // ''\ns.charAt(1) // ''\ns.charCodeAt(0) // 55362\ns.charCodeAt(1) // 57271\n```\n\n### at()\n\n```js\n'abc'.charAt(0) // \"a\"\n'𠮷'.charAt(0) // \"\\uD842\"\n\n'abc'.at(0) // \"a\"\n'𠮷'.at(0) // \"𠮷\"\n```\n\n### 字符串遍历器\n\n> for ...of可以遍历大于0xFFFF的码点\n\n```js\nfor (let codePoint of 'foo') {\n  console.log(codePoint)\n}\n// \"f\"\n// \"o\"\n// \"o\"\n```\n\n### includes(), startsWith(), endsWith()\n\n> - indexOf():用来确定一个字符串是否包含在另一个字符串中。\n> - **includes()**：返回布尔值，表示是否找到了参数字符串。\n>\n> - **startsWith()**：返回布尔值，表示参数字符串是否在源字符串的头部。\n> - **endsWith()**：返回布尔值，表示参数字符串是否在源字符串的尾部。\n\n```js\nvar s = 'Hello world!';\n\ns.startsWith('Hello') // true\ns.endsWith('!') // true\ns.includes('o') // true\n\ns.startsWith('world', 6) // true\ns.endsWith('Hello', 5) // true\ns.includes('Hello', 6) // false\n```\n\nrepest()\n\n> 返回一个字符重复n次的新字符\n\n```js\n 'x'.repeat(3) // \"xxx\"\n```\n\n### 模板字符串\n\n```js\n// 字符串中嵌入变量\nvar name = \"Bob\", time = \"today\";\n`Hello ${name}, how are you ${time}?`\n\n\n//标签模板\nalert`123`\n// 等同于\nalert(123)\n```\n\n## symbol\n\n> - 通过Symbol函数生成\n>   - 原来就有的字符串\n>   - 新增的Symbol类型\n> - 每一个symbol都是不相等的\n>\n> -\n\n```js\nlet s = Symbol();\n\ntypeof s\n// \"symbol\"\n\nvar mySymbol = Symbol();\n\nvar a = {};\na[mySymbol] = 'Hello!';\n```\n\n## set和Map数据结构\n\n### Set\n\n> - 每一个成员都是唯一,没有重复的值\n> - 遍历操作\n>   - keys():返回键名的遍历器\n>   - values():返回键值的遍历器\n>   - entries():返回键值对的遍历器\n>   - forEach():使用回调函数遍历每一个成员\n\n```js\nvar s = new Set();\n\n[2, 3, 5, 4, 5, 2, 2].map(x => s.add(x));\n\nfor (let i of s) {\n  console.log(i);\n}\n// 2 3 5 4\n\n// 例一\nvar set = new Set([1, 2, 3, 4, 4]);\n[...set]\n// [1, 2, 3, 4]\n\n// 例二\nvar items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);\nitems.size // 5\n\n// 例三\nfunction divs () {\n  return [...document.querySelectorAll('div')];\n}\n\nvar set = new Set(divs());\nset.size // 56\n\n// 类似于\ndivs().forEach(div => set.add(div));\nset.size // 56\n```\n\n### Map\n\n> - 只能使用字符串当做键\n> - set(key,value):赋值\n> - get(key):获取\n\n```js\nvar data = {};\nvar element = document.getElementById('myDiv');\n\ndata[element] = 'metadata';\ndata['[object HTMLDivElement]'] // \"metadata\"\n\n```\n\n```javascript\nvar m = new Map();\nvar o = {p: 'Hello World'};\n\nm.set(o, 'content')\nm.get(o) // \"content\"\n\nm.has(o) // true\nm.delete(o) // true\nm.has(o) // false\n```\n\n## Proxy和Reflect\n\n### Proxy\n\n> Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。\n>\n> Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。\n>\n> ```javascript\n> var proxy = new Proxy(target, handler);\n> target:拦截目标\n> handler:拦截行为\n> ```\n\n```js\nvar obj = new Proxy({}, {\n  get: function (target, key, receiver) {\n    console.log(`getting ${key}!`);\n    return Reflect.get(target, key, receiver);\n  },\n  set: function (target, key, value, receiver) {\n    console.log(`setting ${key}!`);\n    return Reflect.set(target, key, value, receiver);\n  }\n});\n\nobj.count = 1\n//  setting count!\n++obj.count\n//  getting count!\n//  setting count!\n//  2\n```\n\n> 对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。\n>\n> **（1）get(target, propKey, receiver)**\n>\n> 拦截对象属性的读取，比如`proxy.foo`和`proxy['foo']`。\n>\n> 最后一个参数`receiver`是一个对象，可选，参见下面`Reflect.get`的部分。\n>\n> ```js\n> var person = {\n> name: \"张三\"\n> };\n> \n> var proxy = new Proxy(person, {\n> get: function(target, property) {\n>  if (property in target) {\n>    return target[property];\n>  } else {\n>    throw new ReferenceError(\"Property \\\"\" + property + \"\\\" does not exist.\");\n>  }\n> }\n> });\n> \n> proxy.name // \"张三\"\n> proxy.age // 抛出一个错误\n> ```\n>\n>\n>\n> **（2）set(target, propKey, value, receiver)**\n>\n> 拦截对象属性的设置，比如`proxy.foo = v`或`proxy['foo'] = v`，返回一个布尔值。\n>\n> ```js\n> let validator = {\n> set: function(obj, prop, value) {\n>  if (prop === 'age') {\n>    if (!Number.isInteger(value)) {\n>      throw new TypeError('The age is not an integer');\n>    }\n>    if (value > 200) {\n>      throw new RangeError('The age seems invalid');\n>    }\n>  }\n> \n>  // 对于age以外的属性，直接保存\n>  obj[prop] = value;\n> }\n> };\n> \n> let person = new Proxy({}, validator);\n> \n> person.age = 100;\n> \n> person.age // 100\n> person.age = 'young' // 报错\n> person.age = 300 // 报错\n> ```\n>\n> **（3）has(target, propKey)**\n>\n> 拦截`propKey in proxy`的操作，以及对象的`hasOwnProperty`方法，返回一个布尔值。\n>\n> **（4）deleteProperty(target, propKey)**\n>\n> 拦截`delete proxy[propKey]`的操作，返回一个布尔值。\n>\n> **（5）ownKeys(target)**\n>\n> 拦截`Object.getOwnPropertyNames(proxy)`、`Object.getOwnPropertySymbols(proxy)`、`Object.keys(proxy)`，返回一个数组。该方法返回对象所有自身的属性，而`Object.keys()`仅返回对象可遍历的属性。\n>\n> **（6）getOwnPropertyDescriptor(target, propKey)**\n>\n> 拦截`Object.getOwnPropertyDescriptor(proxy, propKey)`，返回属性的描述对象。\n>\n> **（7）defineProperty(target, propKey, propDesc)**\n>\n> 拦截`Object.defineProperty(proxy, propKey, propDesc）`、`Object.defineProperties(proxy, propDescs)`，返回一个布尔值。\n>\n> **（8）preventExtensions(target)**\n>\n> 拦截`Object.preventExtensions(proxy)`，返回一个布尔值。\n>\n> **（9）getPrototypeOf(target)**\n>\n> 拦截`Object.getPrototypeOf(proxy)`，返回一个对象。\n>\n> **（10）isExtensible(target)**\n>\n> 拦截`Object.isExtensible(proxy)`，返回一个布尔值。\n>\n> **（11）setPrototypeOf(target, proto)**\n>\n> 拦截`Object.setPrototypeOf(proxy, proto)`，返回一个布尔值。\n>\n> 如果目标对象是函数，那么还有两种额外操作可以拦截。\n>\n> **（12）apply(target, object, args)**\n>\n> 拦截 Proxy 实例作为函数调用的操作，比如`proxy(...args)`、`proxy.call(object, ...args)`、`proxy.apply(...)`。\n>\n> **（13）construct(target, args)**\n>\n> 拦截 Proxy 实例作为构造函数调用的操作，比如`new proxy(...args)`。\n\n### Reflect\n\n> `Reflect`对象与`Proxy`对象一样，也是ES6为了操作对象而提供的新API。`Reflect`对象的设计目的有这样几个。\n>\n> （1） 将`Object`对象的一些明显属于语言内部的方法（比如`Object.defineProperty`），放到`Reflect`对象上。现阶段，某些方法同时在`Object`和`Reflect`对象上部署，未来的新方法将只部署在`Reflect`对象上。\n>\n> （2） 修改某些Object方法的返回结果，让其变得更合理。比如，`Object.defineProperty(obj, name, desc)`在无法定义属性时，会抛出一个错误，而`Reflect.defineProperty(obj, name, desc)`则会返回`false`。\n>\n> - Reflect.apply(target,thisArg,args)\n> - Reflect.construct(target,args)\n> - Reflect.get(target,name,receiver)\n>\n> ```js\n> var obj = {\n>   get foo() { return this.bar(); },\n>   bar: function() { ... }\n> };\n> \n> // 下面语句会让 this.bar()\n> // 变成调用 wrapper.bar()\n> Reflect.get(obj, \"foo\", wrapper);\n> ```\n>\n> - Reflect.set(target,name,value,receiver)\n> - Reflect.defineProperty(target,name,desc)\n> - Reflect.deleteProperty(target,name)\n> - Reflect.has(target,name)\n> - Reflect.ownKeys(target)\n> - Reflect.isExtensible(target)\n> - Reflect.preventExtensions(target)\n> - Reflect.getOwnPropertyDescriptor(target, name)\n> - Reflect.getPrototypeOf(target)\n> - Reflect.setPrototypeOf(target, prototype)\n\n## Generator\n\n> - 提供异步变成解决方案\n>\n> - 状态机:封装多个内部状态\n> - 特征\n>   - function:关键词和函数名之间有一个星号(没有规定位置,只要在这之间都可以)\n>   - 内部使用yield(产出)语句[定义状态]\n\n```js\nfunction* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';//结束\n}\n/*\n 建立后并不执行,\n 返回也不是函数运行结果\n 而是一个指向内部状态指针对象(遍历对象Iterator Object)\n*/\n\n\nvar hw = helloWorldGenerator();\n//done:false;表示对象遍历没有结束\nhw.next()\n// { value: 'hello', done: false }\n\nhw.next()\n// { value: 'world', done: false }\n\nhw.next()\n// { value: 'ending', done: true }\n\nhw.next()\n// { value: undefined, done: true }//表示遍历结束\n```\n\n## 代理Proxy\n\n### 语法\n\n```js\nlet p = new Proxy(target, handler);\n```\n\n> `target`: 一个目标对象( 可以是任何类型对象, 包括数组函数等, 甚至另一个代理 ) 用Proxy 来封装\n>\n> `handler`: 一个对象, 其属性是执行一个操作时定义代理的行为函数\n\n### 代理使用\n\n```js\nconst obj = {\n  a: 10\n}\nlet handler = {\n  get: function(target, name){\n    console.log('test: ', target, name)\n    // test:  {\"a\":10} a\n    // test:  {\"a\":10} b\n    return name in target ? target[name] : 37\n  }\n}\nlet p = new Proxy(obj, handler)\nconsole.log(p.a, p.b) // 10 37\n```\n\n## Object.assign()\n\n## 基本用法\n\n`-Object.assign`方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。\n\n```dart\nconst target = { a: 1 };\n\nconst source1 = { b: 2 };\nconst source2 = { c: 3 };\n\nObject.assign(target, source1, source2);\ntarget // {a:1, b:2, c:3}\n```\n\n`Object.assign`方法的第一个参数是目标对象，后面的参数都是源对象。\n\n注意，如果目标对象与源对象有同名属性，或多个源对象有**同名属性，则后面的属性会覆盖前面的属性。**\n\n```dart\nconst target = { a: 1, b: 1 };\n\nconst source1 = { b: 2, c: 2 };\nconst source2 = { c: 3 };\n\nObject.assign(target, source1, source2);\ntarget // {a:1, b:2, c:3}\n```\n\n如果只有一个参数，`Object.assign`会直接返回该参数。\n\n```dart\nconst obj = {a: 1};\nObject.assign(obj) === obj // true\n```\n\n如果该参数不是对象，则会先转成对象，然后返回。\n\n```jsx\ntypeof Object.assign(2) // \"object\"\n```\n\n由于`undefined`和`null`无法转成对象，所以如果它们作为参数，就会报错。\n\n```jsx\nObject.assign(undefined) // 报错\nObject.assign(null) // 报错\n```\n\n如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果`undefined`和`null`不在首参数，就不会报错。\n\n```jsx\nlet obj = {a: 1};\nObject.assign(obj, undefined) === obj // true\nObject.assign(obj, null) === obj // true\n```\n\n其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。\n\n```jsx\nconst v1 = 'abc';\nconst v2 = true;\nconst v3 = 10;\n\nconst obj = Object.assign({}, v1, v2, v3);\nconsole.log(obj); // { \"0\": \"a\", \"1\": \"b\", \"2\": \"c\" }\n```\n\n上面代码中，`v1`、`v2`、`v3`分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。\n\n```dart\nObject(true) // {[[PrimitiveValue]]: true}\nObject(10)  //  {[[PrimitiveValue]]: 10}\nObject('abc') // {0: \"a\", 1: \"b\", 2: \"c\", length: 3, [[PrimitiveValue]]: \"abc\"}\n```\n\n上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性 `[[PrimitiveValue]]`上面，这个属性是不会被`Object.assign`拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。\n\n`Object.assign`拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（`enumerable: false`）。\n\n```dart\nObject.assign({b: 'c'},\n  Object.defineProperty({}, 'invisible', {\n    enumerable: false,\n    value: 'hello'\n  })\n)\n// { b: 'c' }\n```\n\n上面代码中，`Object.assign`要拷贝的对象只有一个不可枚举属性`invisible`，这个属性并没有被拷贝进去。\n\n属性名为 Symbol 值的属性，也会被`Object.assign`拷贝。\n\n```dart\nObject.assign({ a: 'b' }, { [Symbol('c')]: 'd' })\n// { a: 'b', Symbol(c): 'd' }\n```\n\n------\n\n### 注意点\n\n#### （1）浅拷贝\n\n`Object.assign`方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。\n\n```dart\nconst obj1 = {a: {b: 1}};\nconst obj2 = Object.assign({}, obj1);\n\nobj1.a.b = 2;\nobj2.a.b // 2\n```\n\n上面代码中，源对象`obj1`的`a`属性的值是一个对象，`Object.assign`拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。\n\n#### （2）同名属性的替换\n\n对于这种嵌套的对象，一旦遇到同名属性，`Object.assign`的处理方法是替换，而不是添加。\n\n```dart\nconst target = { a: { b: 'c', d: 'e' } }\nconst source = { a: { b: 'hello' } }\nObject.assign(target, source)\n// { a: { b: 'hello' } }\n```\n\n上面代码中，`target`对象的`a`属性被`source`对象的`a`属性整个替换掉了，而不会得到`{ a: { b: 'hello', d: 'e' } }`的结果。这通常不是开发者想要的，需要特别小心。\n\n一些函数库提供 `Object.assign`的定制版本（比如 Lodash 的`_.defaultsDeep`方法），可以得到深拷贝的合并。\n\n#### （3）数组的处理\n\n`Object.assign`可以用来处理数组，但是会把数组视为对象。\n\n```dart\nObject.assign([1, 2, 3], [4, 5])\n// [4, 5, 3]\n```\n\n上面代码中，`Object.assign`把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性`4`覆盖了目标数组的 0 号属性`1`。\n\n#### （4）取值函数的处理\n\n`Object.assign`只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。\n\n```jsx\nconst source = {\n  get foo() { return 1 }\n};\nconst target = {};\n\nObject.assign(target, source)\n// { foo: 1 }\n```\n\n上面代码中， `source`对象的`foo`属性是一个取值函数，`Object.assign`不会复制这个取值函数，只会拿到值以后，将这个值复制过去。\n\n## 常见用途\n\n`Object.assign`方法有很多用处。\n\n### （1）为对象添加属性\n\n```jsx\nclass Point {\n  constructor(x, y) {\n    Object.assign(this, {x, y});\n  }\n}\n```\n\n上面方法通过`Object.assign`方法，将`x`属性和`y`属性添加到`Point`类的对象实例。\n\n### （2）为对象添加方法\n\n```jsx\nObject.assign(SomeClass.prototype, {\n  someMethod(arg1, arg2) {\n    ···\n  },\n  anotherMethod() {\n    ···\n  }\n});\n\n// 等同于下面的写法\nSomeClass.prototype.someMethod = function (arg1, arg2) {\n  ···\n};\nSomeClass.prototype.anotherMethod = function () {\n  ···\n};\n```\n\n上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用`assign`方法添加到`SomeClass.prototype`之中。\n\n### （3）克隆对象\n\n```jsx\nfunction clone(origin) {\n  return Object.assign({}, origin);\n}\n```\n\n上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。\n\n不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。\n\n```jsx\nfunction clone(origin) {\n  let originProto = Object.getPrototypeOf(origin);\n  return Object.assign(Object.create(originProto), origin);\n}\n```\n\n### （4）合并多个对象\n\n将多个对象合并到某个对象。\n\n```jsx\nconst merge = (target, ...sources) => Object.assign(target, ...sources);\n```\n\n如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。\n\n```jsx\nconst merge = (...sources) => Object.assign({}, ...sources);\n```\n\n### （5）为属性指定默认值\n\n```jsx\nconst DEFAULTS = {\n  logLevel: 0,\n  outputFormat: 'html'\n};\n\nfunction processContent(options) {\n  options = Object.assign({}, DEFAULTS, options);\n  console.log(options);\n  // ...\n}\n```\n\n上面代码中，`DEFAULTS`对象是默认值，`options`对象是用户提供的参数。`Object.assign`方法将`DEFAULTS`和`options`合并成一个新对象，如果两者有同名属性，则`option`的属性值会覆盖`DEFAULTS`的属性值。\n\n注意，由于存在浅拷贝的问题，`DEFAULTS`对象和`options`对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，`DEFAULTS`对象的该属性很可能不起作用。\n\n```csharp\nconst DEFAULTS = {\n  url: {\n    host: 'example.com',\n    port: 7070\n  },\n};\n\nprocessContent({ url: {port: 8000} })\n// {\n//   url: {port: 8000}\n// }\n```\n\n上面代码的原意是将 `url.port`改成 8000，`url.host`不变。实际结果却是`options.url`覆盖掉`DEFAULTS.url`，所以`url.host`就不存在了。\n\n## function\n\n```js\n//传统\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function () {\n  return '(' + this.x + ', ' + this.y + ')';\n};\n\nvar p = new Point(1, 2);\n\n//ES6\nclass Point {\n  constructor(x, y) {//类似于java的构造函数\n    this.x = x;\n    this.y = y;\n  }\n // 私有方法\n  _bar(baz) {\n    return this.snaf = baz;\n  }\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\n```\n","children":[]},{"name":"ESMAScript.md","path":"../guanruihua.github.io/JavaScript","data":"# ESMAScript\n\n## 变量的解构赋值\n\nES6允许我们，通过数组或者对象的方式，对一组变量进行赋值，这被称为解构。\n\n解构赋值在实际开发中可以大量减少我们的代码量，并且让程序结构更清晰。\n\n### 数组的解构赋值\n\n**举例：**\n\n通常情况下，我们在为一组变量赋值时，一般是这样写：\n\n```javascript\n let a = 0;\n let b = 1;\n let c = 2;\n\n```\n\n现在我们可以通过数组解构的方式进行赋值：\n\n```javascript\n let [a, b, c] = [1, 2, 3];\n```\n\n二者的效果是一样的。\n\n**解构的默认值：**\n\n在解构赋值时，是允许使用默认值的。举例如下：\n\n```javascript\n{\n    //一个变量时\n    let [foo = true] = [];\n    console.log(foo); //输出结果：true\n}\n\n{\n    //两个变量时\n    let [a, b] = ['生命壹号']   //a 赋值为：生命壹号。b没有赋值\n    console.log(a + ',' + b); //输出结果：生命壹号,undefined\n}\n\n\n{\n    //两个变量时\n    let [a, b = 'smyhvae'] = ['生命壹号']   //a 赋值为：生命壹号。b 采用默认值 smyhvae\n    console.log(a + ',' + b); //输出结果：生命壹号,smyhvae\n}\n\n```\n\n`undefined`和`null`的区别：\n\n如果我们在赋值时，采用的是 `undefined`或者`null`，那会有什么区别呢？\n\n```javascript\n{\n    let [a, b = 'smyhvae'] = ['生命壹号', undefined]; //b 虽然被赋值为 undefined，但是 b 会采用默认值\n    console.log(a + ',' + b); //输出结果：生命壹号,smyhvae\n}\n\n{\n    let [a, b = 'smyhvae'] = ['生命壹号', null];  //b 被赋值为 null\n    console.log(a + ',' + b); //输出结果：生命壹号,null\n}\n\n```\n\n上方代码分析：\n\n- undefined：相当于什么都没有，此时 b 采用默认值。\n\n- null：相当于有值，但值为 null。\n\n### 对象的解构赋值\n\n通常情况下，我们从接口拿到json数据后，一般这么赋值：\n\n```javascript\nvar a = json.a;\n\nvar b = json.b;\n\nbar c = json.c;\n```\n\n上面这样写，过于麻烦了。\n\n现在，我们同样可以针对对象，进行结构赋值。\n\n**举例如下：**\n\n```js\n let { foo, bar } = { bar: '我是 bar 的值', foo: '我是 foo 的值' };\n console.log(foo + ',' + bar); //输出结果：我是键 foo 的值,我是键 bar 的值\n```\n\n上方代码可以看出，对象的解构与数组的结构，有一个重要的区别：**数组**的元素是按次序排列的，变量的取值由它的**位置**决定；而**对象的属性没有次序**，是**根据键来取值**的。\n\n**圆括号的使用**：\n\n如果变量 foo 在解构之前就已经定义了，此时你再去解构，就会出现问题。下面是错误的代码，编译会报错：\n\n```javascript\n let foo = 'haha';\n { foo } = { foo: 'smyhvae' };\n console.log(foo);\n\n```\n\n要解决报错，只要在解构的语句外边，加一个圆括号即可：\n\n```javascript\n let foo = 'haha';\n ({ foo } = { foo: 'smyhvae' });\n console.log(foo); //输出结果：smyhvae\n\n```\n\n### 字符串解构\n\n字符串也可以解构，这是因为，此时字符串被转换成了一个类似数组的对象。举例如下：\n\n```javascript\nconst [a, b, c, d] = 'smyhvae';\nconsole.log(a);\nconsole.log(b);\nconsole.log(c);\nconsole.log(d);\n\nconsole.log(typeof a);  //输出结果：string\n```\n\n输出结果：\n\n![](http://img.smyhvae.com/20180304_1626.png)\n\n## for ... of 循环\n\nES6 中，如果我们要遍历一个数组，可以这样做：\n\n```\n let arr1 = [1, 2, 3, 4, 5];\n\n for (let value of arr1) {\n     console.log(value);\n }\n```\n\n输出结果：\n\n![](http://img.smyhvae.com/20180304_2016.png)\n\nfor…of 的循环可以避免我们开拓内存空间，增加代码运行效率，所以建议大家在以后的工作中使用for…of循环。\n\n注意，上面的数组中，`for ... of`获取的是数组里的值；`for ... in`获取的是index索引值。\n\n### Map对象的遍历\n\n`for ... of`既可以遍历数组，也可以遍历Map对象。\n\n## 模板字符串\n\n我们以前让字符串进行拼接的时候，是这样做的：（传统写法的字符串拼接）\n\n```javascript\n    var name = 'smyhvae';\n    var age = '26';\n    console.log('name:'+name+',age:'+age);   //传统写法\n```\n\n这种写法，比较繁琐，而且容易出错。\n\n现在有了 ES6 语法，字符串拼接可以这样写：\n\n```javascript\n    var name = 'smyhvae';\n    var age = '26';\n\n    console.log('name:'+name+',age:'+age);   //传统写法\n\n    console.log(`name:${name},age:${age}`);  //ES6 写法\n\n```\n\n**注意**，上方代码中，倒数第二行用的符号是单引号，最后一行用的符号是反引号（在tab键的上方）。\n\n## 函数拓展\n\nES6在**函数扩展**方面，新增了很多特性。例如：\n\n- 箭头函数\n\n- 参数默认值\n\n- 参数结构赋值\n\n- 扩展运算符\n\n- rest参数\n\n- this绑定\n\n- 尾调用\n\n### 箭头函数\n\n定义和调用函数：（传统写法）\n\n```javascript\nfunction fn1(a, b) {\n    return a + b;\n}\n\nconsole.log(fn1(1, 2));  //输出结果：3\n```\n\n定义和调用函数：（ES6中的写法）\n\n```javascript\n var fn2 = (a, b) => a + b;\n console.log(fn2(1, 2));  //输出结果：3\n```\n\n二者的效果是一样的。\n\n在箭头函数中，如果方法体内有两句话，那就需要在方法体外边加上{}括号。如下：\n\n```javascript\n var fn2 = (a, b) => {\n     console.log('haha');\n     return a + b;\n };\n console.log(fn2(1, 2));  //输出结果：3\n\n```\n\n从上面的箭头函数中，我们可以很清晰地找到函数名、参数名、方法体。\n\n上方代码中：\n\n- 如果有且仅有1个参数，则`()`可以省略\n\n- 如果方法体内有且仅有1条语句，则`{}`可以省略，但前提是，这条语句必须是 return。\n\n### this的指向\n\n> 箭头函数只是为了让函数写起来更优雅吗？当然不是，还有一个很大的作用是与this的指向有关。\n\nES5 中，this指向的是函数被调用的对象；而 ES6 的箭头函数中，this指向的是函数被定义时。\n\n简单来说，箭头函数中的this，是不会变的，是永远绑定在当前的环境下。\n\n### 参数默认值\n\n**传统写法**：\n\n```javascript\n    function fn(param) {\n        let p = param || 'hello';\n        console.log(p);\n    }\n```\n\n上方代码中，函数体内的写法是：如果 param 不存在，就用 `hello`字符串做兜底。这样写比较啰嗦。\n\n**ES6 写法**：（参数默认值的写法，很简洁）\n\n```javascript\n    function fn(param = 'hello') {\n        console.log(param);\n    }\n```\n\n在 ES6 中定义方法时，我们可以给方法里的参数加一个**默认值**（缺省值）：\n\n- 方法被调用时，如果没有给参数赋值，那就是用默认值；\n\n- 方法被调用时，如果给参数赋值了新的值，那就用新的值。\n\n如下：\n\n```javascript\n var fn2 = (a, b = 5) => {\n     console.log('haha');\n     return a + b;\n };\n console.log(fn2(1));     //第二个参数使用默认值 5。输出结果：6\n\n console.log(fn2(1, 8));  //输出结果：9\n\n```\n\n**提醒1**：默认值的后面，不能再有**没有默认值的变量**。比如`(a,b,c)`这三个参数，如果我给b设置了默认值，那么就一定要给c设置默认值。\n\n**提醒2**：\n\n我们来看下面这段代码：\n\n```javascript\n    let x = 'smyh';\n    function fn(x, y = x) {\n        console.log(x, y);\n    }\n    fn('vae');\n```\n\n注意第二行代码，我们给y赋值为`x`，这里的`x`是括号里的第一个参数，并不是第一行代码里定义的`x`。打印结果：`vae vae`。\n\n如果我把第一个参数改一下，改成：\n\n```javascript\n    let x = \"smyh\";\n    function fn(z, y = x) {\n        console.log(z, y);\n    }\n    fn(\"vae\");\n```\n\n此时打印结果是：`vae smyh`。\n\n### 扩展运算符\n\n注意区分：\n\n- 扩展运算符的格式为`...`\n\n- rest运算符的格式为`...变量名`\n\n有了ES6，当我们在定义一个方法，但是不确定其参数的个数时，我们就可以用**扩展运算符**作为参数。\n\n以前，我们在定义方法时，参数要确定个数，如下：（程序会报错）\n\n```javascript\n    function fn(a, b, c) {\n        console.log(a);\n        console.log(b);\n        console.log(c);\n        console.log(d);\n    }\n\n    fn(1, 2, 3);\n```\n\n上方代码中，因为方法的参数是三个，但使用时是用到了四个参数，所以会报错：\n\n![](http://img.smyhvae.com/20180304_1638.png)\n\n现在，我们有了扩展运算符，就不用担心报错的问题了。代码可以这样写：\n\n```javascript\nfunction fn(...arg) {   //当不确定方法的参数时，可以使用扩展运算符\n    console.log(arg[0]);\n    console.log(arg[1]);\n    console.log(arg[2]);\n    console.log(arg[3]);\n}\n\nfn(1, 2, 3); //方法中定义了四个参数，但只引用了三个参数，ES6 中并不会报错。\n\n```\n\n![](http://img.smyhvae.com/20180304_1650.png)\n\n上方代码中注意，arg参数之后，不能再加别的参数，否则编译报错。\n\n**举例：**数组赋值的问题\n\n我们来分析一段代码：（将数组 arr1 赋值给 arr2）\n\n```javascript\n let arr1 = ['www', 'smyhvae', 'com'];\n let arr2 = arr1;          // 将 arr1 赋值给 arr2，其实是让 arr2 指向 arr1 的内存地址\n console.log('arr1:' + arr1);\n console.log('arr2:' + arr2);\n console.log('---------------------');\n\n arr2.push('你懂得');  //往arr2 里添加一部分内容\n console.log('arr1:' + arr1);\n console.log('arr2:' + arr2);\n```\n\n运行结果：\n\n![](http://img.smyhvae.com/20180304_1950.png)\n\n上方代码中，我们往往 arr2 里添加了`你懂的`，却发现，arr1 里也有这个内容。原因是：`let arr2 = arr1;`其实是让 arr2 指向 arr1 的地址。也就是说，二者指向的是同一个内存地址。\n\n如果不想让 arr1 和 arr2 指向同一个内存地址，我们可以借助扩展运算符来做：\n\n```javascript\n let arr1 = ['www', 'smyhvae', 'com'];\n let arr2 = [...arr1];  //arr2 会重新开辟内存地址\n console.log('arr1:' + arr1);\n console.log('arr2:' + arr2);\n console.log('---------------------');\n\n arr2.push('你懂得');  //往arr2 里添加一部分内容\n console.log('arr1:' + arr1);\n console.log('arr2:' + arr2);\n```\n\n运行结果：\n\n![](http://img.smyhvae.com/20180304_1951.png)\n\n我们明白了这个例子，就可以避免开发中的很多业务逻辑上的 bug。\n\n### `rest` 运算符\n\n`rest` 在英文中指的是**剩余部分**（不是指休息）。我们来举个例子，理解剩余部分的含义：\n\n```javascript\n function fn(first, second, ...arg) {\n     console.log(arg.length);\n }\n\n fn(0, 1, 2, 3, 4, 5, 6);  //调用函数后，输出结果为 5\n```\n\n上方代码的输出结果为 5。 调用`fn()`时，里面有七个参数，而`arg`指的是剩下的部分（因为除去了`first`和`second`）。\n\n从上方例子中可以看出，`rest`运算符适用于：知道前面的一部分参数的数量，但对于后面剩余的参数数量未知的情况。\n\n## promise,async,Symbol\n\n### Promise\n\n#### 概述\n\nPromise对象: 代表了未来某个将要发生的事件(通常是一个异步操作)。\n\nES6中的promise对象, 可以**将异步操作以同步的流程表达出来，**很好地解决了**回调地狱**的问题（避免了层层嵌套的回调函数）。在使用ES5的时候，在多层嵌套回调时，写完的代码层次过多，很难进行维护和二次开发。\n\n### 回调地狱的举例\n\n假设买菜、做饭、洗碗都是异步的。\n\n现在的流程是：买菜成功之后，才能开始做饭。做饭成功后，才能开始洗碗。这里面就涉及到了回调的嵌套。\n\nES6的Promise是一个构造函数, 用来生成promise实例。\n\n### promise对象的3个状态\n\n- 初始化状态（等待状态）：pending\n\n- 成功状态：fullfilled\n\n- 失败状态：rejected\n\n### promise 方法\n\n  Promise.prototype.then()\n\n  Promise.prototype.catch(): 捕获错误\n\n  Promise.all(): 循环处理数组, 对象, 集合等\n\n  Promise.race(): 输出最先出的结果, 不用等到所有操作都得出结果\n\n  Promise.resolve()\n\n  Promise.reject()\n\n### 使用promise的基本步骤\n\n（1）创建promise对象\n\n（2）调用promise的**回调函数**then()\n\n代码格式如下：\n\n```javascript\nlet promise = new Promise((resolve, reject) => {\n  //进来之后，状态为pending\n  console.log('111');  //这一行代码是同步的\n  //开始执行异步操作（这里开始，写异步的代码，比如ajax请求 or 开启定时器）\n  if (异步的ajax请求成功) {\n    console.log('333');\n    resolve();//如果请求成功了，请写resolve()，此时，promise的状态会被自动修改为fullfilled\n  } else {\n    reject();//如果请求失败了，请写reject()，此时，promise的状态会被自动修改为rejected\n  }\n})\nconsole.log('222');\n\n//调用promise的then()\npromise\n  .then(() => {\n    //如果promise的状态为fullfilled，则执行这里的代码\n    console.log('成功了');\n  }, () => {\n    //如果promise的状态为rejected，则执行这里的代码\n    console.log('失败了');\n  })\n```\n\n代码解释：\n\n（1）当new Promise()执行之后，promise对象的状态会被初始化为`pending`，这个状态是初始化状态。`new Promise()`这行代码，括号里的内容是同步执行的。括号里定义一个function，function有两个参数：resolve和reject。如下：\n\n- 如果请求成功了，请写resolve()，此时，promise的状态会被自动修改为fullfilled。\n\n- 如果请求失败了，请写reject()，此时，promise的状态会被自动修改为rejected\n\n（2）promise.then()方法，括号里面有两个参数，分别代表两个函数 function1 和 function2：\n\n- 如果promise的状态为fullfilled（意思是：如果请求成功），则执行function1里的内容\n\n- 如果promise的状态为rejected（意思是，如果请求失败），则执行function2里的内容\n\n另外，resolve()和reject()这两个方法，是可以给promise.then()传递参数的。如下：\n\n```javascript\n    let promise = new Promise((resolve, reject) => {\n        //进来之后，状态为pending\n        console.log('111');  //这行代码是同步的\n        //开始执行异步操作（这里开始，写异步的代码，比如ajax请求 or 开启定时器）\n        if (异步的ajax请求成功) {\n            console.log('333');\n            resolve('haha');//如果请求成功了，请写resolve()，此时，promise的状态会被自动修改为fullfilled\n        } else {\n            reject('555');//如果请求失败了，请写reject()，此时，promise的状态会被自动修改为rejected\n        }\n    })\n    console.log('222');\n\n    //调用promise的then()\n    promise.then((successMsg) => {\n            //如果promise的状态为fullfilled，则执行这里的代码\n            console.log(successMsg, '成功了');\n        }\n        , (errorMsg) => {\n            //如果promise的状态为rejected，则执行这里的代码\n            console.log(errorMsg, '失败了');\n\n        }\n    )\n```\n\nP\n\n### ajax请求的举例（涉及到嵌套的回调）\n\n```javascript\n    //定义一个请求news的方法\n    function getNews(url) {\n        //创建一个promise对象\n        let promise = new Promise((resolve, reject) => {\n            //初始化promise状态为pending\n            //启动异步任务\n            let request = new XMLHttpRequest();\n            request.onreadystatechange = function () {\n                if (request.readyState === 4) {\n                    if (request.status === 200) {\n                        let news = request.response;\n                        resolve(news);\n                    } else {\n                        reject('请求失败了。。。');\n                    }\n                }\n            };\n            request.responseType = 'json';//设置返回的数据类型\n            request.open(\"GET\", url);//规定请求的方法，创建链接\n            request.send();//发送\n        })\n        return promise;\n    }\n\n    getNews('http://localhost:3000/news?id=2')\n        .then((news) => {\n            console.log(news);\n            document.write(JSON.stringify(news));\n            console.log('http://localhost:3000' + news.commentsUrl);\n            return getNews('http://localhost:3000' + news.commentsUrl);\n        }, (error) => {\n            alert(error);\n        })\n        .then((comments) => {\n            console.log(comments);\n            document.write('<br><br><br><br><br>' + JSON.stringify(comments));\n        }, (error) => {\n            alert(error);\n        })\n\n```\n\n### Symbol\n\n#### 概述\n\n背景：ES5中对象的属性名都是字符串，容易造成重名，污染环境。\n\n**概念**：ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。\n\n**特点：**\n\n- Symbol属性对应的值是唯一的，解决**命名冲突问题**\n\n- Symbol值不能与其他数据进行计算，包括同字符串拼串\n\n- for in、for of 遍历时不会遍历Symbol属性。\n\n#### 创建Symbol属性值\n\nSymbol是函数，但并不是构造函数。创建一个Symbol数据类型：\n\n```javascript\n    let mySymbol = Symbol();\n\n    console.log(typeof mySymbol);  //打印结果：symbol\n    console.log(mySymbol);         //打印结果：Symbol()\n```\n\n打印结果：\n\n![](http://img.smyhvae.com/20180317_1134.png)\n\n下面来讲一下Symbol的使用。\n\n#### 将Symbol作为对象的属性值\n\n```javascript\n    let mySymbol = Symbol();\n\n    let obj = {\n        name: 'smyhvae',\n        age: 26\n    };\n\n    //obj.mySymbol = 'male'; //错误：不能用 . 这个符号给对象添加 Symbol 属性。\n    obj[mySymbol] = 'hello';    //正确：通过**属性选择器**给对象添加 Symbol 属性。后面的属性值随便写。\n\n    console.log(obj);\n```\n\n上面的代码中，我们尝试给obj添加一个Symbol类型的属性值，但是添加的时候，不能采用`.`这个符号，而是应该用`属性选择器`的方式。打印结果：\n\n![](http://img.smyhvae.com/20180317_1134.png)\n\n现在我们用for in尝试对上面的obj进行遍历：\n\n```javascript\n    let mySymbol = Symbol();\n\n    let obj = {\n        name: 'smyhvae',\n        age: 26\n    };\n\n    obj[mySymbol] = 'hello';\n\n    console.log(obj);\n\n    //遍历obj\n    for (let i in obj) {\n        console.log(i);\n    }\n```\n\n打印结果：\n\n![](http://img.smyhvae.com/20180317_1134.png)\n\n从打印结果中可以看到：for in、for of 遍历时不会遍历Symbol属性。\n\n#### 创建Symbol属性值时，传参作为标识\n\n如果我通过 Symbol()函数创建了两个值，这两个值是不一样的：\n\n```javascript\n    let mySymbol1 = Symbol();\n    let mySymbol2 = Symbol();\n\n    console.log(mySymbol1 == mySymbol2); //打印结果：false\n    console.log(mySymbol1);         //打印结果：Symbol()\n    console.log(mySymbol2);         //打印结果：Symbol()\n```\n\n![](http://img.smyhvae.com/20180317_1134.png)\n\n上面代码中，倒数第三行的打印结果也就表明了，二者的值确实是不相等的。\n\n最后两行的打印结果却发现，二者的打印输出，肉眼看到的却相同。那该怎么区分它们呢？\n\n既然Symbol()是函数，函数就可以传入参数，我们可以通过参数的不同来作为**标识**。比如：\n\n```javascript\n    //在括号里加入参数，来标识不同的Symbol\n    let mySymbol1 = Symbol('one');\n    let mySymbol2 = Symbol('two');\n\n    console.log(mySymbol1 == mySymbol2); //打印结果：false\n    console.log(mySymbol1);         //打印结果：Symbol(one)\n    console.log(mySymbol2);         //打印结果：Symbol(two)。颜色为红色。\n    console.log(mySymbol2.toString());//打印结果：Symbol(two)。颜色为黑色。\n```\n\n打印结果：\n\n![](http://img.smyhvae.com/20180317_1134.png)\n\n#### 定义常量\n\nSymbol 可以用来定义常量：\n\n```javascript\n    const MY_NAME = Symbol('my_name');\n```\n\n### async函数（异步函数）\n\n概念：真正意义上去解决异步回调的问题，同步流程表达异步操作。\n\n本质： Generator 的语法糖。\n\nasync比之前的 Promise、Generator要好用一些。\n\n语法：\n\n```javascript\n    async function foo() {\n        await 异步操作;\n        await 异步操作；\n    }\n```\n\n我们在普通的函数前面加上 async 关键字，就成了 async 函数。\n\n### async、Promise、Generator的对比（async的特点）\n\n1、不需要像Generator去调用next方法，遇到await等待，当前的异步操作完成就往下执行。\n\n2、async返回的总是Promise对象，可以用then方法进行下一步操作。\n\n3、async取代Generator函数的星号*，await取代Generator的yield。\n\n4、语意上更为明确，使用简单，经临床验证，暂时没有任何副作用。\n\n## 字符串的扩展\n\nES6中的字符串扩展，用得少，而且逻辑相对简单。如下：\n\n- `includes(str)`：判断是否包含指定的字符串\n\n- `startsWith(str)`：判断是否以指定字符串开头\n\n- `endsWith(str)`：判断是否以指定字符串结尾\n\n- `repeat(count)`：重复指定次数\n\n举例如下：\n\n```javascript\n    let str = 'abcdefg';\n\n    console.log(str.includes('a'));//true\n    console.log(str.includes('h'));//false\n\n    //startsWith(str) : 判断是否以指定字符串开头\n    console.log(str.startsWith('a'));//true\n    console.log(str.startsWith('d'));//false\n\n    //endsWith(str) : 判断是否以指定字符串结尾\n    console.log(str.endsWith('g'));//true\n    console.log(str.endsWith('d'));//false\n\n    //repeat(count) : 重复指定次数a\n    console.log(str.repeat(5));\n```\n\n打印结果：\n\n![](http://img.smyhvae.com/20180402_1050.png)\n\n## Number 的扩展\n\n- 二进制与八进制数值表示法: 二进制用`0b`, 八进制用`0o`。\n\n举例：\n\n```javascript\n    console.log(0b1010);//10\n    console.log(0o56);//46\n```\n\n- `Number.isFinite(i)`：判断是否为有限大的数。比如`Infinity`这种无穷大的数，返回的就是false。\n\n- `Number.isNaN(i)`：判断是否为NaN。\n\n- `Number.isInteger(i)`：判断是否为整数。\n\n- `Number.parseInt(str)`：将字符串转换为对应的数值。\n\n- `Math.trunc(i)`：去除小数部分。\n\n举例：\n\n```javascript\n    //Number.isFinite(i) : 判断是否是有限大的数\n    console.log(Number.isFinite(NaN)); //false\n    console.log(Number.isFinite(5)); //true\n    console.log(Number.isFinite(Infinity)); //false\n\n    //Number.isNaN(i) : 判断是否是NaN\n    console.log(Number.isNaN(NaN));//true\n    console.log(Number.isNaN(5));//falsse\n\n    //Number.isInteger(i) : 判断是否是整数\n    console.log(Number.isInteger(5.23));//false\n    console.log(Number.isInteger(5.0));//true\n    console.log(Number.isInteger(5));//true\n\n    //Number.parseInt(str) : 将字符串转换为对应的数值\n    console.log(Number.parseInt('123abc'));//123\n    console.log(Number.parseInt('a123abc'));//NaN\n\n    // Math.trunc(i) : 直接去除小数部分\n    console.log(Math.trunc(13.123));//13\n```\n\n## 数组的扩展\n\n> 下面提到的数组的几个方法，更详细的内容，可以看《04-JavaScript基础/17-数组的常见方法.md》。\n\n### 扩展1：Array.from()\n\n```javascript\n Array.from(伪数组/可遍历的对象)\n```\n\n**作用**：将**伪数组**或可遍历对象转换为**真数组**。\n\n### 扩展2：Array.of()\n\n```javascript\n Array.of(value1, value2, value3)\n```\n\n**作用**：将一系列值转换成数组。\n\n### 扩展3：find() 和 findIndex()\n\n**方法1**：\n\n```javascript\n find(function(item, index, arr){return true})\n```\n\n**作用**：找出**第一个**满足「指定条件返回true」的元素。\n\n**方法2**：\n\n```javascript\n findIndex(function(item, index, arr){return true})\n```\n\n**作用**：找出第一个满足「指定条件返回true」的元素的index。\n\n## 对象的扩展\n\n### 扩展1\n\n```javascript\n Object.is(v1, v2)\n```\n\n**作用：**判断两个数据是否完全相等。底层是通过**字符串**来判断的。\n\n我们先来看下面这两行代码的打印结果：\n\n```javascript\n        console.log(0 == -0);\n        console.log(NaN == NaN);\n```\n\n打印结果：\n\n```\n true\n false\n```\n\n上方代码中，第一行代码的打印结果为true，这个很好理解。第二行代码的打印结果为false，因为NaN和任何值都不相等。\n\n但是，如果换成下面这种方式来比较：\n\n```javascript\n        console.log(Object.is(0, -0));\n        console.log(Object.is(NaN, NaN));\n```\n\n打印结果却是：\n\n```\n false\n true\n```\n\n代码解释：还是刚刚说的那样，`Object.is(v1, v2)`比较的是字符串是否相等。\n\n### 扩展2（重要）\n\n```javascript\n Object.assign(目标对象, 源对象1, 源对象2...)\n```\n\n**作用：** 将源对象的属性追加到目标对象上。如果对象里属性名相同，会被覆盖。\n\n其实可以理解成：将多个对象**合并**为一个新的对象。\n\n举例：\n\n```javascript\n        let obj1 = { name: 'smyhvae', age: 26 };\n        let obj2 = { city: 'shenzhen' };\n        let obj3 = {};\n\n        Object.assign(obj3, obj1, obj2);\n        console.log(obj3);\n```\n\n打印结果：\n\n![](http://img.smyhvae.com/20180404_2240.png)\n\n上图显示，成功将obj1和obj2的属性复制给了obj3。\n\n### 扩展3：`__proto__`属性\n\n举例：\n\n```javascript\n       let obj1 = {name:'smyhvae'};\n       let obj2 = {};\n\n       obj2.__proto__ = obj1;\n\n       console.log(obj1);\n       console.log(obj2);\n       console.log(obj2.name);\n```\n\n打印结果：\n\n![](http://img.smyhvae.com/20180404_2251.png)\n\n上方代码中，obj2本身是没有属性的，但是通过`__proto__`属性和obj1产生关联，于是就可以获得obj1里的属性。\n\n## 迭代器（Iterator）\n\n#### ES5实现迭代器\n\n迭代器是什么？遇到这种新的概念，莫慌张。\n\n**迭代器是一种特殊对象，每一个迭代器对象都有一个next()，该方法返回一个对象，包括value和done属性。**\n\n**ES5实现迭代器的代码如下：**\n\n```js\n    //实现一个返回迭代器对象的函数，注意该函数不是迭代器，返回结果才叫做迭代器。\n    function createIterator(items) {\n      var i = 0;\n      return {\n        next() {\n          var done = (i >= items.length); // 判断i是否小于遍历的对象长度。\n          var value = !done ? items[i++] : undefined; //如果done为false，设置value为当前遍历的值。\n          return {\n            done,\n            value\n          }\n        }\n      }\n    }\n    const a = createIterator([1, 2, 3]);\n    \n    //该方法返回的最终是一个对象，包含value、done属性。\n    console.log(a.next()); //{value: 1, done: false}\n    console.log(a.next()); //{value: 2, done: false}\n    console.log(a.next()); //{value: 3, done: false}\n    console.log(a.next()); //{value: undefined, done: true}\n```\n\n### 生成器（Generator）\n\n**生成器是函数：用来返回迭代器。**\n\n这个概念有2个关键点，一个是函数、一个是返回迭代器。这个函数不是上面ES5中创建迭代器的函数，而是ES6中特有的，一个带有*（星号）的函数，同时你也需要使用到yield。\n\n```js\n//生成器函数，ES6内部实现了迭代器功能，你要做的只是使用yield来迭代输出。\nfunction *createIterator() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\nconst a = createIterator();\nconsole.log(a.next()); //{value: 1, done: false}\nconsole.log(a.next()); //{value: 2, done: false}\nconsole.log(a.next()); //{value: 3, done: false}\nconsole.log(a.next()); //{value: undefined, done: true}\n```\n\n生成器的yield关键字有个神奇的功能，就是当你执行一次next()，那么只会执行一个yield后面的内容，然后语句终止运行。\n\n#### 在for循环中使用迭代器\n\n即使你是在for循环中使用yield关键字，也会暂停循环。\n\n```js\n    function *createIterator(items) {\n      for(let i = 0; i < items.length;  i++) {\n        yield items[i]\n      }\n    }\n    const a = createIterator([1, 2, 3]);\n    console.log(a.next()); //{value: 1, done: false}\n```\n\n#### yield使用限制\n\nyield只可以在生成器函数内部使用，如果在非生成器函数内部使用，则会报错。\n\n```js\nfunction *createIterator(items) {\n  //你应该在这里使用yield\n  items.map((value, key) => {\n    yield value //语法错误，在map的回调函数里面使用了yield\n  })\n}\nconst a = createIterator([1, 2, 3]);\nconsole.log(a.next()); //无输出\n```\n\n#### 生成器函数表达式\n\n函数表达式很简单，就是下面这种写法，也叫匿名函数，不用纠结。\n\n```js\nconst createIterator = function *() {\n  yield 1;\n  yield 2;\n}\nconst a = createIterator();\nconsole.log(a.next());\n```\n\n#### 在对象中添加生成器函数\n\n一个对象长这样：\n\n```\nconst obj = {}\n```\n\n我们可以在obj中添加一个生成器，也就是添加一个带星号的方法：\n\n```js\nconst obj = {\n  a: 1,\n  *createIterator() {\n    yield this.a\n  }\n}\nconst a = obj.createIterator();\nconsole.log(a.next());  //{value: 1, done: false}\n```\n\n#### 可迭代对象和for of循环\n\n再次默读一遍，迭代器是对象，生成器是返回迭代器的函数。\n\n凡是通过生成器生成的迭代器，都是可以迭代的对象(可迭代对象具有Symbol.iterator属性)，也就是可以通过for of将value遍历出来。\n\n```js\nfunction *createIterator() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\nconst a = createIterator();\nfor(let value of a) {\n  console.log(value)\n}\n// 1 2 3\n```\n\n上面的例子告诉我们生成器函数返回的迭代器是一个可以迭代的对象。其实我们这里要研究的是Symbol.iterator的用法。\n\n```js\nfunction *createIterator() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\nconst a = createIterator(); //a是一个迭代器\nconst s = a[Symbol.iterator]();//使用Symbol.iterator访问迭代器\nconsole.log(s.next()) //{value: 1, done: false}\n```\n\nSymbol.iterator还可以用来检测一个对象是否可迭代：\n\n```\ntypeof obj[Symbol.iterator] === \"function\"\n```\n\n#### 创建可迭代对象\n\n**在ES6中，数组、Set、Map、字符串都是可迭代对象。**\n\n**默认情况下定义的对象（object）是不可迭代的，但是可以通过Symbol.iterator创建迭代器。**\n\n```js\n    const obj = {\n      items: []\n    }\n    obj.items.push(1);//这样子虽然向数组添加了新元素，但是obj不可迭代\n    for (let x of obj) {\n      console.log(x) // _iterator[Symbol.iterator] is not a function\n    }\n\n    //接下来给obj添加一个生成器，使obj成为一个可以迭代的对象。\n    const obj = {\n      items: [],\n      *[Symbol.iterator]() {\n        for (let item of this.items) {\n          yield item;\n        }\n      }\n    }\n    obj.items.push(1)\n    //现在可以通过for of迭代obj了。\n    for (let x of obj) {\n      console.log(x)\n    }\n```\n\n#### 内建迭代器\n\n上面提到了，数组、Set、Map都是可迭代对象，即它们内部实现了迭代器，并且提供了3种迭代器函数调用。\n\n**1、entries() 返回迭代器**：返回键值对\n\n```js\n    //数组\n    const arr = ['a', 'b', 'c'];\n    for(let v of arr.entries()) {\n      console.log(v)\n    }\n    // [0, 'a'] [1, 'b'] [2, 'c']\n    \n    //Set\n    const arr = new Set(['a', 'b', 'c']);\n    for(let v of arr.entries()) {\n      console.log(v)\n    }\n    // ['a', 'a'] ['b', 'b'] ['c', 'c']\n\n    //Map\n    const arr = new Map();\n    arr.set('a', 'a');\n    arr.set('b', 'b');\n    for(let v of arr.entries()) {\n      console.log(v)\n    }\n    // ['a', 'a'] ['b', 'b']\n```\n\n**2、values() 返回迭代器**：返回键值对的value\n\n```js\n    //数组\n    const arr = ['a', 'b', 'c'];\n    for(let v of arr.values()) {\n      console.log(v)\n    }\n    //'a' 'b' 'c'\n\n    //Set\n    const arr = new Set(['a', 'b', 'c']);\n    for(let v of arr.values()) {\n      console.log(v)\n    }\n    // 'a' 'b' 'c'\n\n    //Map\n    const arr = new Map();\n    arr.set('a', 'a');\n    arr.set('b', 'b');\n    for(let v of arr.values()) {\n      console.log(v)\n    }\n    // 'a' 'b'\n```\n\n**3、keys() 返回迭代器**：返回键值对的key\n\n```js\n    //数组\n    const arr = ['a', 'b', 'c'];\n    for(let v of arr.keys()) {\n      console.log(v)\n    }\n    // 0 1 2\n    \n    //Set\n    const arr = new Set(['a', 'b', 'c']);\n    for(let v of arr.keys()) {\n      console.log(v)\n    }\n    // 'a' 'b' 'c'\n\n    //Map\n    const arr = new Map();\n    arr.set('a', 'a');\n    arr.set('b', 'b');\n    for(let v of arr.keys()) {\n      console.log(v)\n    }\n    // 'a' 'b'\n```\n\n虽然上面列举了3种内建的迭代器方法，但是不同集合的类型还有自己默认的迭代器，在for of中，数组和Set的默认迭代器是values()，Map的默认迭代器是entries()。\n\n#### for of循环解构\n\n对象本身不支持迭代，但是我们可以自己添加一个生成器，返回一个key，value的迭代器，然后使用for of循环解构key和value。\n\n```js\n    const obj = {\n      a: 1,\n      b: 2,\n      *[Symbol.iterator]() {\n        for(let i in obj) {\n          yield [i, obj[i]]\n        }\n      }\n    }\n    for(let [key, value] of obj) {\n      console.log(key, value)\n    }\n    // 'a' 1, 'b' 2\n```\n\n#### 字符串迭代器\n\n```\n    const str = 'abc';\n    for(let v of str) {\n      console.log(v)\n    }\n    // 'a' 'b' 'c'\n```\n\n#### NodeList迭代器\n\n迭代器真是无处不在啊，dom节点的迭代器你应该已经用过了。\n\n```js\nconst divs = document.getElementByTagName('div');\nfor(let d of divs) {\n  console.log(d)\n}\n```\n\n#### 展开运算符和迭代器\n\n```js\n    const a = [1, 2, 3];\n    const b = [4, 5, 6];\n    const c = [...a, ...b]\n    console.log(c) // [1, 2, 3, 4, 5, 6]\n```\n\n#### 高级迭代器功能\n\n你说什么？上面讲了一堆废话都是基础功能？还有高级功能没讲？\n\n高级功能不复杂，就是传参、抛出异常、生成器返回语句、委托生成器。\n\n1、传参\n\n生成器里面有2个yield，当执行第一个next()的时候，返回value为1，然后给第二个next()传入参数10，传递的参数会替代掉上一个next()的yield返回值。在下面的例子中就是first。\n\n```js\nfunction *createIterator() {\n  let first = yield 1;\n  yield first + 2;\n}\nlet i = createIterator();\nconsole.log(i.next()); // {value: 1, done: false}\nconsole.log(i.next(10)); // {value: 12, done: false}\n```\n\n2、在迭代器中抛出错误\n\n```js\nfunction *createIterator() {\n  let first = yield 1;\n  yield first + 2;\n}\nlet i = createIterator();\nconsole.log(i.next()); // {value: 1, done: false}\nconsole.log(i.throw(new Error('error'))); // error\nconsole.log(i.next()); //不再执行\n```\n\n3、生成器返回语句\n\n生成器中添加return表示退出操作。\n\n```js\nfunction *createIterator() {\n  let first = yield 1;\n  return;\n  yield first + 2;\n}\nlet i = createIterator();\nconsole.log(i.next()); // {value: 1, done: false}\nconsole.log(i.next()); // {value: undefined, done: true}\n```\n\n4、委托生成器\n\n生成器嵌套生成器\n\n```js\nfunction *aIterator() {\nyield 1;\n}\nfunction *bIterator() {\nyield 2;\n}\nfunction *cIterator() {\nyield *aIterator()\nyield *bIterator()\n}\n\nlet i = cIterator();\nconsole.log(i.next()); // {value: 1, done: false}\nconsole.log(i.next()); // {value: 2, done: false}\n```\n\n### 异步任务执行器\n\nES6之前，我们使用异步的操作方式是调用函数并执行回调函数。\n\n书上举的例子挺好的，在nodejs中，有一个读取文件的操作，使用的就是回调函数的方式。\n\n```js\nvar fs = require(\"fs\");\nfs.readFile(\"xx.json\", function(err, contents) {\n//在回调函数中做一些事情\n})\n```\n\n那么任务执行器是什么呢？\n\n**任务执行器是一个函数，用来循环执行生成器，因为我们知道生成器需要执行N次next()方法，才能运行完，所以我们需要一个自动任务执行器帮我们做这些事情，这就是任务执行器的作用。**\n\n下面我们编写一个异步任务执行器。\n\n```js\n//taskDef是一个生成器函数，run是异步任务执行器\nfunction run(taskDef) {\n  let task = taskDef(); //调用生成器\n  let result = task.next(); //执行生成器的第一个next()，返回result\n  function step() {\n    if(!result.done) {\n      //如果done为false，则继续执行next()，并且循环step，直到done为true退出。\n      result = task.next(result.value);\n      step();\n    }\n  }\n  step(); //开始执行step()\n}\n```\n\n测试一下我们编写的run方法，我们不再需要console.log N个next了，因为run执行器已经帮我们做了循环执行操作：\n\n```js\n    run(function *() {\n      let value = yield 1;\n      value = yield value + 20;\n      console.log(value) // 21\n    })\n```\n\n## 代理 Proxy\n\n![clipboard.png](https://segmentfault.com/img/bVR5W5?w=710&h=182)\n\n#### 语法\n\n```\n    let p = new Proxy(target, handler);\n```\n\ntarget：一个目标对象(可以是任何类型的对象，包括本机数组，函数，甚至另一个代理)用Proxy来包装。 handler：一个对象，其属性是当执行一个操作时定义代理的行为的函数。\n\n#### 代理的使用\n\n**基础demo：**Proxy的demo有很多，我们只分析基础demo，主要看new Proxy({}, handler)的操作，指定目标obj对象，然后handler对象执行get()操作，get()返回值的判断是，如果name是target目标对象的属性，则返回target[name]的值，否则返回37，最后测试的时候，p.a是对象p的key，所以返回a的value，而p.b不存在，返回37。\n\n```js\nconst obj = {\n  a: 10\n}\nlet handler = {\n  get: function(target, name){\n    console.log('test: ', target, name)\n    // test:  {\"a\":10} a\n    // test:  {\"a\":10} b\n    return name in target ? target[name] : 37\n  }\n}\nlet p = new Proxy(obj, handler)\nconsole.log(p.a, p.b) // 10 37\n```\n\n这个例子的作用是拦截目标对象obj，当执行obj的读写操作时，进入handler函数进行判断，如果读取的key不存在，则返回默认值。\n\n## 模块的定义\n\n模块是自动运行在严格模式下并且没有办法退出运行的JavaScript代码。\n\n模块可以是函数、数据、类，需要指定导出的模块名，才能被其他模块访问。\n\n```js\n//数据模块\nconst obj = {a: 1}\n//函数模块\nconst sum = (a, b) => {\n  return a + b\n}\n//类模块\nclass My extends React.Components {\n\n}\n```\n\n### 模块的导出\n\n给数据、函数、类添加一个export，就能导出模块。一个配置型的JavaScript文件中，你可能会封装多种函数，然后给每个函数加上一个export关键字，就能在其他文件访问到。\n\n```js\n//数据模块\nexport const obj = {a: 1}\n//函数模块\nexport const sum = (a, b) => {\n  return a + b\n}\n//类模块\nexport class My extends React.Components {\n\n}\n```\n\n```json\n// module.js\nlet variable = []\n\n// 选择导出的变量\nmodule.exports = {\n  variable: variable\n  // 可以写多个\n}\n\n//使用\nlet module = require('./module')\nconsole.log(module.varibale) \n```\n\n### 模块的引用\n\n在另外的js文件中，我们可以引用上面定义的模块。使用import关键字，导入分2种情况，一种是导入指定的模块，另外一种是导入全部模块。\n\n1、导入指定的模块。\n\n```js\n//导入obj数据，My类\nimport {obj, My} from './xx.js'\n\n//使用\nconsole.log(obj, My)\n```\n\n2、导入全部模块\n\n```\n    //导入全部模块\n    import * as all from './xx.js'\n    \n    //使用\n    console.log(all.obj, all.sun(1, 2), all.My)\n```\n\n### 默认模块的使用\n\n如果给我们的模块加上default关键字，那么该js文件默认只导出该模块，你还需要把大括号去掉。\n\n```js\n//默认模块的定义\nfunction sum(a, b) {\n  return a + b\n}\nexport default sum\n\n//导入默认模块\nimport sum from './xx.js'\n```\n\n### 模块的使用限制\n\n不能在语句和函数之内使用export关键字，只能在模块顶部使用，作为react和vue开发者的你，这个限制你应该很熟悉了。\n\n**在react中，模块顶部导入其他模块。**\n\n```js\nimport react from 'react'\n```\n\n**在vue中，模块顶部导入其他模块。**\n\n```js\n<script>\nimport sum from './xx.js'\n</script>\n```\n\n### 修改模块导入和导出名\n\n有2种修改方式，一种是模块导出时修改，一种是导入模块时修改。\n\n1、导出时修改：\n\n```js\n    function sum(a, b) {\n        return a + b\n    }\n    export {sum as add}\n\n    import { add } from './xx.js'\n    add(1, 2)\n```\n\n2、导入时修改：\n\n```\n    function sum(a, b) {\n        return a + b\n    }\n    export sum\n\n    import { sum as add } from './xx.js'\n    add(1, 2)\n```\n\n### 无绑定导入\n\n当你的模块没有可导出模块，全都是定义的全局变量的时候，你可以使用无绑定导入。\n\n模块：\n\n```js\nlet a = 1\nconst PI = 3.1314\n```\n\n无绑定导入：\n\n```js\nimport './xx.js'\nconsole.log(a, PI)\n```\n\n### 浏览器加载模块\n\n有用过webpack打包js模块的同学可能有经验，使用webpack打包了多个js文件，然后放到HTML使用script加载时，如果加载顺序不对，就会出现找不到模块的错误。\n\n这是因为模块之间是有依赖关系的，就像你使用jQuery的时候，必须先加载jQuery的代码，才能使用jQuery提供的方法。\n\n**加载模块的方法，总是先加载模块1，再加载模块2，因为module类型默认使用defer属性。**\n\n```html\n<script type=\"module\" src=\"module1.js\"></script>\n<script type=\"module\" src=\"module2.js\"></script>\n```\n\n### 总结\n\n模块还有很多有意思的特性，对react和vue开发有一定经验的人对这些基本知识应该了如指掌，新手不了解也不用太心急，写几个module.js做一下尝试。如果浏览器报错，不能识别export模块，你可能需要先加载babel的js插件来编译它。\n","children":[]},{"name":"Number","path":"../guanruihua.github.io/JavaScript","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/JavaScript/Number","data":"# Number\n\n## BigInt\n\n> 在 ES10 增加了新的原始数据类型：BigInt，表示一个任意精度的整数，可以表示超长数据，可以超出2的53次方。\n\nJs 中 Number类型只能安全的表示-(2^53-1)至 2^53-1 范的值\n\n```\nconsole.log(2 ** 53) // es7 幂运算符\nconsole.log(Number.MAX_SAFE_INTEGER) // 最大值-1\n```\n\n**使用 BigInt 有两种方式：**\n\n- 方式一：数字后面增加n\n\n  ```\n  const bigInt = 9007199254740993n\n  console.log(bigInt)\n  console.log(typeof bigInt) // bigint\n  \n  console.log(1n == 1) // true\n  console.log(1n === 1) // false\n  ```\n\n- 方式二：使用 BigInt 函数\n\n  ```\n  const bigIntNum = BigInt(9007199254740993n)\n  console.log(bigIntNum)\n  ```\n\n  ### Promise.allSettled()\n\n  > 学习了ES新特性，我们都知道 Promise.all() 具有并发执行异步任务的能力。但它的最大问题就是如果其中某个任务出现异常(reject)，所有任务都会挂掉，Promise直接进入reject 状态。而 Promise.allSettled 返回一个在所有给定的promise已被决议或被拒绝后决议的promise，并带有一个对象数组，每个对象表示对应的promise结果。\n\n  ```\n  Promise.allSettled([\n    Promise.reject({\n        code: 500,\n        msg: '服务异常'\n    }),\n    Promise.resolve({\n        code: 200,\n        data: ['1', '2', '3']\n    }),\n    Promise.resolve({\n        code: 200,\n        data: ['4', '5', '6']\n    })\n  ]).then(res => {\n    console.log(res)\n    // console.log('成功')\n    const data = res.filter(item => item.status === 'fulfilled')\n    console.log(data)\n  }).catch(err => {\n    console.log(err)\n    console.log('失败')\n  })\n  ```\n\n## 幂运算符\n\n求幂运算\n\n```\nconsole.log(2 ** 10) // 1024\n```\n\n## **二进制与八进制**\n\n- JS中如何把十进制转化为二进制？\n\n  ```\n  const a = 5 // 101\n  \n  console.log(a.toString(2))\n  ```\n\n- 如何把八进制转化为二进制？\n\n  ```\n  const b = 101\n  \n  console.log(parseInt(b, 2))\n  ```\n\n  ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。\n\n  ```\n  const a = 0B0101\n  console.log(a)\n  \n  const b = 0O777\n  console.log(b)\n  ```\n\n  **2.新增方法**\n\n- Number.isFinite()\n  用来检查一个数值是否为有限的（finite），即不是Infinity。\n\n  ```\n  Number.isFinite(15) // true\n  Number.isFinite(0.8) // true\n  Number.isFinite(NaN) // false\n  Number.isFinite(Infinity) // false\n  Number.isFinite(-Infinity) // false\n  Number.isFinite('foo') // false\n  Number.isFinite('15') // false\n  Number.isFinite(true) // false\n  ```\n\n- Number.isNaN()\n  用来检查一个值是否为NaN。\n\n  ```\n  Number.isNaN(NaN) // true\n  Number.isNaN(15) // false\n  Number.isNaN('15') // false\n  Number.isNaN(true) // false\n  Number.isNaN(9 / NaN) // true\n  Number.isNaN('true' / 0) // true\n  Number.isNaN('true' / 'true') // true\n  ```\n\n- Number.parseInt()\n  ES6 将全局方法parseInt()移植到Number对象上面，行为完全保持不变。 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。\n\n  ```\n  // ES5的写法\n  parseInt('12.34') // 12\n  \n  // ES6的写法\n  Number.parseInt('12.34') // 12\n  ```\n\n- Number.parseFloat()\n  ES6 将全局方法parseFloat()移植到Number对象上面，行为完全保持不变。这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。\n\n  ```\n  // ES5的写法\n  parseFloat('123.45#') // 123.45\n  \n  // ES6的写法\n  Number.parseFloat('123.45#') // 123.45\n  ```\n\n- Number.isInteger()\n  用来判断一个数值是否为整数。\n\n  ```\n  Number.isInteger(25) // true\n  Number.isInteger(25.1) // false\n  \n  Number.isInteger() // false\n  Number.isInteger(null) // false\n  Number.isInteger('15') // false\n  Number.isInteger(true) // false\n  ```\n\n- Number.MAX_SAFE_INTEGER\n\n  ```\n  Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1 // true\n  \n  Number.MAX_SAFE_INTEGER === 9007199254740991 // true\n  ```\n\n- Number.MIN_SAFE_INTEGER\n\n  ```\n  Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER // true\n  \n  Number.MIN_SAFE_INTEGER === -9007199254740991 // true\n  ```\n\n- Number.isSafeInteger()\n  JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。\n\n  ```\n  Math.pow(2, 53) // 9007199254740992\n  \n  Math.pow(2, 53) === Math.pow(2, 53) + 1 // true\n  ```","children":[]}]},{"name":"README.md","path":"../guanruihua.github.io/JavaScript","data":"# [ruihuag](https://guanruihua.github.io/#/)\r\n\r\n<!-- ![](../__assets__/001.jpg) -->\r\n<!-- ![Metrics](https://metrics.lecoq.io/guanruihua?template=classic&isocalendar=1&languages=1&base=header%2C%20activity%2C%20community%2C%20repositories%2C%20metadata&base.indepth=false&base.hireable=false&base.skip=false&isocalendar=false&isocalendar.duration=half-year&languages=false&languages.limit=8&languages.threshold=0%25&languages.other=false&languages.colors=github&languages.sections=most-used&languages.indepth=false&languages.analysis.timeout=15&languages.categories=markup%2C%20programming&languages.recent.categories=markup%2C%20programming&languages.recent.load=300&languages.recent.days=14&config.timezone=Asia%2FShanghai) -->\r\n","children":[]},{"name":"String","path":"../guanruihua.github.io/JavaScript","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/JavaScript/String","data":"# 字符串\n\n### 查找方法\n\n#### 字符方法\n\n> - charAt([要查询下标])    根据下标查找指定字符,超出范围返回空字符串\n>\n> - charCodeAt([要查询下标])     返回Unicode编码  超出范围返回NaN\n>\n> - fromCharCode()                根据字符编码创建字符串\n\n#### 位置方法\n\n> - 根据指定字符串查找下标\n>   - 没有找到返回 -1\n>   - indexOf()    : 首次出现的下标\n>   - lastIndexOf() : 最后一次出现的下标\n\n#### 匹配方法\n\n> - match()\n>\n>   - 找到一个或多个正则表达式的匹配\n>   - 参数:\n>     - 要进行模式匹配的正则表达式\n>     - 非正则表达式 将其传递给RegExp()构造函数,并转换为正则表达式对象\n>   - 返回值\n>     - 存放匹配结果的数组\n>     - 有全局标记g\n>     - 无全局标记g(执行一次匹配)\n>\n> - search()\n>\n>   - 功能: 检索字符串分钟与正则雕大师匹配的字串\n>   - 参数: 要进行模式匹配的正则表达式\n>   - 返回值:\n>     - 找到: 第一个个匹配的起始位置\n>     - 未找到: -1\n>   - 特性: 忽略全局标记g和lastIndex()属性\n>\n> - replace()\n>\n>   - 替换一个与正则表达式匹配的字串\n>\n>   - 参数\n>\n>     - 参数1: 需要进行替换正则表达式或字符串\n>     - 参数2: 替换文本或替换函数\n>\n>   - 特性:\n>\n>     - 要想全局替换要加全局标记g\n>\n>     - 如果参数2位字符串这可使用特殊字符序列\n>\n>     - ```js\n>       $$  $\n>       $& 匹配整个模式的子字符串\n>       $' 匹配子字符串之前的子字符串\n>       $` 匹配子字符串之后的子字符串\n>       $n  匹配第n个捕获组的子字符串 n=1~9\n>       $nn 匹配第nn个捕获组的子字符串 nn=1~~99\n>       ```\n>\n> - split():切割\n>\n>   - 必须: 指定分隔符\n>   - 可选: 指定数组的长度\n\n### 操作方法\n\n#### 拼接方法\n\n> - concat()和\"+\"功能相同\n> - string.concat()\n>   - 可以连接一个或多个值\n\n#### 截取方法\n\n> - 根据下标截取字符串\n>   - slice()\n>   - substring()\n> - 根据长度截取字符串\n>   - substr()\n\n#### 空格处理\n\n> - trim() 清除前后的空格\n>\n> - trimLeft() 清除前置空格\n>\n> - trimRight() 清除后缀空格\n\n#### 填充处理\n\n> - padStart: 长度不够在前面填充\n>\n> - padEnd: 长度不够就在后面填充\n>\n>   ```javascript\n>     'x'.padstart(5, 'ab'); //ababx\n>     'x'.padstart(4, 'ab'); //abax\n>     'x'.padEnd(5, 'ab'); //xabab\n>     'x'.padEnd(4, 'ab'); //xaba\n>   ```\n\n#### 比较方法\n\n> localeCompare()\n>\n> - 用本地特定顺序比较两个字符串\n\n### 编码方法\n\n> - 字符串常规编码与解码\n>   - escape()\n>   - unescape()\n> - URI字符串编码与解码\n>   - encodeURI()\n>   - decodeURI()\n> - URI组件编码与解码\n>   - encodeURIComponent()\n>   - decodeURIComponent()\n\n### 转换方法\n\n> - 大小写转换:\n>   - 转为大写\n>     - toUpperCase()\n>     - toLocaleUpperCase()\n>   - 转为小写\n>     - toLowerCase()\n>     - toLocaleLowerCase()\n","children":[]},{"name":"字符串","path":"../guanruihua.github.io/JavaScript/String","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/JavaScript/String/字符串","data":"# 字符串\n\n## 模板字符串\n\n```js\n`string`\nlet a = '123'\n`string ${a}` // string 123\n```\n\n## Unicode表示法\n\nES6 加强了对 Unicode 的支持，允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。\n\n```js\n\"\\u0061\"\n// \"a\"\n```\n\n但是，这种表示法只限于码点在\\u0000~\\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。\n\n```js\n\"\\uD842\\uDFB7\"\n// \"𠮷\"\n\n\"\\u20BB7\"\n// \" 7\"\n```\n\n上面代码表示，如果直接在\\u后面跟上超过0xFFFF的数值（比如\\u20BB7），JavaScript 会理解成\\u20BB+7。由于\\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。\n\nES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。\n\n```js\n\"\\u{20BB7}\"\n// \"𠮷\"\n```\n\n有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。\n\n```js\n'\\z' === 'z' // true\n'\\172' === 'z' // true\n'\\x7A' === 'z' // true\n'\\u007A' === 'z' // true\n'\\u{7A}' === 'z' // true\n```\n\n## 拓展方法\n\n### String.prototype.fromCodePoint()\n\n```js\n// ES5\nconsole.log(String.fromCharCode(0x20BB7))\n// ஷ\n\n// ES6\nconsole.log(String.fromCodePoint(0x20BB7))\n// 𠮷\n```\n\n### String.prototype.includes()\n\n> `indexOf`:判断一个字符是否存在\n>\n> `includes`:判断一个字符串是否存在\n\n### String.prototype.startsWith()\n\n> 判断字符串是否在头部\n\n### String.prototype.endsWith()\n\n> 判断字符串是否在尾部\n\n### String.prototype.repeat()\n\n> 返回一个新字符串, 参数表示重复的次数\n\n```js\nconst str = 'isxxx'\nconst newStr = str.repeat(10)\nconsole.log(newStr)\n// isxxxisxxxisxxxisxxxisxxxisxxxisxxxisxxxisxxxisxxx\n```\n\n\n\n","children":[]}]}]},{"name":"_sidebar.md","path":"../guanruihua.github.io/JavaScript","data":"* api\n  * [Buffer](api/Buffer.md)\n  * [console](api/console.md)\n  * [Cookie](api/Cookie.md)\n  * [Math](api/Math.md)\n  * [Reflect](api/Reflect.md)\n  * window\n    * [getSelection](api/window/getSelection.md)\n  * [特殊标记](api/特殊标记.md)\n* [Class](Class/index.md)\n  * [home](Class/index.md)\n* [es6](es6.md)\n* [ESMAScript](ESMAScript.md)\n* [Number](Number/index.md)\n  * [home](Number/index.md)\n* [String](String/index.md)\n  * [home](String/index.md)\n  * [字符串](String/字符串/index.md)\n    * [home](String/字符串/index.md)\n* [函数](函数/index.md)\n  * [call&apply&bind](函数/call&apply&bind.md)\n  * [home](函数/index.md)\n  * [原型链](函数/原型链.md)\n  * [异步处理](函数/异步处理.md)\n  * [继承](函数/继承.md)\n  * [节流和防抖](函数/节流和防抖.md)\n  * [闭包](函数/闭包.md)\n  * [高阶函数](函数/高阶函数.md)\n* [动画](动画/index.md)\n  * [home](动画/index.md)\n  * [requestAnimationFrame ](动画/requestAnimationFrame .md)\n* 基础\n  * [static](基础/static.md)\n  * [this相关](基础/this相关.md)\n  * [V8编译过程](基础/V8编译过程.md)\n  * [协程](基础/协程.md)\n  * [注册事件](基础/注册事件.md)\n  * [流程&基础遍历](基础/流程&基础遍历.md)\n* 对象\n  * [BOM](对象/BOM.md)\n  * [class](对象/class.md)\n  * [cookie](对象/cookie.md)\n  * [DOM](对象/DOM.md)\n  * [event](对象/event.md)\n  * [Intl](对象/Intl.md)\n  * [Iterator](对象/Iterator.md)\n  * [Object](对象/Object.md)\n  * promise\n    * [Generator](对象/promise/Generator.md)\n    * [promise_async_await](对象/promise/promise_async_await.md)\n    * [promise原理模拟](对象/promise/promise原理模拟.md)\n  * [proxy](对象/proxy.md)\n  * [Reflect](对象/Reflect.md)\n* 拓展\n  * [深浅拷贝](拓展/深浅拷贝.md)\n* 数据结构\n  * [buffer](数据结构/buffer.md)\n  * Map\n    * [Map](数据结构/Map/Map.md)\n    * [WeekMap](数据结构/Map/WeekMap.md)\n  * Set\n    * [set](数据结构/Set/set.md)\n    * [WeakSet](数据结构/Set/WeakSet.md)\n  * 数组\n    * [flat](数据结构/数组/flat.md)\n    * [v8引擎下的数组](数据结构/数组/v8引擎下的数组.md)\n    * [下标](数据结构/数组/下标.md)\n    * [数组](数据结构/数组/数组.md)\n* 时间\n  * [农历](时间/农历.md)\n  * [时区](时间/时区.md)\n* 概念\n  * [import_xxx与import{}区别](概念/import_xxx与import{}区别.md)\n  * [mvc&mvvm](概念/mvc&mvvm.md)\n  * [模式](概念/模式.md)\n* 正则\n  * [RegExp](正则/RegExp.md)\n  * [正则](正则/正则.md)\n* [监听](监听.md)\n* [类型](类型/index.md)\n  * [home](类型/index.md)\n* [类型](类型.md)\n* [运算符](运算符/index.md)\n  * [home](运算符/index.md)\n  * [js运算符号](运算符/js运算符号.md)\n  * [拓展运算符](运算符/拓展运算符.md)\n","children":[]},{"name":"函数","path":"../guanruihua.github.io/JavaScript","data":"","children":[{"name":"call&apply&bind.md","path":"../guanruihua.github.io/JavaScript/函数","data":"# call&apply&bind\n\n> call, bind, apply第一参数都是this的指向对象\n>\n> call和bind的写法几乎相同, 但是bind是返回的是函数\n>\n> apply只能传输一个变量\n\n```js\nvar name = 'guanruihua';\nvar age = '23';\nvar obj = {\n  name: 'mawenliang',\n  age: 22,\n  fn: function() {\n    console.log( this.name + this.age )\n  },\n  fn2: function(fm, ft) {\n    console.log( this.name + this.age + \" aa \"+ fm + \" bb \" + ft)\n  }\n\n}\nvar obj2 = {\n  name: 'haungzelin',\n  age: 21,\n}\n\nobj.fn.call(obj2);\nobj.fn.apply(obj2);\nobj.fn.bind(obj2)();\n\nobj.fn2.call(obj2, '成都', '上海');\nobj.fn2.apply(obj2, ['成都', '上海']);\nobj.fn2.bind(obj2, '成都', '上海')();\n\n```\n\n运行结果\n\n```js\nhaungzelin21\nhaungzelin21\nhaungzelin21\nhaungzelin21 aa 成都 bb 上海  \nhaungzelin21 aa 成都 bb 上海  \nhaungzelin21 aa 成都 bb 上海  \n```\n","children":[]},{"name":"index.md","path":"../guanruihua.github.io/JavaScript/函数","data":"# 函数\n\n## **定义方法**\n\n> 静态方法\tfunction 函数名([参数]){}\n>\n> 动态匿名\tvar 函数名 = new Function([\"虚参列表\"], \"函数体\");\n>\n> **直接变量** 函数名 = function([虚参列表]){函数体;}\n\n### 函数声明\n\n```js\n// ES5\nfunction [name](){}\nfunction (){} //匿名函数\n// ES6\n()=>{}// 函数体只有一行{}和return 可以省略\n```\n\n### 函数表达式\n\n```js\n// ES5\nvar sum = function(){};\n// ES6\nlet sum = () => {};// 函数体只有一行{}和return 可以省略\n```\n\n### 构造函数\n\n```js\nconst sum = new Function('a', 'b', 'return a + b');\n```\n\n### 三种方法对比\n\n> 1. 函数声明有预解析,而且函数声明的优先级高于变量; \n> 2. 使用Function构造函数定义函数的方式是一个函数表达式,这种方式会导致解析两次代码，影响性能。\n>    1. 第一次解析常规的JavaScript代码\n>    2. 第二次解析传入构造函数的字符串\n\n------\n\n## Rest 参数\n\n> rest : 剩余部分\n\n```js\nfunction sum(...nums) {\n    let num = 0\n    nums.forEach(function(item) {\n        num += item * 1\n    })\n    return num\n}\n\nconsole.log(sum(1, 2, 3)) // 6\nconsole.log(sum(1, 2, 3, 4)) // 10\n```\n\n## name属性\n\n```js\nfunction foo(){}\n\nfoo.name // \"foo\"s\n```\n\n\n\n## 调用\n\n> - 直接调用 :\t函数名(实参列表)\n> - 在连接中调用: `<a href = \"javascript: 函数名()\">tap</a>`\n> - 在事件中调用 : 事件类型 = \"函数名()\"\n> - 递归调用\n\n### ES5\n\n> ES5函数内容的this指向和调用方法相关\n\n#### 调用模式\n\n> 函数名()和匿名函数调用, this 指向 window\n\n```js\n function getSum() {\n    console.log(this) //这个属于函数名调用，this指向window\n }\n getSum()\n \n (function() {\n    console.log(this) //匿名函数调用，this指向window\n })()\n \n var getSum=function() {\n    console.log(this) //实际上也是函数名调用，window\n }\n getSum()\n```\n\n#### 方法调用\n\n> `对象.方法名()`, this 指向对象\n\n```js\nvar obj = {\n   name: 'methods',\n   getSum: function() {\n     console.log(this) //objList对象\n   }\n}\nobj.getSum()\n```\n\n\n\n#### 构造器调用\n\n> new关键词 , this 指向实例化的对象;\n\n```js\nfunction Person() {\n  console.log(this); //是构造函数调用，指向实例化的对象personOne\n}\nvar personOne = new Person();\n```\n\n\n\n#### 间接调用\n\n> 利用call和apply来实现,this就是call和apply对应的第一个参数,如果不传值或者第一个值为null,undefined时this指向window 通过call/apply如果第一个参数是string、number、boolean，call内部会调用其相应的构造器String、Numer、Boolean将其转换为相应的实例对象\n\n```js\nfunction foo() {\n   console.log(this);\n}\nfoo.apply('我是apply改变的this值');//我是apply改变的this值\nfoo.call('我是call改变的this值');//我是call改变的this值\n```\n\n\n\n### ES6箭头函数\n\n> - ==箭头函数==不可以作为构造函数使用\n> - 不可以使用arguments 对象\n> - this的指向定义时所在的对象, 而不是调用的对象\n> - 不可以通过new实例化对象\n> - 调用就是调用模式\n\n```js\n(() => {\n   console.log(this)//window\n})()\n\nlet arrowFun = () => {\n  console.log(this)//window\n}\narrowFun()\n\nlet arrowObj = {\n  arrFun: function() {\n   (() => {\n     console.log(this)//this指向的是arrowObj对象\n   })()\n   }\n }\n arrowObj.arrFun();\n```\n\n## 方法\n\n> - IE5之前不支持call和apply,bind是ES5出来的; \n>   \n> - call和apply可以调用函数,改变this,实现继承和借用别的对象的方法;\n>   \n> - apply  : \n>   \n>   - 将函数作为对象的方法来调用\n>   - 将参数以数组形式传递给改方法(多个参)\n>   \n> - ##### call : \n>   \n>   - 将函数作为对象的方法来调用\n>   - 将指定参数传递给该方法(一个参)\n>   \n> - toString\n\n\n\n### call 和 apply\n\n> 1. 间接调用函数, 改变作用域的this的值\n> 2. 劫持其他对象方法\n> 3. 调用方法,用一个对象替换掉另一个对象(this) \n>    1. `对象.call(新this对象,实参1,实参2,实参3.....)  `\n>    2. `对象.apply(新this对象,[实参1,实参2,实参3.....]) `\n\n```js\nvar foo = {\n  name:\"张三\",\n  logName:function(){\n    console.log(this.name);\n  }\n}\nvar bar={\n  name:\"李四\"\n};\nfoo.logName.call(bar);//李四\n// 实质是call改变了foo的this指向为bar,并调用该函数\n```\n\n#### 两个函数继承\n\n```js\nfunction Animal(name){   \n  this.name = name;   \n  this.showName = function(){   \n    console.log(this.name);   \n  }   \n}   \nfunction Cat(name){  \n  Animal.call(this, name);  \n}    \nvar cat = new Cat(\"Black Cat\");   \ncat.showName(); //Black Cat\n```\n\n\n\n### 其他运用\n\n```js\nlet arr1 = [1, 2, 3];\nlet arr2 = [4, 5, 6];\nArray.prototype.push.apply(arr1, arr2); //将arr2合并到了arr1中\nconsole.log('max:', Math.max.apply(null, arr1)); // max: 6\nconsole.log('arr1:', arr1); //arr1:  [1,2,3,4,5,6]\nconsole.log('type:', Object.prototype.toString.call({}));// type: [Object Object]\nconsole.log('type:', Object.prototype.toString.call(arr1)); // type: [Object arrary]\n```\n\n\n\n### bind\n\n> - 是`function`一个函数拓展方法\n> - bind以后的代码重新绑定了func内部的this指向, 返回一个函数, 不会调用方法\n> - 不兼容`IE8`\n\n```js\nlet foo = {\n  name: \"张三\",\n  logName: function (age) {\n    console.log(this.name, age);\n  }\n}\nlet fooNewBind = foo.logName.bind(foo);\nfooNewBind(11)//张三,11  因为bind改变了fooNewBind里面的this指向\n```\n\n### call apply bind 原理\n\n#### call\n\n```js\n// call\nFunction.prototype.newCall = function (context, ...parameter) {\n  if (typeof context === 'object' || typeof context === 'function') {\n    context = context || window\n  } else {\n    context = Object.create(null)\n  }\n  let fn = Symbol()\n  context[fn] = this\n  const res = context[fn](...parameter)\n  delete context.fn;\n  return res\n}\n\nlet person = {\n  name: 'Abiel'\n}\nfunction sayHi(age, sex) {\n  console.log(this.name, age, sex);\n}\nsayHi.newCall(person, 25, '男'); // Abiel 25 男\n```\n\n\n\n#### apply\n\n```js\n// apply\nFunction.prototype.newApply = function (context, parameter) {\n  if (typeof context === 'object' || typeof context === 'function') {\n    context = context || window\n  } else {\n    context = Object.create(null)\n  }\n  let fn = Symbol()\n  context[fn] = this\n  const res = context[fn](...parameter);\n  delete context[fn]\n  return res\n}\nlet person = {\n  name: \"Abiel\"\n};\nfunction sayHi(age, sex) {\n  console.log(this.name, age, sex);\n}\nsayHi.newApply(person, [25, '男']) //Abiel 25 男\n```\n\n\n\n#### bind\n\n```js\n// bind\nFunction.prototype.bind = function (context, ...innerArgs) {\n  var me = this\n  return function (...finnalyArgs) {\n    return me.call(context, ...innerArgs, ...finnalyArgs)\n  }\n}\nlet person = {\n  name: 'Abiel'\n}\nfunction sayHi(age, sex) {\n  console.log(this.name, age, sex);\n}\nlet personSayHi = sayHi.bind(person, 25)\npersonSayHi('男')\n```\n\n\n\n## arguments对象\n\n> - 功能: 存放实参的参数列表\n> - 特性: \n>   - 仅能在函数体内使用\n>   - 带有下标属性, 当并非数组\n>   - 函数声明自动初始化\n> - 属性: \n>   - length\n>   - callee   当前正指向的函数\n>   - caler    抵用当前正在执行函数的函数名\n\n## 指针标识\n\n> - this                 指向当前操作对象\n> - callee             指向参数集合所处函数\n> - prototype      指向函数附带的原型对象\n> - constructor   指向创建该对象的构造函数\n\n","children":[]},{"name":"原型链.md","path":"../guanruihua.github.io/JavaScript/函数","data":"\n\n# 原型链\n\n> - 对象集成属性的一个链条\n> - 原型对象默认的==constructor==属性指向构造函数\n\n\n\n![图片描述](原型链.assets/8e320268216e4c4b992a5f119c734acctplv-k3u1fbpfcp-zoom-1.image)\n\n\n\n\n\n```js\nvar Person = function (name) { this.name = name; } //person是构造函数\nvar o3 = new Person('personTwo' )// o3 是实例\n\no3 // Persion{name:\"persionTwo\"}\nPerson // f(name){this.name = name; }\n```\n\n\n\n\n\n![image-20210603150948491](原型链.assets/image-20210603150948491-1622704190338.png)\n\n## 实例化方法\n\n\n\n###  字面量\n\n```js\nlet obj = { name : 'grh'}\n```\n\n\n\n\n\n###  Object 构造函数 创建\n\n```js\nlet obj = new Object();\nobj.name = 'grh';\n```\n\n\n\n### 工厂模式创建对象\n\n```js\nfunction createPerson(name){\n letr o = new Object();\n o.name = name;\n return o; \n}\nlet person1 = createPerson('grh');\n```\n\n\n\n### 使用构造函数创建对象\n\n```js\nfunction Person(name){\n  this.name = name;\n}\nlet person = new Person('grh')\n```\n\n## new 运算符\n\n> 1. 创建一个新的对象\n> 2. ==this==指向构造函数\n> 3. 构造函数有返回, 会替代new出来的对象,  如果没有就是new出来的对象\n> 4. 手动封装一个new运算符\n\n\n\n\n\n\n\n## 对象的原型链\n\n\n\n![图片描述](原型链.assets/8b03fb5eae9d431aaca1e73925a2b24etplv-k3u1fbpfcp-zoom-1.image)\n\n## 继承方式\n\n\n\n### 原型链继承\n\n> - 将父类的实例封装作为子类的原型\n> - 优缺点\n>   - 简单易于实现\n>   - 想为子类新增属性和方法, 必须要在`new Animal()`之后\n\n```js\n// 定义一个动物类\nfunction Animal (name) {\n  // 属性\n  this.name = name || 'Animal';\n  // 实例方法\n  this.sleep = function(){\n    console.log(this.name + '正在睡觉！');\n  }\n}\n// 原型方法\nAnimal.prototype.eat = function(food) {\n  console.log(this.name + '正在吃：' + food);\n};\n\n// 子类\nfunction Cat(){}\nCat.prototype = new Animal();\nCat.prototype.name = 'cat';\n\n//　Test Code\nvar cat = new Cat();\nconsole.log(cat.name);//cat\nconsole.log(cat.eat('fish'));//cat正在吃：fish  undefined\nconsole.log(cat.sleep());//cat正在睡觉！ undefined\nconsole.log(cat instanceof Animal); //true \nconsole.log(cat instanceof Cat); //true\n```\n\n\n\n### 构造继承\n\n> - 利用call来改变Cat中的this指向\n> - 优缺点\n>   - 可以实现多继承\n>   - 不能继承原型属性 / 方法\n\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || '';\n}\n```\n\n\n\n### 实例继承\n\n> - 为父类实例添加新特性, 作为子类实例返回\n> - 优缺点\n>   - 不限制调用方法, 但不能实现多继承\n\n```js\nfunction Cat(name){\n  let instance = new Animal();\n  instance.name = name || \"\";\n  return instance;\n}\n```\n\n\n\n### 拷贝继承\n\n> - 将父类属性和方法拷贝一份到子类中\n> - 优缺点\n>   - 支持多继承\n>   - 效率低, 占用内存\n\n```js\nfunction Cat(name){\n  var animal = new Animal();\n  for(var p in animal){\n    Cat.prototype[p] = animal[p];\n  }\n  Cat.prototype.name = name || 'Tom';\n}\n```\n\n\n\n### 组合继承\n\n> - 通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 \n\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\nCat.prototype = new Animal();\nCat.prototype.constructor = Cat;\n```\n\n\n\n### 寄生组合继承\n\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n(function(){\n  // 创建一个没有实例方法的类\n  var Super = function(){};\n  Super.prototype = Animal.prototype;\n  //将实例作为子类的原型\n  Cat.prototype = new Super();\n})();\n```\n\n\n\n### ES6 extend 继承\n\n> - ES6 的继承机制是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this\n\n```js\n//父类\nclass Person {\n    //constructor是构造方法\n    constructor(skin, language) {\n        this.skin = skin;\n        this.language = language;\n    }\n    say() {\n        console.log('我是父类')\n    }\n}\n\n//子类\nclass Chinese extends Person {\n    constructor(skin, language, positon) {\n        //console.log(this);//报错\n        super(skin, language);\n        //super();相当于父类的构造函数\n        //console.log(this);调用super后得到了this，不报错，this指向子类，相当于调用了父类.prototype.constructor.call(this)\n        this.positon = positon;\n    }\n    aboutMe() {\n        console.log(`${this.skin} ${this.language}  ${this.positon}`);\n    }\n}\n\n\n//调用只能通过new的方法得到实例,再调用里面的方法\nlet obj = new Chinese('红色', '中文', '香港');\nobj.aboutMe();\nobj.say();\n\n```\n\n","children":[]},{"name":"异步处理.md","path":"../guanruihua.github.io/JavaScript/函数","data":"# 异步处理\n\n> async 和 yield  可以处理异步方法\n\n## async await\n\n> await可以让异步函数或方法同步执行\n\n```js\nconst A = () => console.log('a')\nconst B = () => console.log('b')\nasync function asyncFn() {\n  console.log('start')\n  await A();\n  await new Promise( resolve => {\n    console.log('wait result');\n    resolve();\n  })\n  const data = await new Promise( resolve => resolve(1) )\n  console.log(data) // 1\n  await B();\n  console.log('end')\n}\n\nasyncFn();\n```\n\n## yield *\n\n> 和next() 一起使用, 每次使用next都会运行一个yield\n\n```js\nfunction * yieldFunc() {\n  console.log('start')\n  yield A();\n  const data = yield new Promise( resolve => resolve(1))\n  console.log(data)\n  yield B();\n  console.log('end')\n}\n\nfunction runYieldFunc() {\n  let yieldFn = yieldFunc();\n  yieldFn.next();\n  const dp = yieldFn.next();\n  console.log( dp )\n  dp.value.then( data => {\n    console.log( data ) // 在最后输出 1\n  })\n  yieldFn.next();\n  yieldFn.next();\n}\n\nrunYieldFunc(); \n```\n","children":[]},{"name":"继承.md","path":"../guanruihua.github.io/JavaScript/函数","data":"# Function继承\n\n既然要实现继承，那么首先我们得有一个父类，代码如下：\n\n```js\n// 定义一个动物类\nfunction Animal (name) {\n  // 属性\n  this.name = name || 'Animal';\n  // 实例方法\n  this.sleep = function(){\n    console.log(this.name + '正在睡觉！');\n  }\n}\n// 原型方法\nAnimal.prototype.eat = function(food) {\n  console.log(this.name + '正在吃：' + food);\n};\n```\n\n## 1、原型链继承\n\n**核心：** 将父类的实例作为子类的原型\n\n```js\nfunction Cat(){ \n}\nCat.prototype = new Animal();\nCat.prototype.name = 'cat';\n\n//　Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.eat('fish'));\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); //true \nconsole.log(cat instanceof Cat); //true\n```\n\n特点：\n\n1. 非常纯粹的继承关系，实例是子类的实例，也是父类的实例\n2. 父类新增原型方法/原型属性，子类都能访问到\n3. 简单，易于实现\n\n缺点：\n\n1. 要想为子类新增属性和方法，必须要在`new Animal()`这样的语句之后执行，不能放到构造器中\n2. 无法实现多继承\n3. 来自原型对象的所有属性被所有实例共享（来自原型对象的引用属性是所有实例共享的）（详细请看附录代码： 示例1）\n4. 创建子类实例时，无法向父类构造函数传参\n\n推荐指数：★★（3、4两大致命缺陷）\n\n**2017-8-17 10:21:43补充：感谢 [MMHS](http://home.cnblogs.com/u/1066372/) 指出。缺点1中描述有误：可以在Cat构造函数中，为Cat实例增加实例属性。如果要新增原型属性和方法，则必须放在`new Animal()`这样的语句之后执行。**\n\n**2018-9-10 00:03:45补充：感谢 [IRVING_J](https://www.cnblogs.com/lianghaijie-ctw/) 指出。缺点3中的描述不够充分。更正为：来自原型对象的所有属性被所有实例共享。**\n\n## 2、构造继承\n\n**核心：**使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）\n\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // false\nconsole.log(cat instanceof Cat); // true\n```\n\n特点：\n\n1. 解决了1中，子类实例共享父类引用属性的问题\n2. 创建子类实例时，可以向父类传递参数\n3. 可以实现多继承（call多个父类对象）\n\n缺点：\n\n1. 实例并不是父类的实例，只是子类的实例\n2. 只能继承父类的实例属性和方法，不能继承原型属性/方法\n3. 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能\n\n推荐指数：★★（缺点3）\n\n## 3、实例继承\n\n**核心：**为父类实例添加新特性，作为子类实例返回\n\n```js\nfunction Cat(name){\n  var instance = new Animal();\n  instance.name = name || 'Tom';\n  return instance;\n}\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); // false\n```\n\n特点：\n\n1. 不限制调用方式，不管是`new 子类()`还是`子类()`,返回的对象具有相同的效果\n\n缺点：\n\n1. 实例是父类的实例，不是子类的实例\n2. 不支持多继承\n\n推荐指数：★★\n\n## 4、拷贝继承\n\n```js\nfunction Cat(name){\n  var animal = new Animal();\n  for(var p in animal){\n    Cat.prototype[p] = animal[p];\n  }  // 2020年10月10日21点36分：感谢 @baclt 的指出，如下实现修改了原型对象，会导致单个实例修改name，会影响所有实例的name值\n  // Cat.prototype.name = name || 'Tom'; 错误的语句，下一句为正确的实现  this.name = name || 'Tom';\n}\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // false\nconsole.log(cat instanceof Cat); // true\n```\n\n特点：\n\n1. 支持多继承\n\n缺点：\n\n1. 效率较低，内存占用高（因为要拷贝父类的属性）\n2. 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）\n\n推荐指数：★（缺点1）\n\n## 5、组合继承\n\n**核心：**通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\nCat.prototype = new Animal();// 感谢 @学无止境c 的提醒，组合继承也是需要修复构造函数指向的。Cat.prototype.constructor = Cat;\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); // true\n```\n\n特点：\n\n1. 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法\n2. 既是子类的实例，也是父类的实例\n3. 不存在引用属性共享问题\n4. 可传参\n5. 函数可复用\n\n缺点：\n\n1. 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）\n\n推荐指数：★★★★（仅仅多消耗了一点内存）\n\n## 6、寄生组合继承★\n\n**核心：**通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点\n\n```ts\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n(function(){\n  // 创建一个没有实例方法的类\n  var Super = function(){};\n  Super.prototype = Animal.prototype;\n  //将实例作为子类的原型\n  Cat.prototype = new Super();\n})();\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); //true感谢 @bluedrink 提醒，该实现没有修复constructor。Cat.prototype.constructor = Cat; // 需要修复下构造函数\n```\n\n特点：\n\n1. 堪称完美\n\n缺点：\n\n1. 实现较为复杂\n\n推荐指数：★★★★（实现复杂，扣掉一颗星）\n\n## 附录代码：\n\n示例一：\n\n```ts\nfunction Animal (name) {\n  // 属性\n  this.name = name || 'Animal';\n  // 实例方法\n  this.sleep = function(){\n    console.log(this.name + '正在睡觉！');\n  }\n  //实例引用属性\n  this.features = [];\n}\nfunction Cat(name){\n}\nCat.prototype = new Animal();\n\nvar tom = new Cat('Tom');\nvar kissy = new Cat('Kissy');\n\nconsole.log(tom.name); // \"Animal\"\nconsole.log(kissy.name); // \"Animal\"\nconsole.log(tom.features); // []\nconsole.log(kissy.features); // []\n\ntom.name = 'Tom-New Name';\ntom.features.push('eat');\n\n//针对父类实例值类型成员的更改，不影响\nconsole.log(tom.name); // \"Tom-New Name\"\nconsole.log(kissy.name); // \"Animal\"\n//针对父类实例引用类型成员的更改，会通过影响其他子类实例\nconsole.log(tom.features); // ['eat']\nconsole.log(kissy.features); // ['eat']\n\n原因分析：\n\n关键点：属性查找过程\n\n执行tom.features.push，首先找tom对象的实例属性（找不到），\n那么去原型对象中找，也就是Animal的实例。发现有，那么就直接在这个对象的\nfeatures属性中插入值。\n在console.log(kissy.features); 的时候。同上，kissy实例上没有，那么去原型上找。\n刚好原型上有，就直接返回，但是注意，这个原型对象中features属性值已经变化了。\n```","children":[]},{"name":"节流和防抖.md","path":"../guanruihua.github.io/JavaScript/函数","data":"# 函数节流和防抖\n\n\n\n## 节流\n\n> - ==高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率==\n> - 应用 : scroll, resize 事件一段时间触发多次\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n\t<meta charset=\"UTF-8\">\n\t<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\t<title>节流</title>\n</head>\n\n<style>\n\t* {\n\t\tpadding: 0;\n\t\tmargin: 0;\n\t}\n\n\t.scroll-box {\n\t\twidth: 100%;\n\t\theight: 500px;\n\t\tbackground: blue;\n\t\toverflow: auto;\n\t}\n\n\t.scroll-item {\n\t\theight: 1000px;\n\t\twidth: 100%;\n\t}\n</style>\n\n<body>\n\t<div class=\"scroll-box\">\n\t\t<div class=\"scroll-item\"></div>\n\t</div>\n\t<script>\n\t\tlet throttle = function (func, delay) {\n\t\t\tlet timer = null;\n\t\t\treturn function () {\n\t\t\t\tif (!timer) {\n\t\t\t\t\ttimer = setTimeout(() => {\n\t\t\t\t\t\tfunc.apply(this, arguments);\n\t\t\t\t\t\t// 或者直接 func()\n\t\t\t\t\t\ttimer = null;\n\t\t\t\t\t}, delay);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\t// 处理函数\n\t\tfunction handle() {\n\t\t\tconsole.log(arguments)\n\t\t\tconsole.log(Math.random());\n\t\t}\n\t\t// 测试用例\n\t\tdocument.getElementsByClassName('scroll-box')[0].addEventListener(\"scroll\", throttle(handle, 3000));\n\t</script>\n</body>\n\n</html>\n```\n\n\n\n\n\n## 防抖\n\n> - ==触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间==\n> - 应用 : sroll, resize 时间触发后一段时间触发\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n\t<meta charset=\"UTF-8\">\n\t<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\t<title>防抖</title>\n</head>\n\n<style>\n\t* {\n\t\tpadding: 0;\n\t\tmargin: 0;\n\t}\n\n\t.scroll-box {\n\t\twidth: 100%;\n\t\theight: 500px;\n\t\tbackground: blue;\n\t\toverflow: auto;\n\t}\n\n\t.scroll-item {\n\t\theight: 1000px;\n\t\twidth: 100%;\n\t}\n</style>\n\n<body>\n\t<div class=\"scroll-box\">\n\t\t<div class=\"scroll-item\"></div>\n\t</div>\n\t<script>\n\t\tlet throttle = function (func, delay) {\n\t\t\tlet timer = null;\n\t\t\treturn function () {\n\t\t\t\tif (!timer) {\n\t\t\t\t\ttimer = setTimeout(() => {\n\t\t\t\t\t\tfunc.apply(this, arguments);\n\t\t\t\t\t\t// 或者直接 func()\n\t\t\t\t\t\ttimer = null;\n\t\t\t\t\t}, delay);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\t// 处理函数\n\t\tfunction handle() {\n\t\t\tconsole.log(arguments)\n\t\t\tconsole.log(Math.random());\n\t\t}\n\t\t// 测试用例\n\t\tdocument.getElementsByClassName('scroll-box')[0].addEventListener(\"scroll\", throttle(handle, 3000));\n\t</script>\n</body>\n\n</html>\n```\n\n","children":[]},{"name":"闭包.md","path":"../guanruihua.github.io/JavaScript/函数","data":"# 闭包\n\n## 一、获取局部作用域的变量\n\n1. 通过变量向外传递。\n\n   ```js\n   // 通过变量 向外传递 \n   var b = '';\n   function fn1(){\n       var a = \"月薪10w\";\n       b = a;\n     \n   }\n   fn1();\n   console.log(b); //取到函数内局部作用域的变量a的值\n   ```\n\n2. 通过函数向外传递。\n\n   ```js\n   // 通过函数传参获取\n   function fn1(){\n       var a = \"月薪10w\";\n       fn2(a);\n   }\n   function fn2(str){\n     console.log(str);\n   }\n   fn1();// 月薪10w\n   ```\n\n3. 条件和循环体：{}不代表作用域，在es6语法中，{}会被看做代码块，此时在{}当中声明一个函数，相当于`var`声明，尽量不要在{}当中声明函数，否则调用的时候会有问题。\n\n   ```js\n   {\n     function fn1(){\n       console.log(1);\n     }\n   }\n   console.log(fn1()); //1\n   ```\n\n#### 二、闭包\n\n1. js垃圾回收机制：js 中的变量和函数不再使用后，会被自动js垃圾回收机制回收。\n2. 形成闭包的条件：有函数/作用域的嵌套；内部函数引用外部函数的变量/参数。\n3. 闭包的结果：内部函数的使用外部函数的那些变量和参数仍然会保存，使用`return`返回了此内部函数，上面的变量和参数不会被回收。\n4. 闭包的原因：返回的函数并非孤立的函数，而是连同周围的环境（AO）打了一个包，成了一个封闭的环境包，共同返回出来 ---->闭包。\n5. 我们在返回函数的时候，并不是单纯的返回了一个函数，我们把该函数连同他的AO链一起返回了。\n6. 函数的作用域，取决于声明时而不取决于调用时。\n7. 变量存储`function(){}`、`{}`、`[]`存储的是一个地址。\n\n```js\nfunction t1(){\n  var age = 20;\n  function t2(){\n      console.log(age);\n  }\n  return t2;\n}\nvar tmp = t1();\nvar age = 1000;\ntmp(); //20\n\n// win 1. AO{t1:function(){},tmp:un,age:un}\n//     2. t1   1. AO{age:un,t2:fun}\n//            2. AO{age:20,t2:fun}\n//       AO{t1:function(){},tmp:t2,age:1000}\n//  \n//       tmp  t2 1.AO{}\n\nvar age = 10;\nfunction t1(){\n  var age = 20;\n  return function t2(){\n      console.log(++age);\n  }\n}\nvar t3 = t1();\nt3(); // 21\nt3(); // 22\nt3(); // 23\nconsole.log(age); //10\n\n\nvar age = 10;\nfunction t1(){\n  var age = 20;\n  return function t2(){\n      console.log(++age);\n  }\n}\nvar t3 = t1();\nvar t4 = t1();\nt3(); //21\nt4(); //21\n\n\nfunction foo(){\n  var a = 2;\n  function baz(){\n      console.log(a);\n  }\n  bar(baz);\n}\nfunction bar(fn){\n  var a = 3;\n  fn();\n}\nfoo();\n//2\n```\n\n#### 三、闭包计数器\n\n使用js的命名空间，优点：变量不受污染。\n\n```html\n<script>\n    var chengming = {};//js的命名空间 一般就是这么写\n    chengming.inc = (function(){\n        var cnt = 0;\n        return function(){\n            return ++cnt;\n        }\n    })();\n\n    console.log(chengming.inc());\n</script>\n<script>\n    var cnt = 100;\n    console.log(inc()); //报错，window下访问不到inc\n</script>\n```\n\n#### 四、循环中的闭包\n\n```js\n<body>\n <input type=\"button\" name=\"\" value=\"按钮1\">\n <input type=\"button\" name=\"\" value=\"按钮2\">\n <input type=\"button\" name=\"\" value=\"按钮3\">\n</body>\n<script>\n    var inp = document.getElementsByTagName('input');\n    for(var i=0; i<inp.length; i++){\n        inp[i].onclick = function(){\n            inp[i].style.background = \"yellow\";\n        }\n    }\n    //点击按钮会报错，因为i在window全局上，for结束之后，本身的值就是3\n</script>\n\n// 方法一  用自定义属性\nfor(var i=0;i<inp.length;i++){\n    inp[i].i = i;\n    inp[i].onclick = function(){\n        inp[this.i].style.background = 'yellow';\n    }\n}\n\n// 方法一  用let关键字\nfor(let i=0; i<inp.length; i++){\n    inp[i].onclick = function(){\n        inp[i].style.background = \"yellow\";\n    }\n}\n\n// 方法三 使用this\nfor(var i=0; i<inp.length; i++){\n    inp[i].onclick = function(){\n        this.style.background = \"yellow\";\n    }\n}\n\n\n// 方法四  for循环每次执行，都会立即执行一个匿名函数，并且匿名函数的作用域中传入了当时的i作为参数传递\nfor(var i=0; i<inp.length; i++){\n    (function(i){\n        // AO{i:1}\n        inp[i].onclick = function(){\n            // AO:{}\n            inp[i].style.background = 'yellow';  \n        }\n    })(i)\n}\n\n\n// 方法五\nfor(var i=0; i<inp.length; i++){\n    (function(){\n        // AO{}\n        var arg = i;\n        inp[arg].onclick = function(){\n            // AO:{}\n            inp[arg].style.background = 'yellow';\n        }\n    })()\n}\n\n\n// 方法六\nfor(var i=0; i<inp.length; i++){\n    inp[i].onclick = function(i){\n        // AO:{i:0}\n        return function(){\n            inp[i].style.background = 'yellow';\n        }\n    }(i)\n}\n\n\n// 方法七\nfor(var i=0; i<inp.length; i++){\n    (inp[i].onclick = function(){\n        inp[arguments.callee.i].style.background = 'yellow';\n    }).i = i;\n}\n\n\n// 方法八九 基本包装类型\nfor(var i=0; i<inp.length; i++){\n    inp[i].onclick = new Function(`inp[${i}].style.background = 'yellow';`);\n}\nfor(var i=0; i<inp.length; i++){\n    inp[i].onclick = Function(`inp[${i}].style.background = 'yellow';`);\n}\n```\n","children":[]},{"name":"高阶函数.md","path":"../guanruihua.github.io/JavaScript/函数","data":"# \\高阶函数\n\n> - 函数的参数是函数或返回函数\n> - 常见的高阶函数: map, reduce, filter, sort\n\n\n\n## 柯里化\n\n> `Currying`\n>\n> - 把接受多个参数的函数变换成接受一个单一参数\n> - 并且返回接受余下的参数而且返回新函数的技术\n> - 多化一\n\n\n\n### 多参数变单一参数\n\n> 将多个参数的函数变换成单一参数函数\n\n```js\n// 正常函数\nfunction add(x, y) {\n  return x + y;\n}\n// Currying后\nfunction curryingAdd(x) {\n  return function(y) {\n    return x + y;\n  }\n}\n\nconsole.log(\n  add(1, 2),// 3\n  curryingAdd(1)(2),// 3\n);\n```\n\n\n\n### 函数封装\n\n> 函数封装, 通过传入不同参数, 变成含有不同功能的函数\n\n```js\n// 正常正则验证字符串 reg.test(txt)\n\n// 函数封装后\nfunction check(reg, txt) {\n  return reg.test(txt)\n}\n\ncheck(/\\d+/g, 'test')       //false\ncheck(/[a-z]+/g, 'test')    //true\n\n// Currying后\nfunction curryingCheck(reg) {\n  return function(txt) {\n      return reg.test(txt)\n  }\n}\n\nvar hasNumber = curryingCheck(/\\d+/g)\nvar hasLetter = curryingCheck(/[a-z]+/g)\nconsole.log(\n  hasNumber('test1')   ,   // true\n  hasNumber('testtest') ,  // false\n  hasLetter('21212')     , // false\n)\n```\n\n\n\n### 柯里化实现多种传参方式\n\n> 利用柯里化函数特性, 可以实现不同的传参方式\n\n```js\nfunction add2() {\n  // 第一次执行时，定义一个数组专门用来存储所有的参数\n  var _args = Array.prototype.slice.call(arguments);\n\n  // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值\n  var _adder = function() {\n      _args.push(...arguments);\n      return _adder;\n  };\n  // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回\n  _adder.toString = function () {\n      // console.log(_args);\n      return _args.reduce(function (a, b) {\n          return a + b;\n      });\n  }\n  return _adder;\n}\n\nlet add2a = add2(1)(2)(3).toString()\nlet add2b = add2(1, 2, 3).toString()\nconsole.log(add2a);\n```\n\n\n\n```js\nfn(a,b,c,d)=>fn(a)(b)(c)(d)\nconst currying = fn => {\nconst len = fn.length\nreturn function curr (...args1) {\n    if (args1.length >= len) {\n         return fn(...args1)\n    }\n    return (...args2) => curr(...args1, ...args2)\n    }\n}\n\n```\n\n## 反柯里化\n\n> - 其实真正的反柯里化的作用是扩大适用范围，就是说当我们调用某个方法的时候，不需要考虑这个对象自身在设计的过程中有没有这个方法，只要这个方法适用于它，我们就可以使用；\n> - 增加被反柯里化方法接收的参数\n> - 一化多\n\n```js\n\t// 轻提示\n\tfunction Toast(option) {\n\t\tthis.prompt = '';\n\t}\n\tToast.prototype = {\n\t\tconstructor: Toast,\n\t\t// 输出提示\n\t\tshow: function () {\n\t\t\tconsole.log(this.prompt);\n\t\t}\n\t};\n\n\t// 新对象\n\tvar obj = {\n\t\tprompt: '新对象'\n\t};\n\n\tfunction unCurrying(fn) {\n\t\treturn function () {\n\t\t\tvar args = [].slice.call(arguments);\n\t\t\tvar that = args.shift();\n\t\t\treturn fn.apply(that, args);\n\t\t}\n\t}\n\n\tvar objShow = unCurrying(Toast.prototype.show);\n\n\tobjShow(obj); // 输出\"新对象\"\n```\n\n\n\n## 偏函数\n\n> - 和柯里化很像\n> - 指将函数的部分参数固定化\n\n```js\n//入参函数\nfunction add(a, b) {\n  return a + b;\n}\n//生产偏函数的工厂\nfunction partial(fn, a) {\n  return function (b) {\n    return fn(a, b);\n  }\n}\nvar parAdd = partial(add, 1);//变量parAdd接受返回的新函数\nconsole.log(parAdd(2));//在调用的时候传入剩余的参数\nconsole.log(parAdd(3));//在调用的时候传入剩余的参数\nconsole.log(parAdd(4));//在调用的时候传入剩余的参数\nconsole.log(parAdd(5));//在调用的时候传入剩余的参数\n```\n\n","children":[]}]},{"name":"动画","path":"../guanruihua.github.io/JavaScript","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/JavaScript/动画","data":"# 动画\n\n## 动画库\n\n> <https://animista.net/>\n> <https://www.minimamente.com/category/css/>\n> <http://guowc.github.io/animastore/>\n> <https://elrumordelaluz.github.io/csshake/>\n> <https://ianlunn.github.io/Hover/>\n> <https://angrytools.com/css/animation/>\n\n## 横向滚动\n\n> <https://github.com/zxuqian/html-css-examples/tree/master/38-horizontal-scrolling>\n","children":[]},{"name":"requestAnimationFrame .md","path":"../guanruihua.github.io/JavaScript/动画","data":"# requestAnimationFrame\n\n```js\n(() => {\n   let n = 0\n   function test() {\n    n++\n    console.log(`🚀🚀hello ~ requestAnimationFrame ${n}`);\n    if (n < 11) requestAnimationFrame(test)\n   }\n   requestAnimationFrame(test)\n  })()\n```\n","children":[]}]},{"name":"基础","path":"../guanruihua.github.io/JavaScript","data":"","children":[{"name":"static.md","path":"../guanruihua.github.io/JavaScript/基础","data":"# static 关键词\n\n> 静态属性 和 静态方法都是通过类(构造函数) 直接使用\n>\n> 引用属性 或 调用方法 的时候, 没有必要首先创建类 ( 构造函数 ) 的对象实例\n\n## 静态属性\n\n> - 给Antzone添加静态属性webName\n> - 静态属性直接由类本身引用, 而不是他的对象实例\n\n```js\nclass Antzone{}\nAntzone.webName=\"grh\";\nconsole.log(Antzone.webName);\n```\n\n## 静态方法\n\n> - 静态方法是由类或构造函数直接调用, 而不是对象实例\n>\n> -\n\n```js\nfunction Antzone() {\n  Antzone.show = function() {\n    console.log('grh')\n  }\n}\nAntzone.show();\n```\n\n使用关键词static\n\n```js\nclass Antzone {\n static show() {\n  console.log('grh')\n  }\n}\nlet ant = new Antzone();\nAntzone.show()\nant.show();// 这里会报ant.show not a function\n```\n\n> 1. 通过关键词static定义show()\n> 2. 直接通过类调用show(), 而不是对象实例调用\n> 3. ant.show() 之所以会报错, 他是调用实例方法show, 然而not 定义\n\n修改\n\n```js\nclass Antzone {\n static show() {\n  console.log('grh')\n  }\n  show() {\n   console.log('grh')\n  }\n}\nlet ant = new Antzone();\nAntzone.show()\nant.show();\n```\n\n> 静态方法与实例化方法可以重名\n\n```js\nclass Antzone{\n  static show(){\n    this.done()\n  }\n  static done(){\n    console.log(\"蚂蚁部落一\");\n  }\n  done(){\n    console.log(\"蚂蚁部落二\");\n  }\n}\nlet ant=new Antzone();\nAntzone.show();\n```\n\n> 1. 使用实例对象调用方法, 方法中的this指向此实例对象\n> 2. 如果使用类调用静态方法, so 静态function 中的this指向类本身\n> 3. show的this指向class Antzone , so this.done() 调用的是方法\n\n## 静态属性 and 静态方法的继承\n\n> - extends 关键字 , 可以实现类之间的继承\n>\n> - 可以继承父类的实例属性and 实例function, 静态属性and 静态方法也会被继承\n\n```js\nclass F{\n  static func() {\n  console.log('grh')\n  }\n} \nF.address = '珠海'\nclass C extends F{}\nC.func();\nconsole.log(C.address);\n```\n","children":[]},{"name":"this相关.md","path":"../guanruihua.github.io/JavaScript/基础","data":"# Question\n\n## 1.this的优先级\n\n> this的优先级:  new>bind>call(apply)>obj.func()>默认绑定\n\n```js\nvar obj = {};\nobj.log= console.log;\nobj.log.call(console,this);\n```\n\n> this的优先级:  new>bind>call(apply)>obj.func()>默认绑定\n>\n> 非严格模式下js语句中\"this\"默认指向全局对象(window)\n>\n> 严格模式下, 普通函数内部的this不会指向window\n>\n> 上面代码可以转换为`console.log.call(console, this)`\n\n```js\n\"use strict\"\nfunction fn(){\n  console.log(this)\n}\nfn();\n// undefined\n```\n\n```js\nfunction fn(){\n  console.log(this)\n}\nfn();\n// window\n```\n\n## 2.this诡异问题, 内存地址\n\n```js\nvar obj ={\n    a:1,\n    b:function () {alert(this.a)} \n}; \nvar fun =obj.b; // 会指向b函数存储的地址\n// 调用的时候就直接使用b, 而和obj.b()的使用不相同\nfun(); // 弹出undefined \nobj.b(); // 弹出 1\n```\n\n> this的行为有时候会显得极其诡异，让人感到困惑，但只需要记住 **this的值要等到代码真正执行时才能确定**\n> 同时this的值具体有以下几种情况：\n>\n> 1. new 调用时指的是被构造的对象\n> 2. call、apply调用，指向我们指定的对象\n> 3. 对象调用，如执行obj.b()，this指向obj\n> 4. 默认的，指向全局变量window(相当于执行window.fun())\n>\n> 这样看来，当你执行fun()的时候，以上1,2点均不满足。\n> 第3点,因为this是运行时确定的，而我们执行fun()，等同于windown.fun()(**与obj没有任何关系**)，自然的this指向window，而window没有定义变量a，结果是undefined。\n","children":[]},{"name":"V8编译过程.md","path":"../guanruihua.github.io/JavaScript/基础","data":"\n# V8编译过程\n\n> - 主要由C++开发\n> - 三个重要的组件: 解析器, 解释器, 编译器\n> - 特点\n>   1. 函数值声明未被调用, 不会被解析生成AST\n>   2. 函数只被调用一次, bytecode直接被解释执行\n>   3. 函数被调用多次, ==可能==会被标记为热点函数, 可以会被编译成机器代码\n>   4. 当一个函数被定义好,不要重复调用传入不同类型的参数,会导致机械代码回退到字节码重新编译,会影响性能\n\n### 编译过程\n\n> 1. 词法分析(分词)\n>    这个过程会将代码中的字符分解成对应有意义的代码块，这些代码块被称为词法单元（token）。\n>\n>    ```js\n>     var a = 1;\n>     => 'var' 'a' '=' '1' ';'\n>    ```\n>\n>    - 至于空格会不会被当做词法单元（token），取决于空格在这门语言中是否有意义。\n>\n> 2. 语法分析(解析)\n>    这个过程将词法单元流转换为一个元素逐级嵌套所组成的程序语法结构的数，被称为抽象语法树(AST);\n>\n> 3. 运行阶段\n>    预解析 - JavaScript引擎将语法检查正常后生成的语法树复制到当前执行的上下文环境中。（包含了函数提升、变量提升等等）。\n>    执行上下文 - 包含了变量对象、作用域链、this\n>    变量对象：由变量申明、函数声明、参数构成。变量对象是单例实现的。\n>    作用域链 - 变量对象和所有的父级作用域构成的。\n>    this - 在进入上下文阶段就已经确定了 一旦进入执行代码阶段阶段，this值就不会发生过改变了。\n>\n> ## Babel\n\n### 现在的V8\n\n```mermaid\ngraph LR\n A(js代码) --> |parser 解析器| B(抽象语法数树AST)\n B --> |interpreter 解释器|C(bytecode 字节码)\n C --> |compiler 编译器|D(machine code机器代码)\n```\n\n### 早期V8\n\n```mermaid\ngraph LR\n A --> |parser|B(AST)\n B --> |Full-codegen|C(机器代码)\n```","children":[]},{"name":"协程.md","path":"../guanruihua.github.io/JavaScript/基础","data":"# JavaScript/Node.js 有协程\r\n\r\n- 从 Callback 到 Promise 的 .then().then()... 也是在不断尝试去解决异步编程带来的回调嵌套、错误管理等问题，Promise 进一步解决了这些问题\r\n- 当异步链多了之后你会发现代码会变成这样 .then().then()... 由原来的横向变成了纵向的模式，仍就存在冗余的代码，基于我们大脑对事物的思考\r\n- 我们更倾向于一种近乎 “同步” 的写法来表达我们的异步代码，在 ES6 规范中为我们提供了 Generator 函数进一步改善我们的代码编写方式\r\n\r\n## Generator\r\n\r\n> Generator 中文翻译过来我们可以称呼它为 “生成器”，它拥有函数的执行权，知道什么时候暂停、什么时候执行，这里还有一个概念协程\r\n\r\n## 进程\r\n\r\n- 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是线程的容器（来自百科）。\r\n\r\n- 启动一个服务、运行一个实例，就是开一个服务进程，例如 Java 里的 JVM 本身就是一个进程，Node.js 里通过 node app.js 开启一个服务进程，多进程就是进程的复制（fork），fork 出来的每个进程都拥有自己的独立空间地址、数据栈，一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了 IPC 通信，进程之间才可数据共享。\r\n\r\n- Mac 系统自带的监控工具 “活动监视器” 也可看到效果。\r\n  \r\n![](./__assets__/协程-2022-05-04-14-51-49.png)\r\n\r\n- Node.js 中我们通过 Cluster 模块创建多进程时为什么要根据 CPU 核心数？创建更多不好吗？在一个 CPU 核心的任何时间内只能执行一个进程。因此，当你 CPU 核心数有限时，创建过多的进程，CPU 也是忙不过来的。\r\n\r\n- Node.js 通过单线程 + 事件循环解决了并发问题。而我们使用 Node.js 利用 Cluster 模块根据 CPU 核心数创建多进程解决的是并行问题，假设我有 4 CPU 每个 CPU 分别对应一个线程并行处理 A、B、C、D 不同的任务，线程之间互不抢占资源。\r\n\r\n- 一句话总结：进程之间数据完全隔离、由操作系统调度，自动切换上下文信息，属系统层级的构造。\r\n\r\n## 线程\r\n\r\n- 线程是操作系统能够进行运算调度的最小单位，首先我们要清楚线程是隶属于进程的，被包含于进程之中。一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的。\r\n\r\n- 同一块代码，可以根据系统 CPU 核心数启动多个进程，每个进程都有属于自己的独立运行空间，进程之间是不相互影响的。同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage)，线程又有单线程和多线程之分，具有代表性的 JavaScript、Java 语言。\r\n\r\n- 线程共享进程的资源，可以由系统调度运行，可以自动完成线程切换，也许你会听到多线程编程、并发问题，首先，并发指的某个时间点多个任务队列对应到同一个 CPU 上运行，在任一时间点内也只会有一个任务队列在 CPU 上执行，这时就产生排队了。\r\n\r\n- 为了解决这个问题，CPU 运行时间片会被分成多个 CPU 时间段，每个时间段给各个任务队列执行（对应多个线程），这样解决了一个任务如果造成阻塞，不会影响到其它的任务运行，同样线程是会自动切换的。\r\n\r\n- Node.js 是怎么解决的并发问题？Node.js 主线程是单线程的，核心通过事件循环，每次循环时取出任务队列中的可执行任务运行，没有多线程上下文切换，资源抢占问题，达到高并发成就。\r\n\r\n- 一句话总结：线程之间大多数共享数据（各自的调用栈这些信息除外），由操作系统调用，自动切换上下文，系统层级的构造。\r\n\r\n## 协程\r\n\r\n- 协程又称为微线程、纤程，英文 Coroutine。协程类似于线程，但是协程是协作式多任务的，而线程是抢占式多任务的。协程之间的调用不需要涉及任何系统调用，是语言层级的构造，可看作一种形式的控制流，有时候我们也会称它为用户态的轻量级线程。\r\n\r\n- 协程一个特点是通过关键字 yield 调用其它协程，接下来每次协程被调用时，从协程上次 yield 返回的位置接着执行，这种通过 yield 协作转移执行权的操作，彼此没有调用者和被调用者的关系，是彼此平等对称的一种关系。\r\n\r\n- 协程与线程两者的差异，可以看出 “同一时间如果有多个线程，但它们会都处于运行状态，线程是抢占式的，而协程同一时间运行的只有一个，其它的协程处于暂停状态，执行权由协程自己分配”。\r\n\r\n- 协程也不是万能的，它需要配合异步 I/O 才能发挥最好的效果，对于操作系统而言是不知道协程的存在的，它只知道线程。需要注意，如果一个协程遇到了阻塞的 I/O 调用，这时会导致操作系统让线程阻塞，那么在这个线程上的其它协程也都会陷入阻塞。\r\n\r\n- 一句话总结：协程共享数据，由程序控制完成上下文切换，语言层级的构造。\r\n\r\n## JavaScript 有协程吗\r\n\r\n之前知乎上有个问题 “Node.js 真的有协程吗？” 协程在很多语言中都支持，只是每个实现略有差异，下图来自维基百科展示了支持协程的编程语言，可以看到 JavaScript 在 ECMAScript 6 支持，ECMAScript 7 之后通过 await 支持，Node.js 做为 JavaScript 在服务端的运行时，只要你的 Node.js 版本对应支持，就是可以的。\r\n![](./__assets__/协程-2022-05-04-14-52-13.png)\r\n\r\n## 协程在 JavaScript 中的实现\r\n\r\n### 生成器与协程\r\n\r\n- 生成器（Generator）是协程的子集，也称为 “半协程”。差异在于，生成器只能把控制权交给它的调用者，完全协程有能力控制在它让位之后哪个协程立即接续它执行。在 JavaScript 里我们说的 Generator 函数就是 ES6 对协程的实现。\r\n\r\n- JavaScript 是一个单线程的语言，只能保持一个调用栈。在异步操作的回调函数里，一旦出错原始的调用栈早已结束，引入协程之后每个任务可以保持自己的调用栈，这样解决的一大问题是出错误时可以找到原始的调用栈。\r\n\r\n- 看下生成器函数与普通函数有什么区别？首先普通函数通过栈实现的，举个例子，调用时是 `A() -> B() -> C()` 入栈，最后是 `C() -> B() -> A()` 这样一个顺序最后进入的先出栈执行。\r\n\r\n- 生成器函数看似和普通函数相似，其实内部执行机制是完全不同的，生成器函数在内部执行遇到 yield 会交出函数的执行权给其它协程（此处类似 CPU 中断），转而去执行别的任务，在将来一段时间后等到执行权返回（生成器还会把控制权交给它的调用者），程序再从暂停的地方继续执行。\r\n\r\n### 无堆栈协程\r\n\r\n- 自 ES6 开始，通过 `Generator` 和 `yield` 表达式提供了无堆栈协程功能\r\n\r\n> “无栈协程的秘密在于它们只能从顶级函数中挂起自己。对于其他所有函数，它们的数据都分配在被调用者堆栈上，因此从协程调用的所有函数必须在挂起协程之前完成。协程保留其状态所需的所有数据都在堆上动态分配。这通常需要几个局部变量和参数，其大小远小于预先分配的整个堆栈”。参考 coroutines-introduction\r\n\r\n栈是一块连续的内存，能够从子函数产生的协程称为栈式，它们可以记住整个调用栈，这种也称为栈式协程。在 JavaScript 中我们只能从生成器函数内部暂停、恢复执行生成器函数。\r\n\r\n下面示例 test1() 是生成器函数，但是 forEach 里面的匿名函数是一个普通的函数，就无法在内部使用 yield 关键字，运行时会抛出错误 “SyntaxError: Unexpected identifier”\r\n\r\n```js\r\n\r\nfunction *test1() {\r\n  console.log('execution start');\r\n  \r\n  ['A', 'B'].forEach(function(item) {\r\n    yield item;\r\n  })\r\n}\r\n```\r\n\r\n### 生成器函数示例\r\n\r\n例如，现在有两个生成器函数 test1()、test2()，还有 co 这个工具可以帮助我们自动的执行生成器函数。\r\n\r\n```js\r\nconst co = require('co');\r\nfunction *test1() {\r\n  console.log('execution 1');\r\n  console.log(yield Promise.resolve(1));\r\n  console.log('execution 2');\r\n  console.log(yield Promise.resolve(2));\r\n}\r\n\r\nfunction *test2() {\r\n  console.log('execution a');\r\n  console.log(yield Promise.resolve('a'));\r\n  console.log('execution b');\r\n  console.log(yield Promise.resolve('b'));\r\n}\r\n\r\nco(test1);\r\nco(test2);\r\n```\r\n\r\n#### 看下运行结果\r\n\r\n> 第一次程序执行 test1() 函数，先输出 'execution 1' 遇到 yield 语句程序的控制权转移。\r\n现在执行权转移到了 test2() 函数，执行代码输出 'execution a' 当遇到 yield 语句后交出程序的控制权。\r\n此时 test1() 函数收回执行权，恢复执行输出 '1' 继续往下执行输出 'execution 2' 当遇到 yield 语句再次交出执行权，依次类推。\r\n\r\n```js\r\nexecution 1\r\nexecution a\r\n1\r\nexecution 2\r\na\r\nexecution b\r\n2\r\nb\r\n```\r\n\r\n## 总结\r\n\r\n“JavaScript 有协程吗？” JavaScript 中是在 ES6 后基于生成器函数（Generator）实现的，生成器只能把程序的执行权还给它的调用者，这种方式我们称为 “半协程”，而完全的协程是任何函数都可让暂停的协程执行。\r\n\r\n基于生成器函数这种写法，如果去掉 yield 关键字，与我们普通的函数是相似的，以一种同步的方式来表达，解决了回调嵌套的问题，另外我们还可以通过 try...catch 做错误捕获，只不过我们还需要借助 CO 这样的模块，让生成器函数自动执行，这个问题在 ES7 中已经得到了更好地解决，可以通过 async/await 轻松的实现\r\n\r\nReference\r\n<https://en.wikipedia.org/wiki/Coroutine#Implementations_in_JavaScript>\r\n<https://zhuanlan.zhihu.com/p/70256971>\r\n<http://zhangchen915.com/index.php/archives/719/>\r\n<https://es6.ruanyifeng.com/#docs/generator>\r\n","children":[]},{"name":"注册事件.md","path":"../guanruihua.github.io/JavaScript/基础","data":"# 注册事件\n\n> addEventListener :  主流浏览器都适用\n>\n> attachEvent() : IE事件模型适用该方法\n\n## addEventListener\n\n> `element.addEventListener(String type, Function listener, boolean useCaptrue);`\n>\n> - type : 注册事件类型名 [ 没有on 前缀 ]\n> - listener : 监听函数\n> - useCaptrue : 事件捕获\n>   - true : 指定事件处理函数将在事件传播的捕获阶段触发\n>   - false : 事件处理函数将在冒泡阶段触发\n\n```js\n<p id=\"p1\">为对象注册多个事件</p>\n<script>\n    var p1 = document.getElementById(\"p1\");  //捕获段落元素的句柄\n    p1.addEventListener(\"mouseover\", function () {\n        this.style.background = 'blue';\n    }, true);  //为段落元素注册第1个事件处理函数\n    p1.addEventListener(\"mouseout\", function () {\n        this.style.background = 'blue';\n    }, true);  //为段落元素注册第2个事件处理函数\n</script>\n```\n\n## attachEvent\n\n> `element.attachEvent(etype, eventName)`\n>\n> - etype : 设置事件类型 [ 这里和addEventListener不相同, 需要on前缀 ]\n> - eventName : 设置时间名称, 也就是时间处理函数\n\n```js\n<p id=\"p1\">为对象注册多个事件</p>\n<script>\n    var p1 = document.getElementById(\"p1\");  //捕获段落元素\n    p1.attachEvent(\"onmouseover\", function () {\n        this.style.background = 'blue';\n    });  //注册mouseover事件\n    p1.attachEvent(\"onmouseout\", function () {\n        this.style.background = 'red';\n    });  //注册mouseout事件\n</script>\n```\n","children":[]},{"name":"流程&基础遍历.md","path":"../guanruihua.github.io/JavaScript/基础","data":"\n# 流程控制\n\n### 循环语句\n\n> `while([条件表达式]){}`\n>\n> `do-while([条件表达式])`:至少执行一次\n>\n> `for(;循环条件;){}`\n>\n> `for(声明变量 in 对象){}`: 枚举对象属性(对象不可以为null,undefined)\n>\n> ```js\n> for (let item of 'grh') {\n>     console.log(item)\n> }\n> // grh\n> ```\n\n### 跳转控制语句\n\n> return\n>\n> break\n>\n> continue\n\n### 选择语句\n\n> ```js\n> if([条件表达式]){\n>  ...\n> }else if[条件表达式]){\n> ...\n> }else{\n> ...\n> }\n> ```\n>\n> ```js\n> switch([条件表达式]){\n> case 标签1:\n> 代码片段1;\n> break;\n> ...\n> default: \n> 代码片段n;\n> }\n> ```\n\n### 异常处理语句\n\n> throw: 主动抛出异常\n>\n> try: 指明需要处理的代码段\n>\n> catch: 捕获异常\n>\n> finally: 后期处理\n","children":[]}]},{"name":"对象","path":"../guanruihua.github.io/JavaScript","data":"","children":[{"name":"BOM.md","path":"../guanruihua.github.io/JavaScript/对象","data":"## Window对象 BOM\n\n> 浏览器对象模型:BOM(Browser Object Model )\n\n### Window尺寸&获取元素的相对位置\n\n> Internet Explorer、Chrome、Firefox、Opera 以及 Safari：\n>\n> - window.innerHeight - 浏览器窗口的内部高度\n> - window.innerWidth - 浏览器窗口的内部宽度\n>\n> Internet Explorer 8、7、6、5 ：\n>\n> - document.documentElement.clientHeight\n> - document.documentElement.clientWidth\n>\n> 或者\n>\n> - document.body.clientHeight\n> - document.body.clientWidth\n\n| js代码                                              | 描述                                                         |\n| --------------------------------------------------- | ------------------------------------------------------------ |\n| element.clientWidth / clientHeight                  | 内高度 / 宽度: margin + content                              |\n| element.offsetWidth / offsetHeight                  | 外高度 / 宽度:border + padding + content                     |\n| element.clientTop / clientLeft                      | 上/左 边框                                                   |\n| element.getBoundingClientRect()                     | x \\ y:              元素的左上角和父元素左上角的距离 <br>width / height: 边框 + 内边距 + 内容框 <br/>top:                元素的上边界和父元素上边界的距离 <br/>left:                元素的左边界和父元素左边界的距离 <br/>right:              元素的右边界和父元素的左边界的距离 <br/>bottom:          元素的下边界和父元素上边界的距离 |\n| element.offsetTop / element.offsetLeft              | 上边 / 左边 的偏移量                                         |\n| document.documentElement.clientWidth / clientHeight | 可视区域的大小                                               |\n| document.documentElement.scrollWidth / scrollHeight | 页面的实际大小                                               |\n| window.screenX / screenY                            | 窗口左上角与屏幕左上角的距离                                 |\n| window.screen.width / height                        | 屏幕可用宽高( 去除任务栏 )                                   |\n| window.innerWidth / innerHeight                     | 窗口的内高度 / 宽度                                          |\n| window.outerWidth / outerHeight                     | 窗口的外高度 / 宽度                                          |\n|                                                     |                                                              |\n\n### Window对象\n\n#### 属性\n\n> - 状态栏\n>   - defaultStatus 改变浏览器状态栏的默认显示\n>   - status          临时改变浏览器状态栏的显示\n> - 窗口位置\n>   - IE\n>     - screenLeft  声明窗口的左上角的X坐标\n>     - screenTop   声明窗口的左上角的Y坐标\n>     - 声明当前文档向右滚动的像素数\n>       - document.body.scrollLeft\n>       - document.documentElement.scrollLeft\n>     - 声明当前文档向下滚动过的像素数\n>       - document.body.scrollTop\n>       - document.documentElemnet.scrollTop\n>   - !IE\n>     - screeenX  声明窗口左上角的==X==坐标\n>     - screenY     声明窗口左上角的==Y==坐标\n>     - pageXOffset    声明当前文档向右滚动过的像素数\n>     - pageYOffset     声明当前文档向下滚动过的像素数\n>   - FF\n>     - innerHeight    返回窗口的文档显示区的高度\n>     - innerWidth      返回当前的文档显示区的宽度\n>     - outerHeight     返回窗口的外部高度\n>     - outerWidth       返回窗口的外部宽度\n> - 其他属性\n\n#### navigator(导航器对象)\n\n>  - appCodeName   返回浏览器的代码名\n>  - appName      返回浏览器的名称\n>  - appVersion    返回浏览器的平台和版本信息\n>  - cookieEnabled   返回指明浏览器中是否启动cookie的布尔值\n>  - platform    返回浏览器的操作系统平台\n>  - userAgent   返回客户机发送服务器的user-agent头部的值\n\n#### screen(显示器对象)\n\n>  - avaiHeight    返回显示器的可用高度\n>  - avaiWidth     返回显示屏幕的可用宽度\n>  - height      返回屏幕高度的像素数\n>  - width       返回屏幕宽度的像素数\n>  - colorDepth   返回屏幕颜色的位数\n\n#### history(历史对象)\n\n>- back()     返回前一个URL\n>- forward()   返回下一个URL\n>- go()     返回某个具体页面\n>- 添加和修改历史记录中的条目\n>\n> - pushState()  添加\n> - replaceState()  修改\n> - popstate\n\n```js\n//history向后跳转\nwindow.history.back()    =>   window.history.go(-1)\nwindow.history.forward();  =>  window.history.go(1)\nlet numberOfEntries = window.history.length//获取堆栈中页面的数量\nlet stateObj = {\n\tfoo: 'bar'\n}\nhistory.pushState( stateObj, \"page 2\", \"bar.html\");\nhistory.replaceState(stateObj, \"page 3\", \"bar2.html\");\n\nwindow.onpopstate = function(event) {\n  console.log(\"location: \" + document.location + \", state: \" + JSON.stringify(event.state));\n};\n//绑定事件处理函数. \nhistory.pushState({page: 1}, \"title 1\", \"?page=1\");    //添加并激活一个历史记录条目 http://example.com/example.html?page=1,条目索引为1\nhistory.pushState({page: 2}, \"title 2\", \"?page=2\");    //添加并激活一个历史记录条目 http://example.com/example.html?page=2,条目索引为2\nhistory.replaceState({page: 3}, \"title 3\", \"?page=3\"); \t//修改当前激活的历史记录条目 http://ex..?page=2 变为 http://ex..?page=3,条目索引为3\nhistory.back(); \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 弹出 \"location: http://example.com/example.html?page=1, state: {\"page\":1}\"\nhistory.back(); \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 弹出 \"location: http://example.com/example.html, state: null\nhistory.go(2);  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 弹出 \"location: http://example.com/example.html?page=3, state: {\"page\":3}\n```\n\n\n\n#### location(位置对象)\n\n>  - 属性\n>    - hash    设置或返回从#号开始的URL\n>    - host     设置或返回主机名或当前URL的端口号\n>    - hostname   设置或返回当前URL的主机名\n>    - href     设置或返回完整的URL\n>    - pathname    设置或返回当前URL的路径部分\n>    - port    设置或返回当前URL的端口号\n>    - protocol    设置或返回当前URL的端口号\n>    - search    设置或返回?开始的URL\n>  - 方法\n>    - assign(URL)    加载新的文档\n>    - reload()      重现加载当前页面\n>    - replace(newURl)    用新的完蛋替换当前文档\n\n#### document(文档对象)\n\n##### 集合\n\n> - anchors[]  锚点对象数组\n> - images[]    图片对象数组\n> - links[]        连接对象数组\n> - forms[]      表单对象数组\n\n##### 属性\n\n> - cookie  设置或返回与当前文档有关所有cookie\n> - domain   返回当前文档的域名\n> - referrer   返回载入当前文档的文档的URL\n> - title 返回当前文档的标题\n> - URL 返回当前文档的URL\n\n##### 方法\n\n> - open()   打开一个新的文档, 并查处旧文档内容\n> - close()   关闭文档输出流\n> - write()    向当前文档追加写入文本\n> - writeIn()   与wtite()相同,在<pre>中追加换行\n\n\n\n#### 窗口控制\n\n>- moveBy:\n>- moveBy(水平位移量, 垂直位移量) \n>- 按照指定像素移动指定窗口\n>- moveTo:\n>- moveTo(x, y)\n>- 将窗口移动到指定坐标(x, y)\n>- resizeBy:\n>- resizeBy(x, y)\n>- 将当前窗口改变指定的大小(x, y)\n>- 当x, y 的值大于0时为扩大\n>- 当x, y 的值小于0时为缩小\n>- resizeTo\n>- resizeTo(x, y)\n>- 将当前窗口改编成(x, y)大小, x, y分别为宽度和高度\n>- scrollBy\n>- scrollBy(x, y)\n>- 将窗口中的内容给定的唯一量滚动\n>- 参数为正数, 正向滚动, 反之, 反向\n>- scrollTo\n>- scrollTo(x, y)\n>- 将窗口内容滚动到指定位置\n\n#### 焦点控制\n\n> - focus 得到焦点\n> - blur    移出焦点\n\n#### 打开关闭窗口\n\n>- open\n>- open(\"URL\", \"窗口名称\", \"窗口风格\")\n>- 打开一个新的窗口, 并在窗口中转载指定URL地址的网页\n>- 窗口风格:\n>  - height    数值    窗口高度   不能小于100\n>  - width      数值    窗口宽度    不能小于100\n>  - left    数值    窗口左坐标   不能为负值\n>  - top    数值    窗口上坐标   不能为负值\n>  - location     是否显示地址栏\n>  - menubar     是否显示菜单栏\n>  - resizable      是否可以改变窗口大小\n>  - scrollbars   是否允许出现滚动栏\n>  - status    是否显示状态栏\n>  - toolbar   是否显示工具栏\n>- close\n>- close()\n>- 自动关闭浏览器窗口\n\n#### 定时器\n\n>- setTimeout(将执行代码,  毫秒):定时器\n>- 到了指定时间后执行代码\n>- clearTimeout(定时器)\n>- 取消由setTimeout设置的定时器\n>- setInterval(重复执行的代码, 毫秒):时间间隔器\n>- 指定周期重复执行功能代码\n>- clearInterval(时间间隔器)\n>- 取消由setInterval()设置的时间间隔期\n\n#### 对话框\n\n> - alert(\"提示字符串\")\n> - confirm(\"提示字符串\")\n>   - 确认=>返回true, 反之false\n> - prompt(\"提示字符串\", \"缺省文本\")\n>   - 返回输入的字符串\n>   - 点击取消   返回null\n\n","children":[]},{"name":"class.md","path":"../guanruihua.github.io/JavaScript/对象","data":"# Class\n\n- class 相对 function 是后出来的，既然 class 出来了，显然是为了解决 function 在处理面向对象设计中的缺陷而来\n- 下面通过对比，来看看 class 作为 ES6 中的重大升级之一的优势在哪里：为了更好的对比，请参见我的另外一篇博文： js面向对象设计之 function 类\n  - class 写法更加简洁、含义更加明确、代码结构更加清晰。\n  - class 尽管也是函数，却无法直接调用（不存在防御性代码了）。\n  - class 不存在变量提升。\n  - class 为污染 window 等全局变量\n  - class 函数体中的代码始终以严格模式执行\n  - 可直接使用 set 和 get 函数, 而function 中需要通过`Object.defineProperty`方法来设置get和set\n  - class 中的 this 永远都不会指向 window。\n  - class 可以从 javascript 中的几大类中进行继承：Array、number、string...\n  - class 中有一个对象super，这个对象可以取到父类的方法、构造函数等。\n  - class 中不存在实例方法，class 中定义所有方法都是原型方法。这些方法也都是不可枚举的，使用 for in 这种方式无法遍历到它们。\n  - class 不能使用 return 来返回一个实例\n\n```js\n/* ReferenceError: Class01 is not defined */\ntry { var ins01 = new Class01(); } catch ( e ) { console.error( e ); }\nclass Class01 { }\nconsole.log( typeof Class01 ); /* function */\n/* Class constructor Class01 cannot be invoked without 'new' */\ntry { Class01() } catch ( e ) { console.error( e ); }\nconsole.log( window.Class01 ); /* undefined */\n```\n\n## set & get\n\n```js\n// 可直接使用 set 和 get 函数, 而function 中需要通过`Object.defineProperty`方法来设置get和set\nclass Class01{\n    constructor() { }\n    get name(){\n        console.log( 'getter' );\n        return this._name;\n    }\n    set name( v ){\n        this._name = v;\n        console.log( 'setter' );\n        return this;\n    }\n}\nvar ins01 =  new Class01();\nins01.name; /* getter */\nins01.name = 2; /* setter */\n```\n\n## class this 不会指向 window\n\n```js\n// class 中的 this 永远都不会指向 window。\nclass Class01 {\n  \n    constructor() {\n        this.a = 'a';\n    }\n    geta(){\n        return this.a;\n    }\n}\nlet ins01 = new Class01();\nconsole.log( ins01.geta() ); /* a */\nlet obj = {};\nobj.a = 'objA';\nobj.geta = ins01.geta;\nconsole.log( obj.geta() ); /* 'objA' */\nwindow.a = 'windowA';\nwindow.geta = ins01.geta;\n/* Cannot read property 'a' of undefined */\n/* 若是 function 类此处会返回 'windowA' */\ntry { geta() } catch ( e ) { console.error( e ); }\n```\n\n## class 继承\n\n```js\n// class 可以从 javascript 中几大类中进行继承：Array、number、string....\nclass Class01 extends Array { }\nlet ins01 = new Class01( 1, 2, 3 ); /* [1,2,3] */\nlet arr = ins01.shift(); /* [2,3] */\narr instanceof Class01; /* false */\nins01 instanceof Class01; /* true */小tips：在 mozilla 的开发者指南中看到一种比较高端的东西（关于从原生类继承肯定还有话题，会继续学习）：\nstatic get [Symbol.species]() { return Array; }参见 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes\n```\n\n## super对象\n\n```js\n// class 中有一个对象super，这个对象可以取到父类的方法、构造函数等。\nclass Class01 {\n    constructor( name ){\n        this.name = name;\n    }\n    geta(){\n        console.log( this.name + ' 父类方法.' );\n    }\n}\nclass Class02 extends Class01 {\n    geta(){\n        super.geta();\n        console.log( this.name + ' 子类方法.' );\n    }\n}\nvar l = new Class02( 'Class02' );\nl.geta();\n```\n\n```js\n// 11、class 不能使用 return 来返回一个实例（等等，我还没有试验过，不好意思，我会马上试验一下）。　　\n// 编辑验证，class 的 constructor 可以使用 return，因此 class 与 function 一样可以返回任意的内容。若不写 return 语句，或返回是数值、字符串等非引用类型的值，则 constructor 任然会返回 this（实例）。return [] 或 return {} 都会使得 new 关键字并不会返回 class 的实例说了这么多的不同点，再来说说 class 和 function 的相同之处：\n\n// 1、静态方法  在这点上，两者还是有相似之处的。尽管相似，显然 class 要更加优雅，可读性也更强，class 使用 static 关键词指定静态方法。并且class 可以在函数体内定义静态函数，而 function 不能，这无疑也让 function 写出来的代码更加的复杂。\n\nclass Class01{\n    static geta(){\n        console.log( '01的静态方法' );\n    }\n}\nfunction Class02 () { }\nClass02.geta = function () { console.log( '02的静态方法' ); }\nClass01.geta();\nClass02.geta();\n\n// 2、私有属性和方法两者都必须采用闭包的方式才能实现。下面给出 class 的私有属性和方法。\nvar Class02 = ( function () {\n    let pVal ;\n    function sayHello(){\n        console.log( this ); /* this 指向 window */\n        console.log( '欢迎访问nDos的博客' );\n    }\n    return class Class01{\n        constructor( v = '初始值' ){\n            pVal = v;\n        }\n        get val(){\n            sayHello();\n            return pVal;\n        }\n        set val( v ){\n            pVal = v;\n        }\n    };\n} )();\nlet ins01 = new Class02();\nconsole.log( ins01.val );\nins01.val = 'hello';\nconsole.log( ins01.val );\nins01 instanceof Class02; /* true */\nins01.constructor.name; /* \"Class01\" */\n// 小tips：上面的代码显示 ins01 是 Class02 的实例，但 ins01 的构造函数 name 属性却是 Class01。显然这在项目中不可行，会给类的使用者造成困惑。下例可解决这个问题：\nvar Class01 = ( function () {\n    return class Class01 { };\n} )();\nlet ins01 = new Class01();\nins01 instanceof Class01; /* true */\nins01.constructor.name; /* \"Class01\" */\n\n\n```\n","children":[]},{"name":"cookie.md","path":"../guanruihua.github.io/JavaScript/对象","data":"# Cookie\n\n> 用户存储一些数据, 存储与电脑上的文本文件中\n>\n> 当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息。\n>\n> Cookie 的作用就是用于解决 \"如何记录客户端的用户信息\":\n>\n> - 当用户访问 web 页面时，他的名字可以记录在 cookie 中。\n> - 在用户下一次访问该页面时，可以在 cookie 中读取用户访问记录\n\n## 使用cookie\n\n> - `expires`: 过期时间\n> - `path`: cookie的路径\n\n```js\ndocument.cookie=\"username=John Smith; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/\";\ndocument.cookie=\"username2=John Smith2; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/\";\n\ngetCookie(\"username\")//John Smith\ngetCookie(\"username2\")//John Smith2\ndocument.cookie // 可以返回全部cookie\n```\n","children":[]},{"name":"DOM.md","path":"../guanruihua.github.io/JavaScript/对象","data":"## DOM事件\n\n### 事件级别\n\n> DOM0: element.onclick = function(){}\n>\n> DOM2: element.addEventListener('click', function(){}, false)\n>\n> DOM3: element.addEventListener('keyup', function(){}, false)\n>\n> 没有DOM1, 因为DOM1标准制定的时候没有涉及DOM事件\n>\n> DOM3比DOM2添加了一些事件类型\n\n\n\n### DOM事件捕获的具体流程\n\n> 捕获流程:  window -> document -> html -> body- >...-> 目标元素\n>\n> 冒泡流程: 目标元素 -> ...-> body -> html - > document -> window\n\n\n\n## DOM操作\n\n### EventListener()方法\n\n> - 添加事件监听器\n>   - 语法 : `element.addEventListener( *event, function, useCapture* );`\n>     - 参数1: 事件类型(不要使用\"on\"前缀, 例如\"click\", 而不是\"onclick\")\n>     - 参数2: 时间出发调用函数\n>     - 参数3: 是个布尔值(false: 冒泡, true:捕获[ 可选])\n>   - eg: `document.getElementById(\"btn\").addEventListener(\"click\",myFunction);`\n> - 移除事件监听器\n>   - eg:`element*.removeEventLister(\"mousemove\", myFunction);`\n\n### 获取节点\n\n> - document\n>   - getElementById([元素ID])\n>   - getElementByName([元素name属性])\n>   - getElementsByTagName([元素标签])\n> - 节点指针\n>   - 父节点.firstChild : 获取元素的首个节点\n>   - 父节点.lastChild : 获取元素最后一个节点\n>   - 父节点.childNodes : 获取元素的==子节点列表==\n>   - 兄弟节点.previousSibling : 获取已知节点的前一个节点\n>   - 兄弟节点.nextSibling : 获取已知节点后一个节点\n>   - 子节点.parentNode : 获取已知节点的父节点\n\n### 节点操作\n\n> - 创建节点 : \n>   - createElement\n>     - document.createElement\n>     - 创建元素节点\n>   - createAttibute\n>     - document.createAttibute\n>     - 创建属性节点\n>   - createTextNode\n>     - document.createTextNode\n>     - 创建文本节点\n> - 插入节点\n>   - appendChild\n>     - appendChild(所添加的新节点)\n>     - 向节点的子节点列表的末尾添加新的节点\n>   - insertBefore\n>     - insertBefore(所添加的新节点[已知子节点])\n>     - 在已知节点前插入一个新的节点\n> - 替换节点\n>   - replaceChild\n>     - replaceChild(要插入的新元素, 将被替换的老元素)\n>     - 将某个子节点替换成另一个\n> - 复制节点\n>   - cloneNode\n>     - 需要被赋值的节点.cloneNode(true/false)\n>     - 创建指定节点的副本\n>     - true : 复制当前节点以及所有的子节点\n>     - false : 仅复制当前节点\n> - 删除节点 : \n>   - removeChild(要删除的节点)\n>   - 删除指定的节点\n>     - 删除父节点的一个子节点 : document.getElementById(\"id1\").parentNode.removeNode(document.getElementById(\"id2\"))\n\n### 属性操作\n\n> - 获取属性: getAttribute([元素属性名])\n>   - 元素节点.getAttribute(元素属性名)\n>   - 获取元素节点指定的属性值\n> - 设置属性: setAttribute([属性名], [属性值])\n>   - 元素节点.setAttribute(属性名, 属性值)\n>   - 创建或改变元素节点的属性\n> - 删除属性: removeAttribute([属性名])\n>   - 元素节点.removeAttribute(属性名)\n>   - 删除元素中的指定属性\n\n### 文本操作\n\n> - insertData(offset, String)   :    从offset指定位置插入string\n>\n> - appedData(String)   :   将string插入到文本节点末尾处\n>\n> - deleteData(offset, count)  :    从offset起杀出count个字符\n> - replaceData(off, count, string)    :    从off将count个字符用string替代\n> - splitData(offset)   :   从offset起将文本节点分成两个节点\n> - substring(offset, count)    :   返回有offset 起的count个节点\n\n\n\n\n\n","children":[]},{"name":"event.md","path":"../guanruihua.github.io/JavaScript/对象","data":"## Event对象\n\n### event对象常见方法\n\n> 1. event.preventDefault(): 取消事件的默认动作\n> 2. event.stopoPropagation(): 阻止事件冒泡\n> 3. event.stopImmediatePropagation(): \n>    1. 阻止剩下的事件处理程序被执行,\t\n>    2. 如果一个元素绑定了三个事件, 其中有一个调用了该方法, 其他两个事件将不会被执行\n\n","children":[]},{"name":"Intl.md","path":"../guanruihua.github.io/JavaScript/对象","data":"待整理\r\n\r\n# Intl\r\n\r\n<https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Intl>\r\n\r\n> ECMAScript 国际化 API 的一个命名空间，它提供了精确的字符串对比、数字格式化，和日期时间格式化。\r\n> `Collator`，`NumberFormat` 和 `DateTimeFormat` 对象的构造函数是 Intl 对象的属性。本页文档内容包括了这些属性，以及国际化使用的构造器和其他语言的方法等常见的功能\r\n\r\n- locales 参数:\r\nlocales 参数必须是一个 BCP 47 语言标记的字符串，或者是一个包括多个语言标记的数组。如果 locales 参数未提供或者是 undefined，便会使用运行时默认的 locale。\r\n[BCP 47 语言标记](https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry)\r\n\r\n属性\r\nIntl.Collator\r\ncollators 的构造函数，用于启用对语言敏感的字符串比较的对象。\r\n\r\nIntl.DateTimeFormat\r\n用于启用语言敏感的日期和时间格式的对象的构造函数。\r\n\r\nIntl.ListFormat\r\nConstructor for objects that enable language-sensitive list formatting.\r\n\r\nIntl.NumberFormat\r\n用于启用语言敏感数字格式的对象的构造函数。\r\n\r\nIntl.PluralRules\r\n用于启用多种敏感格式和多种语言语言规则的对象的构造函数。\r\n\r\nIntl.RelativeTimeFormat\r\nConstructor for objects that enable language-sensitive relative time formatting.\r\n","children":[]},{"name":"Iterator.md","path":"../guanruihua.github.io/JavaScript/对象","data":"- ### Iterator\n\n  > 处理集合中的每个项是很常见的操作。JavaScript 提供了许多迭代集合的方法，从简单的for循环到map()和filter()。迭代器和生成器将迭代的概念直接带入核心语言，并提供了一种机制来自定义for...of循环的行为。\n\n如果对 MDN 这个描述理解不是很到位的话，可以看下接下来这个小示例：\n\n```\nlet authors = {\n    allAuthors: {\n        fiction: [\n            'Agatha Christie',\n            'J. K. Rowling',\n            'Dr. Seuss'\n        ],\n        scienceFiction: [\n            'Neal Stephenson',\n            'Arthur Clarke',\n            'Isaac Asimov',\n            'Robert Heinlein'\n        ],\n        fantasy: [\n            'J. R. R. Tolkien',\n            'J. K. Rowling',\n            'Terry Pratchett'\n        ]\n    }\n}\n```\n\n这个数据结构是汇总了所有作者，每个作者按创作性质进行了分类。如果我们想获取所有作者的名单，该怎么做呢？\n\n```\nfor (let author of authors) {\n    console.log(author)\n}\n```\n\n你发现这个遍历遇到了报错：Uncaught TypeError: authors is not iterable\n\n**1、基本语法**\n\nIterator 就是 ES6 中用来实现自定义遍历的接口，按照上述的示例，我们来实现下这个接口：\n\n```\nauthors[Symbol.iterator] = function() {\n    let allAuthors = this.allAuthors\n    let keys = Reflect.ownKeys(allAuthors)\n    let values = []\n    return {\n        next() {\n            if (!values.length) {\n                if (keys.length) {\n                    values = allAuthors[keys[0]]\n                    keys.shift()\n                }\n            }\n            return {\n                done: !values.length,\n                value: values.shift()\n            }\n        }\n    }\n}\n```\n\n这个代码在数据结构上部署了 Iterator 接口，我们就可以用 for...of 来遍历代码了：\n\n```\nfor (let value of authors) {\n    console.log( `${value}` )\n}\n```\n\n**2、可迭代协议和迭代器协议。**\n\n- 1. 迭代器协议\n\n这是两个概念：可迭代协议、迭代器协议。通俗的讲，迭代器协议要求符合以下条件：\n\n- 首先，它是一个对象\n- 其次，这个对象包含一个无参函数 next\n- 最后，next 返回一个对象，对象包含 done 和 value 属性。其中 done 表示遍历是否结束，value 返回当前遍历的值。\n- 1. 可迭代协议\n     可迭代协议允许 JavaScript 对象去定义或定制它们的迭代行为, 例如（定义）在一个 for..of 结构中什么值可以被循环（得到）。一些内置类型都是内置的可迭代类型并且有默认的迭代行为, 比如 Array or Map, 另一些类型则不是 (比如Object) 。\n\n为了变成可迭代对象， 一个对象必须实现 @@iterator 方法, 意思是这个对象（或者它原型链 prototype chain 上的某个对象）必须有一个名字是 Symbol.iterator 的属性。\n\n如果让一个对象是可遍历的，就要遵守可迭代协议，该协议要求对象要部署一个以 Symbol.iterator 为 key 的键值对，而 value 就是一个无参函数，这个函数返回的对象要遵守迭代器协议。\n\n**3、Generator**\n\n熟悉了 Generator 之后，发现它是天然满足可迭代协议的。上述的代码我们可以用 Generator 来实现：\n\n```\nauthors[Symbol.iterator] = function*() {\n    let allAuthors = this.allAuthors\n    let keys = Reflect.ownKeys(allAuthors)\n    let values = []\n    while (1) {\n        if (!values.length) {\n            if (keys.length) {\n                values = allAuthors[keys[0]]\n                keys.shift()\n                yield values.shift()\n            } else {\n                return false\n            }\n        } else {\n            yield values.shift()\n        }\n    }\n}\n```\n\n同一个场景，同一个数据结构，写法确实不同的，利用 Generator 就不再需要显示的写迭代协议了（next方法和包含 done、value 属性的返回对象）。","children":[]},{"name":"Object.md","path":"../guanruihua.github.io/JavaScript/对象","data":"# JavaScript中Object构造函数的方法\n\n## Object\n\n### 简洁属性表示法\n\n```js\nlet name = 'xx'\n  let age = 18\n  let obj = {\n      name,\n      age\n  }\n```\n\n### 属性名表达式\n\n```js\n  let s = 'school'\n  let obj = {\n      foo: 'bar',\n      [s]: 'xx'\n  }\n```\n\n## Object构造函数的方法\n\n### Object.assign()\n\n> 通过复制一个或多个对象来创建一个新的对象\n>\n> 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象\n\n```js\nconst target = { a: 1, b: 2 };\nconst source = { b: 4, c: 5 };\nconst returnedTarget = Object.assign(target, source);\nconsole.log(source); // { b: 4, c: 5 }; 原数据不变\nconsole.log(target);\n// expected output: Object { a: 1, b: 4, c: 5 }\nconsole.log(returnedTarget);\n// expected output: Object { a: 1, b: 4, c: 5 }\n```\n\n### Object.create()\n\n> 使用指定的原型对象和属性创建一个新对象。\n>\n> 创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。\n\n```js\nconst person = {\n  isHuman: false,\n  printIntroduction: function () {\n    console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);\n  }\n};\n\nconst me = Object.create(person);\n\nme.name = \"Matthew\"; // \"name\" is a property set on \"me\", but not on \"person\"\nme.isHuman = true; // inherited properties can be overwritten\n\nme.printIntroduction();\n// expected output: \"My name is Matthew. Am I human? true\"\n```\n\n### Object.defineProperty()\n\n> 给对象添加一个属性并指定该属性的配置。\n>\n> 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。\n>\n> 语法   Object.defineProperties(obj, props)   obj在其上定义或修改属性的对象。props要定义其可枚举属性或修改的属性描述符的对象。对象中存在的属性描述符主要有两种：数据描述符和访问器描述符（更多详情，请参阅Object.defineProperty()）。描述符具有以下键：configurabletrue 当且仅当该属性描述符的类型可以被改变并且该属性可以从对应对象中删除。 默认为 falseenumerabletrue 当且仅当在枚举相应对象上的属性时该属性显现。 默认为 falsevalue与属性关联的值。可以是任何有效的JavaScript值（数字，对象，函数等）。 默认为 undefined.writabletrue当且仅当与该属性相关联的值可以用assignment operator改变时。 默认为 falseget作为该属性的 getter 函数，如果没有 getter 则为undefined。函数返回值将被用作属性的值。 默认为 undefinedset作为属性的 setter 函数，如果没有 setter 则为undefined。函数将仅接受参数赋值给该属性的新值。 默认为 undefined返回值节 传递给函数的对象。\n>\n> 语法 Object.defineProperty(obj, prop, descriptor)      obj要在其上定义属性的对象。prop要定义或修改的属性的名称。descriptor将被定义或修改的属性描述符。返回值节    被传递给函数的对象。在ES6中，由于 Symbol类型的特殊性，用Symbol类型的值来做对象的key与常规的定义或修改不同，而Object.defineProperty 是定义key为Symbol的属性的方法之一。\n>\n> Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。\n\n```js\n\n```\n\n### Object.defineProperties()\n\n> 给对象添加多个属性并分别指定它们的配置。\n\n```js\nvar obj = {};\nObject.defineProperties(obj, {\n  'property1': {\n    value: true,\n    writable: true\n  },\n  'property2': {\n    value: 'Hello',\n    writable: false\n  }\n  // etc. etc.\n});\n```\n\n### Object.entries()\n\n> 返回给定对象自身可枚举属性的[key, value]数组。\n>\n> 返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）\n\n```js\nconst object1 = { foo: 'bar', baz: 42 };\nconsole.log(Object.entries(object1)[1]);\n// expected output: Array [\"baz\", 42]\n\nconst object2 = { 0: 'a', 1: 'b', 2: 'c' };\nconsole.log(Object.entries(object2)[2]);\n// expected output: Array [\"2\", \"c\"]\n\nconst result = Object.entries(object2).sort((a, b) => a - b);\nconsole.log(Object.entries(result)[1]);\n// expected output: Array [\"1\", Array [\"1\", \"b\"]]\n```\n\n### Object.freeze()\n\n> 冻结对象：其他代码不能删除或更改任何属性。\n>\n> 可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。\n\n```js\nconst object1 = {\n  property1: 42\n};\n\nconst object2 = Object.freeze(object1);\n\nobject2.property1 = 33;\n// Throws an error in strict mode\n\nconsole.log(object2.property1);\n// expected output: 42\n```\n\n### Object.is()\n\n> 比较两个值是否相同。所有 NaN 值都相等（这与==和===不同）。\n>\n> 判断两个值是否是相同的值\n\n```js\nObject.is('foo', 'foo');     // true\nObject.is(window, window);   // true\n\nObject.is('foo', 'bar');     // false\nObject.is([], []);           // false\n\nvar foo = { a: 1 };\nvar bar = { a: 1 };\nObject.is(foo, foo);         // true\nObject.is(foo, bar);         // false\n\nObject.is(null, null);       // true\n\n// 特例\nObject.is(0, -0);            // false\nObject.is(-0, -0);           // true\nObject.is(NaN, 0/0);         // true\n```\n\n### Object.isExtensible()\n\n> 判断对象是否可扩展。\n\n```js\n// 使用Object.freeze是冻结一个对象最方便的方法.\nvar frozen = { 1: 81 };\nObject.isFrozen(frozen) //=== false\nObject.freeze(frozen);\nObject.isFrozen(frozen) //=== true\n\n// 一个冻结对象也是一个密封对象.\nObject.isSealed(frozen) //=== true\n\n// 当然,更是一个不可扩展的对象.\nObject.isExtensible(frozen) //=== false\n在 ES5 中，如果参数不是一个对象类型，将抛出一个TypeError异常。在 ES2015 中，非对象参数将被视为一个冻结的普通对象，因此会返回true。\n\nObject.isFrozen(1);\n// TypeError: 1 is not an object (ES5 code)\n\nObject.isFrozen(1);\n// true                          (ES2015 code)\n```\n\n### Object.isFrozen()\n\n> 判断对象是否已经冻结。\n\n```js\n// 使用Object.freeze是冻结一个对象最方便的方法.\nvar frozen = { 1: 81 };\nObject.isFrozen(frozen) //=== false\nObject.freeze(frozen);\nObject.isFrozen(frozen) //=== true\n\n// 一个冻结对象也是一个密封对象.\nObject.isSealed(frozen) //=== true\n\n// 当然,更是一个不可扩展的对象.\nObject.isExtensible(frozen) //=== false\n在 ES5 中，如果参数不是一个对象类型，将抛出一个TypeError异常。在 ES2015 中，非对象参数将被视为一个冻结的普通对象，因此会返回true。\n\nObject.isFrozen(1);\n// TypeError: 1 is not an object (ES5 code)\n\nObject.isFrozen(1);\n// true                          (ES2015 code)\n```\n\n### Object.isSealed()\n\n> 判断对象是否已经密封。\n\n```js\n// 使用Object.freeze是冻结一个对象最方便的方法.\nvar frozen = { 1: 81 };\nObject.isFrozen(frozen) //=== false\nObject.freeze(frozen);\nObject.isFrozen(frozen) //=== true\n\n// 一个冻结对象也是一个密封对象.\nObject.isSealed(frozen) //=== true\n\n// 当然,更是一个不可扩展的对象.\nObject.isExtensible(frozen) //=== false\n在 ES5 中，如果参数不是一个对象类型，将抛出一个TypeError异常。在 ES2015 中，非对象参数将被视为一个冻结的普通对象，因此会返回true。\n\nObject.isFrozen(1);\n// TypeError: 1 is not an object (ES5 code)\n\nObject.isFrozen(1);\n// true                          (ES2015 code)\n```\n\n### Object.keys()\n\n> 返回一个包含所有给定对象自身可枚举属性名称的数组。\n>\n> 会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致 。\n\n```js\n// simple array\nvar arr = ['a', 'b', 'c'];\nconsole.log(Object.keys(arr)); // console: ['0', '1', '2']\n\n// array like object\nvar obj = { 0: 'a', 1: 'b', 2: 'c' };\nconsole.log(Object.keys(obj)); // console: ['0', '1', '2']\n\n// array like object with random key ordering\nvar anObj = { 100: 'a', 2: 'b', 7: 'c' };\nconsole.log(Object.keys(anObj)); // console: ['2', '7', '100']\n\n// getFoo is a property which isn't enumerable\nvar myObj = Object.create({}, {\n  getFoo: {\n    value: function () { return this.foo; }\n  } \n});\nmyObj.foo = 1;\nconsole.log(Object.keys(myObj)); // console: ['foo']\n```\n\n### Object.values()\n\n> 返回给定对象自身可枚举值的数组。\n>\n> 返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。\n\n```js\nvar obj = { foo: 'bar', baz: 42 };\nconsole.log(Object.values(obj)); // ['bar', 42]\n\n// array like object\nvar obj = { 0: 'a', 1: 'b', 2: 'c' };\nconsole.log(Object.values(obj)); // ['a', 'b', 'c']\n\n// array like object with random key ordering\n// when we use numeric keys, the value returned in a numerical order according to the keys\nvar an_obj = { 100: 'a', 2: 'b', 7: 'c' };\nconsole.log(Object.values(an_obj)); // ['b', 'c', 'a']\n\n// getFoo is property which isn't enumerable\nvar my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; } } });\nmy_obj.foo = 'bar';\nconsole.log(Object.values(my_obj)); // ['bar']\n\n// non-object argument will be coerced to an object\nconsole.log(Object.values('foo')); // ['f', 'o', 'o']\n```\n\n### Object.fromEntries()\n\n> 把键值对列表转换为一个对象。\n\n```js\n Map 转化为 Object\n通过 Object.fromEntries， 可以将 Map 转化为 Object:\n\nconst map = new Map([ ['foo', 'bar'], ['baz', 42] ]);\nconst obj = Object.fromEntries(map);\nconsole.log(obj); // { foo: \"bar\", baz: 42 }\n\nArray 转化为 Object\n通过 Object.fromEntries， 可以将 Array 转化为 Object:\n\nconst arr = [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ];\nconst obj = Object.fromEntries(arr);\nconsole.log(obj); // { 0: \"a\", 1: \"b\", 2: \"c\" }\n对象转换为Object\nObject.fromEntries 是 Object.entries() 的反转函数， 借用 array manipulation methods 可以转换对象，如下：\n\nconst object1 = { a: 1, b: 2, c: 3 };\n\nconst object2 = Object.fromEntries(\n  Object.entries(object1)\n  .map(([ key, val ]) => [ key, val * 2 ])\n);\n\nconsole.log(object2);\n// { a: 2, b: 4, c: 6 }\n```\n\n## 对象\n\n### 对象方法\n\n#### 创建对象的方法\n\n```js\n//1.字面量\nvar obj1 = {name: 'solo obj1'};\nobj1// { name: \"solo obj1\" }\n\n//2.new Object\nvar obj2 = new Object({name: 'solo obj2'})\nobj2// { name: \"solo obj2\" }\n\n//3.构造函数创建\nvar M = function(name){\n  this.name = name;\n}\nvar obj3 = new M('solo obj3');\nobj3// { name: \"solo obj3\" }\nM.prototype.constructor === M // true\nM.prototype === obj3.__proto__ // true\n//4.Object.create\nvar p = {name: 'p'};\nvar obj4 = Object.create(p);\nobj4// {}\nobj4.name // \"p\"\n```\n\n![](https://images.gitee.com/uploads/images/2020/0920/202923_e68d1728_7984151.png)\n\n#### Object.is()\n\n- 在 Es5 中，比较两个数是否相等，使用的是相等( == )和全等( === ),对两数进行比较。相等会自动转换数据类型(例如，布尔型数据类型在进行比较时，会转换为0或者1，NaN不等于NaN,)。\n\n```js\nObject.is(NaN,NaN); //true\nObject.is(+0,-0);  //false\n```\n\n#### Object.assign(obj1,obj2,obj3,..)\n\n- assign() 方法用于对象的合并\n- obj1 属于目标对象，后面的obj对象均为源对象。\n\n```js\nvar obj = {name:\"zhangsan\"}\nvar obj2 = {age:\"19\"}\n\nObject.assign(obj,obj2); // {name:\"zhangsan\",age:\"19\"}\n```\n\n- 当目标对象和源对象的属性名称出现冲突时，后面对象的属性会覆盖前面的对象的属性。\n\n```js\nvar obj = {name:\"zhangsan\"}\nvar obj2 = {name:\"lisi\"}\nObject.assign(obj,obj2) // {name: \"lisi\"}\n```\n\n1. 当assign()方法中，只有一个参数，object.assign()方法会返回参数对象。\n2. 当assign()方法中的参数不是对象，会先转换为对象，再返回该参数。\n3. 当assign()方法中，第一个参数为null、undefined时，因为不能转换为对象，便会报错。（只要null，undefined不是首个参数，就不会报错）\n\n*首个参数处理规则与其他的参数不同，除了首参，不能转换为对象的参数就会跳过。参数为数值、布尔型均会跳过。*\n\n#### Object.assign() -- 深拷贝、浅拷贝\n\n例子1：\n\n```js\nvar obj = {name:\"zhangsan\"}\nvar obj2 = Object.assign({},obj);\n\nconsole.log(obj) // {name:\"zhangsan\"}\nconsole.log(obj2) // {name:\"zhangsan\"}\n\nobj2.name = \"lisi\"; // {name:\"lisi\"}\nconsole.log(obj2.name) // \"lisi\"\nconsole.log(obj.name) // \"zhangsan\"\n```\n\n例子2：\n\n```js\nvar obj = {name:\"zhangsan\",info:{age:\"18\"}}\nvar obj2 = Object.assign({},obj);\n\nconsole.log(obj); // {name:\"zhangsan\",info:{age:\"18\"}}\nconsole.log(obj2); // {name:\"zhangsan\",info:{age:\"18\"}}\n\nobj2.info.age = \"19\"\n\nconsole.log(obj2.info.age); // \"19\"\nconsole.log(obj.info.age); // \"19\"\n```\n\n- 有以上两个例子得出。\n  - Object.assign()的第一层属性是属于深拷贝，第二层以上的属性则为浅拷贝。\n  - 第二层的会改变原数据\n\n# JavaScript中Object构造函数的方法\n\n## Object.assign()\n\n> Object构造函数的方法节\n>\n> Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。\n\n```js\nconst target = { a: 1, b: 2 };\nconst source = { b: 4, c: 5 };\nconst returnedTarget = Object.assign(target, source);\nconsole.log(target);\n// expected output: Object { a: 1, b: 4, c: 5 }\nconsole.log(returnedTarget);\n// expected output: Object { a: 1, b: 4, c: 5 }\n```\n\n## Object.create()\n\n> 通过复制一个或多个对象来创建一个新的对象。\n>\n> Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。\n\n```js\nconst person = {\n  isHuman: false,\n  printIntroduction: function () {\n    console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);\n  }\n};\nconst me = Object.create(person);\n\nme.name = \"Matthew\"; // \"name\" is a property set on \"me\", but not on \"person\"\nme.isHuman = true; // inherited properties can be overwritten\n\nme.printIntroduction();\n// expected output: \"My name is Matthew. Am I human? true\"\n```\n\n## Object.defineProperty()\n\n> 使用指定的原型对象和属性创建一个新对象。\n>\n> 语法   Object.defineProperties(obj, props)   obj在其上定义或修改属性的对象。\n>\n> Object.defineProperties() 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。\n>\n> props要定义其可枚举属性或修改的属性描述符的对象。\n>\n> 对象中存在的属性描述符主要有两种：\n>\n> - 数据描述符和访问器描述符（更多详情，请参阅Object.defineProperty()）。\n> - 描述符具有以下键：configurabletrue 当且仅当该属性描述符的类型可以被改变并且该属性可以从对应对象中删除。\n> - 默认为 falseenumerabletrue 当且仅当在枚举相应对象上的属性时该属性显现。\n> - 默认为 falsevalue与属性关联的值。可以是任何有效的JavaScript值（数字，对象，函数等）。\n> - 默认为 undefined.writabletrue当且仅当与该属性相关联的值可以用assignment operator改变时。\n> - 默认为 falseget作为该属性的 getter 函数，如果没有 getter 则为undefined。函数返回值将被用作属性的值。\n> - 默认为 undefinedset作为属性的 setter 函数，如果没有 setter 则为undefined。函数将仅接受参数赋值给该属性的新值。\n> - 默认为 undefined返回值节 传递给函数的对象。\n\n```js\nvar obj = {};\nObject.defineProperties(obj, {\n  'property1': {\n    value: true,\n    writable: true\n  },\n  'property2': {\n    value: 'Hello',\n    writable: false\n  }\n  // etc. etc.\n});\n```\n\n## Object.defineProperties()\n\n> 给对象添加一个属性并指定该属性的配置。\n>\n> Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。\n>\n> 语法 Object.defineProperty(obj, prop, descriptor)\n>\n> - obj要在其上定义属性的对象。\n>\n> - prop要定义或修改的属性的名称。\n>\n> - descriptor将被定义或修改的属性描述符。\n> - 返回值节    被传递给函数的对象。在ES6中，由于 Symbol类型的特殊性，用Symbol类型的值来做对象的key与常规的定义或修改不同，而Object.defineProperty 是定义key为Symbol的属性的方法之一。\n\n## Object.entries()\n\n> 给对象添加多个属性并分别指定它们的配置。\n>\n> Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）\n\n```js\nconst object1 = { foo: 'bar', baz: 42 };\nconsole.log(Object.entries(object1)[1]);\n// expected output: Array [\"baz\", 42]\n\nconst object2 = { 0: 'a', 1: 'b', 2: 'c' };\nconsole.log(Object.entries(object2)[2]);\n// expected output: Array [\"2\", \"c\"]\n\nconst result = Object.entries(object2).sort((a, b) => a - b);\nconsole.log(Object.entries(result)[1]);\n// expected output: Array [\"1\", Array [\"1\", \"b\"]]\n```\n\n## Object.freeze()\n\n> 返回给定对象自身可枚举属性的[key, value]数组。\n>\n> Object.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。\n\n```js\nconst object1 = {\n  property1: 42\n};\n\nconst object2 = Object.freeze(object1);\n\nobject2.property1 = 33;\n// Throws an error in strict mode\n\nconsole.log(object2.property1);\n// expected output: 42\n```\n\n## Object.is()\n\n> 冻结对象：其他代码不能删除或更改任何属性。\n>\n> Object.is() 方法判断两个值是否是相同的值\n\n```js\nObject.is('foo', 'foo');     // true\nObject.is(window, window);   // true\n\nObject.is('foo', 'bar');     // false\nObject.is([], []);           // false\n\nvar foo = { a: 1 };\nvar bar = { a: 1 };\nObject.is(foo, foo);         // true\nObject.is(foo, bar);         // false\n\nObject.is(null, null);       // true\n\n// 特例\nObject.is(0, -0);            // false\nObject.is(-0, -0);           // true\nObject.is(NaN, 0/0);         // true\n```\n\n## Object.isExtensible()\n\n>　比较两个值是否相同。所有 NaN 值都相等（这与==和===不同）。\n\n## Object.isFrozen()\n\n> 判断对象是否可扩展。\n>\n> Object.isFrozen()方法判断一个对象是否被冻结\n\n```js\n// 使用Object.freeze是冻结一个对象最方便的方法.\nvar frozen = { 1: 81 };\nObject.isFrozen(frozen) //=== false\nObject.freeze(frozen);\nObject.isFrozen(frozen) //=== true\n\n// 一个冻结对象也是一个密封对象.\nObject.isSealed(frozen) //=== true\n\n// 当然,更是一个不可扩展的对象.\nObject.isExtensible(frozen) //=== false\n在 ES5 中，如果参数不是一个对象类型，将抛出一个TypeError异常。在 ES2015 中，非对象参数将被视为一个冻结的普通对象，因此会返回true。\n\nObject.isFrozen(1);\n// TypeError: 1 is not an object (ES5 code)\n\nObject.isFrozen(1);\n// true                          (ES2015 code)\n```\n\n## Object.isSealed()\n\n> 判断对象是否已经冻结。\n\n## Object.keys()\n\n> 判断对象是否已经密封。\n>\n> Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致 。\n\n```js\n// simple array\nvar arr = ['a', 'b', 'c'];\nconsole.log(Object.keys(arr)); // console: ['0', '1', '2']\n\n// array like object\nvar obj = { 0: 'a', 1: 'b', 2: 'c' };\nconsole.log(Object.keys(obj)); // console: ['0', '1', '2']\n\n// array like object with random key ordering\nvar anObj = { 100: 'a', 2: 'b', 7: 'c' };\nconsole.log(Object.keys(anObj)); // console: ['2', '7', '100']\n\n// getFoo is a property which isn't enumerable\nvar myObj = Object.create({}, {\n  getFoo: {\n    value: function () { return this.foo; }\n  } \n});\nmyObj.foo = 1;\nconsole.log(Object.keys(myObj)); // console: ['foo']\n```\n\n## Object.values()\n\n> 返回一个包含所有给定对象自身可枚举属性名称的数组。\n>\n> Object.values()方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。\n\n```js\nvar obj = { foo: 'bar', baz: 42 };\nconsole.log(Object.values(obj)); // ['bar', 42]\n\n// array like object\nvar obj = { 0: 'a', 1: 'b', 2: 'c' };\nconsole.log(Object.values(obj)); // ['a', 'b', 'c']\n\n// array like object with random key ordering\n// when we use numeric keys, the value returned in a numerical order according to the keys\nvar an_obj = { 100: 'a', 2: 'b', 7: 'c' };\nconsole.log(Object.values(an_obj)); // ['b', 'c', 'a']\n\n// getFoo is property which isn't enumerable\nvar my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; } } });\nmy_obj.foo = 'bar';\nconsole.log(Object.values(my_obj)); // ['bar']\n\n// non-object argument will be coerced to an object\nconsole.log(Object.values('foo')); // ['f', 'o', 'o']\n```\n\n## Object.fromEntries()\n\n> 把键值对列表转换为一个对象。\n>\n> Map 转化为 Object\n> 通过 Object.fromEntries， 可以将 Map 转化为 Object:\n\n```js\nconst map = new Map([ ['foo', 'bar'], ['baz', 42] ]);\nconst obj = Object.fromEntries(map);\nconsole.log(obj); // { foo: \"bar\", baz: 42 }\n\nArray 转化为 Object\n通过 Object.fromEntries， 可以将 Array 转化为 Object:\n\nconst arr = [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ];\nconst obj = Object.fromEntries(arr);\nconsole.log(obj); // { 0: \"a\", 1: \"b\", 2: \"c\" }\n对象转换为Object\nObject.fromEntries 是 Object.entries() 的反转函数， 借用 array manipulation methods 可以转换对象，如下：\n\nconst object1 = { a: 1, b: 2, c: 3 };\n\nconst object2 = Object.fromEntries(\n  Object.entries(object1)\n  .map(([ key, val ]) => [ key, val * 2 ])\n);\n\nconsole.log(object2);\n// { a: 2, b: 4, c: 6 }\n\n\n```\n","children":[]},{"name":"promise","path":"../guanruihua.github.io/JavaScript/对象","data":"","children":[{"name":"Generator.md","path":"../guanruihua.github.io/JavaScript/对象/promise","data":"# Generator\n\nGenerators 是可以用来控制迭代器的函数。它们可以暂停，然后在任何时候恢复。如果这句话不好理解，可以看下接下来的示例。\n\n1. 常规循环\n\n   ```js\n   for (let i = 0; i < 5; i += 1) {\n    console.log(i)\n   }\n   // this will return immediately 0 -> 1 -> 2 -> 3 -> 4\n   ```\n\n2. 利用 Generator\n\n   ```js\n   function* generatorForLoop() {\n    for (let i = 0; i < 5; i += 1) {\n        yield console.log(i)\n    }\n   }\n   \n   const genForLoop = generatorForLoop()\n   \n   console.log(genForLoop.next()) // first console.log - 0\n   console.log(genForLoop.next()) // 1\n   console.log(genForLoop.next()) // 2\n   console.log(genForLoop.next()) // 3\n   console.log(genForLoop.next()) // 4\n   ```\n\n   对比下代码，常规的循环只能一次遍历完所有值，Generator 可以通过调用 next 方法拿到依次遍历的值，让遍历的执行变得“可控”。\n\n**1、基本语法**\n\n```js\nfunction* gen() {\n    yield 1\n    yield 2\n    yield 3\n}\n\nlet g = gen()\n// \"Generator { }\"\n```\n\n这个是 Generator 的定义方法，有几个点值得注意：\n\n- 比普通函数多一个 *\n- 函数内部用 yield 来控制程序的执行的“暂停”\n- 函数的返回值通过调用 next 来“恢复”程序执行\n\nGenerator 函数的定义不能使用箭头函数，否则会触发 SyntaxError 错误\n\n```js\nlet generator = * () => {} // SyntaxError\nlet generator = () * => {} // SyntaxError\nlet generator = ( * ) => {} // SyntaxError\n```\n\n**2、yield 表达式**\nyield 关键字用来暂停和恢复一个生成器函数\n\n- yield 表达式的返回值是 undefined，但是遍历器对象的 next 方法可以修改这个默认值。\n\n- Generator 对象的 next 方法，遇到 yield 就暂停，并返回一个对象，这个对象包括两个属性：value 和 done。\n\n  ```js\n   function* gen() {\n      let val\n      val = yield 1\n      console.log( `1:${val}` ) // 1:undefined\n      val = yield 2\n      console.log( `2:${val}` ) // 2:undefined\n      val = yield 3\n      console.log( `3:${val}` ) // 3:undefined\n  }\n  \n  var g = gen()\n  \n  console.log(g.next()) // {value: 1, done: false}\n  console.log(g.next()) // {value: 2, done: false}\n  console.log(g.next()) // {value: 3, done: false}\n  console.log(g.next()) // {value: undefined, done: true}\n  ```\n\n  **3、方法**\n\nGenerator 对象有几个方法，next、return、throw。\n\n- next([value])\n  Generator 对象通过 next 方法来获取每一次遍历的结果，这个方法返回一个对象，这个对象包含两个属性：value 和 done。value 是指当前程序的运行结果，done 表示遍历是否结束。\n\n其实 next 是可以接受参数的，这个参数可以让你在 Generator 外部给内部传递数据，而这个参数就是作为 yield 的返回值。\n\n```js\nfunction* gen() {\n      var val = 100\n      while (true) {\n          console.log( `before ${val}` )\n          val = yield val\n          console.log( `return ${val}` )\n      }\n  }\n\n  var g = gen()\n  console.log(g.next(20).value)\n  // before 100\n  // 100\n  console.log(g.next(30).value)\n  // return 30\n  // before 30\n  // 30\n  console.log(g.next(40).value)\n  // return 40\n  // before 40\n  // 40\n```\n\n- return()\n  return 方法可以让 Generator 遍历终止，有点类似 for 循环的 break。\n\n  ```js\n  function* gen() {\n  yield 1\n  yield 2\n  yield 3\n  }\n  \n  var g = gen()\n  \n  console.log(g.next()) // {value: 1, done: false}\n  console.log(g.return()) // {value: undefined, done: true}\n  console.log(g.next()) // {value: undefined, done: true}\n  ```\n\n- throw()\n  可以通过 throw 方法在 Generator 外部控制内部执行的“终断”。\n\n  ```js\n  function* gen() {\n    while (true) {\n        try {\n            yield 42\n        } catch (e) {\n            console.log(e.message)\n        }\n    }\n  }\n  \n  let g = gen()\n  console.log(g.next()) // { value: 42, done: false }\n  console.log(g.next()) // { value: 42, done: false }\n  console.log(g.next()) // { value: 42, done: false }\n  // 中断操作\n  g.throw(new Error('break'))\n  \n  console.log(g.next()) // {value: undefined, done: true}\n  ```","children":[]},{"name":"promise_async_await.md","path":"../guanruihua.github.io/JavaScript/对象/promise","data":"# Promise async await\n\n## Promise\n\n> - 特点\n>   - 链式调用\n>\n> （1）对象的状态不受外界影响。\n>\n> ​ `Promise`对象代表一个异步操作，有三种状态：`Pending`（进行中）、`Resolved`（已完成，又称Fulfilled）和`Rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是`Promise`这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。\n>\n> （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。\n>\n> ​ `Promise`对象的状态改变，只有两种可能：从`Pending`变为`Resolved`和从`Pending`变为`Rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对`Promise`对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n>\n> 有了`Promise`对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，`Promise`对象提供统一的接口，使得控制异步操作更加容易。\n>\n> ​ `Promise`也有一些缺点。首先，无法取消`Promise`，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部。第三，当处于`Pending`状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\n>\n> 如果某些事件不断地反复发生，一般来说，使用stream模式是比部署`Promise`更好的选择。\n\n```js\nvar promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n\n### Promise.prototype.then()\n\n> - then方法返回的是一个新的Promise实例\n> - 第一个回调函数,会将返回结果作为参数,传入第二个回调函数\n\n```js\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\n\n### Promise.prototype.catch()\n\n> `Promise.prototype.catch`方法是`.then(null, rejection)`的别名，用于指定发生错误时的回调函数。\n\n### Promise.all()\n\n> 将多个Promise实例,包装成一个新的Promise实例\n>\n> ```js\n> var p = Promise.all([p1, p2, p3]);\n> \n> /*\n> （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，\n>   此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。\n> （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，\n>   此时第一个被reject的实例的返回值，会传递给p的回\n> 调函数。\n> */\n> \n> let p1 = new Promise((resolve, reject) => {\n>   resolve(11);\n> })\n> let p2 = new Promise(((resolve, reject) => {\n>   resolve(12);\n> }))\n> \n> let p3 = new Promise(((resolve, reject) => {\n>   resolve(13);\n> }))\n> \n> let p = Promise.all([p1, p2, p3]);\n> p.then(res => {\n>   console.log('then', res);\n> }).catch(res => {\n>   console.log(\"catch\", res)\n> });\n> // 打印\n> then [11, 12, 13]\n> ```\n>\n> ```js\n> let p1 = new Promise((resolve, reject) => {\n>   resolve(11);\n> })\n> let p2 = new Promise(((resolve, reject) => {\n>   resolve(12);\n> }))\n> \n> let p3 = new Promise(((resolve, reject) => {\n>   reject(33)\n> }))\n> \n> let p = Promise.all([p1, p2, p3]);\n> p.then(res => {\n>   console.log('then', res);\n> }).catch(res => {\n>   console.log(\"catch\", res)\n> });\n> // 打印\n> catch 33\n> \n> ```\n\n### Promise.race()\n\n> 就是通过竞赛来比较, 看谁的转态先发生改变\n>\n> ```js\n> var p = Promise.race([p1, p2, p3]);\n> /*\n>  p1, p2, p3 中有一个实例率先改变状态,p就会跟着改变,先改变的Promise实例的返回值,就返回给p的回调函数\n> */\n> ```\n>\n>\n\n### Promise.resolve()\n\n> 将现有对象转换为Promise对象\n>\n> `var jsPromise = Promise.resolve($.ajax('/whatever.json'));`\n> 是一个状态为`fulfilled`的Promise实例\n>\n> - 不会触发catch， 可以正常出发then\n> - 若是该方法触发`throw new Error('error')`, 可以将状态修改为`rejected`\n\n### Promise.reject()\n\n```js\nvar p = Promise.reject('出错了');\n// 等同于\nvar p = new Promise((resolve, reject) => reject('出错了'))\n\np.then(null, function (s){\n  console.log(s)\n});\n// 出错了\n```\n\n### done()\n\n> Promise对象的回调链，不管以`then`方法或`catch`方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个`done`方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。\n\n```js\nasyncFunc()\n  .then(f1)\n  .catch(r1)\n  .then(f2)\n  .done();\n```\n\n### finally()\n\n>不管状态,都一定会执行\n\n```js\nserver.listen(0)\n  .then(function () {\n    // run test\n  })\n  .finally(server.stop);\n```\n\n### Promise.try()\n\n```js\nPromise.try(database.users.get({id: userId}))\n  .then(...)\n  .catch(...)\n```\n\n### 例子\n\n#### promise, then , catch\n\n```js\nfunction demo() {\n let pr = new Promise((resolve, reject) => {\n    // 1. 这里使用setTimeout模拟异步, 可以证明promise里面还是同步执行的, 这里还是触发了 reject\n    // 2. promise是通过resolve或reject传递数据给下一层\n    // 3. then 是通过 return传输给下一层\n  let flag = false;\n  setTimeout(() => {\n   flag = true;\n  }, 500);\n  if (flag)\n   resolve(\"true\")\n  else\n   reject(\"false\")\n });\n return pr.then(res => {\n  return \"then return data\"\n }).catch(res => {\n  console.log('catch data', res);\n  return \"data\"// catch 使用return 也可以返回数据\n });\n}\n\ndemo().then(res => {\n console.log(\"show data \", res)\n})\n// 输出\ncatch data false\nshow data data\n// flag　改为 true\nshow data then return data\n```\n\n#### Promise对象实现Ajax操作的例子\n\n```js\nvar getJSON = function(url) {\n  var promise = new Promise(function(resolve, reject){\n    var client = new XMLHttpRequest();\n    client.open(\"GET\", url);\n    client.onreadystatechange = handler;\n    client.responseType = \"json\";\n    client.setRequestHeader(\"Accept\", \"application/json\");\n    client.send();\n\n    function handler() {\n      if (this.readyState !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n  });\n\n  return promise;\n};\n\ngetJSON(\"/posts.json\").then(function(json) {\n  console.log('Contents: ' + json);\n}, function(error) {\n  console.error('出错了', error);\n});\n```\n\n## async, await\n\n> 异步\n\n```javascript\nasync function main() {\n  try {\n    var val1 = await firstStep();\n    var val2 = await secondStep(val1);\n    var val3 = await thirdStep(val1, val2);\n\n    console.log('Final: ', val3);\n  }\n  catch (err) {\n    console.error(err);\n  }\n}\n```\n\n### Promise\n\n**1、基本语法**\n\n> Promise 就是为了解决“回调地狱”问题的，它可以将异步操作的处理变得很优雅。回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象promise可以支持多个并发的请求，获取并发请求中的数据这个promise可以解决异步的问题，本身不能说promise是异步的。\n\n创建Promise实例。\n\n```\nconst promise = new Promise(function(resolve, reject) {\n    // ... some code\n\n    if ( /* 异步操作成功 */ ) {\n        resolve(value)\n    } else {\n        reject(error)\n    }\n})\n```\n\nPromise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n\n- 处理结果正常的话，调用resolve(处理结果值)，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去\n\n- 处理结果错误的话，调用reject(Error对象)，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n  Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。\n\n  ```\n  promise.then(function(value) {\n    // success\n  }, function(error) {\n    // failure\n  })\n  ```\n\n  Promise 内部是有状态的(pending、fulfilled、rejected)，Promise 对象根据状态来确定执行哪个方法。Promise 在实例化的时候状态是默认 pending 的，当异步操作是完成的，状态会被修改为 fulfilled，如果异步操作遇到异常，状态会被修改为 rejected。\n\n**2、Promise.prototype.then()**\n\n```\nvar promise = new Promise(function(resolve, reject) {\n    resolve('传递给then的值')\n})\npromise.then(function(value) {\n    console.log(value)\n}, function(error) {\n    console.error(error)\n})\n```\n\n- 当 handler 返回一个正常值的时候，这个值会传递给 Promise 对象的 onFulfilled 方法。\n- 定义的 handler 中产生异常的时候，这个值则会传递给 Promise 对象的 onRejected 方法。\n\n**3、Promise.prototype.catch()**\n\n捕获异常是程序质量保障最基本的要求，可以使用 Promise 对象的 catch 方法来捕获异步操作过程中出现的任何异常\n\n```\nfunction test() {\n    return new Promise((resolve, reject) => {\n        reject(new Error('es'))\n    })\n}\n\ntest().catch((e) => {\n    console.log(e.message) // es\n})\n```\n\n**4、Promise.resolve()**\n\n一般情况下我们都会使用 new Promise() 来创建 Promise 对象，但是除此之外我们也可以使用其他方法。\n\n在这里，我们将会学习如何使用 Promise.resolve 和 Promise.reject 这两个方法。\n\n静态方法 Promise.resolve(value) 可以认为是 new Promise() 方法的快捷方式。\n\n比如 Promise.resolve(42) 可以认为是以下代码的语法糖。\n\n```\nnew Promise(function(resolve) {\n    resolve(42)\n})\n```\n\n方法 Promise.resolve(value) 的返回值也是一个 Promise 对象，所以我们可以像下面那样接着对其返回值进行 .then 调用。\n\n```\nPromise.resolve(42).then(function(value) {\n    console.log(value)\n})\n```\n\n**5、Promise.reject()**\n\nPromise.reject(error) 是和 Promise.resolve(value) 类似的静态方法，是 new Promise() 方法的快捷方式。\n\n比如 Promise.reject(new Error(\"出错了\")) 就是下面代码的语法糖形式。\n\n```\nnew Promise(function(resolve, reject) {\n    reject(new Error('出错了'))\n})\n```\n\n这段代码的功能是调用该Promise 对象通过then指定的 onRejected 函数，并将错误（Error）对象传递给这个 onRejected 函数。\n\n```\nPromise.reject(new Error('BOOM!'))\n```\n\n**6、Promise.all()**\n\n```\nvar p1 = Promise.resolve(1)\nvar p2 = Promise.resolve(2)\nvar p3 = Promise.resolve(3)\nPromise.all([p1, p2, p3]).then(function(results) {\n    console.log(results) // [1, 2, 3]\n})\n```\n\nPromise.all 生成并返回一个新的 Promise 对象，所以它可以使用 Promise 实例的所有方法。参数传递promise数组中所有的 Promise 对象都变为resolve的时候，该方法才会返回， 新创建的 Promise 则会使用这些 promise 的值。\n\n如果参数中的任何一个promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的 Promise 对象。\n\n由于参数数组中的每个元素都是由 Promise.resolve 包装（wrap）的，所以Promise.all 可以处理不同类型的 Promise 对象。\n\n**7、Promise.race()**\n\n```\nvar p1 = Promise.resolve(1)\nvar p2 = Promise.resolve(2)\nvar p3 = Promise.resolve(3)\nPromise.race([p1, p2, p3]).then(function(value) {\n    console.log(value) // 1\n})\n```\n\nPromise.race 生成并返回一个新的 Promise 对象。\n\n参数 promise 数组中的任何一个 Promise 对象如果变为 resolve 或者 reject 的话， 该函数就会返回，并使用这个 Promise 对象的值进行 resolve 或者 reject。\n","children":[]},{"name":"promise原理模拟.md","path":"../guanruihua.github.io/JavaScript/对象/promise","data":"\n\n# Promise原理模拟\n\n## 核心逻辑分析\n\n1. Promise 就是一个类 在执行这个类的时候 需要传递一个执行器进去 执行器会立即执行\n2. Promise 中有三种状态 分别为 成功 fulfilled 失败 rejected 等待 pending\n   - pending -> fulfilled\n   - pending -> rejected\n   - 一旦状态确定就不可更改`\n3. resolve和reject函数是用来更改状态的\n   - resolve: fulfilled\n   - reject: rejected\n4. then方法内部做的事情就判断状态 如果状态是成功 调用成功的回调函数 如果状态是失败 调用失败回调函数 then方法是被定义在原型对象中的\n5. then成功回调有一个参数 表示成功之后的值 then失败回调有一个参数 表示失败后的原因\n6. 同一个promise对象下面的then方法是可以被调用多次的\n7. then方法是可以被链式调用的, 后面then方法的回调函数拿到值的是上一个then方法的回调函数的返回值\n\n```js\nconst PENDING = 'pending'; // 等待\nconst FULFILLED = 'fulfilled'; // 成功\nconst REJECTED = 'rejected'; // 失败\n\nclass MyPromise {\n    constructor(executor) {\n        executor(this.resolve, this.reject); \n    }\n\n    status = PENDING; // 状态\n    value = undefined; // then函数成功回调需要的参数\n    reason = undefined; // then函数失败回调需要的参数\n\n    resolve = value => {\n        // 如果状态不是等待 阻止程序向下执行\n        if(this.status !== PENDING) return;\n        // 将状态更改为成功\n        this.status = FULFILLED;\n        // 保存成功之后的值\n        this.value = value;\n    }\n\n    reject = reason => {\n        // 如果状态不是等待 阻止程序向下执行\n        if(this.status !== PENDING) return;\n        // 将状态更改为失败\n        this.status = REJECTED;\n        // 保存失败后的原因\n        this.reason = reason;\n    }\n\n    then = (successCallback, failCallback) => {\n        // 判断状态\n        if(this.status === FULFILLED) {\n            successCallback(this.value);\n        } else if(this.status === REJECTED) {\n            failCallback(this.reason);\n        }\n    }\n}\n\nmodule.exports = MyPromise;\n```\n\n## 异步调用解决\n\n### 1. 场景\n\n```js\nconst promise = new MyPromise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('成功');\n    }, 2000);\n});\npromise.then(value => {\n    console.log(value);\n}, reason => {\n    console.log(reason);\n});\n```\n\n### 2. 实现步骤分析\n\n- 定时器中回调函数为异步执行代码\n- then函数执行时状态还是pending\n- 即then函数中需要增加状态为pending时的执行逻辑，将成功和失败的回调存储起来在相应的resolve和reject函数中调用\n\n### 3. 代码实现\n\n```js\nclass MyPromise {\n    ...\n    successCallback = undefined; // 成功回调\n    failCallback = undefined; // 失败回调\n\n    resolve = value => {\n        ...\n        // 成功回调存在则调用\n        this.successCallback && this.successCallback(value);\n    }\n\n    reject = reason => {\n        ...\n        // 失败回调存在则调用\n        this.failCallback && this.failCallback(reason);\n    }\n\n    then = (successCallback, failCallback) => {\n        // 判断状态\n        if(this.status === FULFILLED) {\n            ...\n        } else {\n            // 等待\n            // 将成功和失败回调存储起来\n            this.successCallback = successCallback;\n            this.failCallback = failCallback;\n        }\n    }\n}\n\n```\n\n## then的多次调用\n\n### 1. 场景\n\n```js\npromise.then(value => {\n    console.log(value);\n});\npromise.then(value => {\n    console.log(value);\n});\npromise.then(value => {\n    console.log(value);\n});\n\n```\n\n### 2. 实现步骤分析\n\n- then多次调用同步代码不需要做特殊处理，而异步的是需要特殊处理的\n- 即在then多次调用时，将每次调用的回调都存储起来\n- 当状态变成成功或失败时，再依次去执行存储起来的回调\n\n### 3. 代码实现\n\n```js\nclass MyPromise {\n    ...\n    successCallback = []; // 成功回调\n    failCallback = []; // 失败回调\n\n    resolve = value => {\n        ...\n        // 成功回调存在则调用\n        // this.successCallback && this.successCallback(value);\n        while (this.successCallback.length) this.successCallback.shift()(this.value)\n    }\n\n    reject = reason => {\n        ...\n        // 失败回调存在则调用\n        // this.failCallback && this.failCallback(reason);\n        while (this.failCallback.length) this.failCallback.shift()(this.reason)\n    }\n\n    then = (successCallback, failCallback) => {\n        // 判断状态\n        if(this.status === FULFILLED) {\n            ...\n        } else {\n            // 等待\n            // 将成功和失败回调存储起来\n            this.successCallback.push(successCallback);\n            this.failCallback.push(failCallback);\n        }\n    }\n}\n\n```\n\n## then的链式调用\n\n### 1. 场景\n\n```js\npromise.then(value => {\n    console.log(value);\n    return 100;\n}).then(value => {\n    console.log(value);\n}).then(value => {\n    console.log(value);\n});\n\n```\n\n### 2. 实现步骤分析\n\n- then方法的链式调用必须每一个then方法都返回一个Promise对象\n- 把上一个then方法的返回值（需要判断这个返回值是不是Promise对象）传递给下一个then方法\n\n### 3. 代码实现\n\n```js\nclass MyPromise {\n    ...\n    then = (successCallback, failCallback) => {\n        const promise2 = new MyPromise((resolve, reject) => {\n            // 判断状态\n            if (this.status === FULFILLED) {\n                const x = successCallback(this.value);\n                // 判断x的值是普通值还是Promise对象\n                // 如果是普通值，直接调用resolve传参\n                // 如果是Promise对象 则查看promise对象返回的结果\n                // 再根据promise对象返回的结果 决定调用resolve 还是调用reject\n                resolvePromise(x, resolve, reject);\n            } else if (this.status === REJECTED) {\n                failCallback(this.reason);\n            } else {\n                // 等待\n                // 将成功和失败回调存储起来\n                this.successCallback.push(successCallback);\n                this.failCallback.push(failCallback);\n            }\n        });\n\n        return promise2;\n    }\n}\nfunction resolvePromise(x, resolve, reject) {\n    if(x instanceof MyPromise) {\n        // promise 对象\n        // x.then(value => resolve(value), reason => reject(reason));\n        x.then(resolve, reject);\n    } else {\n        // 普通值\n        resolve(x);\n    }\n}\n\n```\n\n## 链式调用then不能传当前promise\n\n### 1. 场景\n\n```js\nlet p1 = promise.then(value => {\n    console.log(value);\n    return p1;\n})\n\n```\n\n### 2. 实现步骤分析\n\n- 在then方法当中不能返回当前这个then方法所返回的Promise对象\n\n### 3. 代码实现\n\n```js\nclass MyPromise {\n    ...\n    then = (successCallback, failCallback) => {\n        const promise2 = new MyPromise((resolve, reject) => {\n            // 判断状态\n            if (this.status === FULFILLED) {\n                setTimeout(() => {\n                    const x = successCallback(this.value);\n                    // 判断x的值是普通值还是Promise对象\n                    // 如果是普通值，直接调用resolve传参\n                    // 如果是Promise对象 则查看promise对象返回的结果\n                    // 再根据promise对象返回的结果 决定调用resolve 还是调用reject\n                    // 由于此处拿不到当前new出来返回的promise2对象，所以需要改为异步调用，包一层setTimeout\n                    resolvePromise(promise2, x, resolve, reject);\n                }, 0);\n            } else if (this.status === REJECTED) {\n                ...\n            } else {\n                ...\n            }\n        });\n\n        return promise2;\n    }\n}\nfunction resolvePromise(promise2, x, resolve, reject) {\n    if(promise2 === x) {\n        return reject(new TypeError(\"Chaining cycle detected for promise #<Promise>\"));\n    }\n    ...\n}\n\n```\n\n## 异常处理\n\n### 1. 场景\n\n> 为了代码的健壮性，要在相应的位置进行适当的错误处理\n\n### 2. 实现步骤分析\n\n- 构造函数调用执行器时\n- 成功或失败回调执行错误时调用下一个promise的reject方法把错误信息传递下去\n\n### 3. 代码实现\n\n```js\nclass MyPromise {\n    constructor(executor) {\n        try {\n            executor(this.resolve, this.reject);\n        } catch (e) {\n            this.reject(e);\n        }\n    }\n    ...\n    resolve = value => {\n        ...\n        while (this.successCallback.length) this.successCallback.shift()();\n    }\n\n    reject = reason => {\n        ...\n        while (this.failCallback.length) this.failCallback.shift()();\n    }\n    then = (successCallback, failCallback) => {\n        const promise2 = new MyPromise((resolve, reject) => {\n            // 判断状态\n            if (this.status === FULFILLED) {\n                setTimeout(() => {\n                    try {\n                        const x = successCallback(this.value);\n                        // 判断x的值是普通值还是Promise对象\n                        // 如果是普通值，直接调用resolve传参\n                        // 如果是Promise对象 则查看promise对象返回的结果\n                        // 再根据promise对象返回的结果 决定调用resolve 还是调用reject\n                        // 由于此处拿不到当前new出来返回的promise2对象，所以改为异步调用，包一层setTimeout\n                        resolvePromise(promise2, x, resolve, reject);\n                    } catch (e) {\n                        // 如果发生错误手动调用下一个promise的reject方法\n                        reject(e);\n                    }\n                }, 0);\n            } else if (this.status === REJECTED) {\n                setTimeout(() => {\n                    try {\n                        const x = failCallback(this.reason);;\n                        // 判断x的值是普通值还是Promise对象\n                        // 如果是普通值，直接调用resolve传参\n                        // 如果是Promise对象 则查看promise对象返回的结果\n                        // 再根据promise对象返回的结果 决定调用resolve 还是调用reject\n                        // 由于此处拿不到当前new出来返回的promise2对象，所以改为异步调用，包一层setTimeout\n                        resolvePromise(promise2, x, resolve, reject);\n                    } catch (e) {\n                        // 如果发生错误手动调用下一个promise的reject方法\n                        reject(e);\n                    }\n                }, 0);\n            } else {\n                // 等待\n                // 将成功和失败回调存储起来\n                this.successCallback.push(() => {\n                    setTimeout(() => {\n                        try {\n                            const x = successCallback(this.value);\n                            // 判断x的值是普通值还是Promise对象\n                            // 如果是普通值，直接调用resolve传参\n                            // 如果是Promise对象 则查看promise对象返回的结果\n                            // 再根据promise对象返回的结果 决定调用resolve 还是调用reject\n                            // 由于此处拿不到当前new出来返回的promise2对象，所以改为异步调用，包一层setTimeout\n                            resolvePromise(promise2, x, resolve, reject);\n                        } catch (e) {\n                            // 如果发生错误手动调用下一个promise的reject方法\n                            reject(e);\n                        }\n                    }, 0);\n                });\n                this.failCallback.push(() => {\n                    setTimeout(() => {\n                        try {\n                            const x = failCallback(this.reason);;\n                            // 判断x的值是普通值还是Promise对象\n                            // 如果是普通值，直接调用resolve传参\n                            // 如果是Promise对象 则查看promise对象返回的结果\n                            // 再根据promise对象返回的结果 决定调用resolve 还是调用reject\n                            // 由于此处拿不到当前new出来返回的promise2对象，所以需要改为异步调用，包一层setTimeout\n                            resolvePromise(promise2, x, resolve, reject);\n                        } catch (e) {\n                            // 如果发生错误手动调用下一个promise的reject方法\n                            reject(e);\n                        }\n                    }, 0);\n                });\n            }\n        });\n\n        return promise2;\n    }\n}\n\n```\n\n## then方法参数变为可选参数\n\n### 1. 场景\n\n```js\nconst promise = new MyPromise((resolve, reject) => {\n    resolve(100);\n});\npromise.then().then().then(value => console.log(value), reason => console.log(reason));\n\n```\n\n### 2. 实现步骤分析\n\n- then方法的参数都是可选参数\n- 如果什么都传入的话就是将值传递下去，相当于传递一个函数**value=>value**\n- 所以在then函数中进行相应的参数判断即可\n\n### 3. 代码实现\n\n```js\nclass MyPromise {\n    ...\n    then = (successCallback, failCallback) => {\n        successCallback = successCallback ? successCallback : value => value;\n        failCallback = failCallback ? failCallback : reason => { throw reason; };\n        ...\n    }\n}\n\n```\n\n## 静态方法all\n\n### 1. 场景\n\n```js\nfunction p1 () {\n  return new MyPromise(function (resolve, reject) {\n    setTimeout(function () {\n      resolve('p1')\n    }, 2000)\n  })\n}\nfunction p2 () {\n  return new MyPromise(function (resolve, reject) {\n    reject('失败')\n    // resolve('成功');  \n  })\n}\nMyPromise.all(['a', 'b', p1(), p2(), 'c']).then(result => {\n  // result -> ['a', 'b', 'p1', 'p2', 'c']\n})\n\n```\n\n### 2. 实现步骤分析\n\n- 按照传入数组的顺序，执行后返回相应顺序的执行结果\n- all方法返回的也是一个Promise对象，可以继续链式调用then\n- all方法传入的数组中有一个执行的结果是失败的则执行的结果为失败\n\n### 3. 代码实现\n\n```js\nstatic all (array) {\n    let result = [];\n    let index = 0;\n    return new MyPromise((resolve, reject) => {\n      function addData (key, value) {\n        result[key] = value;\n        index++;\n        if (index === array.length) {\n          resolve(result);\n        }\n      }\n      for (let i = 0; i < array.length; i++) {\n        let current = array[i];\n        if (current instanceof MyPromise) {\n          // promise 对象\n          current.then(value => addData(i, value), reason => reject(reason))\n        }else {\n          // 普通值\n          addData(i, array[i]);\n        }\n      }\n    })\n}\n\n```\n\n## 静态方法resolve\n\n### 1. 场景\n\n```js\nMyPromise.resolve(100).then(value => console.log(value)); // 100\n\n```\n\n### 2. 实现步骤分析\n\n- 将给定的值转化为一个Promise对象，即返回的就是一个Promise对象\n\n### 3. 代码实现\n\n```js\nstatic resolve (value) {\n    if (value instanceof MyPromise) return value;\n    return new MyPromise(resolve => resolve(value));\n}\n\n```\n\n## 原型方法finally\n\n### 1. 场景\n\n \n\n### 2. 实现步骤分析\n\n- 无论当前的promise对象最终的状态是成功还是失败，finally方法的回调都会执行\n- 在finally方法后面可以继续的链式调用then方法拿到当前promise对象最终返回的结果\n\n### 3. 代码实现\n\n```js\nfinally (callback) {\n    return this.then(value => {\n        return MyPromise.resolve(callback()).then(() => value);\n    }, reason => {\n        return MyPromise.resolve(callback()).then(() => { throw reason })\n    })\n}\n```\n\n## 十、原型方法catch\n\n### 1. 场景\n\n```js\nfunction p1 () {\n    return new Promise(function (resolve, reject) {\n        reject('hello');\n    })\n}\np1()\n    .then(value => console.log(value))\n    .catch(reason => console.log(reason))\n\n```\n\n### 2. 实现步骤分析\n\n- 用来处理当前的promise对象最终的状态为失败的情况的\n- 当前的then方法是可以不传递失败回调的，可以在后面链式调用catch即可捕获到失败信息\n\n### 3. 代码实现\n\n```js\ncatch (failCallback) {\n    return this.then(undefined, failCallback)\n}\n```\n\n```js\n// 附上完整代码\nconst PENDING = 'pending'; // 等待\nconst FULFILLED = 'fulfilled'; // 成功\nconst REJECTED = 'rejected'; // 失败\n\nclass MyPromise {\n  constructor (executor) {\n    try {\n      executor(this.resolve, this.reject)\n    } catch (e) {\n      this.reject(e);\n    }\n  }\n  // promsie 状态 \n  status = PENDING;\n  // 成功之后的值\n  value = undefined;\n  // 失败后的原因\n  reason = undefined;\n  // 成功回调\n  successCallback = [];\n  // 失败回调\n  failCallback = [];\n\n  resolve = value => {\n    // 如果状态不是等待 阻止程序向下执行\n    if (this.status !== PENDING) return;\n    // 将状态更改为成功\n    this.status = FULFILLED;\n    // 保存成功之后的值\n    this.value = value;\n    // 判断成功回调是否存在 如果存在 调用\n    // this.successCallback && this.successCallback(this.value);\n    while(this.successCallback.length) this.successCallback.shift()()\n  }\n  reject = reason => {\n    // 如果状态不是等待 阻止程序向下执行\n    if (this.status !== PENDING) return;\n    // 将状态更改为失败\n    this.status = REJECTED;\n    // 保存失败后的原因\n    this.reason = reason;\n    // 判断失败回调是否存在 如果存在 调用\n    // this.failCallback && this.failCallback(this.reason);\n    while(this.failCallback.length) this.failCallback.shift()()\n  }\n  then (successCallback, failCallback) {\n    // 参数可选\n    successCallback = successCallback ? successCallback : value => value;\n    // 参数可选\n    failCallback = failCallback ? failCallback: reason => { throw reason };\n    let promsie2 = new MyPromise((resolve, reject) => {\n      // 判断状态\n      if (this.status === FULFILLED) {\n        setTimeout(() => {\n          try {\n            let x = successCallback(this.value);\n            // 判断 x 的值是普通值还是promise对象\n            // 如果是普通值 直接调用resolve \n            // 如果是promise对象 查看promsie对象返回的结果 \n            // 再根据promise对象返回的结果 决定调用resolve 还是调用reject\n            resolvePromise(promsie2, x, resolve, reject)\n          }catch (e) {\n            reject(e);\n          }\n        }, 0)\n      }else if (this.status === REJECTED) {\n        setTimeout(() => {\n          try {\n            let x = failCallback(this.reason);\n            // 判断 x 的值是普通值还是promise对象\n            // 如果是普通值 直接调用resolve \n            // 如果是promise对象 查看promsie对象返回的结果 \n            // 再根据promise对象返回的结果 决定调用resolve 还是调用reject\n            resolvePromise(promsie2, x, resolve, reject)\n          }catch (e) {\n            reject(e);\n          }\n        }, 0)\n      } else {\n        // 等待\n        // 将成功回调和失败回调存储起来\n        this.successCallback.push(() => {\n          setTimeout(() => {\n            try {\n              let x = successCallback(this.value);\n              // 判断 x 的值是普通值还是promise对象\n              // 如果是普通值 直接调用resolve \n              // 如果是promise对象 查看promsie对象返回的结果 \n              // 再根据promise对象返回的结果 决定调用resolve 还是调用reject\n              resolvePromise(promsie2, x, resolve, reject)\n            }catch (e) {\n              reject(e);\n            }\n          }, 0)\n        });\n        this.failCallback.push(() => {\n          setTimeout(() => {\n            try {\n              let x = failCallback(this.reason);\n              // 判断 x 的值是普通值还是promise对象\n              // 如果是普通值 直接调用resolve \n              // 如果是promise对象 查看promsie对象返回的结果 \n              // 再根据promise对象返回的结果 决定调用resolve 还是调用reject\n              resolvePromise(promsie2, x, resolve, reject)\n            }catch (e) {\n              reject(e);\n            }\n          }, 0)\n        });\n      }\n    });\n    return promsie2;\n  }\n  finally (callback) {\n    return this.then(value => {\n      return MyPromise.resolve(callback()).then(() => value);\n    }, reason => {\n      return MyPromise.resolve(callback()).then(() => { throw reason })\n    })\n  }\n  catch (failCallback) {\n    return this.then(undefined, failCallback)\n  }\n  static all (array) {\n    let result = [];\n    let index = 0;\n    return new MyPromise((resolve, reject) => {\n      function addData (key, value) {\n        result[key] = value;\n        index++;\n        if (index === array.length) {\n          resolve(result);\n        }\n      }\n      for (let i = 0; i < array.length; i++) {\n        let current = array[i];\n        if (current instanceof MyPromise) {\n          // promise 对象\n          current.then(value => addData(i, value), reason => reject(reason))\n        }else {\n          // 普通值\n          addData(i, array[i]);\n        }\n      }\n    })\n  }\n  static resolve (value) {\n    if (value instanceof MyPromise) return value;\n    return new MyPromise(resolve => resolve(value));\n  }\n}\n\nfunction resolvePromise (promsie2, x, resolve, reject) {\n  if (promsie2 === x) {\n    return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))\n  }\n  if (x instanceof MyPromise) {\n    // promise 对象\n    // x.then(value => resolve(value), reason => reject(reason));\n    x.then(resolve, reject);\n  } else {\n    // 普通值\n    resolve(x);\n  }\n}\n\nmodule.exports = MyPromise;\n```","children":[]}]},{"name":"proxy.md","path":"../guanruihua.github.io/JavaScript/对象","data":"# Proxy\n\n> 在 ES6 标准中新增的一个非常强大的功能是 Proxy，它可以自定义一些常用行为如查找、赋值、枚举、函数调用等。通过 Proxy 这个名称也可以看出来它包含了“代理”的含义，只要有“代理”的诉求都可以考虑使用 Proxy 来实现。\n\n**1.基本语法**\n\n```js\nlet p = new Proxy(target, handler)\n```\n\n| 参数    | 含义                                                         | 必选 |\n| ------- | ------------------------------------------------------------ | ---- |\n| target  | 用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理） | y    |\n| handler | 一个对象，其属性是当执行一个操作时定义代理的行为的函数       | y    |\n\n**2.常用拦截操作**\n\n- get\n  拦截对象属性的读取，比如proxy.foo和proxy['foo']。\n\n  ```js\n  let arr = [7, 8, 9]\n  arr = new Proxy(arr, {\n    get(target, prop) {\n        // console.log(target, prop)\n        return prop in target ? target[prop] : 'error'\n    }\n  })\n  console.log(arr[1])\n  console.log(arr[10])\n  ```\n\n  ```js\n  let dict = {\n    'hello': '你好',\n    'world': '世界'\n  }\n  dict = new Proxy(dict, {\n    get(target, prop) {\n        return prop in target ? target[prop] : prop\n    }\n  })\n  console.log(dict['world'])\n  console.log(dict['imooc'])\n  ```\n\n- set\n  拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。\n\n  ```js\n  let arr = []\n  arr = new Proxy(arr, {\n    set(target, prop, val) {\n        if (typeof val === 'number') {\n            target[prop] = val\n            return true\n        } else {\n            return false\n        }\n    }\n  })\n  arr.push(5)\n  arr.push(6)\n  console.log(arr[0], arr[1], arr.length)\n  ```\n\n- has\n  拦截propKey in proxy的操作，返回一个布尔值。\n\n  ```js\n  let range = {\n    start: 1,\n    end: 5\n  }\n  \n  range = new Proxy(range, {\n    has(target, prop) {\n        return prop >= target.start && prop <= target.end\n    }\n  })\n  console.log(2 in range)\n  console.log(9 in range)\n  ```\n\n- ownKeys\n  拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。\n\n  ```js\n  let userinfo = {\n    username: 'xxx',\n    age: 18,\n    _password: '***'\n  }\n  userinfo = new Proxy(userinfo, {\n    ownKeys(target) {\n        return Object.keys(target).filter(key => !key.startsWith('_'))\n    }\n  })\n  \n  // for (let key in userinfo) {\n  //     console.log(key)\n  // }\n  console.log(Object.keys(userinfo))\n  ```\n\n- deleteProperty\n  拦截delete proxy[propKey]的操作，返回一个布尔值。\n\n  ```js\n  let user = {\n    name: 'xxx',\n    age: 18,\n    _password: '***'\n  }\n  user = new Proxy(user, {\n    get(target, prop) {\n        if (prop.startsWith('_')) {\n            throw new Error('不可访问')\n        } else {\n            return target[prop]\n        }\n    },\n    set(target, prop, val) {\n        if (prop.startsWith('_')) {\n            throw new Error('不可访问')\n        } else {\n            target[prop] = val\n            return true\n        }\n    },\n    deleteProperty(target, prop) { // 拦截删除\n        if (prop.startsWith('_')) {\n            throw new Error('不可删除')\n        } else {\n            delete target[prop]\n            return true\n        }\n    },\n    ownKeys(target) {\n        return Object.keys(target).filter(key => !key.startsWith('_'))\n    }\n  })\n  console.log(user.age)\n  console.log(user._password)\n  user.age = 18\n  console.log(user.age)\n  try {\n    user._password = 'xxx'\n  } catch (e) {\n    console.log(e.message)\n  }\n  \n  try {\n    // delete user.age\n    delete user._password\n  } catch (e) {\n    console.log(e.message)\n  }\n  console.log(user.age)\n  \n  for (let key in user) {\n    console.log(key)\n  }\n  ```\n\n- apply\n  拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。\n\n  ```js\n  let sum = (...args) => {\n    let num = 0\n    args.forEach(item => {\n        num += item\n    })\n    return num\n  }\n  \n  sum = new Proxy(sum, {\n    apply(target, ctx, args) {\n        return target(...args) * 2\n    }\n  })\n  console.log(sum(1, 2))\n  console.log(sum.call(null, 1, 2, 3))\n  console.log(sum.apply(null, [1, 2, 3]))\n  ```\n\n- construct\n  拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。\n\n  ```js\n  let User = class {\n    constructor(name) {\n        this.name = name\n    }\n  }\n  User = new Proxy(User, {\n    construct(target, args, newTarget) {\n        console.log('construct')\n        return new target(...args)\n    }\n  })\n  console.log(new User('imooc'))\n  ```","children":[]},{"name":"Reflect.md","path":"../guanruihua.github.io/JavaScript/对象","data":"# Reflect\n\nReflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。\n\n**1.设计目的**\n\n- 将Object属于语言内部的方法放到Reflect上\n\n  ```js\n  let obj = {}\n  let newVal = ''\n  Reflect.defineProperty(obj, 'name', {\n    get() {\n        return newVal\n    },\n    set(val) {\n        console.log('set')\n        // this.name = val\n        newVal = val\n    }\n  })\n  obj.name = 'es'\n  console.log(obj.name)\n  ```\n\n- 修改某些Object方法的返回结果，让其变得更合理\n\n  ```js\n  // 老写法\n  try {\n    Object.defineProperty(target, property, attributes)\n    // success\n  } catch (e) {\n    // failure\n  }\n  \n  // 新写法\n  if (Reflect.defineProperty(target, property, attributes)) {\n    // success\n  } else {\n    // failure\n  }\n  ```\n\n- 让Object操作变成函数行为\n\n  ```js\n  // 老写法\n  'assign' in Object // true\n  \n  // 新写法\n  Reflect.has(Object, 'assign') // true\n  ```\n\n- Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。\n\n  ```js\n  Proxy(target, {\n    set: function(target, name, value, receiver) {\n        var success = Reflect.set(target, name, value, receiver)\n        if (success) {\n            console.log('property ' + name + ' on ' + target + ' set to ' + value)\n        }\n        return success\n    }\n  })\n  ```\n\n  Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法，这些方法与处理器对象的方法相同。Reflect不是一个函数对象，因此它是不可构造的。\n\n**2、常用方法**\n\n- Reflect.apply()\n\n  > Reflect.apply(target, thisArgument, argumentsList),target为目标函数；thisArgument为target函数调用时绑定的this对象；argumentsList为target函数调用时传入的实参列表，该参数应该是一个类数组的对象\n\n```js\nReflect.apply(Math.floor, undefined, [1.75])\n// 1\n\nReflect.apply(String.fromCharCode, undefined, [104, 101, 108, 108, 111])\n// \"hello\"\n\nReflect.apply(RegExp.prototype.exec, /ab/, ['confabulation']).index\n// 4\n\nReflect.apply(''.charAt, 'ponies', [3])\n// \"i\"\n```\n\n- Reflect.construct()\n  Reflect.construct() 方法的行为有点像 new 操作符 构造函数 ， 相当于运行 new target(...args)\n\n  ```js\n  var d = Reflect.construct(Date, [1776, 6, 4])\n  d instanceof Date // true\n  d.getFullYear() // 1776\n  ```\n\n- Reflect.defineProperty()\n  静态方法 Reflect.defineProperty() 基本等同于 Object.defineProperty() 方法，唯一不同是返回 Boolean 值。\n\n  ```js\n  const student = {}\n  Reflect.defineProperty(student, 'name', {\n    value: 'Mike'\n  }) // true\n  student.name // \"Mike\"\n  ```\n\n- Reflect.deleteProperty()\n  Reflect.deleteProperty 允许你删除一个对象上的属性。返回一个 Boolean 值表示该属性是否被成功删除。它几乎与非严格的 delete operator 相同。\n\n  ```js\n  var obj = {\n    x: 1,\n    y: 2\n  }\n  Reflect.deleteProperty(obj, \"x\") // true\n  obj // { y: 2 }\n  \n  var arr = [1, 2, 3, 4, 5]\n  Reflect.deleteProperty(arr, \"3\") // true\n  arr // [1, 2, 3, , 5]\n  \n  // 如果属性不存在，返回 true\n  Reflect.deleteProperty({}, \"foo\") // true\n  \n  // 如果属性不可配置，返回 false\n  Reflect.deleteProperty(Object.freeze({\n    foo: 1\n  }), \"foo\") // false\n  ```\n\n- Reflect.get()\n  Reflect.get() 方法的工作方式，就像从 object (target[propertyKey]) 中获取属性，但它是作为一个函数执行的。\n\n  ```js\n  // Object\n  var obj = {\n    x: 1,\n    y: 2\n  }\n  Reflect.get(obj, 'x') // 1\n  \n  // Array\n  Reflect.get(['zero', 'one'], 1) // \"one\"\n  \n  // Proxy with a get handler\n  var x = {\n    p: 1\n  }\n  var obj = new Proxy(x, {\n    get(t, k, r) {\n        return k + 'bar'\n    }\n  })\n  Reflect.get(obj, 'foo') // \"foobar\"\n  ```\n\n- Reflect.getOwnPropertyDescriptor()\n  静态方法 Reflect.getOwnPropertyDescriptor() 与 Object.getOwnPropertyDescriptor() 方法相似。如果在对象中存在，则返回给定的属性的属性描述符，否则返回 undefined。\n\n  ```js\n  Reflect.getOwnPropertyDescriptor({\n    x: 'hello'\n  }, 'x')\n  // {value: \"hello\", writable: true, enumerable: true, configurable: true}\n  \n  Reflect.getOwnPropertyDescriptor({\n    x: 'hello'\n  }, 'y')\n  // undefined\n  \n  Reflect.getOwnPropertyDescriptor([], 'length')\n  // {value: 0, writable: true, enumerable: false, configurable: false}\n  ```\n\n- 更多方法可以参考[Reflect](https://link.segmentfault.com/?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FReflect)","children":[]}]},{"name":"拓展","path":"../guanruihua.github.io/JavaScript","data":"","children":[{"name":"深浅拷贝.md","path":"../guanruihua.github.io/JavaScript/拓展","data":"# 深浅拷贝\n\n> 引用类型在赋值的过程中其实是复制了地址, 从而导致, 改变一行其他的也会发生改变\n\n## 问题\n\n> 改变任意一方都会影响例外一方\n\n```js\nlet a = {\n    age: 1,\n    name : 'grh',\n}\nlet b = a\na.age = 2\nb.name = 'rh'\nconsole.log(b.age) // 2  希望是1\nconsole.log(b.name) // rh  希望是grh\n```\n\n## 浅拷贝\n\n> - 当复制的对象都不是引用类型, 就可以使用浅拷贝\n>\n> - 遍历复制, 最后返回新的对象\n\n```js\nfunction shallowCopy(obj) {\n  var temp = {};\n  for( key in obj ) {\n    if(obj.hasOwnProperty(key)){\n      temp[key] = obj[key];\n    }\n  }\n  return temp\n}\nlet a = {\n  age: 1,\n  name : {\n    first: 'grh'\n  }\n}\nlet b = shallowCopy(a)\na.age = 2\na.name.first = 'rh'\nconsole.log(b.age) // 1\nconsole.log(b.name.first); // rh 希望拿到的是grh , 这里的问题主要是name属性不是值类型, 是引用类型, 改方法就会失效\n```\n\n## 深拷贝\n\n> - 简单说就是浅拷贝 + 递归\n> - 浅拷贝时候, 判断是否为对象, 如果是对象就进行递归操作\n\n```js\nfunction cloneDeep(source) {\n  var target = {};\n  for( let key in source ) {\n    if( Object.prototype.hasOwnProperty.call(source, key)) {\n      if( typeof source[key] === 'object') {\n        target[key] = cloneDeep(source[key]);\n      } else {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n}\nlet a = {\n  age: 1,\n  name : {\n    first: 'grh'\n  }\n}\nlet b = cloneDeep(a)\na.age = 2\na.name.first = 'rh'\nconsole.log(b.age) // 1\nconsole.log(b.name.first); // grh \n```\n\n> 该方法问题:\n>\n> 1. typeof null === 'object'  , 传入null 应该返回null, 而不是 {}\n> 2. 没有考虑数组的兼容性, 传入[1, 2 ] 会返回 { 0: 1, 1: 2 }\n\n```js\nfunction cloneDeep2(source) {\n \n    if (!isObject(source)) return source; // 非对象返回自身\n    // if(source === null) return null \n    \n    //解决数组兼容\n    var target = Array.isArray(source) ? [] : {};\n    \n    for(var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (isObject(source[key])) {\n                target[key] = cloneDeep2(source[key]); // 注意这里\n            } else {\n                target[key] = source[key];\n            }\n        }\n    }\n    return target;\n}\n \n \n// 解决typeof null === 'object'\nfunction isObject(obj) {\n    return typeof obj === 'object' && obj != null;\n}\n```\n","children":[]}]},{"name":"数据结构","path":"../guanruihua.github.io/JavaScript","data":"","children":[{"name":"buffer.md","path":"../guanruihua.github.io/JavaScript/数据结构","data":"# Buffer\n\n> **buffer 即缓存，是对二进制数据处理的一种方式。**\n>\n> ES6 推出才正式有了 `ArrayBuffer`\n\n## ArrayBuffer\n\n> - 最基础的二进制对象，是对固定长度的连续内存空间的引用\n>\n> - `Uint8Array`，`Uint16Array`，`Uint32Array`可以理解为`ArrayBuffer`的翻译器\n\n- `Uint8Array` 将 `ArrayBuffer` 中的每个字节视为一个单位。每个单位是 0 到 255 之间的数字。之所以是255，是因为每个单位最多是 8 位，即 2^8 次方。\n- `Uint16Array` 将 `ArrayBuffer` 中每 2 个字节视为一个单位。每个单位是 0 到 65535 之间的整数, 2^16。\n- `Uint32Array` 将 `ArrayBuffer` 中每 4 个字节视为一个单位。每个单位是 0 到 4294967295 之间的整数。2^32。\n\n```js\n// 我们可以通过 BYTES_PER_ELEMENT 静态属性来得之视图单位的大小\nconst buf8 = new Uint8Array();\nconst buf16 = new Uint16Array();\nconst buf32 = new Uint32Array();\nconsole.log(buf8.BYTES_PER_ELEMENT); // 1\nconsole.log(buf16.BYTES_PER_ELEMENT); // 2\nconsole.log(buf32.BYTES_PER_ELEMENT); // 4\n```\n\n## TypedArray\n\n> `TypedArray` 是 `Uint8Array`， `Uint16Array`, `Uint32Array` 统称, 都是 `TypedArray` （类型数组）的一种形式罢了。\n\n### DataView\n\n> `DataView` 就是一种更灵活的视图\n\n```js\nconst buffer = new ArrayBuffer(16); // 分配一个内存空间\nconst view = new DataView(buffer); // 创建 DataView 视图\nview.setUint32(0, 4294967295); // 从第 0 个空间开始，以 32 位的形式写入数据\n\n// 有时候我想以 8 位的形式 “翻译” 这个内存空间，从偏移量 0 开始翻译\nconsole.log(view.getUint8(0)); // 255\n// 今天心情好，想以 16 位的形式 “翻译” 这个内存空间，从偏移量 0 开始读\nconsole.log(view.getUint16(0)); // 65535\n// 今天心情超好，想以 32 位的形式 “翻译” 这个内存空间，从偏移量 0 开始读\nconsole.log(view.getUint32(0)); // 4294967295\n```\n\n### Node 中的 Buffer\n\n- `Buffer.alloc(size[, fill[, encoding]])` 创建一个 buffer 空间，可以填充制定元素，也可以指定编码类型\n\n- ```\n  Buffer.from()\n  ```\n\n   以 buffer 方式存储内容\n\n  - `Buffer.from(array)` 创建一个 buffer 数组 buf，`buf.values()` 返回一个可以迭代的对象\n  - `Buffer.from(string[, encoding])` 创建一个 buffer 字符串，可以指定编码类型\n  - `Buffer.from(buffer)` 拷贝一个 buffer 对象\n\n### 前端人眼中的 Buffer\n\n先从前端比较常见的说起。在 Web 开发中，我们可能需要对文件做一些处理。比如**导出excel，下载文件，上传头像等等。** 这些操作其实都是操作二进制数据。\n\n```js\n// 伪代码示例\n// Blob 上传图片\n\n// fileHandler 为前置工作伪代码\n// FileReader 加载图片，cavans 压缩图片等\nconst canvas = fileHandler()\n\n// 创建 Blob 对象和 FormData\ncanvas.toBlob(blob => {\n  this.imgBlob = blob\n}, 'image/jpeg')\nlet formdata = new FormData()\nformdata.append('file', this.imgBlob, 'img.jpeg')\n\n// 上传图片\naxios({\n  headers: {\n    \"Content-Type\": \"multipart/form-data\"\n  },\n  method: \"post\",\n  url: uploadUrl,\n  data: formdata\n})\n  .then(res => {\n    // do something\n  })\n  .catch(err => {\n    // do something\n  });\n```\n\n### 大前端眼中的 Buffer\n\n大前端可能就涉及一些前端工程化，脚手架，打包工具等。这时候就可以通过流式处理操作 Buffer。比如**按行读取某个配置文件**，处理 webpack 的一些工作流，和 cli 交互读取和写入文件等等。\n\n```ts\n// 伪代码示例\n// 逐行读取配置文件，个性化配置\n\nconst fs = require(\"fs\");\nconst readline = require(\"readline\");\n\n// 创建可读流\nconst rl = readline.createInterface({\n  input: fs.createReadStream(\"theme.less\"),\n});\n\nrl.on(\"line\", (line: string) => {\n  if (line.trim().startsWith(\"configStart\")) {\n    // 伪代码，处理变量\n    themeHandlerStart()\n  }\n  if (line.trim().startsWith(\"configStart\")) {\n    // 伪代码，处理变量\n    themeHandlerEnd()\n  }\n});\n```\n\n### 服务端眼中的 Buffer\n\n对于服务端的同学来说，buffer 的应用就更广泛了\n 比如压缩和解压缩，比如加密解密，信息脱敏等等，其实都和 buffer 脱不了干系\n\n此外因为 buffer 是操作二进制对象，所以他的性能和灵活性比常规的 js API 会强很多\n\n- 比如要求更快速的响应时，http 直接传输 buffer 会比传输字符串的效率更高\n- 比如日志持久化需要节省空间时，用不同的编码来压缩空间等等\n\n用 Buffer 能更自由灵活的去调和时间复杂度和空间复杂度之间的关系\n\n```js\n// 伪代码示例\n// 压缩文件\n\nconst { createGzip } = require(\"zlib\");\nconst { pipeline } = require(\"stream\");\nconst { createReadStream, createWriteStream } = require(\"fs\");\n\nconst gzip = createGzip();\nconst source = createReadStream(\"./package.json\");\nconst destination = createWriteStream(\"./package.json.gz\");\n\npipeline(source, gzip, destination, (err) => {\n  if (err) {\n    console.error(\"发生错误:\", err);\n    process.exitCode = 1;\n  }\n});\n```\n","children":[]},{"name":"Map","path":"../guanruihua.github.io/JavaScript/数据结构","data":"","children":[{"name":"Map.md","path":"../guanruihua.github.io/JavaScript/数据结构/Map","data":"# Map\n\n> - 类似对象\n> - 键值对的集合\n> - '键' 不限于 字符串\n\n## 实例化\n\n```js\nlet map = new Map([iterable]);\n```\n\n> - Iterable 可以是一个数组或其他的Iterable对象, 其元素为键值对( 两个元素的数组,  eg:`[[1, 'one'],[2,`'two']]`)\n> - `null` 会被当做 `undefined`\n\n## 添加 set\n\n```js\nlet keyObj = {}\nlet keyFunc = function() {}\nlet keyString = 'a string'\n\n// 添加键\nmap.set(keyString, \"和键'a string'关联的值\")\nmap.set(keyObj, '和键keyObj关联的值')\nmap.set(keyFunc, '和键keyFunc关联的值')\n```\n\n### 删除 delete & clear\n\n```js\n// 删除指定的数据\nmap.delete(keyObj)\n// 删除所有数据\nmap.clear()\n```\n\n### 统计 size\n\n```js\n// 统计所有 key-value 的总数\nconsole.log(map.size) //2\n// 判断是否有 key-value\nconsole.log(map.has(keyObj)) // true\n```\n\n### 查询 get\n\n```js\nconsole.log(map.get(keyObj));\n```\n\n## 遍历方法\n\n> - `keys`:  返回一个新的Iterator对象,  (按照插入map对象的每个key值)\n> - `values`: 返回一个新的Iterrator对象\n> - `entries` : 返回一个新的包含`[ key, value]` 对的迭代(`Iterator`)对象\n> - `forEach` : 会以插入顺序对Map对象每一个键值对执行应该参数提供回调函数\n> - `for...of`: 直接遍历每一个成员\n\n```js\nmap.forEach((value, key) => console.log(value, key))\n\nfor (let [key, value] of map) {\n console.log(key, value)\n}\n\nfor (let key of map.keys()) {\n console.log(key)\n}\n\nfor (let value of map.values()) {\n console.log(value)\n}\n\nfor (let [key, value] of map.entries()) {\n console.log(key, value)\n}\n```\n","children":[]},{"name":"WeekMap.md","path":"../guanruihua.github.io/JavaScript/数据结构/Map","data":"# WeekMap\n\n> - 只接受对象作为键名( null除外 ) , 不接受其他类型的值作为键值\n> - 不计入垃圾回收机制\n\n```js\n// WeakMap 可以使用 set 方法添加成员\nconst wm1 = new WeakMap()\nconst key = {\n    foo: 1\n}\nwm1.set(key, 2)\nwm1.get(key) // 2\n\n// WeakMap 也可以接受一个数组，\n// 作为构造函数的参数\nconst k1 = [1, 2, 3]\nconst k2 = [4, 5, 6]\nconst wm2 = new WeakMap([\n    [k1, 'foo'],\n    [k2, 'bar']\n])\nwm2.get(k2) // \"bar\"\n```\n","children":[]}]},{"name":"Set","path":"../guanruihua.github.io/JavaScript/数据结构","data":"","children":[{"name":"set.md","path":"../guanruihua.github.io/JavaScript/数据结构/Set","data":"# Set\n\n> - 在 JavaScript 里通常使用 Array 或 Object 来存储数据。\n>\n> - 但是在频繁操作数据的过程中查找或者统计并需要手动来实现，并不能简单的直接使用。\n> - 比如如何保证 Array 是去重的，如何统计 Object 的数据总数等，必须自己去手动实现类似的需求，不是很方便。\n> - 在 ES6 中为了解决上述痛点，新增了数据结构 Set 和 Map，它们分别对应传统数据结构的“集合”和“字典”\n> - 特性\n>   - 不允许数据重复\n\n## 基本用法\n\n### 生成Set实例\n\n```js\nlet s = new Set();\nlet s = new Set([1,2,3,4]);\n```\n\n### 添加数据\n\n```js\ns.add('a');\ns.add('b');\n// or\ns.add('a').add('b');\n```\n\n### 删除数据\n\n```js\n// 删除指定\ns.delete('a');\n// 删除全部\ns.clear();\n```\n\n### 统计数据\n\n> - `has`: 是否拥有该元素\n> - `size`: 统计数据的总数\n\n```js\n// 判断是否拥有数据项, 返回boolean\ns.has('a')// true\n// 计算总数\ns.size // 2\n```\n\n## 遍历方法\n\n> `keys`: 键名的遍历器\n>\n> `values`: 键值遍历器\n>\n> `entries`: 返回键值对的遍历器\n>\n> `forEach`: 使用回调函数遍历每个成员\n>\n> `for...of`: 可以直接遍历每一个成员\n\n```js\nconsole.log(s.keys()) // SetIterator {\"hello\", \"goodbye\"}\nconsole.log(s.values()) // SetIterator {\"hello\", \"goodbye\"}\nconsole.log(s.entries()) // SetIterator {\"hello\" => \"hello\", \"goodbye\" => \"goodbye\"}\ns.forEach(item => {\n    console.log(item) // hello // goodbye\n})\n\nfor (let item of s) {\n    console.log(item)\n}\n\nfor (let item of s.keys()) {\n    console.log(item)\n}\n\nfor (let item of s.values()) {\n    console.log(item)\n}\n\nfor (let item of s.entries()) {\n    console.log(item[0], item[1])\n}\n```\n\n## set 运用\n\n### 数据去重\n\n```js\nlet arr = [1,2,3,4,5,6,7]\nlet s = new Set(arr);\n```\n\n### 合并去重\n\n```js\nlet arr1 = [1,2,3];\nlet arr2 = [2,3,4];\nlet s = new Set([...arr1, ...arr2]);\nconsole.log(s)\nconsole.log([...s])\nconsole.log(Array.from(s))\n```\n\n### 交集\n\n```js\n// let s1 = new Set(arr1);\nlet s2 = new Set(arr2);\nlet result = new Set(arr1.filter(item => s2.has(item)))\nArray.from(result);\n```\n","children":[]},{"name":"WeakSet.md","path":"../guanruihua.github.io/JavaScript/数据结构/Set","data":"# WeakSet\n\n> - 和Set类似\n> - WeakSet成员只能是对象,不能是其他类型的值\n> - 没有size属性\n> - 不可以遍历它的成员\n> - WeakSet 的 对象是弱引用\n> - 垃圾回收机制不用考虑WeakSet对该对象的引用\n\n\n\n```js\nconst ws = new WeakSet()\nws.add(1)\n// TypeError: Invalid value used in weak set\nws.add(Symbol())\n// TypeError: invalid value used in weak set\nlet ws = new WeakSet()\nconst obj1 = {\n    name: 'imooc'\n}\nconst obj2 = {\n    age: 5\n}\nws.add(obj1)\nws.add(obj2)\nws.delete(obj1)\nconsole.log(ws)\nconsole.log(ws.has(obj2))\n```\n\n","children":[]}]},{"name":"数组","path":"../guanruihua.github.io/JavaScript/数据结构","data":"","children":[{"name":"flat.md","path":"../guanruihua.github.io/JavaScript/数据结构/数组","data":"# flat\r\n\r\n## 普通递归实现\r\n\r\n> 普通递归的思路很容易理解，就是通过for循环的方式，逐层逐个元素地去展平，如果当前元素是一个数组，那么就对它进行递归处理，再将递归处理的结果拼接到结果数组上\r\n\r\n```js\r\nfunction flatten(arr) {\r\n  let result = [];\r\n  for(let i = 0; i < arr.length; i++) {\r\n    if(Array.isArray(arr[i])) {\r\n      result = result.concat(flatten(arr[i]));\r\n   continue;\r\n    }\r\n      result.push(arr[i]);\r\n  }\r\n  return result;\r\n}\r\nconsole.log(flatten([1, [2, [3, 4, 5]]]));  //  [1, 2, 3, 4，5]\r\n```\r\n\r\n## reduce实现\r\n\r\n> reduce是JS数组中非常强大的一个方法，同时也是JS中的一个函数式编程API。\r\n> 上面的递归实现的关键就是对数组的每一项进行处理，遇到数组就递归处理它，既然需要循环和结果数组，那么我们可以使用reduce来简化我们的代码\r\n\r\n```js\r\nfunction flatten(arr) {\r\n    return arr.reduce(function(pre, cur){\r\n        return pre.concat(Array.isArray(cur) ? flatten(cur) : cur)\r\n    }, [])\r\n}\r\nconsole.log(flatten([1, [2, [3, 4]]]));//  [1, 2, 3, 4，5]\r\n```\r\n\r\n> 使用reduce后，代码更加的简洁，reduce 的第一个参数用来返回最后累加的结果，第二个参数是当前遍历到的元素值，处理数组元素和非数组元素的思路和第一种方法是一样，最后再把处理后的结果拼接到累加的结果数组中返回即可。\r\n\r\n## 扩展运算符实现\r\n\r\n>扩展运算符是ES6的新特性之一，用它操作数组可以直接展开数组的第一层，利用这个特性，我们可以不使用递归来实现数组的展平，这是因为每一次递归都是对当前层次数组的一次展开，而扩展操作符就是干这工作的。\r\n\r\n```js\r\nfunction flatten(arr) {\r\n    while (arr.some(i => Array.isArray(i))) {\r\n        arr = [].concat(...arr);\r\n    }\r\n    return arr;\r\n}\r\nconsole.log(flatten([1, [2, [3, 4]]])); //  [1, 2, 3, 4，5]\r\n```\r\n\r\n> 代码中使用了数组的另一个方法some，目的是判断当前数组是否还有数组元素，如果有则对数组进行一层展开，同时将展开结果作为下一次判断的条件，这样就像剥洋葱一样，一层层地剥开洋葱皮，当循环条件不满足时说明数组里已经没有数组元素了，这是数组已经完全扁平。\r\n\r\n## split + toString 实现\r\n\r\n> 我们也可以通过 split 和 toString 两个方法，来共同实现数组扁平化。toString是Object原型链上的一个方法，由于JS中所有对象都派生自Object对象，所以它们都能调用toString，只不过不同的对象可能会对这个方法进行改写以输出自己想要的格式。数组的toString方法会将数组转换成一个元素间以逗号相隔的字符串，它内部会先将数组展平成一维后再转换成字符串，因此我们可以先利用toString进行展平，然后再通过split方法以逗号分隔每个元素来复原一个包含所有元素的数组，从而实现数组的扁平化。\r\n\r\n```js\r\nfunction flatten(arr) {\r\n  return arr.toString().split(',').map(i=>Number(i));\r\n}\r\nconsole.log(flatten([1, [2, [3, 4]]])); //  [1, 2, 3, 4]\r\n```\r\n\r\n> - 不过需要注意的是，虽然这个方法非常简单，但具有一定的局限性，对于包含引用类型元素的数组来说，在toString过程中会发生类型转换，从而使得转换结果异常，因为对于引用类型转成字符串，会调用引用类型的toString，上面提到不同对象会对它进行改写，例如函数就会得到一个函数体的代码字符串，而不是我们想要的函数引用。\r\n> - 因此，使用这种方式我们要看元素类型而定。\r\n\r\n## 正则 + JSON实现\r\n\r\n> 正则实现也是先将数组转换成字符串的表达形式，这里将数组转成字符串我们使用JSON.stringify方法，将数组转换成一个由括号包裹、元素间以逗号相隔的字符串，例如\"[1, [2, [3, [4, 5]]], 6]\",从转换后的字符可以发现，每一对括号包着的范围就是一个层级，数组的展平就是将内部的层级全部消除，只保留最外层，在这里，就是将括号全部替换成空字符，得到一个元素以逗号相隔字符串，最后将利用JSON.parse方法解析成数组对象。\r\n\r\n```js\r\nfunction flatten(arr) {\r\n  let str = JSON.stringify(arr);\r\n  str = str.replace(/(\\[|\\])/g, '');\r\n  // 拼接最外层，变成JSON能解析的格式\r\n  str = '[' + str + ']';\r\n  return JSON.parse(str);\r\n}\r\nconsole.log(flatten([1, [2, [3, [4, 5]]], 6])); //  [1, 2, 3, 4，5]\r\n```\r\n\r\n> 同样，这种方式在处理引用数据类型上也有局限性，同时还要注意元素是否是JSON的合法数据类型。\r\n\r\n## Array.prototype.flat\r\n\r\n> `Array.prototype.flat`是ES6新增的一个数组方法，它的作用就是用来数组扁平化，并且根据传入的参数来决定展开的层级，是数组扁平化的终极解决方案。\r\n\r\n```js\r\nlet arr = [1, [2, [3, 4]]];\r\nfunction flatten(arr) {\r\n  return arr.flat(Infinity);\r\n}\r\nconsole.log(flatten(arr)); //  [1, 2, 3, 4，5]\r\n```\r\n\r\n> 参数Infinity表示完全展开，使用起来非常方便、快捷。\r\n","children":[]},{"name":"v8引擎下的数组.md","path":"../guanruihua.github.io/JavaScript/数据结构/数组","data":"# V8引擎下的\"数组\"底层实现\r\n\r\n## 数组描述\r\n\r\n| 数组     | 描述                                                         |\r\n| :------- | :----------------------------------------------------------- |\r\n| 传统数组 | 相同数据类型, 连续内存, 连续空间存储, 线性存储结构, 固定长度 |\r\n| JS数组   | 多种数据类型, 动态容量\r\n\r\n## JS数组\r\n\r\n> 新建数组时, 没有设置容量, 默认Fast Elements 模式\r\n> 设置容量, 没有进行内部元素初始化(`new Array(10)`), 出现空洞, 将会以**Fast Holey Elements**模式实现\r\n> 对数组进行初始化, `Fast Elements`模式实现, 不存在空洞\r\n\r\n### FixedArray 快数组(默认)\r\n\r\n> 特点:\r\n>\r\n> - 数组长度: `length < elements.length()`\r\n>\r\n> - 线性存储方式 (默认)\r\n> - 长度可变\r\n> - 可扩容: 扩容后的新容量= 旧容量*1.5 + 16, 扩容后会将拷贝到新的内存空间中\r\n> - 可缩放:如果容量> length*2+16, 就进行收缩容量调整, 否则用holes对象\r\n\r\n### HashTable 慢数组\r\n\r\n> 特点:\r\n>\r\n> - 以数组为键的`HashTable`\r\n> - 字典内存形式\r\n> - 不用连续的存储空间(节省内存)\r\n> - 效率较低\r\n\r\n### 快慢数组切换\r\n\r\n> **转换为慢数组**:\r\n>\r\n> - `新容量>=3*拓展后的容量*2`\r\n> - `newIndex - Now容量>=1024`\r\n>\r\n> **转换为快数组**:\r\n>\r\n> ( `smi在64位平台为-2^31到2^31-1, 在32位平台为-2^30到2^30-1`)\r\n>\r\n> - 数组长度在`smi`之间不可转换\r\n> - 当慢数组的元素可存放在快数组中且长度在 smi 之间且仅节省了50%的空间,则会转变为快数组\r\n\r\n### 补充\r\n\r\n#### holes对象\r\n\r\n> holes(空洞): 指数组分配了空间, 但是没有存放元素的地方\r\n>\r\n> - 快数组中在 **Fast Elements** 模式中的拓展模式 **Fast Holey Elements**\r\n\r\n##### Fast Holey Elements\r\n\r\n> 动态分配连续的存储空间, 分配空间的大小由最大的索引值决定\r\n","children":[]},{"name":"下标.md","path":"../guanruihua.github.io/JavaScript/数据结构/数组","data":"# 数组下标问题\n\n```js\nvar arr = [];\narr[\"a\"] = 1;\nconsole.log(arr.length);   // 0\narr['2'] = 2;\nconsole.log(arr.length);   // 3\narr.length = 0;\nconsole.log(arr);          // [a:1]\narr.length//0\narr['a']//1\n```\n\n​   javascript 数组下标值的范围为0到2的32次方 对于给定的数字下标值,如果不在这个范围内 js 就会把这个值转为字符串 并当做一个数组对象存储, 而不是一个数组元素 但是如果下标值在合法范围之内 无论是数字型字符串还是数字 都转换为数字, array[\"100\"] = array[100];\n​   使用字符串当做下标是 其实就相当于给该数组对象中存储了一个属性 由于给数组对象添加一个属性时 数组的长度始终为0\n","children":[]},{"name":"数组.md","path":"../guanruihua.github.io/JavaScript/数据结构/数组","data":"# 数组\n\n## 创建方法\n\n> 空数组: `var Obj  = new Array();`\n> 指定长度数组: `var Obj  =  new Array(size);`\n> 指定元素数组: `var Obj = new Array(元素1, 元素2, 元素3....);`\n> 单维数组: `var Obj = [元素1, 元素2, 元素3....];`\n> 多维数组: `var Obj = [[数组序列1],[数组序列2],[数组序列3]...]`\n\n## 基本操作\n\n- 特性:\n  - 下标类型:\n    - 数值\n    - 非数值\n      - 转换为字符串\n      - 生成关联数组,  下标将作为对象属性的名字\n\n- 删除数组 delete 数组名[下标]\n\n- 遍历数组 for(var 数组元素变量 in 数组)\n\n### 数组属性\n\n> - constructor:\n>   - 引用数组对象的构造函数\n> - length :\n>   - 返回数组的长度\n> - prototype\n>   - 通过增加属性和方法扩展数组定义\n\n### 数组方法\n\n#### 添加\n\n> push() 尾加\n>\n> unshify()头加\n>\n> _Array.concat(...values) 合并两个数组\n>\n> - _Array: 数组\n> - values: 可以为数组或非数组\n> - result: 都会合并为一个数组\n>\n\n#### 删除\n\n> pop() 尾删\n>\n> shift() 头删\n\n#### 子数组\n\n> - splice()\n>   - 删除任意数量: `splice( [删除的其实坐标], [要删除的项] )`\n>   - 在指定位置插入指定的项目: `splice([起始坐标], 0 ,[插入的项])`\n>   - 替换任意数量的项: `splice([起始坐标], [要删除的数量], [要插入的项目])`\n> - slice()\n>   - 功能: 从已有数组中选取部分元素构成新的数组\n>   - 用法: `slice([起始位置], [结束位置])`\n>   - 特性:\n>     - 如果位置为负数, 则用数组长度加上改值确认位置\n>     - 起始位置为数组实际下标\n>     - 结束位置为实际下标减一\n\n#### 数组排序\n\n> - reverse():  颠倒数组中的元素顺序\n> - sort(): 排序\n>   - 按照数值大小排序需要函数支持\n\n#### 数组转换\n\n> toString()\n>\n> toLocaleString() :转换为本地格式字符串并返回\n>\n> join() 用指定分隔符连接数组并转换成字符串\n\n#### 位置方法\n\n> indexOf 起始位置开始查找\n>\n> lastIndexOf 结束位置开始查找\n\n### 迭代方法\n\n- every : 每一项都返回true,则返回true\n\n- filter : 返回值为true的所有数组\n\n  - filter(callback, _this),有两个参数，第一个是必须有的回调函数，第二个是可以选择的回调函数执行中的this值\n  - callback(element, index, array),回调函数有三个参数，第一个参数是必须有的，是指当前元素的值。第二个参数是指当前元素的索引值，可选。第三个参数是指被遍历的数组本身，可选。\n  - 过滤掉数组中大于3的元素:\n    `[1, 2, 3, 4].filter(item=>item<3);`\n\n- forEach : 就是遍历,无返回值(undefined)\n\n  - Array.prototype.forEach();\n    1. forEach(callback, [ _this ]) 遍历方法中有两个参数，一个是必须的会有的回调函数，第二个是可选择的回调函数执行的this值\n  \n    2. callback()回调函数的参数\n\n       1. callback(value){},当回调函数的参数只有一个的时候，这个参数的就是每个元素的值\n       2. callback(value, index){},当回调函数的参数有两个的时候，value 是每个元素的值，index 就是每个元素的索引\n       3. callback(value, index, array){}, 当回调函数的有三个的时候，value 是每个元素的值，index 就是每个元素的索引，array 指的是当前数组\n\n- map : **返回每次函数调用的结果数组**\n\n  ```\n    1. map(callback, [_this]) 遍历中有两个参数，一个是必须有的回调函数，第二个是可选择的回调函数执行的this值。\n  \n    2. callback()回调函数的参数\n     callback(value){},当回调函数的参数只有一个的时候，这个参数的就是每个元素的值\n     callback(value, index){},当回调函数的参数有两个的时候，value 是每个元素的值index 就是每个元素的索引。\n     callback(value, index, array){}, 当回调函数的有三个的时候，value 是每个元素的值，index 就是每个元素的索引，array 指的是当前数组。\n  ```\n\n- some : 有一项返回true,则返回true\n\n  ```js\n  1. some(callback, _this_)，有三个参数，\n    数组，可选。\n    _this_是指回调函数执行中的this值。\n    \n  2. callback(element, index, array)\n    第一个参数是指，正在处理的元素。\n    第二参数是指，当前当前元素的索引值，可选。\n    第三个参数是指，调用some()的数组。\n    \n    [1,2,3,4].some(x => x>10);//false\n  ```\n\n- reduce : 起始位置开始遍历\n\n  ```\n   1. reduce(callback, init); 有两个参数，第一个参数是必须有的回调函数，第二个是遍历之前的初始值。\n   2. callback(acc, cur, [index], [arr]); 有四个参数，acc是指累加器，cur是指当前的元素值，index 是指当前元素的索引值，arr 是指当前的遍历的数组\n  ```\n  \n- 累加\n  \n  ```js\n    var arr = [1,2,3,4,5]\n    arr.reduce(function(acc, cur){\n        return acc + cur;\n    },0)\n    \n    // 返值为 15\n  ```\n  \n- 去重\n  \n  ```js\n    var arr = [];\n    arr.reduce(function(acc, cur){\n        acc.indexOf(cur) === -1 && acc.push(cur);\n        return acc;\n    },[])\n  ```\n  \n- reduceRight : 尾部开始遍历\n\n  - 接收参数\n    - 每一项上调用的函数\n    - 作为缩小基础的初始值\n  - 传入参数\n    - 前一个值prev\n    - 当前值cur\n    - 项的索引index\n    - 数组对象array\n  \n  ```js\n  // 累加器\n  console.log( arr.reduceRight( (prev , cur) => {\n    return prev + cur;\n  }))\n  ```\n  \n## 数组拓展\n\n### Array.from()\n\n> `Array.from`方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。\n\n```js\nlet arrayLike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n};\n\n// ES5的写法\nvar arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']\n\n// ES6的写法\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n\nArray.from({ length: 2 }, () => 'jack')\n// ['jack', 'jack']\n```\n\n### Array.of()\n\n> 将一组值转换成数组\n\n```js\nArray.of(3, 11, 8) // [3,11,8]\n```\n\n### copyWithin()\n\n> 指定数组的元素复制到指定位置\n>\n> - Array.prototype.copyWithin(target, start = 0, end = this.length)\n>   - target（必需）：从该位置开始替换数据。\n>   - start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。\n>   - end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。\n>\n> ```javascript\n> [1, 2, 3, 4, 5].copyWithin(0, 3)// 将第四个数据到最后的数据复制到下标为零的地方开始\n> // [4, 5, 3, 4, 5]\n> ```\n\n### find()和findIndex()\n\n> find() : 查找数组相应的元素\n>\n> findIndex() :  查找对应元素的下标\n>\n> - 只会返回第一个满足条件的元素下标\n> - 没有满足的返回 -1\n\n```js\n[1, 4, -5, 10].find((n) => n < 0)\n// -5\n\n[1, 5, 10, 15].find(function(value, index, arr) {\n  return value > 9;\n}) // 10\n\n[1, 4, -5, 10 ].findIndex( n => n > 9) // 3\n```\n\n### fill()\n\n> 给定值填充为一个数组\n\n```js\nnew Array(3).fill(7)\n// [7, 7, 7]\n```\n\n### entries()，keys()和values()\n\n> keys() : 返回当前元素的下标\n>\n> values() : 返回当前元素的值\n>\n> entries() : 返回每个元素的`key - value`对\n\n```js\nfor (let index of ['a', 'b'].keys()) {\n  console.log(index);\n}\n// 0\n// 1\n\nfor (let elem of ['a', 'b'].values()) {\n  console.log(elem);\n}\n// 'a'\n// 'b'\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n  console.log(index, elem);\n}\n// 0 \"a\"\n// 1 \"b\"\n```\n\n### includes()\n\n> `Array.prototype.includes`方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的`includes`方法类似。该方法属于ES7，但Babel转码器已经支持\n\n```js\n[1, 2, 3].includes(2);     // true\n[1, 2, 3].includes(4);     // false\n[1, 2, NaN].includes(NaN); // true\n//第二个参数:匹配比较\n[1, 2, 3].includes(3, 3);  // false\n[1, 2, 3].includes(3, -1); // true\n```\n\n## 3.1 扁平化n维数组\n\n1.终极篇\n\n```\n[1,[2,3]].flat(1) //[1,2,3]\n[1,[2,3,[4,5]]].flat(2) //[1,2,3,4,5]\n[1,[2,3,[4,5]]].toString()  //'1,2,3,4,5'\n[1[2,3,[4,5[...]].flat(Infinity) //[1,2,3,4...n]\n\n```\n\nArray.flat(n)是ES10扁平数组的api,n表示维度,n值为Infinity时维度为无限大\n\n2.开始篇\n\n```\nfunction flatten(arr) {\n    while(arr.some(item=>Array.isArray(item))) {\n        arr = [].concat(...arr);\n    }\n    return arr;\n}\nflatten([1,[2,3]]) //[1,2,3]\nflatten([1,[2,3,[4,5]]) //[1,2,3,4,5]\n\n```\n\n实质是利用递归和数组合并方法concat实现扁平\n\n## 3.2 去重\n\n1.终极篇\n\n```js\nArray.from(new Set([1,2,3,3,4,4])) //[1,2,3,4]\n[...new Set([1,2,3,3,4,4])] //[1,2,3,4]\n\n```\n\nset是ES6新出来的一种一种定义不重复数组的数据类型 Array.from是将类数组转化为数组 ...是扩展运算符,将set里面的值转化为字符串 2.开始篇\n\n```js\nArray.prototype.distinct = function() {\n    const map = {}\n    const result = []\n    for (const n of this) {\n        if (!(n in map)) {\n            map[n] = 1\n            result.push(n)\n        }\n    }\n    return result\n}\n[1,2,3,3,4,4].distinct(); //[1,2,3,4]\n\n```\n\n取新数组存值,循环两个数组值相比较\n\n## 3.3排序\n\n1.终极篇\n\n```js\n[1,2,3,4].sort((a, b) => a - b); // [1, 2,3,4],默认是升序\n[1,2,3,4].sort((a, b) => b - a); // [4,3,2,1] 降序\n\n```\n\nsort是js内置的排序方法,参数为一个函数 2.开始篇 冒泡排序:\n\n```js\nArray.prototype.bubleSort=function () {\n    let arr=this,\n        len = arr.length;\n    for (let outer = len; outer >= 2; outer--) {\n      for (let inner = 0; inner <= outer - 1; inner++) {\n        if (arr[inner] > arr[inner + 1]) {\n          //升序\n          [arr[inner], arr[inner + 1]] = [arr[inner + 1], arr[inner]];\n          console.log([arr[inner], arr[inner + 1]]);\n        }\n      }\n    }\n    return arr;\n  }\n[1,2,3,4].bubleSort() //[1,2,3,4]    \n\n```\n\n选择排序\n\n```js\nArray.prototype.selectSort=function () {\n  let arr=this,\n      len = arr.length;\n  for (let i = 0, len = arr.length; i < len; i++) {\n    for (let j = i, len = arr.length; j < len; j++) {\n      if (arr[i] > arr[j]) {\n        [arr[i], arr[j]] = [arr[j], arr[i]];\n      }\n    }\n  }\n  return arr;\n}\n[1,2,3,4].selectSort() //[1,2,3,4] \n```\n\n## 3.4最大值\n\n1.终极篇\n\n```js\nMath.max(...[1,2,3,4]) //4\nMath.max.apply(this,[1,2,3,4]) //4\n[1,2,3,4].reduce( (prev, cur,curIndex,arr)=> {\n return Math.max(prev,cur);\n},0) //4\n\n```\n\nMath.max()是Math对象内置的方法,参数是字符串; reduce是ES5的数组api,参数有函数和默认初始值; 函数有四个参数,pre(上一次的返回值),cur(当前值),curIndex(当前值索引),arr(当前数组)\n\n2.开始篇 先排序再取值\n\n## 3.5求和\n\n1.终极篇\n\n```js\n[1,2,3,4].reduce(function (prev, cur) {\n   return prev + cur;\n },0) //10 \n\n```\n\n2.开始篇\n\n```js\nfunction sum(arr) {\n  var len = arr.length;\n  if(len == 0){\n    return 0;\n  } else if (len == 1){\n    return arr[0];\n  } else {\n    return arr[0] + sum(arr.slice(1));\n  }\n}\nsum([1,2,3,4]) //10\n\n```\n\n利用slice截取改变数组,再利用递归求和\n\n## 3.6合并\n\n1.终极篇\n\n```js\n[1,2,3,4].concat([5,6]) //[1,2,3,4,5,6]\n[...[1,2,3,4],...[4,5]] //[1,2,3,4,5,6]\nlet arrA = [1, 2], arrB = [3, 4]\nArray.prototype.push.apply(arrA, arrB))//arrA值为[1,2,3,4]\n\n```\n\n2.开始篇\n\n```js\nlet arr=[1,2,3,4];\n  [5,6].map(item=>{\n   arr.push(item)\n })\n //arr值为[1,2,3,4,5,6],注意不能直接return出来,return后只会返回[5,6]\n\n```\n\n## 3.7判断是否包含值\n\n1.终极篇\n\n```js\n[1,2,3].includes(4) //false\n[1,2,3].indexOf(4) //-1 如果存在换回索引\n[1, 2, 3].find((item)=>item===3)) //3 如果数组中无值返回undefined\n[1, 2, 3].findIndex((item)=>item===3)) //2 如果数组中无值返回-1\n```\n\nincludes(),find(),findIndex()是ES6的api\n\n2.开始篇\n\n```\n[1,2,3].some(item=>{\n  return item===3\n}) //true 如果不包含返回false\n\n```\n\n## 3.8类数组转化\n\n1.终极篇\n\n```\nArray.prototype.slice.call(arguments) //arguments是类数组(伪数组)\nArray.prototype.slice.apply(arguments)\nArray.from(arguments)\n[...arguments]\n\n```\n\n类数组:表示有length属性,但是不具备数组的方法\n call,apply:是改变slice里面的this指向arguments,所以arguments也可调用数组的方法\n Array.from是将类似数组或可迭代对象创建为数组\n ...是将类数组扩展为字符串,再定义为数组\n\n2.开始篇\n\n```\nArray.prototype.slice = function(start,end){  \n      var result = new Array();  \n      start = start || 0;  \n      end = end || this.length; //this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键  \n      for(var i = start; i < end; i++){  \n           result.push(this[i]);  \n      }  \n      return result;  \n } \n\n```\n\n## 3.9每一项设置值\n\n1.终极篇\n\n```\n[1,2,3].fill(false) //[false,false,false] \n\n```\n\nfill是ES6的方法 2.开始篇\n\n```\n[1,2,3].map(() => 0)\n\n```\n\n## 3.10每一项是否满足\n\n```\n[1,2,3].every(item=>{return item>2}) //false\n\n```\n\nevery是ES5的api,每一项满足返回 true\n\n## 3.11有一项满足\n\n```\n[1,2,3].some(item=>{return item>2}) //true\n\n```\n\nsome是ES5的api,有一项满足返回 true\n\n## 3.12.过滤数组\n\n```\n[1,2,3].filter(item=>{return item>2}) //[3]\n\n```\n\nfilter是ES5的api,返回满足添加的项的数组\n\n## 3.13对象和数组转化\n\n```\nObject.keys({name:'张三',age:14}) //['name','age']\nObject.values({name:'张三',age:14}) //['张三',14]\nObject.entries({name:'张三',age:14}) //[[name,'张三'],[age,14]]\nObject.fromEntries([name,'张三'],[age,14]) //ES10的api,Chrome不支持 , firebox输出{name:'张三',age:14}\n\n```\n\n## 3.14 对象数组\n\n```js\n[{count:1},{count:2},{count:3}].reduce((p, e)=>p+(e.count), 0)\n```\n","children":[]}]}]},{"name":"时间","path":"../guanruihua.github.io/JavaScript","data":"","children":[{"name":"农历.md","path":"../guanruihua.github.io/JavaScript/时间","data":"# 农历\r\n\r\n> <https://github.com/jjonline/calendar.js/blob/master/calendar.js>\r\n> [公历与阳历对照表](https://www.hko.gov.hk/tc/gts/time/conversion.htm)\r\n> <https://blog.csdn.net/qq_43915356/article/details/110872220>\r\n> <https://blog.csdn.net/qq_33538651/article/details/114053664>\r\n\r\n## 农历1900-2100的润大小信息表\r\n\r\n```js\r\n// 农历1900-2100的润大小信息表\r\n// 0表示小月【29】，1表示大月【30】，将16进制转为2进制查看\r\nvar lunarInfo = [\r\n    0x04bd8, 0x04ae0, 0x0a570, 0x054d5, 0x0d260, 0x0d950, 0x16554, 0x056a0, 0x09ad0, 0x055d2, //1900-1909\r\n    0x04ae0, 0x0a5b6, 0x0a4d0, 0x0d250, 0x1d255, 0x0b540, 0x0d6a0, 0x0ada2, 0x095b0, 0x14977, //1910-1919\r\n    0x04970, 0x0a4b0, 0x0b4b5, 0x06a50, 0x06d40, 0x1ab54, 0x02b60, 0x09570, 0x052f2, 0x04970, //1920-1929\r\n    0x06566, 0x0d4a0, 0x0ea50, 0x06e95, 0x05ad0, 0x02b60, 0x186e3, 0x092e0, 0x1c8d7, 0x0c950, //1930-1939\r\n    0x0d4a0, 0x1d8a6, 0x0b550, 0x056a0, 0x1a5b4, 0x025d0, 0x092d0, 0x0d2b2, 0x0a950, 0x0b557, //1940-1949\r\n    0x06ca0, 0x0b550, 0x15355, 0x04da0, 0x0a5b0, 0x14573, 0x052b0, 0x0a9a8, 0x0e950, 0x06aa0, //1950-1959\r\n    0x0aea6, 0x0ab50, 0x04b60, 0x0aae4, 0x0a570, 0x05260, 0x0f263, 0x0d950, 0x05b57, 0x056a0, //1960-1969\r\n    0x096d0, 0x04dd5, 0x04ad0, 0x0a4d0, 0x0d4d4, 0x0d250, 0x0d558, 0x0b540, 0x0b6a0, 0x195a6, //1970-1979\r\n    0x095b0, 0x049b0, 0x0a974, 0x0a4b0, 0x0b27a, 0x06a50, 0x06d40, 0x0af46, 0x0ab60, 0x09570, //1980-1989\r\n    0x04af5, 0x04970, 0x064b0, 0x074a3, 0x0ea50, 0x06b58, 0x05ac0, 0x0ab60, 0x096d5, 0x092e0, //1990-1999\r\n    0x0c960, 0x0d954, 0x0d4a0, 0x0da50, 0x07552, 0x056a0, 0x0abb7, 0x025d0, 0x092d0, 0x0cab5, //2000-2009\r\n    0x0a950, 0x0b4a0, 0x0baa4, 0x0ad50, 0x055d9, 0x04ba0, 0x0a5b0, 0x15176, 0x052b0, 0x0a930, //2010-2019\r\n    0x07954, 0x06aa0, 0x0ad50, 0x05b52, 0x04b60, 0x0a6e6, 0x0a4e0, 0x0d260, 0x0ea65, 0x0d530, //2020-2029\r\n    0x05aa0, 0x076a3, 0x096d0, 0x04afb, 0x04ad0, 0x0a4d0, 0x1d0b6, 0x0d250, 0x0d520, 0x0dd45, //2030-2039\r\n    0x0b5a0, 0x056d0, 0x055b2, 0x049b0, 0x0a577, 0x0a4b0, 0x0aa50, 0x1b255, 0x06d20, 0x0ada0, //2040-2049\r\n    /**Add By JJonline@JJonline.Cn**/\r\n    0x14b63, 0x09370, 0x049f8, 0x04970, 0x064b0, 0x168a6, 0x0ea50, 0x06b20, 0x1a6c4, 0x0aae0, //2050-2059\r\n    0x0a2e0, 0x0d2e3, 0x0c960, 0x0d557, 0x0d4a0, 0x0da50, 0x05d55, 0x056a0, 0x0a6d0, 0x055d4, //2060-2069\r\n    0x052d0, 0x0a9b8, 0x0a950, 0x0b4a0, 0x0b6a6, 0x0ad50, 0x055a0, 0x0aba4, 0x0a5b0, 0x052b0, //2070-2079\r\n    0x0b273, 0x06930, 0x07337, 0x06aa0, 0x0ad50, 0x14b55, 0x04b60, 0x0a570, 0x054e4, 0x0d160, //2080-2089\r\n    0x0e968, 0x0d520, 0x0daa0, 0x16aa6, 0x056d0, 0x04ae0, 0x0a9d4, 0x0a2d0, 0x0d150, 0x0f252, //2090-2099\r\n    0x0d520\r\n    ], //2100\r\n\r\n```\r\n\r\n## 天干地支\r\n\r\n今年是壬寅虎年，那么具体是怎么来的呢？干支是天干和地支的总称，干支纪年法是中国历法上自古以来就一直使用的纪年方法。干支纪年法的组合方式是天干在前地支在后，以十天干和十二地支循环配合，每个组合代表一年，60年为一个循环。\r\n\r\n天干的计算方法是：年份减3，除以10所得的余数；地支的计算方法是：年份减3，除以12所得的余数。以2022年为例：天干为：(2022-3)/10=201···9；地支为：(2022-3)/12=167···3；对照天干地支表得出，2022年为壬寅年。\r\n\r\n因为公元4年为甲子年,所以计算时必须减3才能农历年元年相对应。\r\n\r\n“甲、乙、丙、丁、戊、己、庚、辛、壬、癸”称为十天干。\r\n\r\n“子、丑、寅、卯、辰、巳、午、未、申、酉、戌、亥”称为十二地支\r\n","children":[]},{"name":"时区.md","path":"../guanruihua.github.io/JavaScript/时间","data":"# 时区\n\n[Moment Timezone 中文网 (momentjs.cn)](http://momentjs.cn/timezone/)\n\n[文档 | Moment.js 中文网 (momentjs.cn)](http://momentjs.cn/docs/#/parsing/)\n\n[世界时区缩写及代表的地区-逍遥峡谷 (icoa.cn)](https://www.icoa.cn/a/611.html)\n\n[时间戳(Unix timestamp)转换工具 - 在线工具 (tool.lu)](https://tool.lu/timestamp/)\n","children":[]}]},{"name":"概念","path":"../guanruihua.github.io/JavaScript","data":"","children":[{"name":"import_xxx与import{}区别.md","path":"../guanruihua.github.io/JavaScript/概念","data":"# import_xxx与import\\{\\}区别\n\ntags:\n\n- import用法\n- front_end\n- es6\n\n> ES6中export与export default均可用于导出常量、函数、文件、模块等，你可以在其它文件或模块中通过import的两种方式对其进行导入。一个模块只能有一个export default,但可以有若干个export。 区别就在下面。\n>\n> 1. export与export default均可用于导出常量、函数、文件、模块等\n> 2. 在一个文件或模块中，export 、import可以有多个，export default仅有一个\n> 3. 通过export方式导出，**在导入时要加export default则不需要**\n> 4. export能直接导出变量表达式，export default不行\n","children":[]},{"name":"mvc&mvvm.md","path":"../guanruihua.github.io/JavaScript/概念","data":"# mvc&mvvm\n\n## MVC\n\n> MVC的思想：一句话描述就是Controller负责将Model的数据用View显示出来，换句话说就是在Controller里面把Model的数据赋值给View，比如在controller中写document.getElementById(\"box\").innerHTML = data[”title”]，只是还没有刻意建一个Model类出来而已。\n\n### M\n\n> Model模型\n\n> - 是应用程序中用于处理应用程序数据逻辑的部分\n> - 通常模型对象负责在数据库中存取数据\n> - 数据结构模型\n\n### V\n\n> View: 视图\n\n> - 是应用程序中处理数据显示的部分\n> - 通常视图是一句模型数据创建的\n\n### C\n\n> Controller: 控制器\n\n> - 是应用程序中处理用户交互的部分\n> - 通常控制器负责视图读取数据, 控制用户输入, 并向模型发送数据\n\n## MVVM\n\n> MVVM：Model、View、ViewModel\n\n> - 低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的\"View\"上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。\n> - 可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。\n> - 独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用 Expression Blend 可以很容易设计界面并生成 xml 代码。\n>\n> - 可测试。界面元素本来是比较难于测试的，而现在测试可以针对 ViewModel 来写。\n\n> **MVVM优点**\n>\n> MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model），有几大优点\n>\n> 1. **低耦合**。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的\"View\"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。\n>\n> 2. **可重用性**。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。\n>\n> 3. **独立开发**。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xml代码。\n>\n> 4. **可测试**。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。\n","children":[]},{"name":"模式.md","path":"../guanruihua.github.io/JavaScript/概念","data":"# 模式\n\n## 严格模式\n\n### 概念\n\n**理解**：除了正常运行模式(混杂模式)，ES5添加了第二种运行模式：\"严格模式\"（strict mode）。\n\n顾名思义，这种模式使得Javascript在更严格的语法条件下运行。\n\n**目的**：\n\n- 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为\n\n- 消除代码运行的一些不安全之处，为代码的安全运行保驾护航\n\n- 为未来新版本的Javascript做好铺垫\n\n### 使用\n\n- 针对整个脚本文件：将`use strict`放在脚本文件的第一行，则整个脚本文件将以严格模式运行。\n\n- 针对单个函数：将`use strict`放在函数体的第一行，则整个函数以严格模式运行。\n\nPS：如果浏览器不支持，则这句话只解析为一条简单的语句, 没有任何副作用。\n\n脚本文件的变通写法：因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。\n\n### 语法和行为改变\n\n- 必须用var声明变量\n\n- 禁止自定义的函数中的this指向window\n\n- 对象不能有重名的属性\n\n## 严格模式和普通模式的区别\n\n### 全局变量显式声明\n\n在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。\n\n### 禁止this关键字指向全局对象\n\n```javascript\nvar foo = function () {\n  console.log(this);\n}\n\nfoo();\n```\n\n上方代码中，普通模式打印的是window。严格模式下打印的是undefined。\n\n### 构造函数必须通过new实例化对象\n\n构造函数必须通过new实例化对象，否则报错。因为this为undefined，此时无法设置属性。\n\n比如说：\n\n```js\nvar Cat = function (name) {\n this.name = name;\n}\n\nCat('haha');\n```\n\n上方代码中，如果在严格模式下，则会报错。\n\n### 属性相关\n\n普通模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。\n\n普通模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，多个重名的参数属于语法错误。\n\n比如下面这样的代码：\n\n```javascript\n var obj = {\n  username: 'smyh';\n  username: 'vae'\n }\n```\n\n上面的代码，在严格模式下属于语法错误，因为有重名的属性。\n\n### 函数必须声明在顶层\n\n将来Javascript的新版本会引入\"块级作用域\"。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。\n\n### 新增关键字\n\n为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。\n","children":[]}]},{"name":"正则","path":"../guanruihua.github.io/JavaScript","data":"","children":[{"name":"RegExp.md","path":"../guanruihua.github.io/JavaScript/正则","data":"# RegExp\n\n## 基础用法\n\n```js\nconst s = 'aaa_aa_a'\nconst r1 = /a+/g\nconst r2 = /a+/y\n\nr1.exec(s) // [\"aaa\"]\nr2.exec(s) // [\"aaa\"]\n\nr1.exec(s) // [\"aa\"]\nr2.exec(s) // null\n```\n\n## String to RegExp\n\n```js\nlet temp = 'UAID'\nlet treg = '/' + temp + '/'\nlet reg = eval(treg)// 核心\n```\n\n## **y修饰符**\n\nES6为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。\n\ny修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。\n\n```js\nconst s = 'aaa_aa_a'\nconst r1 = /a+/g\nconst r2 = /a+/y\n\nr1.exec(s) // [\"aaa\"]\nr2.exec(s) // [\"aaa\"]\n\nr1.exec(s) // [\"aa\"]\nr2.exec(s) // null\n```\n\n上面代码有两个正则表达式，一个使用g修饰符，另一个使用y修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。\n\n如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。\n\n```js\nconst s = 'aaa_aa_a'\nconst r = /a+_/y\n\nr.exec(s) // [\"aaa_\"]\nr.exec(s) // [\"aa_\"]\n```\n\n使用lastIndex属性，可以更好地说明y修饰符。\n\n```js\nconst regexp = /a/g\n\n// 指定从2号位置（y）开始匹配\nregexp.lastIndex = 2\n\n// 匹配成功\nconst match = regexp.exec('xaya')\n\n// 在3号位置匹配成功\nconsole.log(match.index) // 3\n\n// 下一次匹配从4号位开始\nconsole.log(regexp.lastIndex) // 4\n\n// 4号位开始匹配失败\nregexp.exec('xaxa') // null\n```\n\n上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。\n\ny修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。\n\n```js\nconst regexp = /a/y\n\n// 指定从2号位置开始匹配\nregexp.lastIndex = 2\n\n// 不是粘连，匹配失败\nregexp.exec('xaya') // null\n\n// 指定从3号位置开始匹配\nregexp.lastIndex = 3\n\n// 3号位置是粘连，匹配成功\nconst match = regexp.exec('xaxa')\nconsole.log(match.index) // 3\nconsole.log(regexp.lastIndex) // 4\n```\n\n进一步说，y修饰符号隐含了头部匹配的标志^。\n\n```js\nconst reg = /b/y\nreg.exec('aba')\n// null\nconsole.log(reg.lastIndex)\n```\n\nsticky 模式在正则匹配过程中只会影响两件事：\n\n- 匹配必须从 re.lastIndex 开始（相当于正则表达中的 ^）\n\n- 如果匹配到会修改 re.lastIndex（相当于 g 模式）\n  **2.u修饰符**\n  ES6为正则表达式添加了u修饰符，含义为“Unicode模式”，用来正确处理大于 \\uFFFF 的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。\n\n  ```\n  /^\\uD83D/u.test('\\uD83D\\uDC2A') // false\n  \n  /^\\uD83D/.test('\\uD83D\\uDC2A') // true\n  ```\n\n  上面代码中， \\uD83D\\uDC2A 是一个四个字节的UTF-16编码，代表一个字符 \"🐪\"。但是，ES5不支持四个字节的UTF-16编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6就会识别其为一个字符，所以第一行代码结果为false。\n\n一旦加上u修饰符号，就会修改下面这些正则表达式的行为。\n\n- 点字符\n  点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于 0xFFFF 的 Unicode 字符，点字符不能识别，必须加上u修饰符。\n\n  ```\n  let s = '𠮷'\n  \n  /^.$/.test(s) // false\n  \n  /^.$/u.test(s) // true\n  ```\n\n- Unicode字符表示法\n  ES6新增了使用大括号表示Unicode字符，这种表示法在正则表达式中必须加上u修饰符，才能识别。\n\n  ```\n  /\\u{61}/.test('a') // false\n  \n  /\\u{61}/u.test('a') // true\n  \n  /\\u{20BB7}/u.test('𠮷') // true\n  ```\n\n- 量词\n  使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的Unicode字符。\n\n  ```\n  /a{2}/.test('aa') // true\n  \n  /a{2}/u.test('aa') // true\n  \n  /𠮷{2}/.test('𠮷𠮷') // false\n  \n  /𠮷{2}/u.test('𠮷𠮷') // true\n  ```\n\n- 预定义模式\n  u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的Unicode字符。\n\n  ```\n  /^\\S$/.test('𠮷') // false\n  \n  /^\\S$/u.test('𠮷') // true\n  ```\n\n  上面代码的\\S是预定义模式，匹配所有不是空格的字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的Unicode字符。\n\n利用这一点，可以写出一个正确返回字符串长度的函数。\n\n```\nfunction codePointLength(text) {\n    const result = text.match(/[\\s\\S]/gu)\n    return result ? result.length : 0\n}\n\nconst s = '𠮷𠮷'\n\ns.length // 4\ncodePointLength(s) // 2\n```\n\n## i修饰符\n\n有些Unicode字符的编码不同，但是字型很相近，比如，\\u004B与\\u212A都是大写的K。\n\n```js\n/[a-z]/i.test('\\u212A') // false\n\n/[a-z]/iu.test('\\u212A') // true\n```\n\n上面代码中，不加u修饰符，就无法识别非规范的K字符。\n","children":[]},{"name":"正则.md","path":"../guanruihua.github.io/JavaScript/正则","data":"# 正则\n\n## 创建\n\n- 字面量    `var [变量名] = /表达式/模式修饰符`\n- 构造函数   `var [变量名] = new RegExp(\"表达式\", \"模式修饰符\")`\n\n  ```javascript\n    var str = \"guanruihua\"\n    var patt = /rui/i\n    document.write(str.match(patt))\n    document.write(str.test(patt))\n    ```\n\n## 规则\n\n### 单个字符与数字\n\n| 标识符      | 描述                   |\n| :---------- | :--------------------- |\n| `.   :`     | 除换行符之外的任意字符 |\n| `[a-z0-9]`  | 方括号中的任意字符     |\n| `[^a-z0-9]` | 不在方括号中的任意字符 |\n| `\\d`        | 数字                   |\n| `\\D`        | 非数值                 |\n| `\\w`        | 字母                   |\n| `\\W`        | 非字母                 |\n\n### 空白字符\n\n| 标识符 | 描述                            |\n| :----- | :------------------------------ |\n| `\\0`   | null                            |\n| `\\b`   | 空格                            |\n| `\\f`   | 换页符                          |\n| `\\n`   | 换行符                          |\n| `\\r`   | 回车符                          |\n| `\\s`   | 空白字符,空格符, 制表符, 换行符 |\n| `\\S`   | 非空白字符                      |\n| `\\t`   | 制表符                          |\n\n### 定位符\n\n| 标识符 | 描述                       |\n| :----- | :------------------------- |\n| `^`    | 行首匹配符                 |\n| `$`    | 行尾匹配符                 |\n| `\\A`   | 值匹配字符串最开始处       |\n| `\\b`   | 匹配单词边界, 词在[]内无效 |\n| `\\B`   | 匹配非单词边界             |\n| `\\G`   | 匹配当前搜索的开始位置     |\n| `\\Z`   | 字符串结束处               |\n| `\\z`   | 只匹配字符串结束处         |\n\n### 限制符\n\n| 标识符    | 描述                  |\n| :-------- | :-------------------- |\n| `x?`      | 匹配0个或1个x         |\n| `x*`      | 匹配0个或任意多个x    |\n| `x+`      | 匹配至少一个x         |\n| `x{m, n}` | 匹配最少m个, 最多n个x |\n| `x        | y                     | z` | 匹配x或y或z(或模式) |\n\n## 断言\n\n| 标识符         | 描述             | 字符串                                  | 正则           | 结果                |\n| :------------- | :--------------- | :-------------------------------------- | :------------- | :------------------ |\n| `(?:x)`        | 匹配x            |\n| `(?=pattern)`  | 零宽正向先行断言 |\n| `(?!pattern)`  | 零宽负向先行断言 | `'regex represents regular expression'` | `/re(?!g)/g`   | `['re','re','re']`  |\n| `(?<=pattern)` | 零宽正向后行断言 | `'regex represents regular expression'` | `/(?<=\\w)re/g` | `['re','re']`       |\n| `(?<!pattern)` | 零宽负向后行断言 | `'regex represents regular expression'` | `/(?<!\\w)re/g` | `['re','re', 're']` |\n\n### 模式修饰符\n\n| 标识符 | 描述                     |\n| :----- | :----------------------- |\n| `g`    | 全局模式, 应用所有字符串 |\n| `i`    | 区分大小写模式           |\n| `m`    | 多行匹配模式             |\n\n## 属性\n\n- 实例属性\n  - global   检测是否设置g标记\n  - ignoreCase 检测是否设置i标记\n  - multiline  检测是否设置了m标记\n  - lastIndex 开始检索上一个匹配项的字符位置\n  - source   返回正则表达式的字符串表示\n  - nextIndex 返回被查找字符串中下一个成功匹配的开始位置\n- 构造函数属性\n  - \\$1....\\$9  返回就搞在模式匹配期间找的,最近保存的部分\n  - $_    input      返回最近一次匹配的字符串\n  - $&    lastMatch   返回最近一次的匹配项\n  - $+    lastParen    返回最近一次匹配的捕获组\n  - $`    leftContext   返回被查找的字符串中从字符串开始位置到最后匹配之前的位置之间的字符\n  - $'     rightContext 返回被搜索的字符串中从最后一个匹配位置开始到字符串结尾之间的字符\n  - $*     multiline   检测表达式是否采用多行模式匹配m\n\n## 方法\n\n### RegExp\n\n- exec\n  - 功能: 在字符串中执行匹配检索, 返回结果数组\n  - 参数:要应用模式匹配的字符串\n  - 特性:\n    - 使用全局标记g      持续查找所有匹配项并返回\n    - 不适用全局标记g  始终返回第一个匹配项信息\n  - 执行过程\n      1. 检索字符串参数, 获取正则表达式匹配文本\n      2. 找到匹配文本则返回一个数组\n         - 第0个元素    与整个模式匹配的字符串\n         - 其他元素      与捕获匹配的字符串\n      3. 否则返回null\n  - 派生属性\n    - index    匹配项在字符串中的位置\n    - input    应用正则表达式的字符串\n    - length   返回数组元素个数\n- test   功能   在字符串中测试模式匹配,  返回true或false\n\n### String\n\n- match    找到一个或多个正则表达式的匹配\n- replace   替换与正则表达式匹配的字符串\n- search    检索与正则表达式相配的值\n- split        把字符串分割为字符串数组\n\n## 案例\n\n### 数字的千位分隔符表示法\n\n```javascript\n// \"12345678\" => \"12,345,678\"\n\"12345678\".replace(/(?=\\d{3}$)/g, ',')\n\"12345678\".replace(/(?=(\\d{3})+$)/g, ',')\n\nvar string = \"12345678 123456789\"\nreg = /(?!\\b)(?=(\\d{3})+\\b)/g;\n\nvar result = string.replace(reg, ',')\nconsole.log(result); \n\n// => \"12,345,678 123,456,789\"\n```\n\n中文: `[\\u4e00-\\u9fa5]`\n\n1.由数字、26个英文字母或者下划线组成的字符串:\n\n ^[0-9a-zA-Z_]{1,}$\n1\n2.非负整数（正整数 + 0 ）:\n\n    ^/d+$\n1\n3.正整数:\n\n   ^[0-9]*[1-9][0-9]*$\n1\n4.非正整数（负整数 + 0）：\n\n   ^((-/d+)|(0+))$\n1\n5.负整数 :\n\n  ^-[0-9]*[1-9][0-9]*$\n1\n6.整数:\n\n ^-?/d+$\n1\n7.非负浮点数（正浮点数 + 0）:\n\n  ^/d+(/./d+)?$\n1\n8.正浮点数 :\n\n  ^(([0-9]+/.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*/.[0-9]+)|([0-9]*[1-9][0-9]*))$\n1\n9.非正浮点数（负浮点数 + 0）:\n\n    ^((-/d+(/./d+)?)|(0+(/.0+)?))$\n1\n10.负浮点数 :\n\n    ^(-(([0-9]+/.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*/.[0-9]+)|([0-9]*[1-9][0-9]*)))$\n1\n11.浮点数 :\n\n ^(-?/d+)(/./d+)?$\n1\n12.由26个英文字母组成的字符串 :\n\n    ^[A-Za-z]+$\n1\n13.由26个英文字母的大写组成的字符串 :\n\n  ^[A-Z]+$\n1\n14.由26个英文字母的小写组成的字符串 :\n\n    ^[a-z]+$\n1\n15.由数字和26个英文字母组成的字符串 :\n\n    ^[A-Za-z0-9]+$\n1\n16.由数字、26个英文字母或者下划线组成的字符串 :\n\n  ^/w+$\n1\n17.email地址 :\n\n   ^[/w-]+(/.[/w-]+)*@[/w-]+(/.[/w-]+)+$\n1\n18.url:\n\n    ^[a-zA-z]+://(/w+(-/w+)*)(/.(/w+(-/w+)*))*(/?/S*)?$\n1\n19.年-月-日:\n\n   /^(d{2}|d{4})-((0([1-9]{1}))|(1[1|2]))-(([0-2]([1-9]{1}))|(3[0|1]))$/\n1\n20.月/日/年:\n\n  /^((0([1-9]{1}))|(1[1|2]))/(([0-2]([1-9]{1}))|(3[0|1]))/(d{2}|d{4})$/\n1\n21.Emil:\n\n    ^([w-.]+)@(([[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.)|(([w-]+.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(]?)$\n1\n22.电话号码:\n\n    (d+-)?(d{4}-?d{7}|d{3}-?d{8}|^d{7,8})(-d+)?\n1\n23.IP地址:\n\n    ^(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5])$\n1\n24.匹配中文字符的正则表达式：\n\n   [/u4e00-/u9fa5]\n1\n25.匹配双字节字符(包括汉字在内)：\n\n   [^/x00-/xff]\n1\n26.匹配空行的正则表达式：\n\n    /n[/s| ]*/r\n1\n27.匹配HTML标记的正则表达式：\n\n  /<(.*)>.*<///1>|<(.*) //>/\n1\n28.匹配首尾空格的正则表达式：\n\n  (^/s*)|(/s*$)\n1\n29.匹配Email地址的正则表达式：\n\n    /w+([-+.]/w+)*@/w+([-.]/w+)*/./w+([-.]/w+)*\n1\n30.匹配网址URL的正则表达式：\n\n  ^[a-zA-z]+://(//w+(-//w+)*)(//.(//w+(-//w+)*))*(//?//S*)?$\n1\n31.匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：\n\n   ^[a-zA-Z][a-zA-Z0-9_]{4,15}$\n1\n32.匹配国内电话号码：\n\n    (/d{3}-|/d{4}-)?(/d{8}|/d{7})?\n1\n33.匹配腾讯QQ号：\n\n  ^[1-9]*[1-9][0-9]*$\n1\n34.只能输入数字：\n\n   ^[0-9]*$\n1\n35.只能输入n位的数字：\n\n^/d{n}$\n1\n36.只能输入至少n位的数字：\n\n^/d{n,}$\n1\n37.只能输入m~n位的数字：\n\n    ^/d{m,n}$\n1\n38.只能输入零和非零开头的数字：\n\n  ^(0|[1-9][0-9]*)$\n1\n39.只能输入有两位小数的正实数：\n\n  ^[0-9]+(.[0-9]{2})?$\n1\n40.只能输入有1~3位小数的正实数：\n\n ^[0-9]+(.[0-9]{1,3})?$\n1\n41.只能输入非零的正整数：\n\n   ^/+?[1-9][0-9]*$\n1\n42.只能输入非零的负整数：\n\n  ^/-[1-9][0-9]*$\n1\n43.只能输入长度为3的字符：\n\n  ^.{3}$\n1\n44.只能输入由26个英文字母组成的字符串：\n\n ^[A-Za-z]+$\n1\n45.只能输入由26个大写英文字母组成的字符串：\n\n    ^[A-Z]+$\n1\n46.只能输入由26个小写英文字母组成的字符串：\n\n    ^[a-z]+$\n1\n47.只能输入由数字和26个英文字母组成的字符串：\n\n ^[A-Za-z0-9]+$\n1\n48.只能输入由数字和26个英文字母或者下划线组成的字符串：\n\n    ^/w+$\n1\n49.验证用户密码(正确格式为： 以字母开头，长度在5~17 之间，只能包含字符、数字和下划线)\n\n  ^[a-zA-Z]/w{5,17}$\n1\n50.验证是否包含有 ^%&’,;=?$/\"等字符：\n\n [^%&',;=?$/x22]+\n1\n51.只能输入汉字：\n\n  ^[\\u4e00-\\u9fa5]{0,}$\n1\n52、只含有汉字、数字、字母、下划线不能以下划线开头和结尾\n\n   ^(?!_)[?!.*?_$](a-zA-Z0-9_\\u4e00-\\u9fa5)+$\n1\n53、只含有汉字、数字、字母、下划线，下划线位置不限\n\n    ^[a-zA-Z0-9_\\u4e00-\\u9fa5]+$\n1\n54、2~4个汉字\n\n @\"^[\\u4E00-\\u9FA5]{2,4}$\n","children":[]}]},{"name":"监听.md","path":"../guanruihua.github.io/JavaScript","data":"# 监听\n\n## 监听器监听自定义事件\n\n### 创建event的对象实例, 表示事件类型（createEvent事件）\n\n```js\nvar event = document.createEvent(\"HTMLEvents\");\n```\n\n- UIEvents UI 事件,用于触摸屏设备\n- MouseEvents 鼠标事件\n- MutationEvents Dom结构发生改变触发的事件\n- HTMLEvents Html事件\n\n### 初始化event对象的属性(initEvent事件)\n\n```js\n// eventType事件名，canBubble是否冒泡，cancelable是否可以使用preventDefault取消事件\nevent.initEvent(eventType事件名, canBubble, cancelable);\n```\n\n- eventType 可以是已经定义好的事件，例如click、submit等，经过初始化后可以直接通过对应的操作进行触发。事件类型如果是自定义的，就需要使用dispachEvent事件进行触发。\n\n### 触发自定义事件(dispachEvent事件)\n\n```js\n// 返回值为 布尔值\n// 当event.cancalable为 false，都会返回true。\ntarget.dispachEvent(event);\n```\n","children":[]},{"name":"类型","path":"../guanruihua.github.io/JavaScript","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/JavaScript/类型","data":"# 判断JS数据类型的四种方法\n\n在 ECMAScript 规范中，共定义了 7 种数据类型，分为 `基本类型` 和 `引用类型` 两大类，如下所示：\n\n- **基本类型**：String、Number、Boolean、Symbol、Undefined、Null\n- **引用类型**：Object\n\n- 基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。\n\n- 引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(heap)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 Object 外，还包括 Function 、Array、RegExp、Date 等等。\n\n## **typeof**\n\n- 对于基本类型，除 null 以外，均可以返回正确的结果\n- 对于引用类型，除 function 以外，一律返回 object 类型\n- 对于 null ，返回 object 类型\n- 对于 function 返回  function 类型\n\n```js\ntypeof '';// string 有效\ntypeof 1;// number 有效\ntypeof Symbol();// symbol 有效\ntypeof true;//boolean 有效\ntypeof undefined;//undefined 有效\ntypeof null;//object 无效\ntypeof [] ;//object 无效\ntypeof new Function();// function 有效\ntypeof new Date();//object 无效\ntypeof new RegExp();//object 无效\n```\n\n- null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型，没有错，但不是我们想要的结果。\n\n## **instanceof**\n\ninstanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：**instanceof 检测的是原型**，我们用一段伪代码来模拟其内部执行过程：\n\n```js\ninstanceof (A,B) = {\n    var L = A.__proto__;\n    var R = B.prototype;\n    if(L === R) {\n        // A的内部属性 __proto__ 指向 B 的原型对象\n        return true;\n    }\n    return false;\n}\n```\n\n- 当 A 的 **proto** 指向 B 的 prototype 时，就认为 A 就是 B 的实例，我们再来看几个例子：\n\n```js\n[] instanceof Array;// true\n{} instanceof Object;// true\nnewDate() instanceof Date;// true\n \nfunction Person(){};\nnew Person() instanceof Person;\n \n[] instanceof Object;// true\nnewDate() instanceof Object;// true\nnewPerson instanceof Object;// true\n```\n\n我们发现，虽然 instanceof 能够判断出 [ ] 是Array的实例，但它认为 [ ] 也是Object的实例，为什么呢？\n\n我们来分析一下 [ ]、Array、Object 三者之间的关系：\n\n从 instanceof 能够判断出 [ ].**proto**  指向 `Array.prototype`，而 `Array.prototype.**proto**` 又指向了`Object.prototype`，最终 `Object.prototype.__proto__` 指向了null，标志着原型链的结束。因此，[]、Array、Object 就在内部形成了一条原型链：\n\n![img](index.assets/849589-20160112232510850-2003340583.png)\n\n从原型链可以看出，[] 的 **proto**  直接指向Array.prototype，间接指向 Object.prototype，所以按照 instanceof 的判断规则，[] 就是Object的实例。依次类推，类似的 new Date()、new Person() 也会形成一条对应的原型链 。因此，**instanceof 只能用来判断两个对象是否属于实例关系****， 而不能判断一个对象实例具体属于哪种类型。**\n\ninstanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。\n\n```js\nvariframe = document.createElement('iframe');\ndocument.body.appendChild(iframe);\nxArray = window.frames[0].Array;\nvararr =newxArray(1,2,3);// [1,2,3]\narr instanceof Array;// false\n```\n\n针对数组的这个问题，ES5 提供了 Array.isArray() 方法 。该方法用以确认某个对象本身是否为 Array 类型，而不区分该对象在哪个环境中创建。\n\n```js\nif(Array.isArray(value)){\n   //对数组执行某些操作\n}\n```\n\nArray.isArray() 本质上检测的是对象的 [[Class]] 值，[[Class]] 是对象的一个内部属性，里面包含了对象的类型信息，其格式为 [object Xxx] ，Xxx 就是对应的具体类型 。对于数组而言，[[Class]] 的值就是 [object Array] 。\n\n## **constructor**\n\n当一个函数 F被定义时，JS引擎会为F添加 prototype 原型，然后再在 prototype上添加一个 constructor 属性，并让其指向 F 的引用。如下所示：\n\n![img](index.assets/849589-20170508125250566-1896556617.png)\n\n当执行 var f = new F() 时，F 被当成了构造函数，f 是F的实例对象，此时 F 原型上的 constructor 传递到了 f 上，因此 f.constructor == F\n\n![img](index.assets/849589-20170508125714941-1649387639.png)\n\n可以看出，F 利用原型对象上的 constructor 引用了自身，当 F 作为构造函数来创建对象时，原型上的 constructor 就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。\n\n同样，JavaScript 中的内置对象在内部构建时也是这样做的：\n\n![img](index.assets/849589-20170508131800457-2091987664.png)\n\n**细节问题：**\n\n1. null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。\n2. 函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object\n\n![img](index.assets/849589-20170508132757347-1999338357.png)\n\n为什么变成了 Object？\n\n- 因为 prototype 被重新赋值的是一个 { }， { } 是 new Object() 的字面量，因此 new Object() 会将 Object 原型上的 constructor 传递给 { }，也就是 Object 本身。\n\n- 因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改。\n\n### **toString**\n\n- toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 `[[Class]]` 。这是一个内部属性，其格式为 `[object Xxx]`，其中 Xxx 就是对象的类型。\n\n- 对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。\n\n```js\nObject.prototype.toString.call('') ;  // [object String]\nObject.prototype.toString.call(1) ;   // [object Number]\nObject.prototype.toString.call(true) ;// [object Boolean]\nObject.prototype.toString.call(Symbol());//[object Symbol]\nObject.prototype.toString.call(undefined) ;// [object Undefined]\nObject.prototype.toString.call(null) ;// [object Null]\nObject.prototype.toString.call(newFunction()) ;// [object Function]\nObject.prototype.toString.call(newDate()) ;// [object Date]\nObject.prototype.toString.call([]) ;// [object Array]\nObject.prototype.toString.call(newRegExp()) ;// [object RegExp]\nObject.prototype.toString.call(newError()) ;// [object Error]\nObject.prototype.toString.call(document) ;// [object HTMLDocument]\nObject.prototype.toString.call(window) ;//[object global] window 是全局对象 global 的引用\n```\n","children":[]}]},{"name":"类型.md","path":"../guanruihua.github.io/JavaScript","data":"# 数据相关\r\n\r\n## null-undefine-NaN\r\n\r\n```js\r\nconsole.log(typeof null);      // 输出 object\r\nconsole.log(typeof NaN);      //输出number\r\nconsole.log(typeof undefined);  //输出undefined\r\n```\r\n\r\n## json相关\r\n\r\n> json 是一种轻量级数据格式, 独立于编程语言来表示和存储数据\r\n> json字符串 => json对象 : `JSON.parse(\"{'a':'hello'}\")`\r\n> json对象 => json字符串 : `JSON.stringify({'a':123})`\r\n\r\n## parseInt(0.0000008) === 8？\r\n\r\n### IEEE 754\r\n\r\nJavaScript 的数字系统是采用 IEEE 754，一开始看到这个问题，以为是 IEEE 754 导致的问题。\r\n\r\n常见的问题有浮点数比较：\r\n\r\n```js\r\nconsole.log((0.1 + 0.2) == 0.3);  // false\r\nconsole.log((0.1 + 0.2) === 0.3); // false\r\nconsole.log(0.1 + 0.2); // 0.30000000000000004\r\n123\r\n```\r\n\r\n后来发现这问题并不会导致 `parseInt(0.0000008)` 变成 `8`，那么问题就可能在 `parseInt` 这个函数上。\r\n\r\n```basic\r\n## parseInt\r\n> `parseInt(string, radix)`\r\n12\r\n```\r\n\r\n`parseInt` 接受两个参数，第一个参数是要转换的字符串（忽略空白）；第二个参数是基数。\r\n\r\n例如：\r\n\r\n```js\r\nparseInt('   12', 10);  // 12\r\nparseInt('12**', 10);   // 12\r\nparseInt('12.34', 10);  // 12\r\nparseInt(12.34, 10);    // 12\r\n1234\r\n```\r\n\r\n最后一个例子让我们看到 `parseInt` 可以将数字类型转换成整数，但最好别这么做。\r\n\r\n再来看下面这个例子：\r\n\r\n```js\r\nparseInt(1000000000000000000000.5, 10); // 1\r\n```\r\n\r\n为什么会这样呢？\r\n\r\n`parseInt` 的第一个类型是字符串，所以会将传入的参数转换成字符串，也就是 `String(1000000000000000000000.5)` 的结果为 `'1e+21'`。`parseInt` 并没有将 `'e'` 视为一个数字，所以在转换到 `1` 后就停止了。\r\n\r\n这也就可以解释 `parseInt(0.0000008) === 8`：\r\n\r\n```js\r\nString(0.000008);  // '0.000008'\r\nString(0.0000008); // '8e-7'\r\n12\r\n```\r\n\r\n从上面的程式码可以看出，小于 `0.0000001`（1e-7） 的数字转换成 `String` 时，会变成科学记号法，再对这个数进行 `parseInt` 操作就会导致这个问题发生。\r\n\r\n### 结论\r\n\r\n> 不要将 `parseInt` 当做转换 `Number` 和 `Integer` 的工具。\r\n\r\n再补上一些悲剧：\r\n\r\n```js\r\nparseInt(1/0, 19);      // 18\r\nparseInt(false, 16);    // 250\r\nparseInt(parseInt, 16); // 15\r\nparseInt(\"0x10\");       // 16\r\nparseInt(\"10\", 2);      // 2\r\n12345\r\n```\r\n","children":[]},{"name":"运算符","path":"../guanruihua.github.io/JavaScript","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/JavaScript/运算符","data":"# 运算符\n\n### 算术运算符\n\n#### 运算符\n\n##### +\n\n- 功能:\n  - 对数字进行代数求和\n  - 对字符串进行拼接\n  - 将一个数值转换成字符串(数值+空字符串)\n  - 字符串拼接:\n    - 字符串+字符串 : 二者直接拼接\n    - 字符串+数值 : 数值转换为字符串再拼接-\n\n##### -\n\n- 功能:  \n  - 对操作数进行取反\n  - 对数字进行减法操作\n  - ==将字符串转换成数值 ( 数值型字符串 - 0 )==\n\n##### *  : 乘  / : 除法  % : 取余\n\n#### 符合赋值运算符\n\n += , -=, *=,/=, %=\n\n#### 自增自减 -- ++\n\n 符号放前就先算\n\n#### 关系运算符\n\n < , > , < = ,> = , ===, ! ==\n\n- 字符串间比较=>比较他们的Unicode数值\n- 与NaN的比较,返回false\n\n#### 对象运算符\n\n- in : 判断左侧运算数是否为右侧运算数的成员\n- instanceof : 判断对象实例是否输入某个类或构造函数\n- new : 根据构造函数创建一个新的对象, 并初始化该对象\n- delete : 删除指定对象的饿属性, 数组元素或变量\n- .及[] : 存取对象和数组元素\n- {} : 函数调用,改变运算符优先级等\n\n#### 逻辑运算符\n\n !, &&, ||\n\n- 非 ! :\n  - 返回值:\n    - true: 空字符串, 0, null, NaN, undefined\n    - false: 对象, 非空字符串 , 非0数字(Infinity)\n  - 特性:\n    - 连续使用两次,可以将任何类型转换成布尔类型\n- 与 && :\n  - 规则:\n    - 第一个操作数是对象 返回第二个操作数\n    - 第二个操作数是对象 第一个操作数值为true时返回该对象\n    - 两个操作数都是对象 返回第二个操作数\n    - 一个操作数是null 返回null\n    - 一个操作数是NaN 返回NaN\n    - 一个操作数是undefined 返回undefined\n  - 特性:\n    - 当且仅当两个运算数的值都是true时,才返回true,否则都是false\n    - 短路操作  当第一个操作数是false则不在对第二个操作数进行求值\n- 或 || :\n  - 规则:\n    - 第一个操作数是对象  返回第一个操作数\n    - 第一个操作数值为false 返回第二操作数\n    - 两个操作数都是对象 返回第一个操作数\n    - 两个操作数都是null 返回null\n    - 两个操作数都是NaN 返回NaN\n    - 两个操作数都是undefined 返回undefined\n  - 特性:\n    - 当且仅当两个运算数值都是false时, 才返回false , 否则返回true\n    - 如果第一个操作数值为true, 则不会对第二个操作数进行求值\n\n#### 位运算符\n\n javaScript位运算不比普通运算有效率提升\n\n##### 基础知识\n\n- 类型:\n  - 有符号 : 一位符号 +  31位数值位\n  - 无符号:\n    - 只能是正数\n    - 32位数值位(0正 1负)\n    - 数值范围可以加大\n- 数值范围: -$2^{31}$ ~ $2^{31}$-1\n- 存储方式:\n  - 正数\n    - 纯二进制存储\n    - 31位中每一位表示2的幂\n    - 用0补充无用位\n  - 负数\n    - 二进制补码存储\n\n- NaN和Infinity做0存储\n\n##### 逻辑位运算\n\n ~, &, |, ^(异或)\n\n##### 位移\n\n- $<<$左移: 数值位左移$x$位置(除以$2^{x}$)\n\n- $>>$有符号右移:数值位右移$x$位置(乘以$2^{x}$)\n- $>>>$无符号右移:\n  - 正数: 和$>>$相同\n  - 负数: 会出现无限大的数值\n- 复合赋值运算符: 位操作符与等号结合, 复合赋值不会有性能提升\n\n其他运算符\n\n- ?: 三目运算符\n\n typeof:类型判定运算符\n\n void 舍弃运算符的值,返回undefined作为表达式值\n","children":[]},{"name":"js运算符号.md","path":"../guanruihua.github.io/JavaScript/运算符","data":"# js运算符\n\n## `||`\n\n> 1. 同真输左\n>\n> 2. 有真输真\n>\n> 3. 同假输右\n>\n>    总结: `从左到右, 只要有真就输出, 碰到为假的就会往后遍历, 若是最后一个, 就输出最后一个`\n\n## `&&`\n\n> 1. 同真输右\n>\n> 2. 同假输左\n>\n> 3. 有假输假\n>\n>    总结: `从左到右, 碰到有假就输出, 碰到为真就往后遍历, 若是最后一个就输出最后一个`\n\n`|`\n\n> 1. 将`假`转换为0进行`|`位运算\n\n`&`\n\n> 1. 将`假`转换为0进行`&`位运算\n\n测试代码\n\n```js\nlet data = [\n  {\n    \"||\" :[\n      1 || 2 ,// 1\n      true || 2 ,// true\n      false || 2 , // 2\n      4 || true, // 4\n      5 || false, // 5\n      false || false,// false\n      undefined || undefined,// undefined\n      false || undefined,// undefined\n      false || NaN, // NaN\n      0 || false, // false\n      0 || NaN, // NaN\n      undefined || NaN, // NaN\n      undefined || 2 ,// 2\n      undefined || null ,// null\n      null || undefined, // undefined\n      NaN || 0, // 0\n      NaN || 2 ,// 2\n      0 || 2 ,// 2\n    ],\n    \"&&\": [\n      1 && 2 ,// 2\n      true && 2 ,// 2\n      false && 2 , // false\n      4 && true, // true\n      5 && false, // false\n      false && false,// false\n      undefined && undefined,// undefined \n      false && undefined,//  false\n      false && NaN, // false\n      0 && false, // 0\n      0 && NaN, // 0\n      undefined && NaN, // undefined \n      undefined && 2 ,// undefined\n      undefined && null ,// undefined\n      null && undefined, // null\n      NaN && 0, // NaN\n      NaN && 2 ,// NaN\n      0 && 2 ,// 0\n    ],\n    \"|\" :[\n      1 | 2 ,// 3\n      true | 2 ,// 3\n      false | 2 , // 2\n      4 | true, // 5\n      5 | false, // 5\n      false | false,// 0 \n      undefined | undefined,// 0\n      false | undefined,// 0\n      false | NaN, // 0\n      0 | false, // 0\n      0 | NaN, // 0\n      undefined | NaN, // 0\n      undefined | 2 ,// 2\n      undefined | null ,// 0\n      null | undefined, // 0\n      NaN | 0, // 0\n      NaN | 2 ,// 2\n      0 | 2 ,// 2\n    ],\n    \"&\": [\n      1 & 2 ,// \n      true & 2 ,// \n      false & 2 , // \n      4 & true, // \n      5 & false, // \n      false & false,// \n      undefined & undefined,// \n      false & undefined,//  \n      false & NaN, // \n      0 & false, // \n      0 & NaN, // \n      undefined & NaN, // \n      undefined & 2 ,// \n      undefined & null ,// \n      null & undefined, // \n      NaN & 0, // \n      NaN & 2 ,// \n      0 & 2 ,// \n      3 & 1, // 1\n    ],\n  }\n]\n\ndata.map(item=>{\n  item['&&'].map(item=>{\n    console.log(item)\n  })\n  item['&'].map(item=>{\n    console.log(item)\n  })\n  item['||'].map(item=>{\n    console.log(item)\n  })\n  item['|'].map(item=>{\n    console.log(item)\n  })\n})\n```\n","children":[]},{"name":"拓展运算符.md","path":"../guanruihua.github.io/JavaScript/运算符","data":"# 拓展运算符\n\n## 数值运算符\n\n> ES2021\n\n| 符号   | 名称           | 描述                                  | EG                                   |\n| ------ | -------------- | ------------------------------------- | ------------------------------------ |\n| `_`    | 数据分割运算符 | _可以用来增加数值的易读性             | `100_00 === 10000, 0x11_1 === 0x111` |\n| `??`   | 零合并运算符   | 和\\|\\|类似, 但是不会过滤掉false, 0    | `0 ?? 'default'// 0`                 |\n| `?.`   | 可选链操作符   | 在引用null 活undefined不会报错        | `obj.b?.c,`                          |\n| `#`    | 私有方法/属性  | 标记私有方法或变量                    |                                      |\n| `~~`   | 双位运算符     | 取整                                  | `~~4.5 // 4`                         |\n| `void` | void 运算符    | 使用改符号的方法, 返回值只有undefined | `void function fn(){...}`            |\n| `**`   | 求幂运算符     | 求幂                                  | `a**b=>a^b`                          |\n\n```js\n()=>{\n  // _\n  console.log( 100_00 === 10000, 0x11_1 === 0x111 , 0b11_1 === 0b111 )\n },\n () =>{\n  // ??\n  console.log( \n   undefined || 'default',\n   null || 'default',\n   false || 'default',\n   0 || 'default',\n   \n   undefined ?? 'default',\n   null ?? 'default',\n   false ?? 'default',\n   0 ?? 'default',\n   )\n\n   let a = { b: null, c: 10 }\n   a.b = a.b ?? 20\n   a.c = a.c ?? 20\n   console.log(a)\n },\n ()=> {\n  // ?.\n  const obj = {\n   a: 'foo',\n   b: {\n    c: 'bar'\n   }\n  }  \n  console.log(\n   obj.b?.c,\n   obj.d?.c,\n   obj.func?.(),\n  )\n },\n () => {\n  // 私有方法/属性 #\n  class Person{\n   getDesc(){\n    return this.#name + \" \" + this.#getAge()\n   }\n\n   #getAge(){\n    return this.#age\n   }\n   get #name(){\n    return 'foo'\n   }\n   #age = 23\n  }\n  const a = new Person()\n  console.log(a.age)\n  console.log(a.getDesc())\n },\n ()=>{\n  // ~~\n  console.log( ~~4.5 , ~~-4.5)\n },\n ()=>{\n  // void\n  const customMethod = ()=> 123\n  const func = () => void customMethod();\n  console.log(func())\n },\n ()=>{\n  // **\n  console.log( 2**3 )   \n },\n```\n","children":[]}]}]},{"name":"Knowledge-Reserve","path":"../guanruihua.github.io","data":"","children":[{"name":"python","path":"../guanruihua.github.io/Knowledge-Reserve","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Knowledge-Reserve/python","data":"# python\r\n\r\n[机器学习](https://juejin.cn/post/7053395684598218765)\r\n","children":[]}]},{"name":"README.md","path":"../guanruihua.github.io/Knowledge-Reserve","data":"# [ruihuag](https://guanruihua.github.io/#/)\r\n","children":[]},{"name":"_sidebar.md","path":"../guanruihua.github.io/Knowledge-Reserve","data":"* [python](python/index.md)\n  * [home](python/index.md)\n* 产品\n  * 画图\n    * [UML类图](产品/画图/UML类图.md)\n    * [思维导图](产品/画图/思维导图.md)\n    * [时序图](产品/画图/时序图.md)\n    * [流程图](产品/画图/流程图.md)\n    * [甘特图](产品/画图/甘特图.md)\n  * 运维\n    * [docker](产品/运维/docker.md)\n    * [jenkins](产品/运维/jenkins.md)\n    * Linux\n      * [linux-question](产品/运维/Linux/linux-question.md)\n      * [linux](产品/运维/Linux/linux.md)\n      * [命令](产品/运维/Linux/命令.md)\n    * [nginx](产品/运维/nginx/index.md)\n      * [home](产品/运维/nginx/index.md)\n      * [命令](产品/运维/nginx/命令.md)\n    * server&运维\n      * [Docker](产品/运维/server&运维/Docker/index.md)\n        * [home](产品/运维/server&运维/Docker/index.md)\n      * [tomcat](产品/运维/server&运维/tomcat.md)\n    * [宝塔面板](产品/运维/宝塔面板.md)\n    * [部署](产品/运维/部署.md)\n* 前置知识\n  * [图片](前置知识/图片.md)\n* [天干地支计算年月日时](天干地支计算年月日时.md)\n* 数据结构\n  * 哈希表\n    * [哈希表](数据结构/哈希表/哈希表.md)\n  * 图\n    * [无向图](数据结构/图/无向图.md)\n    * [有向图](数据结构/图/有向图.md)\n  * 堆\n    * [堆](数据结构/堆/堆.md)\n  * 布隆过滤器\n  * 并查集\n  * 栈\n  * 树\n    * [AVL树](数据结构/树/AVL树.md)\n    * [二叉树](数据结构/树/二叉树.md)\n    * [字典树](数据结构/树/字典树.md)\n    * [树](数据结构/树/树.md)\n    * [树状数组](数据结构/树/树状数组.md)\n    * [红黑树](数据结构/树/红黑树.md)\n    * [线段树](数据结构/树/线段树.md)\n  * 特殊\n    * [字典](数据结构/特殊/字典.md)\n    * [栈](数据结构/特殊/栈.md)\n    * [队列](数据结构/特殊/队列.md)\n  * 链表\n    * 双向链表\n    * [链表](数据结构/链表/链表.md)\n  * 队列\n* 架构&相关\n  * 拓展\n    * [编程规范](架构&相关/拓展/编程规范.md)\n  * 算法\n    * basis\n      * [时间复杂度](架构&相关/算法/basis/时间复杂度.md)\n      * [空间复杂度](架构&相关/算法/basis/空间复杂度.md)\n    * 排序\n      * [排序](架构&相关/算法/排序/排序.md)\n    * [算法](架构&相关/算法/算法/index.md)\n      * [diff](架构&相关/算法/算法/diff/index.md)\n        * [home](架构&相关/算法/算法/diff/index.md)\n        * [snabbdom](架构&相关/算法/算法/diff/snabbdom.md)\n        * [virtual-dom](架构&相关/算法/算法/diff/virtual-dom.md)\n      * [home](架构&相关/算法/算法/index.md)\n  * 设计模式\n    * 创建型\n      * [单例模式](架构&相关/设计模式/创建型/单例模式.md)\n      * [原型模式](架构&相关/设计模式/创建型/原型模式.md)\n      * [工厂模式](架构&相关/设计模式/创建型/工厂模式.md)\n      * [生成器&创建者模式](架构&相关/设计模式/创建型/生成器&创建者模式.md)\n    * 结构型\n      * [享元模式](架构&相关/设计模式/结构型/享元模式.md)\n      * [代理模式](架构&相关/设计模式/结构型/代理模式.md)\n      * [外观模式](架构&相关/设计模式/结构型/外观模式.md)\n      * [桥接模式](架构&相关/设计模式/结构型/桥接模式.md)\n      * [装饰者模式](架构&相关/设计模式/结构型/装饰者模式.md)\n      * [适配器模式](架构&相关/设计模式/结构型/适配器模式.md)\n    * 行为型\n      * [中介者模式](架构&相关/设计模式/行为型/中介者模式.md)\n      * [命令模式](架构&相关/设计模式/行为型/命令模式.md)\n      * [模板方法模式](架构&相关/设计模式/行为型/模板方法模式.md)\n      * [状态模式](架构&相关/设计模式/行为型/状态模式.md)\n      * [策略模式](架构&相关/设计模式/行为型/策略模式.md)\n      * [职责链模式](架构&相关/设计模式/行为型/职责链模式.md)\n      * [观察者(发布-订阅)模式](架构&相关/设计模式/行为型/观察者(发布-订阅)模式.md)\n      * [解释器模式](架构&相关/设计模式/行为型/解释器模式.md)\n      * [访问者模式](架构&相关/设计模式/行为型/访问者模式.md)\n      * [迭代器模式](架构&相关/设计模式/行为型/迭代器模式.md)\n    * 设计原则\n      * [依赖倒置](架构&相关/设计模式/设计原则/依赖倒置.md)\n      * [六大原则](架构&相关/设计模式/设计原则/六大原则.md)\n      * [单一责任](架构&相关/设计模式/设计原则/单一责任.md)\n      * [合并复用](架构&相关/设计模式/设计原则/合并复用.md)\n      * [开闭原则](架构&相关/设计模式/设计原则/开闭原则.md)\n      * [接口隔离](架构&相关/设计模式/设计原则/接口隔离.md)\n      * [迪米特](架构&相关/设计模式/设计原则/迪米特.md)\n      * [里氏替换](架构&相关/设计模式/设计原则/里氏替换.md)\n* 相关技术\n  * [geojson](相关技术/geojson.md)\n  * HTTP\n    * [HTTP](相关技术/HTTP/HTTP.md)\n    * [HTTP缓存](相关技术/HTTP/HTTP缓存.md)\n  * Python\n    * [basis](相关技术/Python/basis.md)\n    * 格式化\n      * [pylint](相关技术/Python/格式化/pylint.md)\n  * [rgb](相关技术/rgb.md)\n  * [unicode](相关技术/unicode.md)\n  * Unity\n    * [c#](相关技术/Unity/c#.md)\n    * [unity](相关技术/Unity/unity.md)\n    * [vscode运行C#](相关技术/Unity/vscode运行C#.md)\n  * 计网\n    * [CDN](相关技术/计网/CDN/index.md)\n      * index\n        * 640\n      * [home](相关技术/计网/CDN/index.md)\n      * [question](相关技术/计网/CDN/question.md)\n    * [http协议](相关技术/计网/http协议.md)\n    * [计网](相关技术/计网/计网.md)\n* [计算机专业术语](计算机专业术语.md)\n","children":[]},{"name":"产品","path":"../guanruihua.github.io/Knowledge-Reserve","data":"","children":[{"name":"画图","path":"../guanruihua.github.io/Knowledge-Reserve/产品","data":"","children":[{"name":"UML类图.md","path":"../guanruihua.github.io/Knowledge-Reserve/产品/画图","data":"# UML类图\n\n> - 虚线+箭头 : 依赖(Dependency)\n> - 虚线+空心三角 : 实现接口\n> - 实线+箭头 : 关联 ( Association )\n> - 实线+空心右三角 :  泛化(继承, extends)\n> - 实线+空心菱形 : 聚合 ( Aggregation )\n> - 实线+实心菱形 : 组合\n>\n> - 基数 ：连线两端的数字表明这一端的类可以有几个实例，比如：一个鸟应该有两只翅膀。\n>\n>\n>\n>   其他: 如果一个类 可能有无数个实例，则就用‘n’来表示。关联、聚合、组合是有基数的\n\n## 类（Class）\n\n> 三层矩形框表示:\n>\n> - 第一层显示类的名称，如果是抽象类，则就用斜体显示\n>\n> - 第二层是字段和属性\n>\n> - 第三层是类的方法\n>\n> 符号:\n>\n> - ‘+’ : public\n> - ‘-’ : private\n> - ‘#’ : protected\n\n![image-20210806171550598](UML类图.assets/image-20210806171550598-16282413538052.png)\n\n## 接口\n\n> :两层矩形框:\n>\n> 与类图的区别主要是顶端有<>显示 。\n>\n> - 第一行是接口名称。\n>\n> - 第二行是接口方法。\n\n![image-20210806171609133](UML类图.assets/image-20210806171609133-16282413722263.png)\n\n## 从非接口类继承\n\n![image-20210806175121309](UML类图.assets/image-20210806175121309.png)\n\n## 双向关联\n\n![image-20210806175217597](UML类图.assets/image-20210806175217597.png)\n\n## 单向关联\n\n![image-20210806175239738](UML类图.assets/image-20210806175239738.png)\n\n## 软件包\n\n![image-20210806175312121](UML类图.assets/image-20210806175312121.png)\n\n## 序列化\n\n![image-20210806175338995](UML类图.assets/image-20210806175338995-16282436215534.png)\n\n## 关联实例=>产生实例\n\n> 水平的连线还是表示上面所说的关联, 但从关联连线中引伸出来的虚线, 这意味当Flight类的一个实例关联到 FrequentFlyer 类的一个实例时，将会产生 MileageCredit 类的一个实例.\n\n![image-20210806175443119](UML类图.assets/image-20210806175443119.png)\n\n## 不随着另一个实例创建销毁\n\n> 带菱形的箭头表示基本聚合, 由上图知道, Wheel类扮演wheels角色, 聚合4个到Car对象里面去, 空心的菱形表示Wheel对象并不随Car的创建而创建,销毁而销毁\n\n![image-20210806175713677](UML类图.assets/image-20210806175713677.png)\n\n## 随着另一个实例创建销毁\n\n> 意义和上面类似, 唯一不同的是, 实心菱形表示Department对象随Company对象的创建而创建,销毁而销毁\n\n![image-20210806175734444](UML类图.assets/image-20210806175734444.png)\n\n## 反射关联\n\n> 表示反射关联, 显示一个Employee类如何通过manager / manages角色与它本身相关。当一个类关联到它本身时，这并不意味着类的实例与它本身相关，而是类的一个实例与类的另一个实例相关\n\n![image-20210806175828710](UML类图.assets/image-20210806175828710.png)\n","children":[]},{"name":"思维导图.md","path":"../guanruihua.github.io/Knowledge-Reserve/产品/画图","data":"# 思维导图\n\n> 又名心智导图，是表达发散性思维的有效图形思维工具 ，它简单却又很有效同时又很高效，是一种实用性的思维工具\n![](/__assets__/img/2022-02-11-17-53-36.png)\n","children":[]},{"name":"时序图.md","path":"../guanruihua.github.io/Knowledge-Reserve/产品/画图","data":"# 时序图\r\n\r\n一、 什么是时序图？\r\n\r\n时序图（Sequence Diagram），亦称为序列图、循序图或顺序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。\r\n\r\n时序图是一个二维图，横轴表示对象，纵轴表示时间，消息在各对象之间横向传递，依照时间顺序纵向排列。\r\n\r\n二、 时序图的作用是什么？\r\n\r\n1、展示对象之间交互的顺序。将交互行为建模为消息传递，通过描述消息是如何在对象间发送和接收的来动态展示对象之间的交互；\r\n\r\n2、相对于其他UML图，时序图更强调交互的时间顺序；\r\n\r\n3、可以直观的描述并发进程。\r\n\r\n三、 组成元素有哪些？\r\n\r\n1. 角色（Actor）\r\n\r\n系统角色，可以是人、机器、其他系统、子系统；在时序图中用表示。\r\n\r\n2. 对象（Object）\r\n\r\n（1）对象的三种命名方式\r\n\r\n第一种方式包括对象名和类名，例如：直播课时:课时，在时序图中，用“对象：类”表示；\r\n\r\n第二种方式只显示类名，即表示它是一个匿名对象，例如： :课程；在时序图中，用“：类”表示；\r\n\r\n第三种方式只显示对象名不显示类名，例如：讲师；在时序图中，用“对象”表示。\r\n\r\n（2）命名方式的选择\r\n\r\n三种命名方式均可，哪种最容易让阅读该时序图的人理解，就选择哪种。\r\n\r\n（3）对象的排列顺序\r\n\r\n对象的左右顺序并不重要，但是为了作图清晰整洁，通常应遵循以下两个原则：把交互频繁的对象尽可能的靠拢；2.把初始化整个交互活动的对象放置在最左端。\r\n\r\n3. 生命线（Lifeline）\r\n\r\n在时序图中表示为从对象图标向下延伸的一条虚线，表示对象存在的时间。\r\n\r\n4. 控制焦点（Focus of Control）\r\n\r\n又称为激活期，表示时间段的符号，在这个时间段内对象将执行相应的操作。它可以被理解成C语言语义中一对花括号{ }中的内容；用小矩形表示。\r\n\r\n5. 消息（Message）\r\n\r\n消息一般分为同步消息（Synchronous Message），异步消息（Asynchronous Message）和返回消息（Return Message）。\r\n\r\n消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义；\r\n\r\n消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。\r\n\r\n返回消息表示从过程调用返回。\r\n\r\n6. 自关联消息\r\n\r\n表示方法的自身调用或者一个对象内的一个方法调用另外一个方法。\r\n\r\n7. 组合片段\r\n\r\n组合片段用来解决交互执行的条件和方式，它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。组合片段共有13种，名称及含义如下：\r\n\r\n![](/__assets__/img/2022-02-11-17-56-53.png)\r\n用来指明在两个或更多的消息序列之间的互斥的选择，相当于经典的if..else..\r\n（1）抉择（Alt）\r\n\r\n抉择在任何场合下只发生一个序列。 可以在每个片段中设置一个临界来指示该片段可以运行的条件。else 的临界指示其他任何临界都不为 True 时应运行的片段。如果所有临界都为 False 并且没有 else，则不执行任何片段。\r\n\r\n![](/__assets__/img/2022-02-11-17-58-09.png)\r\n\r\n（2）选项（Opt）\r\n\r\n包含一个可能发生或不发生的序列；\r\n\r\n![](/__assets__/img/2022-02-11-17-58-15.png)\r\n\r\n（3）循环（Loop）\r\n\r\n片段重复一定次数，可以在临界中指示片段重复的条件。\r\n\r\n![](/__assets__/img/2022-02-11-17-58-22.png)\r\n\r\n（4）并行（Par）\r\n\r\n![](/__assets__/img/2022-02-11-17-58-27.png)\r\n\r\n## 标准时序图\r\n\r\n> Title:标题 ：指定时序图的标题\r\n> Note direction of 对象:描述 ： 在对象的某一侧添加描述，direction 可以为 right/left/over ， 对象 可以是多个对象，以 , 作为分隔符\r\n> participant 对象 ：创建一个对象\r\n> loop...end ：创建一个循环体\r\n> 对象A->对象B:描述 ： 绘制A与B之间的对话，以实线连接\r\n>\r\n> - -> 实线实心箭头指向\r\n> - --> 虚线实心箭头指向\r\n> - ->> 实线小箭头指向\r\n> - -->> 虚线小箭头指向\r\n\r\n![](./__assets__/时序图-2022-03-15-21-58-58.png)\r\n\r\n```shell\r\n# ```sequence\r\nTitle:时序图示例\r\n客户端->服务端: 我想找你拿下数据 SYN\r\n服务端-->客户端: 我收到你的请求啦 ACK+SYN\r\n客户端->>服务端: 我收到你的确认啦，我们开始通信吧 ACK\r\nNote right of 服务端: 我是一个服务端\r\nNote left of 客户端: 我是一个客户端\r\nNote over 服务端,客户端: TCP 三次握手\r\nparticipant 观察者\r\n```\r\n\r\n![](./__assets__/时序图-2022-03-15-21-59-38.png)\r\n\r\n```shell\r\n# ``` sequence\r\n客户端->打印机: 打印请求(id)\r\n打印机->数据库:请求数据(id)\r\nNote right of 数据库: 执行SQL获取数据\r\n数据库-->打印机:返回数据信息\r\nNote right of 打印机:使用数据打印\r\n打印机-->>客户端:返回打印结果\r\n客户端->客户端:等待提取结果\r\n```\r\n\r\n## 带样式时序图\r\n\r\n> 需要使用 mermaid 解析，并在开头使用关键字 sequenceDiagram 指明\r\n> 线段的样式遵循 mermaid 的解析方式\r\n>\r\n> - -> ： 实线连接\r\n> - --> ：虚线连接\r\n> - ->> ：实线箭头指向\r\n> - -->> ：虚线箭头指向\r\n\r\n![](./__assets__/时序图-2022-03-15-22-00-45.png)\r\n\r\n```shell\r\nsequenceDiagram\r\n对象A->对象B:中午吃什么？\r\n对象B->>对象A: 随便\r\nloop 思考\r\n对象A->对象A: 努力搜索\r\nend\r\n对象A-->>对象B: 火锅？\r\n对象B->>对象A: 可以\r\nNote left of 对象A: 我是一个对象A\r\nNote right of 对象B: 我是一个对象B\r\nparticipant 对象C\r\nNote over 对象C: 我自己说了算\r\n```\r\n\r\n```shell\r\n# ```mermaid\r\nsequenceDiagram\r\n对象A->对象B:中午吃什么？\r\n对象B->>对象A: 随便\r\nloop 思考\r\n对象A->对象A: 努力搜索\r\nend\r\n对象A-->>对象B: 火锅？\r\n对象B->>对象A: 可以\r\nNote left of 对象A: 我是一个对象A\r\nNote right of 对象B: 我是一个对象B\r\nparticipant 对象C\r\nNote over 对象C: 我自己说了算\r\n```\r\n","children":[]},{"name":"流程图.md","path":"../guanruihua.github.io/Knowledge-Reserve/产品/画图","data":"# 流程图\r\n\r\n## 标准流程图\r\n\r\n```flow\r\nstart=>start: 接收到消息\r\ninfo=>operation: 读取信息\r\nsetCache=>operation: 更新缓存\r\nend=>end: 处理结束\r\n\r\nstart->info->setCache->end\r\n```\r\n\r\n![](/__assets__/img/2022-03-02-16-00-20.png)\r\n\r\n## 简易流程图\r\n\r\n```flow\r\nst=>start: Start\r\nop=>operation: Your Operation\r\ncond=>condition: Yes or No?\r\ne=>end\r\nst->op->cond\r\ncond(yes)->e\r\ncond(no)->op\r\n\r\n```\r\n\r\n![](/__assets__/img/2022-03-02-16-03-01.png)\r\n\r\n```shell\r\n# ```flow\r\nstart=>start: API请求\r\ncache=>operation: 读取Redis缓存\r\ncached=>condition: 是否有缓存？\r\nsendMq=>operation: 发送MQ，后台服务更新缓存\r\ninfo=>operation: 读取信息\r\nsetCache=>operation: 保存缓存\r\nend=>end: 返回信息\r\n\r\nstart->cache->cached\r\ncached(yes)->sendMq\r\ncached(no)->info\r\ninfo->setCache\r\nsetCache->end\r\nsendMq->end\r\n```\r\n\r\n> 基本语法：\r\n>\r\n> 定义模块 id=>关键字: 描述 （“描述”的前面必须有空格，“=>” 两端不能有空格）\r\n> 关键字：\r\n> start 流程开始，以圆角矩形绘制\r\n> opearation 操作，以直角矩形绘制\r\n> condition 判断，以菱形绘制\r\n> subroutine 子流程，以左右带空白框的矩形绘制\r\n> inputoutput 输入输出，以平行四边形绘制\r\n> end 流程结束，以圆角矩形绘制\r\n> 定义模块间的流向：\r\n> 模块1 id->模块2 id ：一般的箭头指向\r\n> 条件模块id (描述)->模块id(direction) ：条件模块跳转到对应的执行模块，并指定对应分支的布局方向\r\n\r\n![](./__assets__/流程图-2022-03-15-21-52-46.png)\r\n\r\n```shell\r\n# ```flow\r\nst=>start: 开始\r\nipt=>inputoutput: 输入一个x\r\nop=>operation: 处理加工x+1\r\ncond=>condition: 溢出（是或否？）\r\nsub=>subroutine: 子流程\r\nio=>inputoutput: 输出x\r\ned=>end: 结束\r\n\r\nst->ipt->op->cond\r\ncond(yes)->io->ed\r\ncond(no)->sub->io->ed\r\n```\r\n\r\n![](./__assets__/流程图-2022-03-15-21-53-23.png)\r\n\r\n```shell\r\n# ```flow\r\nst=>start: Start|past:>http://www.google.com[blank]\r\ne=>end: End:>http://www.google.com\r\nop1=>operation: get_hotel_ids|past\r\nop2=>operation: get_proxy|current\r\nsub1=>subroutine: get_proxy|current\r\nop3=>operation: save_comment|current\r\nop4=>operation: set_sentiment|current\r\nop5=>operation: set_record|current\r\n\r\ncond1=>condition: ids_remain空?\r\ncond2=>condition: proxy_list空?\r\ncond3=>condition: ids_got空?\r\ncond4=>condition: 爬取成功??\r\ncond5=>condition: ids_remain空?\r\n\r\nio1=>inputoutput: ids-remain\r\nio2=>inputoutput: proxy_list\r\nio3=>inputoutput: ids-got\r\n\r\nst->op1(right)->io1->cond1\r\ncond1(yes)->sub1->io2->cond2\r\ncond2(no)->op3\r\ncond2(yes)->sub1\r\ncond1(no)->op3->cond4\r\ncond4(yes)->io3->cond3\r\ncond4(no)->io1\r\ncond3(no)->op4\r\ncond3(yes, right)->cond5\r\ncond5(yes)->op5\r\ncond5(no)->cond3\r\nop5->e\r\n```\r\n\r\n## 样式流程图\r\n\r\n> 基本语法：\r\n>\r\n> graph 指定流程图方向：graph LR 横向，graph TD 纵向\r\n> 元素的形状定义：\r\n>\r\n> - id[描述] 以直角矩形绘制\r\n> - id(描述) 以圆角矩形绘制\r\n> - id{描述} 以菱形绘制\r\n> - id>描述] 以不对称矩形绘制\r\n> - id((描述)) 以圆形绘制\r\n>\r\n> 线条定义：\r\n> A-->B 带箭头指向\r\n> A---B 不带箭头连接\r\n> A-.-B 虚线连接\r\n> A-.->B 虚线指向\r\n> A==>B 加粗箭头指向\r\n> A--描述---B 不带箭头指向并在线段中间添加描述\r\n> A--描述-->B 带描述的箭头指向\r\n> A-.描述.->B 带描述的虚线连指向\r\n> A==描述==>B 带描述的加粗箭头指向\r\n> 子流程图定义\r\n> subgraph title\r\n> graph direction\r\n> end\r\n![](./__assets__/流程图-2022-03-15-21-56-04.png)\r\n\r\n```shell\r\ngraph LR\r\nA(开始) -->B(起床)\r\nB --天气不好--- C>干活]\r\nC ==> D{休息时间到了}\r\nD -.yes.-> E((休息))\r\nD -.no.-> C\r\nE --> F(吃饭)\r\n```\r\n\r\n```shell\r\n# ```mermaid\r\ngraph LR\r\nA(开始) -->B(起床)\r\nB --天气不好--- C>干活]\r\nC ==> D{休息时间到了}\r\nD -.yes.-> E((休息))\r\nD -.no.-> C\r\nE --> F(吃饭)\r\n```\r\n","children":[]},{"name":"甘特图.md","path":"../guanruihua.github.io/Knowledge-Reserve/产品/画图","data":"# 甘特图\r\n\r\n> 使用 mermaid 解析语言，在开头使用关键字 gantt 指明\r\n> deteFormat 格式 指明日期的显示格式\r\n> title 标题 设置图标的标题\r\n> section 描述 定义纵向上的一个环节\r\n> 定义步骤：每个步骤有两种状态 done（已完成）/ active（执行中）\r\n>\r\n> - 描述: 状态,id,开始日期,结束日期/持续时间\r\n> - 描述: 状态[,id],after id2,持续时间\r\n> - crit ：可用于标记该步骤需要被修正，将高亮显示\r\n> - 如果不指定具体的开始时间或在某个步骤之后，将默认依次顺序排列\r\n\r\n> 甘特图视图有两个部分、树形任务列表及含时间显示的任务条视图\r\n![](/__assets__/img/2022-02-11-17-47-59.png)\r\n• 左边部分，也可以编辑任务信息，包括任务的开始、结束时间，优先级，进度。\r\n• 右边部分，可以看到任务条，不同颜色表示不同的优先级，两个任务之间的联系，表示这两个任务有依赖关系。\r\n\r\n除了浏览任务信息外，我们还可以：\r\n\r\n1. 更改时间轴到小时、天、周、星期几、月。\r\n2. 将鼠标滑动到任务上，显示其所有详情，如开始、结束时间，优先级，进度。\r\n3. 选中任务进行移动可以更改起始时间。\r\n4. 选中任务的一端进行移动，可以更改任务时长。\r\n5. 选中任务开始或结束端的小圆圈，可以将其链接到其他任何任务上，然后设置之间的依赖关系。\r\n\r\n备注\r\n依赖关系的类型：\r\n\r\n- 截止日期-至-开始日期, 任务A的开始日期 不得早于任务B的截止日期。\r\n- 开始日期-至-截止日期, 任务A的截止日期 不得早于任务B的开始日期。\r\n- 开始日期-至-开始日期, 任务A的开始日期 不得早于任务B的开始日期。\r\n- 截止日期-至-截止日期, 任务A的截止日期 不得早于任务B的截止日期。\r\n\r\n![](./__assets__/甘特图-2022-03-15-22-04-06.png)\r\n\r\n```shell\r\ngantt\r\ndateFormat YYYY-MM-DD\r\n\r\ntitle 软件开发甘特图\r\n\r\nsection 设计\r\n需求:done,des1, 2019-01-06,2019-01-08\r\n原型:active,des2, 2019-01-09, 3d\r\nUI设计:des3, after des2, 5d\r\n未来任务:des4, after des3, 5d\r\n\r\nsection 开发\r\n学习准备理解需求:crit, done, 2019-01-06,24h\r\n设计框架:crit, done, after des2, 2d\r\n开发:crit, active, 3d\r\n未来任务:crit, 5d\r\n休息时间:2d\r\n\r\nsection 测试\r\n功能测试:active, a1, after des3, 3d\r\n压力测试:after a1, 20h\r\n测试报告: 48h\r\n```\r\n\r\n```shell\r\n# ```mermaid\r\ngantt\r\ndateFormat YYYY-MM-DD\r\n\r\ntitle 软件开发甘特图\r\n\r\nsection 设计\r\n需求:done,des1, 2019-01-06,2019-01-08\r\n原型:active,des2, 2019-01-09, 3d\r\nUI设计:des3, after des2, 5d\r\n未来任务:des4, after des3, 5d\r\n\r\nsection 开发\r\n学习准备理解需求:crit, done, 2019-01-06,24h\r\n设计框架:crit, done, after des2, 2d\r\n开发:crit, active, 3d\r\n未来任务:crit, 5d\r\n休息时间:2d\r\n\r\nsection 测试\r\n功能测试:active, a1, after des3, 3d\r\n压力测试:after a1, 20h\r\n测试报告: 48h\r\n```\r\n","children":[]}]},{"name":"运维","path":"../guanruihua.github.io/Knowledge-Reserve/产品","data":"","children":[{"name":"docker.md","path":"../guanruihua.github.io/Knowledge-Reserve/产品/运维","data":"# docker\n\n## 安装\n\n> <<https://hub.docker.com/editions/community/docker-ce-desktop-window>\n\n### 查看Docker Engin, Compose 和 Machine 版本\n\n```shell\nPS C:\\Users\\Docker> docker --version\nDocker version 17.03.0-ce, build 60ccb22\n\nPS C:\\Users\\Docker> docker-compose --version\ndocker-compose version 1.11.2, build dfed245\n\nPS C:\\Users\\Docker> docker-machine --version\ndocker-machine version 0.10.0, build 76ed2a6\n```\n\n## 问题\n\n### Windows 10 启动 Docker Desktop 时出现 WSL 2 installation is incomplete\n\n![](/__assets__/img/2022-01-26-14-11-26.png)\n\n> 去安装 <https://docs.microsoft.com/en-us/windows/wsl/install-win10#step-4—download-the-linux-kernel-update-package>\n","children":[]},{"name":"jenkins.md","path":"../guanruihua.github.io/Knowledge-Reserve/产品/运维","data":"# Jenkins\n\n> 一个平台: 主要运行*插件*\n> 把软件生命周期中所有工作自动化\n> [13、持续集成工具jenkins](https://shimo.im/docs/V8XRTpPPYvjjX8Ct/read)\n\n## 安装\n\n> <https://www.jenkins.io/download/>\n> 端口: 8989\n> 第一次打开可能要解锁jenkins，页面如下图。在C:\\ProgramData\\Jenkins\\.jenkins\\secrets\\initialAdminPassword输入框，点击继续即可进行下一步操作\n> admin  1234\n> <http://localhost:8989/jenkins>\n\n## 使用\n>\n> - 新建job\n> - 自定义项目空间\n> - 指定工作项目空间\n\n## 集成Allure报告\n","children":[]},{"name":"Linux","path":"../guanruihua.github.io/Knowledge-Reserve/产品/运维","data":"","children":[{"name":"linux-question.md","path":"../guanruihua.github.io/Knowledge-Reserve/产品/运维/Linux","data":"# linux-question\n\n## su: Authentication failure问题\n\n> su命令不能切换root，提示su: Authentication failure，只要你sudo passwd root过一次之后，下次再su的时候只要输入密码就可以成功登录了。\n","children":[]},{"name":"linux.md","path":"../guanruihua.github.io/Knowledge-Reserve/产品/运维/Linux","data":"# linux 常用功能命令\n\n## 系统服务管理\n\n### systemctl\n\n- 输出系统中各个服务的状态：\n\n```bash\nsystemctl list-units --type=service\n```\n\n- 查看服务的运行状态：\n\n```basic\nsystemctl status firewalld\n```\n\n- 关闭服务：\n\n```basic\nsystemctl stop firewalld\n```\n\n- 启动服务：\n\n```\nsystemctl start firewalld\n```\n\n- 重新启动服务（不管当前服务是启动还是关闭）：\n\n```\nsystemctl restart firewalld\n```\n\n- 重新载入配置信息而不中断服务：\n\n```\nsystemctl reload firewalld\n```\n\n- 禁止服务开机自启动：\n\n```\nsystemctl disable firewalld\n```\n\n- 设置服务开机自启动：\n\n```\nsystemctl enable firewalld\n```\n\n## 文件管理\n\n### ls\n\n列出当前目录(/)下的所有文件：\n\n```\nls -l /\n```\n\n### pwd\n\n获取目前所在工作目录的绝对路径\n\n### cd\n\n改变当前工作目录：\n\n```\ncd /usr/local\n```\n\n### date\n\n显示或修改系统时间与日期；\n\n```\ndate '+%Y-%m-%d %H:%M:%S'\n```\n\n### passwd\n\n用于设置用户密码：\n\n```\npasswd root\n```\n\n### su\n\n改变用户身份（切换到超级用户）：\n\n```\nsu -\n```\n\n### clear\n\n用于清除屏幕信息\n\n### man\n\n显示指定命令的帮助信息：\n\n```\nman ls\n```\n\n### who\n\n- 查询系统处于什么运行级别：\n\n```\nwho -r\n```\n\n- 显示目前登录到系统的用户：\n\n```\nwho -buT\n```\n\n### free\n\n显示系统内存状态（单位MB）：\n\n```\nfree -m\n```\n\n### ps\n\n显示系统进程运行动态：\n\n```\nps -ef\n```\n\n查看sshd进程的运行动态：\n\n```\nps -ef | grep sshd\n```\n\n### top\n\n查看即时活跃的进程，类似Windows的任务管理器\n\n### mkdir\n\n创建目录\n\n### more\n\n用于文件过长时分页查看文件内容 每页10行查看boot.log文件\n\n```\nmore -c -10 /var/log/boot.log\n```\n\n### cat\n\n查看Linux启动日志文件文件，并标明行号：\n\n```\ncat -Ab /var/log/boot.log\n```\n\n### touch\n\n创建text.txt文件：\n\n```\ntouch text.txt\n```\n\n### rm\n\n- 删除文件：\n\n```\nrm text.txt\n```\n\n- 强制删除某个目录及其子目录：\n\n```\nrm -rf testdir/\n```\n\n### cp\n\n将test1目录复制到test2目录\n\n```\ncp -r /mydata/tes1 /mydata/test2\n```\n\n### mv\n\n移动或覆盖文件：\n\n```\nmv text.txt text2.txt\n```\n\n## 压缩与解压\n\n### tar\n\n- 将/etc文件夹中的文件归档到文件etc.tar（并不会进行压缩）：\n\n```\ntar -cvf /mydata/etc.tar /etc\n```\n\n- 用gzip压缩文件夹/etc中的文件到文件etc.tar.gz：\n\n```\ntar -zcvf /mydata/etc.tar.gz /etc\n```\n\n- 用bzip2压缩文件夹/etc到文件/etc.tar.bz2：\n\n```\ntar -jcvf /mydata/etc.tar.bz2 /etc\n```\n\n- 分页查看压缩包中内容（gzip）：\n\n```\ntar -ztvf /mydata/etc.tar.gz |more -c -10\n```\n\n- 解压文件到当前目录（gzip）：\n\n```\ntar -zxvf /mydata/etc.tar.gz\n```\n\n## 磁盘和网络管理\n\n### df\n\n查看磁盘空间占用情况：\n\n```\ndf -hT\n```\n\n### dh\n\n查看当前目录下的文件及文件夹所占大小：\n\n```\ndu -h --max-depth=1 ./*\n```\n\n### ifconfig\n\n显示当前网络接口状态\n\n### netstat\n\n- 查看当前路由信息：\n\n```\nnetstat -rn\n```\n\n- 查看所有有效TCP连接：\n\n```\nnetstat -an\n```\n\n- 查看系统中启动的监听服务：\n\n```\nnetstat -tulnp\n```\n\n- 查看处于连接状态的系统资源信息：\n\n```\nnetstat -atunp\n```\n\n### wget\n\n从网络上下载文件\n\n## 软件的安装与管理\n\n### rpm\n\n- 安装软件包：rpm -ivh nginx-1.12.2-2.el7.x86_64.rpm\n- 模糊搜索软件包：rpm -qa | grep nginx\n- 精确查找软件包：rpm -qa nginx\n- 查询软件包的安装路径：rpm -ql nginx-1.12.2-2.el7.x86_64\n- 查看软件包的概要信息：rpm -qi nginx-1.12.2-2.el7.x86_64\n- 验证软件包内容和安装文件是否一致：rpm -V nginx-1.12.2-2.el7.x86_64\n- 更新软件包：rpm -Uvh nginx-1.12.2-2.el7.x86_64\n- 删除软件包：rpm -e nginx-1.12.2-2.el7.x86_64\n\n### yum\n\n- 安装软件包： yum install nginx\n- 检查可以更新的软件包：yum check-update\n- 更新指定的软件包：yum update nginx\n- 在资源库中查找软件包信息：yum info nginx*\n- 列出已经安装的所有软件包：yum info installed\n- 列出软件包名称：yum list nginx*\n- 模糊搜索软件包：yum search nginx\n","children":[]},{"name":"命令.md","path":"../guanruihua.github.io/Knowledge-Reserve/产品/运维/Linux","data":"# linux命令\n\n## 命令\n\n### 命令行提示符\n\n进入命令行环境以后，用户会看到 `Shell` 的提示符。提示符往往是一串前缀，最后以一个美元符号 `$` 结尾，用户可以在这个符号后面输入各种命令。\n\n执行一个简单的命令 `pwd` ：\n\n```\n[root@iZm5e8dsxce9ufaic7hi3uZ ~]# pwd\n/root\n\n```\n\n命令解析：\n\n- `root`：表示用户名；\n- `iZm5e8dsxce9ufaic7hi3uZ`：表示主机名；\n- `~`：表示目前所在目录为家目录，其中 `root` 用户的家目录是 `/root` 普通用户的家目录在 `/home` 下；\n- `#`：指示你所具有的权限（ `root` 用户为 `#` ，普通用户为 `$` ）。\n- 执行 `whoami` 命令可以查看当前用户名；\n- 执行 `hostname` 命令可以查看当前主机名；\n\n关于如何创建、切换、删除用户，在后面的用户与权限会具体讲解，这里先使用 `root` 用户进行演示。\n\n[备注] `root` 是超级用户，具备操作系统的一切权限。\n\n### 命令格式\n\n```\ncommand parameters（命令 参数）\n\n```\n\n#### 长短参数\n\n```\n单个参数：ls -a（a 是英文 all 的缩写，表示“全部”）\n多个参数：ls -al（全部文件 + 列表形式展示）\n单个长参数：ls --all\n多个长参数：ls --reverse --all\n长短混合参数：ls --all -l\n\n```\n\n#### 参数值\n\n```\n短参数：command -p 10（例如：ssh root@121.42.11.34 -p 22）\n长参数：command --paramters=10（例如：ssh root@121.42.11.34 --port=22）\n\n```\n\n## 快捷方式\n\n在开始学习 `Linux` 命令之前，有这么一些快捷方式，是必须要提前掌握的，它将贯穿整个 `Linux` 使用生涯。\n\n- 通过上下方向键 ↑ ↓ 来调取过往执行过的 `Linux` 命令；\n- 命令或参数仅需输入前几位就可以用 `Tab` 键补全；\n- `Ctrl + R` ：用于查找使用过的命令（`history` 命令用于列出之前使用过的所有命令，然后输入 `!` 命令加上编号( `!2` )就可以直接执行该历史命令）；\n- `Ctrl + L`：清除屏幕并将当前行移到页面顶部；\n- `Ctrl + C`：中止当前正在执行的命令；\n- `Ctrl + U`：从光标位置剪切到行首；\n- `Ctrl + K`：从光标位置剪切到行尾；\n- `Ctrl + W`：剪切光标左侧的一个单词；\n- `Ctrl + Y`：粘贴 `Ctrl + U | K | Y` 剪切的命令；\n- `Ctrl + A`：光标跳到命令行的开头；\n- `Ctrl + E`：光标跳到命令行的结尾；\n- `Ctrl + D`：关闭 `Shell` 会话；\n\n## 文件和目录\n\n### 文件的组织\n\n![image.png](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>)\n\n### 查看路径\n\n#### pwd\n\n显示当前目录的路径\n\n![image.png](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>)\n\n#### which\n\n查看命令的可执行文件所在路径， `Linux` 下，每一条命令其实都对应一个可执行程序，在终端中输入命令，按回车的时候，就是执行了对应的那个程序， `which` 命令本身对应的程序也存在于 `Linux` 中。\n\n总的来说一个命令就是一个可执行程序。\n\n![image.png](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>)\n\n### 浏览和切换目录\n\n#### ls\n\n列出文件和目录，它是 `Linux` 最常用的命令之一。\n\n【常用参数】\n\n- `-a` 显示所有文件和目录包括隐藏的\n- `-l` 显示详细列表\n- `-h` 适合人类阅读的\n- `-t` 按文件最近一次修改时间排序\n- `-i` 显示文件的 `inode` （ `inode` 是文件内容的标识）\n\n![image.png](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>)\n\n#### cd\n\n`cd` 是英语 `change directory` 的缩写，表示切换目录。\n\n```kotlin\ncd / --> 跳转到根目录\ncd ~ --> 跳转到家目录\ncd .. --> 跳转到上级目录\ncd ./home --> 跳转到当前目录的home目录下\ncd /home/lion --> 跳转到根目录下的home目录下的lion目录\ncd --> 不添加任何参数，也是回到家目录\n\n```\n\n[注意] 输入`cd /ho` + 单次 `tab` 键会自动补全路径 + 两次 `tab` 键会列出所有可能的目录列表。\n\n#### du\n\n列举目录大小信息。\n\n【常用参数】\n\n- `-h` 适合人类阅读的；\n- `-a` 同时列举出目录下文件的大小信息；\n- `-s` 只显示总计大小，不显示具体信息。\n\n### 浏览和创建文件\n\n#### cat\n\n一次性显示文件所有内容，更适合查看小的文件。\n\n```kotlin\ncat cloud-init.log\n\n```\n\n【常用参数】\n\n- `-n` 显示行号。\n\n#### less\n\n分页显示文件内容，更适合查看大的文件。\n\n```kotlin\nless cloud-init.log\n\n```\n\n【快捷操作】\n\n- 空格键：前进一页（一个屏幕）；\n- `b` 键：后退一页；\n- 回车键：前进一行；\n- `y` 键：后退一行；\n- 上下键：回退或前进一行；\n- `d` 键：前进半页；\n- `u` 键：后退半页；\n- `q` 键：停止读取文件，中止 `less` 命令；\n- `=` 键：显示当前页面的内容是文件中的第几行到第几行以及一些其它关于本页内容的详细信息；\n- `h` 键：显示帮助文档；\n- `/` 键：进入搜索模式后，按 `n` 键跳到一个符合项目，按 `N` 键跳到上一个符合项目，同时也可以输入正则表达式匹配。\n\n#### head\n\n显示文件的开头几行（默认是10行）\n\n```bash\nhead cloud-init.log\n\n```\n\n【参数】\n\n- `-n` 指定行数 `head cloud-init.log -n 2`\n\n#### tail\n\n显示文件的结尾几行（默认是10行）\n\n```bash\ntail cloud-init.log\n\n```\n\n【参数】\n\n- `-n` 指定行数 `tail cloud-init.log -n 2`\n- `-f` 会每过1秒检查下文件是否有更新内容，也可以用 `-s` 参数指定间隔时间 `tail -f -s 4 xxx.log`\n\n#### touch\n\n创建一个文件\n\n```bash\ntouch new_file\n\n```\n\n#### mkdir\n\n创建一个目录\n\n```bash\nmkdir new_folder\n\n```\n\n【常用参数】\n\n- `-p` 递归的创建目录结构 `mkdir -p one/two/three`\n\n### 文件的复制和移动\n\n#### cp\n\n拷贝文件和目录\n\n```bash\ncp file file_copy --> file 是目标文件，file_copy 是拷贝出来的文件\ncp file one --> 把 file 文件拷贝到 one 目录下，并且文件名依然为 file\ncp file one/file_copy --> 把 file 文件拷贝到 one 目录下，文件名为file_copy\ncp *.txt folder --> 把当前目录下所有 txt 文件拷贝到 folder 目录下\n\n```\n\n【常用参数】\n\n- `-r` 递归的拷贝，常用来拷贝一整个目录\n\n#### mv\n\n移动（重命名）文件或目录，与cp命令用法相似。\n\n```bash\nmv file one --> 将 file 文件移动到 one 目录下\nmv new_folder one --> 将 new_folder 文件夹移动到one目录下\nmv *.txt folder --> 把当前目录下所有 txt 文件移动到 folder 目录下\nmv file new_file --> file 文件重命名为 new_file\n\n```\n\n### 文件的删除和链接\n\n#### rm\n\n删除文件和目录，由于 `Linux` 下没有回收站，一旦删除非常难恢复，因此需要谨慎操作\n\n```bash\nrm new_file  --> 删除 new_file 文件\nrm f1 f2 f3  --> 同时删除 f1 f2 f3 3个文件\n\n```\n\n【常用参数】\n\n- `-i` 向用户确认是否删除；\n- `-f` 文件强制删除；\n- `-r` 递归删除文件夹，著名的删除操作 `rm -rf` 。\n\n#### ln\n\n英文 `Link` 的缩写，表示创建链接。\n\n学习创建链接之前，首先要理解链接是什么，我们先来看看 `Linux` 的文件是如何存储的：\n\n`Linux` 文件的存储方式分为3个部分，文件名、文件内容以及权限，其中文件名的列表是存储在硬盘的其它地方和文件内容是分开存放的，每个文件名通过 `inode` 标识绑定到文件内容。\n\nLinux 下有两种链接类型：硬链接和软链接。\n\n##### 硬链接\n\n使链接的两个文件共享同样文件内容，就是同样的 `inode` ，一旦文件1和文件2之间有了硬链接，那么修改任何一个文件，修改的都是同一块内容，它的缺点是，只能创建指向文件的硬链接，不能创建指向目录的（其实也可以，但比较复杂）而软链接都可以，因此软链接使用更加广泛。\n\n```bash\nln file1 file2  --> 创建 file2 为 file1 的硬链接\n\n```\n\n![image.png](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>)\n\n如果我们用 `rm file1` 来删除 `file1` ，对 `file2` 没有什么影响，对于硬链接来说，删除任意一方的文件，共同指向的文件内容并不会从硬盘上删除。只有同时删除了 `file1` 与 `file2` 后，它们共同指向的文件内容才会消失。\n\n##### 软链接\n\n软链接就类似 `windows` 下快捷方式。\n\n```bash\nln -s file1 file2\n\n```\n\n![image.png](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>)\n\n执行 `ls -l` 命名查看当前目录下文件的具体信息\n\n```bash\ntotal 0\n-rw-r--r-- 1 root root 0 Jan 14 06:29 file1\nlrwxrwxrwx 1 root root 5 Jan 14 06:42 file2 -> file1  # 表示file2 指向 file1\n\n```\n\n其实 `file2` 只是 `file1` 的一个快捷方式，它指向的是 `file1` ，所以显示的是 `file1` 的内容，但其实 `file2` 的 `inode` 与 `file1` 并不相同。如果我们删除了 `file2` 的话， `file1` 是不会受影响的，但如果删除 `file1` 的话， `file2` 就会变成死链接，因为指向的文件不见了。\n\n## 用户与权限\n\n### 用户\n\n`Linux` 是一个多用户的操作系统。在 `Linux` 中，理论上来说，我们可以创建无数个用户，但是这些用户是被划分到不同的群组里面的，有一个用户，名叫 `root` ，是一个很特殊的用户，它是超级用户，拥有最高权限。\n\n![image.png](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>)\n\n自己创建的用户是有限权限的用户，这样大大提高了 `Linux` 系统的安全性，有效防止误操作或是病毒攻击，但是我们执行的某些命令需要更高权限时可以使用 `sudo` 命令。\n\n#### sudo\n\n以 `root` 身份运行命令\n\n```bash\nsudo date  --> 当然查看日期是不需要sudo的这里只是演示，sudo 完之后一般还需要输入用户密码的\n```\n\n#### useradd + passwd\n\n- `useradd` 添加新用户\n- `passwd` 修改用户密码\n\n这两个命令需要 `root` 用户权限\n\n```bash\nuseradd lion --> 添加一个lion用户，添加完之后在 /home 路径下可以查看\npasswd lion --> 修改lion用户的密码\n```\n\n#### userdel\n\n删除用户，需要 `root` 用户权限\n\n```bash\nuserdel lion --> 只会删除用户名，不会从/home中删除对应文件夹\nuserdel lion -r --> 会同时删除/home下的对应文件夹\n```\n\n#### su\n\n切换用户，需要 `root` 用户权限\n\n```bash\nsudo su --> 切换为root用户（exit 命令或 CTRL + D 快捷键都可以使普通用户切换为 root 用户）\nsu lion --> 切换为普通用户\nsu - --> 切换为root用户\n\n```\n\n### 群组的管理\n\n`Linux` 中每个用户都属于一个特定的群组，如果你不设置用户的群组，默认会创建一个和它的用户名一样的群组，并且把用户划归到这个群组。\n\n#### groupadd\n\n创建群组，用法和 `useradd` 类似。\n\n```bash\ngroupadd friends\n```\n\n#### groupdel\n\n删除一个已存在的群组\n\n```bash\ngroupdel foo  --> 删除foo群组\n```\n\n#### groups\n\n查看用户所在群组\n\n```bash\ngroups lion  --> 查看 lion 用户所在的群组\n```\n\n#### usermod\n\n用于修改用户的账户。\n\n【常用参数】\n\n- `-l` 对用户重命名。需要注意的是 `/home` 中的用户家目录的名字不会改变，需要手动修改。\n- `-g` 修改用户所在的群组，例如 `usermod -g friends lion` 修改 `lion` 用户的群组为 `friends` 。\n- `-G` 一次性让用户添加多个群组，例如 `usermod -G friends,foo,bar lion` 。\n- `-a` `-G` 会让你离开原先的群组，如果你不想这样做的话，就得再添加 `-a` 参数，意味着 `append` 追加的意思。\n\n#### chgrp\n\n用于修改文件的群组。\n\n```bash\nchgrp bar file.txt --> file.txt文件的群组修改为bar\n\n```\n\n#### chown\n\n改变文件的所有者，需要 `root` 身份才能运行。\n\n```bash\nchown lion file.txt --> 把其它用户创建的file.txt转让给lion用户\nchown lion:bar file.txt --> 把file.txt的用户改为lion，群组改为bar\n\n```\n\n【常用参数】\n\n- `-R` 递归设置子目录和子文件， `chown -R lion:lion /home/frank` 把 `frank` 文件夹的用户和群组都改为 `lion` 。\n\n### 文件权限管理\n\n#### chmod\n\n修改访问权限。\n\n```bash\nchmod 740 file.txt\n\n```\n\n【常用参数】\n\n- `-R` 可以递归地修改文件访问权限，例如 `chmod -R 777 /home/lion`\n\n修改权限的确简单，但是理解其深层次的意义才是更加重要的。下面我们来系统的学习 `Linux` 的文件权限。\n\n```bash\n[root@lion ~]# ls -l\ndrwxr-xr-x 5 root root 4096 Apr 13  2020 climb\nlrwxrwxrwx 1 root root    7 Jan 14 06:41 hello2.c -> hello.c\n-rw-r--r-- 1 root root  149 Jan 13 06:14 hello.c\n\n```\n\n其中 `drwxr-xr-x` 表示文件或目录的权限。让我们一起来解读它具体代表什么？\n\n- `d` ：表示目录，就是说这是一个目录，普通文件是 `-` ，链接是 `l` 。\n- `r` ： `read` 表示文件可读。\n- `w` ： `write` 表示文件可写，一般有写的权限，就有删除的权限。\n- `x` ： `execute` 表示文件可执行。\n- `-` ：表示没有相应权限。\n\n权限的整体是按用户来划分的，如下图所示：\n\n![image.png](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>)\n\n现在再来理解这句权限 `drwxr-xr-x` 的意思：\n\n- 它是一个文件夹；\n- 它的所有者具有：读、写、执行权限；\n- 它的群组用户具有：读、执行的权限，没有写的权限；\n- 它的其它用户具有：读、执行的权限，没有写的权限。\n\n现在理解了权限，我们使用 `chmod` 来尝试修改权限。 `chmod` 它不需要是 `root` 用户才能运行的，只要你是此文件所有者，就可以用 `chmod` 来修改文件的访问权限。\n\n##### 数字分配权限\n\n| 权限 | 数字 |\n| ---- | ---- |\n| r    | 4    |\n| w    | 2    |\n| x    | 1    |\n\n因此要改变权限，只要做一些简单的加法就行：\n\n```bash\nchmod 640 hello.c \n\n# 分析\n6 = 4 + 2 + 0 表示所有者具有 rw 权限\n4 = 4 + 0 + 0 表示群组用户具有 r 权限\n0 = 0 + 0 + 0 表示其它用户没有权限\n\n对应文字权限为：-rw-r-----\n\n```\n\n##### 用字母来分配权限\n\n- `u` ： `user` 的缩写，用户的意思，表示所有者。\n- `g` ： `group` 的缩写，群组的意思，表示群组用户。\n- `o` ： `other` 的缩写，其它的意思，表示其它用户。\n- `a` ： `all` 的缩写，所有的意思，表示所有用户。\n- `+` ：加号，表示添加权限。\n- `-` ：减号，表示去除权限。\n- `=` ：等于号，表示分配权限。\n\n```bash\nchmod u+rx file --> 文件file的所有者增加读和运行的权限\nchmod g+r file --> 文件file的群组用户增加读的权限\nchmod o-r file --> 文件file的其它用户移除读的权限\nchmod g+r o-r file --> 文件file的群组用户增加读的权限，其它用户移除读的权限\nchmod go-r file --> 文件file的群组和其他用户移除读的权限\nchmod +x file --> 文件file的所有用户增加运行的权限\nchmod u=rwx,g=r,o=- file --> 文件file的所有者分配读写和执行的权限，群组其它用户分配读的权限，其他用户没有任何权限\n\n```\n\n## 查找文件\n\n### locate\n\n搜索包含关键字的所有文件和目录。后接需要查找的文件名，也可以用正则表达式。\n\n#### 安装 locate\n\n```bash\nyum -y install mlocate --> 安装包\nupdatedb --> 更新数据库\n\nlocate file.txt\nlocate fil*.txt\n\n```\n\n[注意] `locate` 命令会去文件数据库中查找命令，而不是全磁盘查找，因此刚创建的文件并不会更新到数据库中，所以无法被查找到，可以执行 `updatedb` 命令去更新数据库。\n\n### find\n\n用于查找文件，它会去遍历你的实际硬盘进行查找，而且它允许我们对每个找到的文件进行后续操作，功能非常强大。\n\n```bash\nfind <何处> <何物> <做什么>\n\n```\n\n- 何处：指定在哪个目录查找，此目录的所有子目录也会被查找。\n- 何物：查找什么，可以根据文件的名字来查找，也可以根据其大小来查找，还可以根据其最近访问时间来查找。\n- 做什么：找到文件后，可以进行后续处理，如果不指定这个参数， `find` 命令只会显示找到的文件。\n\n#### 根据文件名查找\n\n```bash\nfind -name \"file.txt\" --> 当前目录以及子目录下通过名称查找文件\nfind . -name \"syslog\" --> 当前目录以及子目录下通过名称查找文件\nfind / -name \"syslog\" --> 整个硬盘下查找syslog\nfind /var/log -name \"syslog\" --> 在指定的目录/var/log下查找syslog文件\nfind /var/log -name \"syslog*\" --> 查找syslog1、syslog2 ... 等文件，通配符表示所有\nfind /var/log -name \"*syslog*\" --> 查找包含syslog的文件 \n\n```\n\n[注意] `find` 命令只会查找完全符合 “何物” 字符串的文件，而 `locate` 会查找所有包含关键字的文件。\n\n#### 根据文件大小查找\n\n```bash\nfind /var -size +10M --> /var 目录下查找文件大小超过 10M 的文件\nfind /var -size -50k --> /var 目录下查找文件大小小于 50k 的文件\nfind /var -size +1G --> /var 目录下查找文件大小查过 1G 的文件\nfind /var -size 1M --> /var 目录下查找文件大小等于 1M 的文件\n\n```\n\n#### 根据文件最近访问时间查找\n\n```bash\nfind -name \"*.txt\" -atime -7  --> 近 7天内访问过的.txt结尾的文件\n\n```\n\n#### 仅查找目录或文件\n\n```bash\nfind . -name \"file\" -type f  --> 只查找当前目录下的file文件\nfind . -name \"file\" -type d  --> 只查找当前目录下的file目录\n\n```\n\n#### 操作查找结果\n\n```bash\nfind -name \"*.txt\" -printf \"%p - %u\\n\" --> 找出所有后缀为txt的文件，并按照 %p - %u\\n 格式打印，其中%p=文件名，%u=文件所有者\nfind -name \"*.jpg\" -delete --> 删除当前目录以及子目录下所有.jpg为后缀的文件，不会有删除提示，因此要慎用\nfind -name \"*.c\" -exec chmod 600 {} \\; --> 对每个.c结尾的文件，都进行 -exec 参数指定的操作，{} 会被查找到的文件替代，\\; 是必须的结尾\nfind -name \"*.c\" -ok chmod 600 {} \\; --> 和上面的功能一直，会多一个确认提示\n\n```\n\n## 软件仓库\n\n`Linux` 下软件是以包的形式存在，一个软件包其实就是软件的所有文件的压缩包，是二进制的形式，包含了安装软件的所有指令。 `Red Hat` 家族的软件包后缀名一般为 `.rpm` ， `Debian` 家族的软件包后缀是 `.deb` 。\n\n`Linux` 的包都存在一个仓库，叫做软件仓库，它可以使用 `yum` 来管理软件包， `yum` 是 `CentOS` 中默认的包管理工具，适用于 `Red Hat` 一族。可以理解成 `Node.js` 的 `npm` 。\n\n### yum 常用命令\n\n- `yum update | yum upgrade` 更新软件包\n- `yum search xxx` 搜索相应的软件包\n- `yum install xxx` 安装软件包\n- `yum remove xxx` 删除软件包\n\n### 切换 CentOS 软件源\n\n有时候 `CentOS` 默认的 `yum` 源不一定是国内镜像，导致 `yum` 在线安装及更新速度不是很理想。这时候需要将 `yum` 源设置为国内镜像站点。国内主要开源的镜像站点是网易和阿里云。\n\n1、首先备份系统自带 `yum` 源配置文件 `mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup`\n\n2、下载阿里云的 `yum` 源配置文件到 `/etc/yum.repos.d/CentOS7`\n\n```bash\nwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo\n\n```\n\n3、生成缓存\n\n```bash\nyum makecache\n\n```\n\n## 阅读手册\n\n### man\n\n#### 安装更新 man\n\n```bash\nsudo yum install -y man-pages --> 安装\nsudo mandb --> 更新\n\n```\n\n#### man 手册种类\n\n1. 可执行程序或 `Shell` 命令；\n2. 系统调用（ `Linux` 内核提供的函数）；\n3. 库调用（程序库中的函数）；\n4. 文件（例如 `/etc/passwd` ）；\n5. 特殊文件（通常在 `/dev` 下）；\n6. 游戏；\n7. 杂项（ `man(7)` ，`groff(7)` ）；\n8. 系统管理命令（通常只能被 `root` 用户使用）；\n9. 内核子程序。\n\n#### man + 数字 + 命令\n\n输入 man + 数字 + 命令/函数，可以查到相关的命令和函数，若不加数字， `man` 默认从数字较小的手册中寻找相关命令和函数\n\n```bash\nman 3 rand  --> 表示在手册的第三部分查找 rand 函数\nman ls    --> 查找 ls 用法手册\n\n```\n\nman 手册核心区域解析：(以 `man pwd` 为例)\n\n```bash\nNAME # 命令名称和简单描述\n     pwd -- return working directory name\n\nSYNOPSIS # 使用此命令的所有方法\n     pwd [-L | -P]\n\nDESCRIPTION # 包括所有参数以及用法\n     The pwd utility writes the absolute pathname of the current working directory to the standard output.\n\n     Some shells may provide a builtin pwd command which is similar or identical to this utility.  Consult the builtin(1) manual page.\n\n     The options are as follows:\n\n     -L      Display the logical current working directory.\n\n     -P      Display the physical current working directory (all symbolic links resolved).\n\n     If no options are specified, the -L option is assumed.\n\nSEE ALSO # 扩展阅读相关命令\n     builtin(1), cd(1), csh(1), sh(1), getcwd(3)\n\n```\n\n### help\n\n`man` 命令像新华词典一样可以查询到命令或函数的详细信息，但其实我们还有更加快捷的方式去查询， `command --help` 或 `command -h` ，它没有 `man` 命令显示的那么详细，但是它更加易于阅读。\n\n# Linux 进阶\n\n## 文本操作\n\n### grep\n\n全局搜索一个正则表达式，并且打印到屏幕。简单来说就是，在文件中查找关键字，并显示关键字所在行。\n\n#### 基础语法\n\n```bash\ngrep text file # text代表要搜索的文本，file代表供搜索的文件\n\n# 实例\n[root@lion ~]# grep path /etc/profile\npathmunge () {\n    pathmunge /usr/sbin\n    pathmunge /usr/local/sbin\n    pathmunge /usr/local/sbin after\n    pathmunge /usr/sbin after\nunset -f pathmunge\n\n```\n\n#### 常用参数\n\n- `-i` 忽略大小写， `grep -i path /etc/profile`\n- `-n` 显示行号，`grep -n path /etc/profile`\n- `-v` 只显示搜索文本不在的那些行，`grep -v path /etc/profile`\n- `-r` 递归查找， `grep -r hello /etc` ，Linux 中还有一个 rgrep 命令，作用相当于 `grep -r`\n\n#### 高级用法\n\n`grep` 可以配合正则表达式使用。\n\n```bash\ngrep -E path /etc/profile --> 完全匹配path\ngrep -E ^path /etc/profile --> 匹配path开头的字符串\ngrep -E [Pp]ath /etc/profile --> 匹配path或Path\n\n```\n\n### sort\n\n对文件的行进行排序。\n\n#### 基础语法\n\n```bash\nsort name.txt # 对name.txt文件进行排序\n\n```\n\n#### 实例用法\n\n为了演示方便，我们首先创建一个文件 `name.txt` ，放入以下内容：\n\n```bash\nChristopher\nShawn\nTed\nRock\nNoah\nZachary\nBella\n\n```\n\n执行 `sort name.txt` 命令，会对文本内容进行排序。\n\n#### 常用参数\n\n- `-o` 将排序后的文件写入新文件， `sort -o name_sorted.txt name.txt` ；\n- `-r` 倒序排序， `sort -r name.txt` ；\n- `-R` 随机排序， `sort -R name.txt` ；\n- `-n` 对数字进行排序，默认是把数字识别成字符串的，因此 138 会排在 25 前面，如果添加了 `-n` 数字排序的话，则 25 会在 138 前面。\n\n### wc\n\n`word count` 的缩写，用于文件的统计。它可以统计单词数目、行数、字符数，字节数等。\n\n#### 基础语法\n\n```bash\nwc name.txt # 统计name.txt\n\n```\n\n#### 实例用法\n\n```bash\n[root@lion ~]# wc name.txt \n13 13 91 name.txt\n\n```\n\n- 第一个13，表示行数；\n- 第二个13，表示单词数；\n- 第三个91，表示字节数。\n\n#### 常用参数\n\n- `-l` 只统计行数， `wc -l name.txt` ；\n- `-w` 只统计单词数， `wc -w name.txt` ；\n- `-c` 只统计字节数， `wc -c name.txt` ；\n- `-m` 只统计字符数， `wc -m name.txt` 。\n\n### uniq\n\n删除文件中的重复内容。\n\n#### 基础语法\n\n```bash\nuniq name.txt # 去除name.txt重复的行数，并打印到屏幕上\nuniq name.txt uniq_name.txt # 把去除重复后的文件保存为 uniq_name.txt\n\n```\n\n【注意】它只能去除连续重复的行数。\n\n#### 常用参数\n\n- `-c` 统计重复行数， `uniq -c name.txt` ；\n- `-d` 只显示重复的行数， `uniq -d name.txt` 。\n\n### cut\n\n剪切文件的一部分内容。\n\n#### 基础语法\n\n```bash\ncut -c 2-4 name.txt # 剪切每一行第二到第四个字符\n\n```\n\n#### 常用参数\n\n- `-d` 用于指定用什么分隔符（比如逗号、分号、双引号等等） `cut -d , name.txt` ；\n- `-f` 表示剪切下用分隔符分割的哪一块或哪几块区域， `cut -d , -f 1 name.txt` 。\n\n## 重定向 管道 流\n\n在 `Linux` 中一个命令的去向可以有3个地方：终端、文件、作为另外一个命令的入参。\n![未命名文件 (4).png](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>)\n命令一般都是通过键盘输入，然后输出到终端、文件等地方，它的标准用语是 `stdin` 、 `stdout` 以及 `stderr` 。\n\n- 标准输入 `stdin` ，终端接收键盘输入的命令，会产生两种输出；\n- 标准输出 `stdout` ，终端输出的信息（不包含错误信息）；\n- 标准错误输出 `stderr` ，终端输出的错误信息。\n\n![image.png](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>)\n\n### 重定向\n\n把本来要显示在终端的命令结果，输送到别的地方（到文件中或者作为其他命令的输入）。\n\n#### 输出重定向 `>`\n\n`>` 表示重定向到新的文件， `cut -d , -f 1 notes.csv > name.csv` ，它表示通过逗号剪切 `notes.csv` 文件（剪切完有3个部分）获取第一个部分，重定向到 `name.csv` 文件。\n\n我们来看一个具体示例，学习它的使用，假设我们有一个文件 `notes.csv` ，文件内容如下：\n\n```javascript\nMark1,951/100,很不错1\nMark2,952/100,很不错2\nMark3,953/100,很不错3\nMark4,954/100,很不错4\nMark5,955/100,很不错5\nMark6,956/100,很不错6\n\n```\n\n执行命令： `cut -d , -f 1 notes.csv > name.csv` 最后输出如下内容：\n\n```javascript\nMark1\nMark2\nMark3\nMark4\nMark5\nMark6\n\n```\n\n【注意】使用 `>` 要注意，如果输出的文件不存在它会新建一个，如果输出的文件已经存在，则会覆盖。因此执行这个操作要非常小心，以免覆盖其它重要文件。\n\n#### 输出重定向 `>>`\n\n表示重定向到文件末尾，因此它不会像 `>` 命令这么危险，它是追加到文件的末尾（当然如果文件不存在，也会被创建）。\n\n再次执行 `cut -d , -f 1 notes.csv >> name.csv` ，则会把名字追加到 `name.csv` 里面。\n\n```javascript\nMark1\nMark2\nMark3\nMark4\nMark5\nMark6\nMark1\nMark2\nMark3\nMark4\nMark5\nMark6\n\n```\n\n我们平时读的 `log` 日志文件其实都是用这个命令输出的。\n\n#### 输出重定向 `2>`\n\n标准错误输出\n\n```javascript\ncat not_exist_file.csv > res.txt 2> errors.log\n\n```\n\n- 当我们 `cat` 一个文件时，会把文件内容打印到屏幕上，这个是标准输出；\n- 当使用了 `> res.txt` 时，则不会打印到屏幕，会把标准输出写入文件 `res.txt` 文件中；\n- `2> errors.log` 当发生错误时会写入 `errors.log` 文件中。\n\n#### 输出重定向 `2>>`\n\n标准错误输出（追加到文件末尾）同 `>>` 相似。\n\n#### 输出重定向 `2>&1`\n\n标准输出和标准错误输出都重定向都一个地方\n\n```javascript\ncat not_exist_file.csv > res.txt 2>&1  # 覆盖输出\ncat not_exist_file.csv >> res.txt 2>&1 # 追加输出\n\n```\n\n目前为止，我们接触的命令的输入都来自命令的参数，其实命令的输入还可以来自文件或者键盘的输入。\n\n![未命名文件 (2).png](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>)\n\n#### 输入重定向 `<`\n\n`<` 符号用于指定命令的输入。\n\n```javascript\ncat < name.csv # 指定命令的输入为 name.csv\n\n```\n\n虽然它的运行结果与 `cat name.csv` 一样，但是它们的原理却完全不同。\n\n- `cat name.csv` 表示 `cat` 命令接收的输入是 `notes.csv` 文件名，那么要先打开这个文件，然后打印出文件内容。\n- `cat < name.csv` 表示 `cat` 命令接收的输入直接是 `notes.csv` 这个文件的内容， `cat` 命令只负责将其内容打印，打开文件并将文件内容传递给 `cat` 命令的工作则交给终端完成。\n\n#### 输入重定向 `<<`\n\n将键盘的输入重定向为某个命令的输入。\n\n```javascript\nsort -n << END # 输入这个命令之后，按下回车，终端就进入键盘输入模式，其中END为结束命令（这个可以自定义）\n\nwc -m << END # 统计输入的单词\n\n```\n\n### 管道 `|`\n\n把两个命令连起来使用，一个命令的输出作为另外一个命令的输入，英文是 `pipeline` ，可以想象一个个水管连接起来，管道算是重定向流的一种。\n\n![未命名文件 (1).png](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>)\n\n举几个实际用法案例：\n\n```javascript\ncut -d , -f 1 name.csv | sort > sorted_name.txt \n# 第一步获取到的 name 列表，通过管道符再进行排序，最后输出到sorted_name.txt\n\ndu | sort -nr | head \n# du 表示列举目录大小信息\n# sort 进行排序,-n 表示按数字排序，-r 表示倒序\n# head 前10行文件\n\ngrep log -Ir /var/log | cut -d : -f 1 | sort | uniq\n# grep log -Ir /var/log 表示在log文件夹下搜索 /var/log 文本，-r 表示递归，-I 用于排除二进制文件\n# cut -d : -f 1 表示通过冒号进行剪切，获取剪切的第一部分\n# sort 进行排序\n# uniq 进行去重\n\n```\n\n### 流\n\n流并非一个命令，在计算机科学中，流 `stream` 的含义是比较难理解的，记住一点即可：**流就是读一点数据, 处理一点点数据。其中数据一般就是二进制格式。** 上面提及的重定向或管道，就是把数据当做流去运转的。\n\n到此我们就接触了，流、重定向、管道等 `Linux` 高级概念及指令。其实你会发现关于流和管道在其它语言中也有广泛的应用。 `Angular` 中的模板语法中可以使用管道。 `Node.js` 中也有 `stream` 流的概念。\n\n## 查看进程\n\n在 `Windows` 中通过 `Ctrl + Alt + Delete` 快捷键查看软件进程。\n\n### w\n\n帮助我们快速了解系统中目前有哪些用户登录着，以及他们在干什么。\n\n```javascript\n[root@lion ~]# w\n 06:31:53 up 25 days,  9:53,  1 user,  load average: 0.00, 0.01, 0.05\nUSER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT\nroot     pts/0    118.31.243.53    05:56    1.00s  0.02s  0.00s w\n \n06:31:53：表示当前时间\nup 25 days, 9:53：表示系统已经正常运行了“25天9小时53分钟”\n1 user：表示一个用户\nload average: 0.00, 0.01, 0.05：表示系统的负载，3个值分别表示“1分钟的平均负载”，“5分钟的平均负载”，“15分钟的平均负载”\n\n USER：表示登录的用于\n TTY：登录的终端名称为pts/0\n FROM：连接到服务器的ip地址\n LOGIN@：登录时间\n IDLE：用户有多久没有活跃了\n JCPU：该终端所有相关的进程使用的 CPU 时间，每当进程结束就停止计时，开始新的进程则会重新计时\n PCPU：表示 CPU 执行当前程序所消耗的时间，当前进程就是在 WHAT 列里显示的程序\n WHAT：表示当下用户正运行的程序是什么，这里我运行的是 w\n\n```\n\n### ps\n\n用于显示当前系统中的进程， `ps` 命令显示的进程列表不会随时间而更新，是静态的，是运行 `ps` 命令那个时刻的状态或者说是一个进程快照。\n\n#### 基础语法\n\n```javascript\n[root@lion ~]# ps\n  PID TTY          TIME CMD\n 1793 pts/0    00:00:00 bash\n 4756 pts/0    00:00:00 ps\n \n PID：进程号，每个进程都有唯一的进程号\n TTY：进程运行所在的终端\n TIME：进程运行时间\n CMD：产生这个进程的程序名，如果在进程列表中看到有好几行都是同样的程序名，那么就是同样的程序产生了不止一个进程\n\n```\n\n#### 常用参数\n\n- `-ef` 列出所有进程;\n- `-efH` 以乔木状列举出所有进程;\n- `-u` 列出此用户运行的进程;\n- `-aux` 通过 `CPU` 和内存使用来过滤进程 `ps -aux | less` ;\n- `-aux --sort -pcpu` 按 `CPU` 使用降序排列， `-aux --sort -pmem` 表示按内存使用降序排列;\n- `-axjf` 以树形结构显示进程， `ps -axjf` 它和 `pstree` 效果类似。\n\n### top\n\n获取进程的动态列表。\n\n```javascript\ntop - 07:20:07 up 25 days, 10:41,  1 user,  load average: 0.30, 0.10, 0.07\nTasks:  67 total,   1 running,  66 sleeping,   0 stopped,   0 zombie\n%Cpu(s):  0.7 us,  0.3 sy,  0.0 ni, 99.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem :  1882072 total,   552148 free,   101048 used,  1228876 buff/cache\nKiB Swap:        0 total,        0 free,        0 used.  1594080 avail Mem \n\n  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                                                       \n  956 root      10 -10  133964  15848  10240 S  0.7  0.8 263:13.01 AliYunDun                                                                                                     \n    1 root      20   0   51644   3664   2400 S  0.0  0.2   3:23.63 systemd                                                                                                       \n    2 root      20   0       0      0      0 S  0.0  0.0   0:00.05 kthreadd                                                                                                      \n    4 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 kworker/0:0H    \n\n```\n\n- `top - 07:20:07 up 25 days, 10:41,  1 user,  load average: 0.30, 0.10, 0.07` 相当 `w` 命令的第一行的信息。\n- 展示的这些进程是按照使用处理器 `%CPU` 的使用率来排序的。\n\n### kill\n\n结束一个进程， `kill + PID` 。\n\n```javascript\nkill 956 # 结束进程号为956的进程\nkill 956 957 # 结束多个进程\nkill -9 7291 # 强制结束进程\n\n```\n\n## 管理进程\n\n### 进程状态\n\n主要是切换进程的状态。我们先了解下 `Linux` 下进程的五种状态：\n\n1. 状态码 `R` ：表示正在运行的状态；\n2. 状态码 `S` ：表示中断（休眠中，受阻，当某个条件形成后或接受到信号时，则脱离该状态）；\n3. 状态码 `D` ：表示不可中断（进程不响应系统异步信号，即使用kill命令也不能使其中断）；\n4. 状态码 `Z` ：表示僵死（进程已终止，但进程描述符依然存在，直到父进程调用 `wait4()` 系统函数后将进程释放）；\n5. 状态码 `T` ：表示停止（进程收到 `SIGSTOP` 、 `SIGSTP` 、 `SIGTIN` 、 `SIGTOU` 等停止信号后停止运行）。\n\n### 前台进程 & 后台进程\n\n默认情况下，用户创建的进程都是前台进程，前台进程从键盘读取数据，并把处理结果输出到显示器。例如运行 `top` 命令，这就是一个一直运行的前台进程。\n\n后台进程的优点是不必等待程序运行结束，就可以输入其它命令。在需要执行的命令后面添加 `&` 符号，就表示启动一个后台进程。\n\n### &\n\n启动后台进程，它的缺点是后台进程与终端相关联，一旦关闭终端，进程就自动结束了。\n\n```javascript\ncp name.csv name-copy.csv &\n\n```\n\n### nohup\n\n使进程不受挂断（关闭终端等动作）的影响。\n\n```javascript\nnohup cp name.csv name-copy.csv\n\n```\n\n`nohup` 命令也可以和 `&` 结合使用。\n\n```javascript\nnohup cp name.csv name-copy.csv &\n\n```\n\n### bg\n\n使一个“后台暂停运行”的进程，状态改为“后台运行”。\n\n```javascript\nbg %1 # 不加任何参数的情况下，bg命令会默认作用于最近的一个后台进程，如果添加参数则会作用于指定标号的进程\n\n```\n\n实际案例1：\n\n```javascript\n1. 执行 grep -r \"log\" / > grep_log 2>&1 命令启动一个前台进程，并且忘记添加 & 符号\n2. ctrl + z 使进程状态转为后台暂停\n3. 执行 bg 将命令转为后台运行\n\n```\n\n实际案例2：\n\n```javascript\n前端开发时我们经常会执行 yarn start 启动项目\n此时我们执行 ctrl + z 先使其暂停\n然后执行 bg 使其转为后台运行\n这样当前终端就空闲出来可以干其它事情了，如果想要唤醒它就使用 fg 命令即可（后面会讲）\n\n```\n\n### jobs\n\n显示当前终端后台进程状态。\n\n```javascript\n[root@lion ~]# jobs\n[1]+  Stopped                 top\n[2]-  Running                 grep --color=auto -r \"log\" / > grep_log 2>&1 &\n\n```\n\n### fg\n\n`fg` 使进程转为前台运行，用法和 `bg` 命令类似。\n\n我们用一张图来表示前后台进程切换：\n\n![image.png](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>)\n\n我们可以使程序在后台运行，成为后台进程，这样在当前终端中我们就可以做其他事情了，而不必等待此进程运行结束。\n\n## 守护进程\n\n一个运行起来的程序被称为进程。在 `Linux` 中有些进程是特殊的，它不与任何进程关联，不论用户的身份如何，都在后台运行，这些进程的父进程是 `PID` 为1的进程， `PID` 为1的进程只在系统关闭时才会被销毁。它们会在后台一直运行等待分配工作。我们将这类进程称之为守护进程 `daemon` 。\n\n守护进程的名字通常会在最后有一个 `d` ，表示 `daemon` 守护的意思，例如 `systemd` 、`httpd` 。\n\n### systemd\n\n`systemd` 是一个 `Linux` 系统基础组件的集合，提供了一个系统和服务管理器，运行为 `PID 1` 并负责启动其它程序。\n\n```javascript\n[root@lion ~]# ps -aux\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot         1  0.0  0.2  51648  3852 ?        Ss   Feb01   1:50 /usr/lib/systemd/systemd --switched-root --system --deserialize 22\n\n```\n\n通过命令也可以看到 `PID` 为1的进程就是 `systemd` 的系统进程。\n\n`systemd` 常用命令（它是一组命令的集合）：\n\n```javascript\nsystemctl start nginx # 启动服务\nsystemctl stop nginx # 停止服务\nsystemctl restart nginx # 重启服务\nsystemctl status nginx # 查看服务状态\nsystemctl reload nginx # 重载配置文件(不停止服务的情况)\nsystemctl enable nginx # 开机自动启动服务\nsystemctl disable nginx # 开机不自动启动服务\nsystemctl is-enabled nginx # 查看服务是否开机自动启动\nsystemctl list-unit-files --type=service # 查看各个级别下服务的启动和禁用情况\n\n```\n\n## 文件压缩解压\n\n- 打包：是将多个文件变成一个总的文件，它的学名叫存档、归档。\n- 压缩：是将一个大文件（通常指归档）压缩变成一个小文件。\n\n我们常常使用 `tar` 将多个文件归档为一个总的文件，称为 `archive` 。 然后用 `gzip` 或 `bzip2` 命令将 `archive` 压缩为更小的文件。\n\n![未命名文件.png](data:image/svg+xml;utf8,<?xml version=\"1.0\"?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"800\" height=\"600\"></svg>)\n\n### tar\n\n创建一个 `tar` 归档。\n\n#### 基础用法\n\n```javascript\ntar -cvf sort.tar sort/ # 将sort文件夹归档为sort.tar\ntar -cvf archive.tar file1 file2 file3 # 将 file1 file2 file3 归档为archive.tar\n\n```\n\n#### 常用参数\n\n- `-cvf` 表示 `create`（创建）+ `verbose`（细节）+ `file`（文件），创建归档文件并显示操作细节；\n- `-tf` 显示归档里的内容，并不解开归档；\n- `-rvf` 追加文件到归档， `tar -rvf archive.tar file.txt` ；\n- `-xvf` 解开归档， `tar -xvf archive.tar` 。\n\n### gzip / gunzip\n\n“压缩/解压”归档，默认用 `gzip` 命令，压缩后的文件后缀名为 `.tar.gz` 。\n\n```javascript\ngzip archive.tar # 压缩\ngunzip archive.tar.gz # 解压\n\n```\n\n### tar 归档+压缩\n\n可以用 `tar` 命令同时完成归档和压缩的操作，就是给 `tar` 命令多加一个选项参数，使之完成归档操作后，还是调用 `gzip` 或 `bzip2` 命令来完成压缩操作。\n\n```javascript\ntar -zcvf archive.tar.gz archive/ # 将archive文件夹归档并压缩\ntar -zxvf archive.tar.gz # 将archive.tar.gz归档压缩文件解压\n\n```\n\n### zcat、zless、zmore\n\n之前讲过使用 `cat less more` 可以查看文件内容，但是压缩文件的内容是不能使用这些命令进行查看的，而要使用 `zcat、zless、zmore` 进行查看。\n\n```javascript\nzcat archive.tar.gz\n\n```\n\n### zip/unzip\n\n“压缩/解压” `zip` 文件（ `zip` 压缩文件一般来自 `windows` 操作系统）。\n\n#### 命令安装\n\n```javascript\n# Red Hat 一族中的安装方式\nyum install zip \nyum install unzip \n\n```\n\n#### 基础用法\n\n```javascript\nunzip archive.zip # 解压 .zip 文件\nunzip -l archive.zip # 不解开 .zip 文件，只看其中内容\n\nzip -r sort.zip sort/ # 将sort文件夹压缩为 sort.zip，其中-r表示递归\n\n```\n\n## 编译安装软件\n\n之前我们学会了使用 `yum` 命令进行软件安装，如果碰到 `yum` 仓库中没有的软件，我们就需要会更高级的软件安装“源码编译安装”。\n\n### 编译安装\n\n简单来说，编译就是将程序的源代码转换成可执行文件的过程。大多数 `Linux` 的程序都是开放源码的，可以编译成适合我们的电脑和操纵系统属性的可执行文件。\n\n基本步骤如下：\n\n1. 下载源代码\n2. 解压压缩包\n3. 配置\n4. 编译\n5. 安装\n\n#### 实际案例\n\n##### 1、下载\n\n我们来编译安装 `htop` 软件，首先在它的官网下载源码：[bintray.com/htop/source…](https://bintray.com/htop/source/htop#files)\n\n下载好的源码在本机电脑上使用如下命令同步到服务器上：\n\n```javascript\nscp 文件名 用户名@服务器ip:目标路径\n\nscp ~/Desktop/htop-3.0.0.tar.gz root@121.42.11.34:.\n\n```\n\n也可以使用 `wegt` 进行下载：\n\n```javascript\nwegt+下载地址\n\nwegt https://bintray.com/htop/source/download_file?file_path=htop-3.0.0.tar.gz\n\n```\n\n##### 2、解压文件\n\n```javascript\ntar -zxvf htop-3.0.0.tar.gz # 解压\n\ncd htop-3.0.0 # 进入目录\n\n```\n\n##### 3、配置\n\n执行 `./configure` ，它会分析你的电脑去确认编译所需的工具是否都已经安装了。\n\n##### 4、编译\n\n执行 `make` 命令\n\n##### 5、安装\n\n执行 `make install` 命令，安装完成后执行 `ls /usr/local/bin/` 查看是否有 `htop` 命令。如果有就可以执行 `htop` 命令查看系统进程了。\n\n## 网络\n\n### ifconfig\n\n查看 `ip` 网络相关信息，如果命令不存在的话， 执行命令 `yum install net-tools` 安装。\n\n```javascript\n[root@lion ~]# ifconfig\n\neth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 172.31.24.78  netmask 255.255.240.0  broadcast 172.31.31.255\n        ether 00:16:3e:04:9c:cd  txqueuelen 1000  (Ethernet)\n        RX packets 1592318  bytes 183722250 (175.2 MiB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 1539361  bytes 154044090 (146.9 MiB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\nlo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536\n        inet 127.0.0.1  netmask 255.0.0.0\n        loop  txqueuelen 1000  (Local Loopback)\n        RX packets 0  bytes 0 (0.0 B)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 0  bytes 0 (0.0 B)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\n```\n\n参数解析：\n\n- `eth0` 对应有线连接（对应你的有线网卡），就是用网线来连接的上网。 `eth` 是 `Ethernet` 的缩写，表示“以太网”。有些电脑可能同时有好几条网线连着，例如服务器，那么除了 `eht0` ，你还会看到 `eth1` 、 `eth2` 等。\n- `lo` 表示本地回环（ `Local Loopback` 的缩写，对应一个虚拟网卡）可以看到它的 `ip` 地址是 `127.0.0.1` 。每台电脑都应该有这个接口，因为它对应着“连向自己的链接”。这也是被称之为“本地回环”的原因。所有经由这个接口发送的东西都会回到你自己的电脑。看起来好像并没有什么用，但有时为了某些缘故，我们需要连接自己。例如用来测试一个网络程序，但又不想让局域网或外网的用户查看，只能在此台主机上运行和查看所有的网络接口。例如在我们启动一个前端工程时，在浏览器输入 `127.0.0.1:3000` 启动项目就能查看到自己的 `web` 网站，并且它只有你能看到。\n- `wlan0` 表示无线局域网（上面案例并未展示）。\n\n### host\n\n`ip` 地址和主机名的互相转换。\n\n#### 软件安装\n\n```javascript\nyum install bind-utils\n\n```\n\n#### 基础用法\n\n```javascript\n[root@lion ~]# host github.com\nbaidu.com has address 13.229.188.59\n \n[root@lion ~]# host 13.229.188.59\n59.188.229.13.in-addr.arpa domain name pointer ec2-13-229-188-59.ap-southeast-1.compute.amazonaws.com.\n\n```\n\n### ssh 连接远程服务器\n\n通过非对称加密以及对称加密的方式（同 `HTTPS` 安全连接原理相似）连接到远端服务器。\n\n```javascript\nssh 用户@ip:port\n\n1、ssh root@172.20.10.1:22 # 端口号可以省略不写，默认是22端口\n2、输入连接密码后就可以操作远端服务器了\n\n```\n\n#### 配置 ssh\n\n`config` 文件可以配置 `ssh` ，方便批量管理多个 `ssh` 连接。\n\n配置文件分为以下几种：\n\n- 全局 `ssh` 服务端的配置： `/etc/ssh/sshd_config` ；\n- 全局 `ssh` 客户端的配置： `/etc/ssh/ssh_config`（很少修改）；\n- 当前用户 `ssh` 客户端的配置： `~/.ssh/config` 。\n\n【服务端 `config` 文件的常用配置参数】\n\n| 服务端 config 参数     | 作用                                       |\n| ---------------------- | ------------------------------------------ |\n| Port                   | sshd 服务端口号（默认是22）                |\n| PermitRootLogin        | 是否允许以 root 用户身份登录（默认是可以） |\n| PasswordAuthentication | 是否允许密码验证登录（默认是可以）         |\n| PubkeyAuthentication   | 是否允许公钥验证登录（默认是可以）         |\n| PermitEmptyPasswords   | 是否允许空密码登录（不安全，默认不可以）   |\n\n[注意] 修改完服务端配置文件需要重启服务 `systemctl restart sshd`\n\n【客户端 `config` 文件的常用配置参数】\n\n| 客户端 config 参数 | 作用                     |\n| ------------------ | ------------------------ |\n| Host               | 别名                     |\n| HostName           | 远程主机名（或 IP 地址） |\n| Port               | 连接到远程主机的端口     |\n| User               | 用户名                   |\n\n配置当前用户的 `config` ：\n\n```javascript\n# 创建config\nvim ~/.ssh/config\n\n# 填写一下内容\nHost lion # 别名\n HostName 172.x.x.x # ip 地址\n  Port 22 # 端口\n  User root # 用户\n\n```\n\n这样配置完成后，下次登录时，可以这样登录 `ssh lion` 会自动识别为 `root` 用户。\n\n[注意] 这段配置不是在服务器上，而是你自己的机器上，它仅仅是设置了一个别名。\n\n#### 免密登录\n\n`ssh` 登录分两种，一种是基于口令（账号密码），另外一种是基于密钥的方式。\n\n基于口令，就是每次登录输入账号和密码，显然这样做是比较麻烦的，今天主要学习如何基于密钥实现免密登录。\n\n##### 基于密钥验证原理\n\n客户机生成密钥对（公钥和私钥），把公钥上传到服务器，每次登录会与服务器的公钥进行比较，这种验证登录的方法更加安全，也被称为“公钥验证登录”。\n\n##### 具体实现步骤\n\n1、在客户机中生成密钥对（公钥和私钥） `ssh-keygen`（默认使用 RSA 非对称加密算法）\n\n运行完 `ssh-keygen` 会在 `~/.ssh/` 目录下，生成两个文件：\n\n- `id_rsa.pub` ：公钥\n- `id_rsa` ：私钥\n\n2、把客户机的公钥传送到服务\n\n执行 `ssh-copy-id root@172.x.x.x`（`ssh-copy-id` 它会把客户机的公钥追加到服务器 `~/.ssh/authorized_keys` 的文件中）。\n\n执行完成后，运行 `ssh root@172.x.x.x` 就可以实现免密登录服务器了。\n\n配合上面设置好的别名，直接执行 `ssh lion` 就可以登录，是不是非常方便。\n\n### wget\n\n可以使我们直接从终端控制台下载文件，只需要给出文件的HTTP或FTP地址。\n\n```javascript\nwget [参数][URL地址]\n\nwget http://www.minjieren.com/wordpress-3.1-zh_CN.zip\n\n```\n\n`wget` 非常稳定，如果是由于网络原因下载失败， `wget` 会不断尝试，直到整个文件下载完毕。\n\n#### 常用参数\n\n- `-c` 继续中断的下载。\n\n## 备份\n\n### scp\n\n它是 `Secure Copy` 的缩写，表示安全拷贝。 `scp` 可以使我们通过网络，把文件从一台电脑拷贝到另一台电脑。\n\n`scp` 是基于 `ssh` 的原理来运作的， `ssh` 会在两台通过网络连接的电脑之间创建一条安全通信的管道， `scp` 就利用这条管道安全地拷贝文件。\n\n```javascript\nscp source_file destination_file # source_file 表示源文件，destination_file 表示目标文件\n\n```\n\n其中 `source_file` 和 `destination_file` 都可以这样表示： `user@ip:file_name` ， `user` 是登录名， `ip` 是域名或 `ip` 地址。 `file_name` 是文件路径。\n\n```javascript\nscp file.txt root@192.168.1.5:/root # 表示把我的电脑中当前文件夹下的 file.txt 文件拷贝到远程电脑\nscp root@192.168.1.5:/root/file.txt file.txt # 表示把远程电脑上的 file.txt 文件拷贝到本机\n\n```\n\n### rsync\n\n`rsync` 命令主要用于远程同步文件。它可以同步两个目录，不管它们是否处于同一台电脑。它应该是最常用于“增量备份”的命令了。它就是智能版的 `scp` 命令。\n\n#### 软件安装\n\n```javascript\nyum install rsync\n\n```\n\n#### 基础用法\n\n```javascript\nrsync -arv Images/ backups/ # 将Images 目录下的所有文件备份到 backups 目录下\nrsync -arv Images/ root@192.x.x.x:backups/ # 同步到服务器的backups目录下\n\n```\n\n#### 常用参数\n\n- `-a` 保留文件的所有信息，包括权限，修改日期等；\n- `-r` 递归调用，表示子目录的所有文件也都包括；\n- `-v` 冗余模式，输出详细操作信息。\n\n默认地， `rsync` 在同步时并不会删除目标目录的文件，例如你在源目录中删除一个文件，但是用 `rsync` 同步时，它并不会删除同步目录中的相同文件。如果向删除也可以这么做： `rsync -arv --delete Images/ backups/` 。\n\n## 系统\n\n### halt\n\n关闭系统，需要 `root` 身份。\n\n```javascript\nhalt\n```\n\n### reboot\n\n重启系统，需要 `root` 身份。\n\n```javascript\nreboot\n```\n\n### poweroff\n\n直接运行即可关机，不需要 `root` 身份。\n","children":[]}]},{"name":"nginx","path":"../guanruihua.github.io/Knowledge-Reserve/产品/运维","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Knowledge-Reserve/产品/运维/nginx","data":"# Nginx\n\n> - [源码](https://trac.nginx.org/nginx/browser)\n> - [官网](<http://www.nginx.org>\n> - [windows10下nginx的安装及使用](https://blog.csdn.net/sinat_36146776/article/details/88992345)\n\n## 安装部署\n\n> 1、下载完成后，解压缩，运行cmd，使用命令进行操作，不要直接双击nginx.exe，不要直接双击nginx.exe，不要直接双击nginx.exe\n> 一定要在dos窗口启动，不要直接双击nginx.exe，这样会导致修改配置后重启、停止nginx无效，需要手动关闭任务管理器内的所有!nginx进程，再启动才可以\n> 2、使用命令到达nginx的加压缩后的目录\n`cd c:\\nginx-1.15.2`\n> 3、启动nginx服务，启动时会一闪而过是正常的\n`start nginx`\n> 4、查看任务进程是否存在，dos或打开任务管理器都行\n`tasklist /fi \"imagename eq nginx.exe\"`\n\n### 启动nginx服务\n\n> 版本: 1.20.2\n> 双击nginx, 或者命令行输入nginx启动\n\n![](./__assets__/nginx-2022-03-10-11-12-24.png)\n\n> 浏览器打开\n\n![](./__assets__/nginx-2022-03-10-11-12-59.png)\n\n### 错误\n\n> 如果都没有可能是启动报错了查看一下日志，在nginx目录中的logs文件夹下error.log是日志文件\n> 常见错误\n>\n> - 端口占用\n> - nginx文件夹路径含中文\n\n### 修改配置\n\n![](/__assets__/img/2022-01-25-15-22-37.png)\n\n#### conf/nginx.conf\n\n> 端口占用可修改: `8800`(或其他没有占用的)\n\n![](/__assets__/img/2022-01-25-15-26-47.png)\n\n重新加载修改后配置\n\n```shell\nnginx -t -c /nginx/conf/nginx.conf\n```\n\n### 重启\n\n> `nginx -s reload`\n\n### 关闭nginx\n\n> 快速停止 `nginx -s stop`\n> 完整有序地关闭 `nginx -s quit`\n\n## 文件目录\n\n```js\n[ruihuag@localhost ~]# tree /usr/local/nginx\n/usr/local/nginx\n├── client_body_temp\n├── conf                             # Nginx所有配置文件的目录\n│   ├── fastcgi.conf                 # fastcgi相关参数的配置文件\n│   ├── fastcgi.conf.default         # fastcgi.conf的原始备份文件\n│   ├── fastcgi_params               # fastcgi的参数文件\n│   ├── fastcgi_params.default       \n│   ├── koi-utf\n│   ├── koi-win\n│   ├── mime.types                   # 媒体类型\n│   ├── mime.types.default\n│   ├── nginx.conf                   # Nginx主配置文件\n│   ├── nginx.conf.default\n│   ├── scgi_params                  # scgi相关参数文件\n│   ├── scgi_params.default  \n│   ├── uwsgi_params                 # uwsgi相关参数文件\n│   ├── uwsgi_params.default\n│   └── win-utf\n├── fastcgi_temp                     # fastcgi临时数据目录\n├── html                             # Nginx默认站点目录\n│   ├── 50x.html                     # 错误页面优雅替代显示文件，例如当出现502错误时会调用此页面\n│   └── index.html                   # 默认的首页文件\n├── logs                             # Nginx日志目录\n│   ├── access.log                   # 访问日志文件\n│   ├── error.log                    # 错误日志文件\n│   └── nginx.pid                    # pid文件，Nginx进程启动后，会把所有进程的ID号写到此文件\n├── proxy_temp                       # 临时目录\n├── sbin                             # Nginx命令目录\n│   └── nginx                        # Nginx的启动命令\n├── scgi_temp                        # 临时目录\n└── uwsgi_temp                       # 临时目录\n```\n\n### 配置文件\n\n> conf //nginx所有配置文件目录\n> nginx.conf //这个是Nginx的核心配置文件，这个文件非常重要，也是我们即将要学习的重点\n> nginx.conf.default //nginx.conf的备份文件  \n\n### 日志\n\n> logs: 记录入门的文件，当nginx服务器启动后\n> 这里面会有 access.log error.log 和nginx.pid三个文件出现。\n\n### 资源目录\n\n> html //存放nginx自带的两个静态的html页面\n> 50x.html //访问失败后的失败页面\n> index.html //成功访问的默认首页\n\n### 备份文件\n\n> fastcgi.conf:fastcgi  //相关配置文件\n> fastcgi.conf.default //fastcgi.conf的备份文件\n> fastcgi_params //fastcgi的参数文件\n> fastcgi_params.default //fastcgi的参数备份文件\n> scgi_params //scgi的参数文件\n> scgi_params.default //scgi的参数备份文件\n> uwsgi_params //uwsgi的参数文件\n> uwsgi_params.default //uwsgi的参数备份文件\n> mime.types //记录的是HTTP协议中的Content-Type的值和文件后缀名的对应关系\n> mime.types.default //mime.types的备份文件\n\n### 编码文件\n\n> koi-utf、koi-win、win-utf这三个文件都是与编码转换映射相关的配置文件，\n> 用来将一种编码转换成另一种编码\n\n### 执行文件\n\n> sbin: 是存放执行程序文件nginx\n\n### 命令\n\n> nginx: 是用来控制Nginx的启动和停止等相关的命令。\n\n## 配置文件\n\n### 配置主要结构\n\n```shell\nworker_processes  1；                   # worker进程的数量\nevents {                                 # 事件区块开始\n worker_connections  1024；            # 每个worker进程支持的最大连接数\n}                                  # 事件区块结束\nhttp {                              # HTTP区块开始\n include       mime.types；            # Nginx支持的媒体类型库文件\n default_type  application/octet-stream；            # 默认的媒体类型\n sendfile        on；           # 开启高效传输模式\n keepalive_timeout  65；          # 连接超时\n server {                              # 第一个Server区块开始，表示一个独立的虚拟主机站点\n  listen       80；                 # 提供服务的端口，默认80\n  server_name  localhost；       # 提供服务的域名主机名\n  location / {                      # 第一个location区块开始\n   root   html；          # 站点的根目录，相当于Nginx的安装目录\n   index  index.html index.htm；        # 默认的首页文件，多个用空格分开\n  }                      # 第一个location区块结果\n  error_page   500502503504  /50x.html；          # 出现对应的http状态码时，使用50x.html回应客户\n  location = /50x.html {                   # location区块开始，访问50x.html\n   root   html；                       # 指定对应的站点目录为html\n  }\n }  \n ......\n```\n\n### 主配置文件\n\n> 通过include 引入其他(子)配置文件\n>\n![](/__assets__/img/2022-01-25-16-40-39.png)\n\n### 子配置文件\n\n![](/__assets__/img/2022-01-25-16-42-26.png)\n\n### location 匹配\n\n```shell\nlocation[ = | ~ | ~* | ^~] url{\n\n}\n```\n\n> location 指令说明，该语法用来匹配 url，语法如上：\n> =：用于不含正则表达式的 url 前，要求字符串与 url 严格匹配，匹配成功就停止向下搜索并处理请求。\n> ~：用于表示 url 包含正则表达式，并且区分大小写。\n> ~*：用于表示 url 包含正则表达式，并且不区分大小写。\n> ^~：用于不含正则表达式的 url 前，要求 Nginx 服务器找到表示 url 和字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再匹配。\n> 如果有 url 包含正则表达式，不需要有 ~ 开头标识。\n\n```shell\n#优先级1,精确匹配，根路径\nlocation =/ {\n  return 400;\n}\n\n#优先级2,以某个字符串开头,以av开头的，优先匹配这里，区分大小写\nlocation ^~ /av {\n  root /data/av/;\n}\n\n#优先级3，区分大小写的正则匹配，匹配/media*****路径\nlocation ~ /media {\n alias /data/static/;\n}\n\n#优先级4 ，不区分大小写的正则匹配，所有的****.jpg|gif|png 都走这里\nlocation ~* .*\\.(jpg|gif|png|js|css)$ {\n  root  /data/av/;\n}\n\n#优先7，通用匹配\nlocation / {\n  return 403;\n}\n\n```\n\n## 反向代理, 负载均衡\n\n### 默认轮询\n\n> 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某个服务器宕机，能自动剔除故障系统。\n\n```shell\n# constPolling 作为存放负载均衡的变量\nupstream constPolling {\n    server localhost:10001; \n    server localhost:10002;\n}\nserver {\n    listen 10000;\n    server_name localhost;\n    location / {\n    proxy_pass http://constPolling; #在代理的时候接入constPolling\n    proxy_redirect default;\n    }\n}\n\n```\n\n### 加权轮询\n\n> 通过设置weight，值越大分配率越大 到的访问概率越高，主要用于后端每台服务器性能不均衡的情况下。其次是为在主从的情况下设置不同的权值，达到合理有效的地利用主机资源。\n\n```shell\n# constPolling 作为存放负载均衡的变量\nupstream constPolling {\n    server localhost:10001 weight=1; \n    server localhost:10002 weight=2;\n}\nserver {\n    listen 10000;\n    server_name localhost;\n    location / {\n    proxy_pass http://constPolling; #在代理的时候接入constPolling\n    proxy_redirect default;\n    }\n}\n\n```\n\n> 权重越大，被访问的概率越大，比如上面就是33.33%和百分66.66%的访问概率\n> 访问的效果：\n> localhost:10001、localhost:10002、localhost:10002、localhost:10001、localhost:10002、localhost:10002\n","children":[]},{"name":"命令.md","path":"../guanruihua.github.io/Knowledge-Reserve/产品/运维/nginx","data":"# 常用命令\r\n\r\n### 启动\r\n\r\n> `nginx` //直接nginx启动，前提是配好nginx环境变量\r\n> `systemctl start nginx.service` //使用systemctl命令启动\r\n\r\n### 停止\r\n\r\n> `nginx  -s stop` //立即停止服务\r\n> `nginx -s quit` // 从容停止服务 需要进程完成当前工作后再停止\r\n> `killall nginx` //直接杀死nginx进程\r\n> `systemctl stop nginx.service` //systemctl停止\r\n\r\n### 重启\r\n\r\n> `nginx -s reload` //重启nginx\r\n> `systemctl reload nginx.service` //systemctl重启nginx\r\n\r\n### 验证nginx配置文件是否正确\r\n\r\n> `nginx -t` //输出nginx.conf syntax is ok即表示nginx的配置文件正确\r\n","children":[]}]},{"name":"server&运维","path":"../guanruihua.github.io/Knowledge-Reserve/产品/运维","data":"","children":[{"name":"Docker","path":"../guanruihua.github.io/Knowledge-Reserve/产品/运维/server&运维","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Knowledge-Reserve/产品/运维/server&运维/Docker","data":"# Docker\n\n\n\n","children":[]}]},{"name":"tomcat.md","path":"../guanruihua.github.io/Knowledge-Reserve/产品/运维/server&运维","data":"# Tomcat\n\n## 安装\n\n> <http://tomcat.apache.org/>\n>\n> 下载``64-bit_Windows_zip`\n>\n> idea 配置 : <https://blog.csdn.net/weixin_41249041/article/details/88375420>\n\n## 配置环境变量\n\n> 不配置也可以使用, 知识每次使用都要到bin文件夹下运行``startup.bat`\n>\n> 配置Tomcat环境变量\n>\n> 1，新建变量名：CATALINA_BASE，变量值：E:\\Develop\\apache-tomcat-7.0.93\n>\n> 2，新建变量名：CATALINA_HOME，变量值：E:\\Develop\\apache-tomcat-7.0.93\n>\n> 3，打开PATH，添加变量值：%CATALINA_HOME%\\lib  %CATALINA_HOME%\\bin\n>\n> 到tomcat的bin目录测试是否可以访问。  \n\n## 常识补充\n\n> 文件目录:\n>\n> - bin: 命令文件, 开启和关闭\n> - conf: tomcat的配置文件\n> - lib: tomcat所需的依赖库(jar包)\n> - logs: 日志文件\n> - temp: 运行产生的临时文件\n> - webapps: 需要发布的项目都会放在这个目录里面\n","children":[]}]},{"name":"宝塔面板.md","path":"../guanruihua.github.io/Knowledge-Reserve/产品/运维","data":"# 运维工具\n\n> [宝塔面板 - 简单好用的Linux/Windows服务器运维管理面板 (bt.cn)](https://www.bt.cn/?btwaf=75316336)\n","children":[]},{"name":"部署.md","path":"../guanruihua.github.io/Knowledge-Reserve/产品/运维","data":"# 部署\n\n## 相关概念\n\n### CI的含义\n\n> CI 的意思是 持续构建\n负责拉取代码库中的代码后，执行用户预置定义好的操作脚本，通过一系列编译操作构建出一个 制品 ，并将制品推送至到制品库里面。常用工具有 Gitlab CI，Github CI，Jenkins 等。这个环节不参与部署，只负责构建代码，然后保存构建物。构建物被称为 制品，保存制品的地方被称为 制品库\n\n### CD的含义\n\n> CD 则有2层含义： 持续部署（Continuous Deployment） 和 持续交付（Continuous Delivery） 。\n持续交付 的概念是：将制品库的制品拿出后，部署在测试环境 / 交付给客户提前测试。 持续部署 则是将制品部署在生产环境。\n","children":[]}]}]},{"name":"前置知识","path":"../guanruihua.github.io/Knowledge-Reserve","data":"","children":[{"name":"图片.md","path":"../guanruihua.github.io/Knowledge-Reserve/前置知识","data":"# 图片\r\n\r\n## 图片的格式\r\n\r\n### jpg 格式\r\n\r\n使用的是一种失真压缩标准格式，24bit色彩，不支持动画，不支持透明色\r\n\r\n- jpeg的格式的压缩方式是破坏性资料性的压缩。即图片在经过压缩的过程中会遭到可见的破坏，一张图片经过多次的上传和下载，图片会逐渐失真。\r\n\r\n优势：\r\n\r\n1. 支持摄影图像和写实图像的高级压缩，并且可以利用压缩比例来控制文件的大小。\r\n2. 占用的存储较少\r\n\r\n劣势：\r\n\r\n```tex\r\n1. 有损的压缩会导致图片数据的质量下降。\r\n2. 在编辑和重新保存的时候，失真的效果会积累。\r\n3. 不适合所含颜色较少的，颜色差异较少的图片。\r\n```\r\n\r\n### png 格式\r\n\r\n是一种可移植网络格式，使用的是无损数据格式。\r\n\r\n优势：\r\n\r\n1. 可以在保证不失真的情况，尽可能的压缩图片的大小。\r\n2. 可以存储灰度图像，可以设置透明色\r\n\r\n劣势：\r\n\r\n 压缩方式是无损压缩，但是图片文件较大，不适合运用在web应用上。\r\n\r\n**总的来说，PNG不适合任何地方，因为这个格式是的图片文件会较大。而JPG就可以使用大部分场景。**\r\n\r\n### webp格式\r\n\r\n一种加快图片的加载速度的图片，压缩图片的体积大约为jpeg的三分之二，并能解决服务器的服务器宽带资源和数据空间。\r\n","children":[]}]},{"name":"天干地支计算年月日时.md","path":"../guanruihua.github.io/Knowledge-Reserve","data":"# 天干地支计算年月日时\r\n\r\n<https://blog.csdn.net/qq_33538651/article/details/114053664>\r\n","children":[]},{"name":"数据结构","path":"../guanruihua.github.io/Knowledge-Reserve","data":"","children":[{"name":"哈希表","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构","data":"","children":[{"name":"哈希表.md","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构/哈希表","data":"# 哈希表\n\n## 散列表\n\n> 散列表使用某种算法操作(散列函数)将键转化为数组的索引来访问数组中的数据，这样可以通过Key-value的方式来访问数据，达到常数级别的存取效率。现在的nosql数据库都是采用key-value的方式来访问存储数据。\n\n散列表是算法在时间和空间上做出权衡的经典例子。通过一个散列函数，将键值key映射到记录的访问地址，达到快速查找的目的。如果没有内存限制，我们可以直接将键作为数组的索引，所有的操作操作只需要一次访问内存就可以完成。但这种情况不太现实。\n\n### 散列函数\n\n散列函数就是将键转化为数组索引的过程。且这个函数应该易于计算且能够均与分布所有的键。\n\n散列函数最常用的方法是`除留余数法`。这时候被除数应该选用`素数`，这样才能保证键值的均匀散步。\n\n散列函数和键的类型有关，每种数据类型都需要相应的散列函数；比如键的类型是整数，那我们可以直接使用`除留余数法`；这里特别说明下，大多数情况下，键的类型都是字符串，这个时候我们任然可以使用`除留余数法`，将字符串当做一个特别大的整数。\n\n```c\nint hash = 0;\nfor (int i=0;i<s.length();i++){\n hash = (R*hash +s.charAt(i)%M);\n}\n```\n\n还有，比如下面的：\n\n```c\nHash hashCode(char *key){\n int offset = 5;\n Hash hashCode = 0;\n while(*key){\n  hashCode = (hashCode << offset) + *key++;\n }\n return hashCode;  \n}\n```\n\n使用时 `hashCode(key) & (size-1)`就可以得到一个 `size-1` 范围内的hash值\n\n当然，还有其他的散列函数，如`平方取中法`, `随机数法`等。\n\n### 碰撞解决\n\n不同的关键字得到同一个散列地址`f(key1)=f(key2)`，即为碰撞 。这是我们需要尽量避免的情况。常见的处理方法有：\n\n1. 拉链法\n2. 线性探测法\n\n#### 拉链法\n\n将大小为M的数组中的每个元素指向一条链表，链表中的每个节点都存储了散列值为该元素索引的键值对。每条链表的平均长度是N/M，N是键值对的总个数。\n\n添加操作：\n\n1. 通过hash函数得到hashCode\n2. 通过hashcode得到index\n3. 如果index处没有链表，建立好新结点，作为新链表的首结点\n4. 如果index处已经有链表，先要遍历看key是否已经存在，如果存在直接返回，如果不存在，加入链表头部\n\n删除操作：\n\n1. 通过hash函数得到hashCode\n2. 通过hashcode得到index\n3. 遍历链表，删除结点\n\n#### 线性探测法\n\n使用大小为M的数组保存N个键值对，当碰撞发生时，直接检查散列表中的下一个位置。\n\n### 数据结构和算法\n\n这里给出拉链法构造的hashmap的算法，表示如下：\n\n```c\ntypedef char * Key;\ntypedef int value;\ntypedef unsigned int Hash;\n\n/*每个节点表示*/\ntypedef struct Entry{\n Hash hash;\n Key key;\n Value value;\n Entry *next;\n}Entry;\n\ntypedef struct HashMap{\n Entry **heads;\n unsigned int size; /* 数组大小*/\n unsigned int usage;/* 键值对的个数*/\n}HashMap;\n\nHash hashCode(Key);\nHashMap *create(unsigned int size);\nHashMap *put(HashMap *,Key ,Value);\nint get(HashMap *,Key);\n\nHashMap *_putInHead(HashMap *,int index,Key,Value);\nHashMap *_putInList(HashMap *,int index,Key,Value);\n\nHash hashCode(char *key){\n int offset = 5;\n Hash hashCode = 0;\n while(*key){\n  hashCode = (hashCode << offset) + *key++;\n }\n return hashCode;  \n}\n\nHashMap *create(unsigned int size){\n HashMap *hashMap = malloc(sizeof(HashMap));\n hashMap->size = size;\n hashMap->usage = 0;\n hashMap->heads = calloc(size,sizeof(Entry *));\n\n return hashMap;\n}\n\nHashMap *put(HashMap *hashMap,Key key,Value value){\n if (key == NULL){\n  return hashMap;\n }\n Hash hash = hashCode(key);\n int index = hash & (size-1);/*  */\n if (hashMap->heads[index] == NULL){\n  _putInHead(hashMap,index,key,value);\n }else{\n  _putInList(hashMap,index,key,value);\n }\n}\n\nValue get(HashMap hashMap*,Key key){\n if (key == NULL){\n  return hashMap;\n }\n Hash hash = hashCode(key);\n int index = hash & (size-1);/*  */\n\n Entry *entry = hashMap->heads[index];\n while(entry != NULL){\n  if (entry->hash == hash){\n   return entry->value;\n  }\n  entry = entry->next;\n }\n return NULL;\n}\n\nHashMap *_putInHead(HashMap *hashMap,int index,Key key,Value value){\n Entry *newHead = malloc(sizeof(Entry));\n newHead->hash = hash;\n newHead->key = key;\n newHead->value = value;\n\n hashMap->heads[index] = newHead;\n (hashMap->usage)++;\n return hashMap;\n}\n\nHashMap *_putInList(HashMap *hashMap,int index,Key key,Value value){\n Entry *lastEntry = hashMap->heads[index];\n while(lastEntry != NULL){\n  if (lastEntry->hash == hash){\n   return hashMap;\n  }else{\n   lastEntry = lastEntry->next;\n  }\n }\n\n lastEntry = malloc(sizeof(Entry));\n lastEntry->hash = hash;\n lastEntry->key = key;\n lastEntry->value = value;\n lastEntry->next = hashMap->heads[index];\n\n hashMap->heads[index] = lastEntry;\n (hashMap->usage)++;\n return hashMap;\n}\n```\n","children":[]}]},{"name":"图","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构","data":"","children":[{"name":"无向图.md","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构/图","data":"","children":[]},{"name":"有向图.md","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构/图","data":"","children":[]}]},{"name":"堆","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构","data":"","children":[{"name":"堆.md","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构/堆","data":"# 堆 (数据结构)\n\n在计算机科学中, 一个 堆(heap) 是一种特殊的基于树的数据结构，它满足下面描述的堆属性。\n\n## 最小堆\n\n> 在一个 最小堆(min heap) 中, 如果 P 是 C 的一个父级节点, 那么 P 的key(或value)应小于或等于 C 的对应值.\n\n![](/__assets__/img/2022-02-08-14-18-37.png)\n\n## 最大堆\n\n> 在一个 最大堆(max heap) 中, P 的key(或value)大于 C 的对应值。  \n\n![](/__assets__/img/2022-02-08-14-27-41.png)\n\n在堆“顶部”的没有父级节点的节点,被称之为根节点。\n","children":[]}]},{"name":"布隆过滤器","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构","data":"","children":[]},{"name":"并查集","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构","data":"","children":[]},{"name":"栈","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构","data":"","children":[]},{"name":"树","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构","data":"","children":[{"name":"AVL树.md","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构/树","data":"","children":[]},{"name":"二叉树.md","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构/树","data":"# 二叉树\n\n特点：每个节点最多有两个子树的树结构 class NodeTree { constructor(key) { this.key = key; this.left = null; this.right = null; } }\n\n```js\n  class BinarySearchTree {\n    constructor() {\n      this.root = null;\n    }\n\n    insert(key) {\n      const newNode = new NodeTree(key);\n      const insertNode = (node, newNode) => {\n        if (newNode.key < node.key) {\n          if (node.left === null) {\n            node.left = newNode;\n          } else {\n            insertNode(node.left, newNode);\n          }\n        } else {\n          if (node.right === null) {\n            node.right = newNode;\n          } else {\n            insertNode(node.right, newNode);\n          }\n        }\n      };\n      if (!this.root) {\n        this.root = newNode;\n      } else {\n        insertNode(this.root, newNode);\n      }\n    }\n\n    //访问树节点的三种方式:中序,先序,后序\n    inOrderTraverse(callback) {\n      const inOrderTraverseNode = (node, callback) => {\n        if (node !== null) {\n          inOrderTraverseNode(node.left, callback);\n          callback(node.key);\n          inOrderTraverseNode(node.right, callback);\n        }\n      };\n      inOrderTraverseNode(this.root, callback);\n    }\n\n    min(node) {\n      const minNode = node => {\n        return node ? (node.left ? minNode(node.left) : node) : null;\n      };\n      return minNode(node || this.root);\n    }\n\n    max(node) {\n      const maxNode = node => {\n        return node ? (node.right ? maxNode(node.right) : node) : null;\n      };\n      return maxNode(node || this.root);\n    }\n  }\n  const tree = new BinarySearchTree();\n  tree.insert(11);\n  tree.insert(7);\n  tree.insert(5);\n  tree.insert(3);\n  tree.insert(9);\n  tree.insert(8);\n  tree.insert(10);\n  tree.insert(13);\n  tree.insert(12);\n  tree.insert(14);\n  tree.inOrderTraverse(value => {\n    console.log(value);\n  });\n\n  console.log(tree.min());\n  console.log(tree.max());\n```\n\n","children":[]},{"name":"字典树.md","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构/树","data":"# 字典树\r\n\r\n> - 在计算机科学中, 字典树(trie,中文又被称为”单词查找树“或 ”键树“), 也称为数字树,有时候也被称为基数树或前缀树（因为它们可以通过前缀搜索）,它是一种搜索树--一种已排序的数据结构,通常用于存储动态集或键为字符串的关联数组。\r\n> - 与二叉搜索树不同, 树上没有节点存储与该节点关联的键; 相反,节点在树上的位置定义了与之关联的键。一个节点的全部后代节点都有一个与该节点关联的通用的字符串前缀, 与根节点关联的是空字符串。\r\n> - 值对于字典树中关联的节点来说,不是必需的,相反,值往往和相关的叶子相关,以及与一些键相关的内部节点相关。\r\n> - 有关字典树的空间优化示意,请参阅紧凑前缀树\r\n\r\n![](./__assets__/字典树-2022-04-04-16-05-26.png)\r\n","children":[]},{"name":"树.md","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构/树","data":"# 树\n\n## 二叉树\n\n> 每个节点最多只有两个节点的结构, 通常左边的叫左子树, 右边的叫右子树, 二叉树的节点是具有左右次序的，不能随意颠倒。\n\n### 二叉树分类\n\n#### 完全二叉树\n\n> 假设其深度为 d（d>1）。除了第 d 层外，其它各层的节点数目均已达最大值，且第 d 层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树。\n>\n> - 简单说: 到第d层 , 从左到右要排满\n\n<img src=\"https://images.gitee.com/uploads/images/2020/1112/223634_36755f03_7984151.png\" style=\"zoom:50%;\" />\n\n#### 满二叉树\n\n> 每层都是满节点\n\n<img src=\"https://images.gitee.com/uploads/images/2020/1112/224205_ff93d738_7984151.png\" style=\"zoom:50%;\" />\n\n#### 斜树\n\n> 只有左子树, 或只有右子树\n>\n> 看起来就只有一撇或一捺\n\n<img src=\"https://images.gitee.com/uploads/images/2020/1112/224549_f78a9184_7984151.png\" style=\"zoom:50%;\" />\n\n#### 二叉搜索树(二叉查找树, 二叉排序树)\n\n> - 若它的左子树不为空，则左子树上所有节点的值均  <  它的根节点的值；\n> - 若它的右子树不为空，则右子树上所有节点的值均  >  它的根节点的值；\n> - 它的左、右子树也分别是二叉排序树。说明它是一颗有顺序的树，左子树节点的值小于根节点的值，右子树节点的值大于根节点的值。\n> - 简说:   **左子节点  <  根节点  <   右子节点**\n\n<img src=\"https://images.gitee.com/uploads/images/2020/1112/225440_9f5be847_7984151.png\" style=\"zoom:67%;\" />\n\n#### 平衡二叉树\n\n> 它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。\n\n<img src=\"https://images.gitee.com/uploads/images/2020/1112/230031_5da6fcec_7984151.png\" style=\"zoom:67%;\" />\n\n### 二叉树存储\n\n<img src=\"https://images.gitee.com/uploads/images/2020/1112/230508_b0b37f01_7984151.png\" style=\"zoom:67%;\" />\n\n#### 顺序存储\n\n<img src=\"https://images.gitee.com/uploads/images/2020/1112/230732_cd0e70da_7984151.png\" style=\"zoom:80%;\" />\n\n> 某个节点的索引为i, (假设根节点的索引为0)\n>\n> - 左子节点: **2i+1**\n> - 右子节点: **2i+2**\n\n#### 链式存储\n\n> 也叫二叉链表\n\n<img src=\"https://images.gitee.com/uploads/images/2020/1112/230759_e2103099_7984151.png\" style=\"zoom:80%;\" />\n\n### 遍历\n\n<img src=\"https://images.gitee.com/uploads/images/2020/1112/230031_5da6fcec_7984151.png\" style=\"zoom:67%;\" />\n\n> 前序遍历 : 根左右 E CBAD GFH\n>\n> 中序遍历 : 左根右 ABCD E FGH\n>\n> 后序遍历 : 左右根 ABDC FHG E\n>\n> 层序遍历 :  一层一层从上到下从左到右 E CG BDFH A。\n\n## 多叉树\n\n> 允许每个节点可以有更多的数据项和更多的子节点\n\n### 2 - 3 树\n\n![](https://images.gitee.com/uploads/images/2020/1112/234702_1e302df9_7984151.png)\n\n![](https://images.gitee.com/uploads/images/2020/1112/234924_d9676727_7984151.png)\n\n> - 2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)\n> - 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.\n> - 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点.\n> - 2-3树是由二节点和三节点构成的树\n> - 当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面3个条件。\n> - 对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则\n\n### 红黑树\n\n> 1. 满足二分搜索树的基本性质\n> 2. 每个节点要么是红色的，要么是黑色的\n> 3. 根节点是黑色的\n> 4. 每一个叶子节点（最后的空节点）是黑色的\n> 5. 如果一个节点是红色的，那么它的孩子节点都是黑色的\n> 6. **从任意一个节点到叶子节点，经过的黑色节点是一样的**\n\n![](https://images.gitee.com/uploads/images/2020/1113/000043_efea1c5a_7984151.png)\n\n![](https://images.gitee.com/uploads/images/2020/1112/235736_91073dd2_7984151.png)\n\n![](https://images.gitee.com/uploads/images/2020/1113/000158_9e0e26d4_7984151.png)\n\n> **红黑树模拟于2-3树也等价于2-3树。**\n>\n> **红黑树的左右旋转等价于2-3树的裂变节点操作；**\n>\n> **红黑树的颜色翻转等价于2-3树的融合节点操作；**\n>\n> **不同点在于红黑树的左右旋转会可以降低子树的高度，而2-3树的裂变节点操作会增加子树的高度；**\n>\n> **红黑树的颜色翻转操作不会改变子树的高度，是一个抽象的融合操作，而2-3树的融合操作可以降低子树高度。**\n>\n> **最终红黑树也会趋于平衡，而2-3会保持绝对平衡。**\n\n### B树\n\n![](https://images.gitee.com/uploads/images/2020/1113/002601_d114c414_7984151.png)\n\n> - B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4\n>- B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询\n> - 关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点\n>- 关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据.\n> - 搜索有可能在非叶子结点结束\n>- 其搜索性能等价于在关键字全集内做一次二分查找\n\n```js\n// 创建树\nfunction tree(obj) {\n\n  var obj = obj.split(')');\n  obj.pop();\n  var newobj = [];\n\n  for (var i = 0; i < obj.length; i++) {\n    newobj.push(obj[i].replace('(', ''));\n  }\n\n  var root = {\n    value: null,\n    left: null,\n    right: null,\n    have: 0\n  }\n  var u;\n\n  for (var i = 0; i < newobj.length; i++) {\n    var a1 = newobj[i].split(',')[0];\n    var a2 = newobj[i].split(',')[1];\n    u = root;\n    if (a2 !== '') {\n      for (var j = 0; j < a2.length; j++) {\n        if (a2[j] === 'L') {\n          if (u.left === null) {\n            u.left = newnode();\n            u = u.left;\n          } else {\n            u = u.left;\n          }\n        } else if (a2[j] === 'R') {\n          if (u.right === null) {\n            u.right = newnode();\n            u = u.right;\n          } else {\n            u = u.right;\n          }\n        }\n      }\n      if (u.have === 1) {} else {\n        u.value = a1;\n        u.have = 1;\n      }\n    } else {\n      root.value = a1;\n      u.have = 1;\n    }\n  }\n\n  return root;\n\n}\n\n// 建立新的结点\nfunction newnode() {\n  return {\n    value: null,\n    left: null,\n    right: null,\n    have: 0\n  }\n}\n// 队列遍历\nfunction bfs() {\n  var root = tree('(11,LL)(7,LLL)(8,R)(5,)(4,L)(13,RL)(2,LLR)(1,RRR)(4,RR)');\n  var front = 0,\n    rear = 1,\n    n = 0;\n  var q = [],\n    ans = [];\n  q[0] = root;\n  while (front < rear) {\n    var u = q[front++];\n    if (u.have !== 1) {\n      return;\n    }\n    ans[n++] = u.value;\n    if (u.left !== null) {\n      q[rear++] = u.left;\n    }\n    if (u.right !== null) {\n      q[rear++] = u.right;\n    }\n  }\n  console.log(ans.join(' '));\n}\nbfs();\n```\n\n### B+树\n\n> B树的变体, 是一种多路搜索树\n\n**<img src=\"https://images.gitee.com/uploads/images/2020/1113/002851_a85fd413_7984151.png\" style=\"zoom: 150%;\" />**\n\n> - B+树的搜索与B树也基本相同，区别是**B+树只有达到叶子结点才命中**（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找\n> - 所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。\n> - 不可能在非叶子结点命中\n> - 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层\n>   更适合文件索引系统\n\n### B*树\n\n> B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针\n\n![](https://images.gitee.com/uploads/images/2020/1113/003238_4058924d_7984151.png)\n\n> - B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2。\n> - 从第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高\n\n### B+树和B树的区别\n\n> 以一个m阶树为例。\n>\n> 关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。\n>\n> 存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。\n>\n> 分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。\n>\n> 查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。\n\n## 前中后层序遍历\n\n```js\n// 先建立一棵树\nfunction node(obj) {\n    var newobj = {};\n    if(obj.length == 1) {\n        newobj.value = obj[0];\n    }else if(obj.length == 0){\n        newobj.value == null;\n    }else{\n        newobj.left = node(obj[0]);\n        newobj.value = obj[1];\n        newobj.right = node(obj[2]);\n    }\n    return newobj;\n}\n\nvar root = node([[[[7], 11, [2]], 4, []], 5, [[13], 8, [[], 4, [1]]]])\n// 中序遍历\nfunction goTree1(tree) {\n    if(tree.hasOwnProperty('left')){\n        goTree1(tree.left);\n        console.log(tree.value);\n        goTree1(tree.right);\n    }else{\n        (tree.value == null)? console.log(\"\"): console.log(tree.value);\n    }\n}\n\n// 前序遍历\nfunction goTree2(tree) {\n    (tree.value == null)? console.log(\"\"): console.log(tree.value);\n    if(tree.hasOwnProperty('left')){\n        goTree2(tree.left);\n        goTree2(tree.right);\n    }\n}\n\n// 后序遍历\nfunction goTree3(tree) {\n    if(tree.hasOwnProperty('left')){\n        goTree3(tree.left);\n        goTree3(tree.right);\n        console.log(tree.value);\n    }else{\n        (tree.value == null)? console.log(\"\"): console.log(tree.value);\n    }\n}\n\n//层序遍历\n// 层序遍历需要使用队列的数据结构，这里可以用数组来替代\n// 这里不能使用迭代\nfunction goTree4(tree) {\n    let deque = [];\n    deque.push(root);\n    while(deque.length != 0){\n        front = deque.shift()\n        if(front.hasOwnProperty('left')){\n            deque.push(front.left);\n            deque.push(front.right);\n        }\n        (front.value == null)? console.log(\"\"): console.log(front.value);\n    }\n}\n```\n\n## 红黑树\n\n> 1. 满足二分搜索树的基本性质\n> 2. 每个节点要么是红色的，要么是黑色的\n> 3. 根节点是黑色的\n> 4. 每一个叶子节点（最后的空节点）是黑色的\n> 5. 如果一个节点是红色的，那么它的孩子节点都是黑色的\n> 6. **从任意一个节点到叶子节点，经过的黑色节点是一样的**\n","children":[]},{"name":"树状数组.md","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构/树","data":"","children":[]},{"name":"红黑树.md","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构/树","data":"","children":[]},{"name":"线段树.md","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构/树","data":"","children":[]}]},{"name":"特殊","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构","data":"","children":[{"name":"字典.md","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构/特殊","data":"# 字典\n\n字典：类似对象，以key，value存贮值 \n\n```js\nclass Dictionary { \n\t\tconstructor() { \n\t\t\tthis.items = {}; \n\t\t}\n\t\tset(key, value) {\n      this.items[key] = value;\n    }\n\n    get(key) {\n      return this.items[key];\n    }\n\n    remove(key) {\n      delete this.items[key];\n    }\n\n    get keys() {\n      return Object.keys(this.items);\n    }\n\n    get values() {\n      /*\n    也可以使用ES7中的values方法\n    return Object.values(this.items)\n    */\n\n      // 在这里我们通过循环生成一个数组并输出\n      return Object.keys(this.items).reduce((r, c, i) => {\n        r.push(this.items[c]);\n        return r;\n      }, []);\n    }\n  }\n  const dictionary = new Dictionary();\n  dictionary.set(\"Gandalf\", \"gandalf@email.com\");\n  dictionary.set(\"John\", \"johnsnow@email.com\");\n  dictionary.set(\"Tyrion\", \"tyrion@email.com\");\n\n  console.log(dictionary);\n  console.log(dictionary.keys);\n  console.log(dictionary.values);\n  console.log(dictionary.items);\n```","children":[]},{"name":"栈.md","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构/特殊","data":"# 栈\n\n栈的特点：先进后出\n\n```js\nclass Stack {\n    constructor() {\n      this.items = [];\n    }\n\n    // 入栈\n    push(element) {\n      this.items.push(element);\n    }\n\n    // 出栈\n    pop() {\n      return this.items.pop();\n    }\n\n    // 末位\n    get peek() {\n      return this.items[this.items.length - 1];\n    }\n\n    // 是否为空栈\n    get isEmpty() {\n      return !this.items.length;\n    }\n\n    // 长度\n    get size() {\n      return this.items.length;\n    }\n\n    // 清空栈\n    clear() {\n      this.items = [];\n    }\n  }\n\n  // 实例化一个栈\n  const stack = new Stack();\n  console.log(stack.isEmpty); // true\n\n  // 添加元素\n  stack.push(5);\n  stack.push(8);\n\n  // 读取属性再添加\n  console.log(stack.peek); // 8\n  stack.push(11);\n  console.log(stack.size); // 3\n  console.log(stack.isEmpty); // false\n```","children":[]},{"name":"队列.md","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构/特殊","data":"# 队列\n\n队列：先进先出 class Queue { constructor(items) { this.items = items || []; }\n\n```js\n    enqueue(element) {\n      this.items.push(element);\n    }\n\n    dequeue() {\n      return this.items.shift();\n    }\n\n    front() {\n      return this.items[0];\n    }\n\n    clear() {\n      this.items = [];\n    }\n\n    get size() {\n      return this.items.length;\n    }\n\n    get isEmpty() {\n      return !this.items.length;\n    }\n\n    print() {\n      console.log(this.items.toString());\n    }\n  }\n\n  const queue = new Queue();\n  console.log(queue.isEmpty); // true\n\n  queue.enqueue(\"John\");\n  queue.enqueue(\"Jack\");\n  queue.enqueue(\"Camila\");\n  console.log(queue.size); // 3\n  console.log(queue.isEmpty); // false\n  queue.dequeue();\n  queue.dequeue();\n```\n\n","children":[]}]},{"name":"链表","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构","data":"","children":[{"name":"双向链表","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构/链表","data":"","children":[]},{"name":"链表.md","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构/链表","data":"# 链表\n\n> Linked-list\n\n## 单向链表\n\n### 简单链表\n\n![linkedList](链表.assets/linkedList.png)\n\n> 指定第一个节点为头节点\n\n![img](https://upload-images.jianshu.io/upload_images/6633377-5c1f96efff0c90ee.png?imageMogr2/auto-orient/strip|imageView2/2/w/773/format/webp)\n\n### 插入节点\n\n![img](https://upload-images.jianshu.io/upload_images/6633377-a75cba57042a50f3.png?imageMogr2/auto-orient/strip|imageView2/2/w/766/format/webp)\n\n### 删除节点\n\n![img](https://upload-images.jianshu.io/upload_images/6633377-aa4650d34f9a0ca4.png?imageMogr2/auto-orient/strip|imageView2/2/w/937/format/webp)\n\n### 代码实现\n\n```js\n//节点\nfunction Node(element) {\n this.element = element;   //当前节点的元素\n this.next = null;         //下一个节点链接\n}\n\n//链表类\nfunction LList() {\n this.head = new Node('head');     //头节点\n this.find = find;                   //查找节点\n this.insert = insert;               //插入节点\n this.remove = remove;               //删除节点\n this.findPrev = findPrev;           //查找前一个节点\n this.display = display;             //显示链表\n}\n\n//查找给定节点\n\nfunction find(item) {\n var currNode = this.head;\n while (currNode.element != item) {\n  currNode = currNode.next;\n }\n return currNode;\n}\n\n//插入节点\n\nfunction insert(newElement, item) {\n var newNode = new Node(newElement);\n var currNode = this.find(item);\n newNode.next = currNode.next;\n currNode.next = newNode;\n}\n\n//显示链表元素\n\nfunction display() {\n var currNode = this.head;\n while (!(currNode.next == null)) {\n  console.log(currNode.next.element);\n  currNode = currNode.next;\n }\n}\n\n//查找带删除节点的前一个节点\n\nfunction findPrev(item) {\n var currNode = this.head;\n while (!(currNode.next == null) && (currNode.next.element != item)) {\n  currNode = currNode.next;\n }\n return currNode;\n}\n\n//删除节点\n\nfunction remove(item) {\n var prevNode = this.findPrev(item);\n if (!(prevNode.next == null)) {\n  prevNode.next = prevNode.next.next;\n }\n}\nvar fruits = new LList();\n\nfruits.insert('Apple', 'head');\nfruits.insert('Banana', 'Apple');\nfruits.insert('Pear', 'Banana');\n\nconsole.log(fruits.display());\n// Apple\n// Banana\n// Pear\n```\n\n```js\nclass Node {\n    constructor(element) {\n      this.element = element;\n      this.next = null;\n    }\n  }\n\n  // 链表\n  class LinkedList {\n    constructor() {\n      this.head = null;\n      this.length = 0;\n    }\n\n    // 追加元素\n    append(element) {\n      const node = new Node(element);\n      let current = null;\n      if (this.head === null) {\n        this.head = node;\n      } else {\n        current = this.head;\n        while (current.next) {\n          current = current.next;\n        }\n        current.next = node;\n      }\n      this.length++;\n    }\n\n    // 任意位置插入元素\n    insert(position, element) {\n      if (position >= 0 && position <= this.length) {\n        const node = new Node(element);\n        let current = this.head;\n        let previous = null;\n        let index = 0;\n        if (position === 0) {\n          this.head = node;\n          node.next = current;\n        } else {\n          while (index++ < position) {\n            previous = current;\n            current = current.next;\n          }\n          node.next = current;\n          previous.next = node;\n        }\n        this.length++;\n        return true;\n      }\n      return false;\n    }\n\n    // 移除指定位置元素\n    removeAt(position) {\n      // 检查越界值\n      if (position > -1 && position < this.length) {\n        let current = this.head;\n        let previous = null;\n        let index = 0;\n        if (position === 0) {\n          this.head = current.next;\n        } else {\n          while (index++ < position) {\n            previous = current;\n            current = current.next;\n          }\n          previous.next = current.next;\n        }\n        this.length--;\n        return current.element;\n      }\n      return null;\n    }\n\n    // 寻找元素下标\n    findIndex(element) {\n      let current = this.head;\n      let index = -1;\n      while (current) {\n        if (element === current.element) {\n          return index + 1;\n        }\n        index++;\n        current = current.next;\n      }\n      return -1;\n    }\n\n    // 删除指定文档\n    remove(element) {\n      const index = this.findIndex(element);\n      return this.removeAt(index);\n    }\n\n    isEmpty() {\n      return !this.length;\n    }\n\n    size() {\n      return this.length;\n    }\n\n    // 转为字符串\n    toString() {\n      let current = this.head;\n      let string = \"\";\n      while (current) {\n        string += ` ${current.element}`;\n        current = current.next;\n      }\n      return string;\n    }\n  }\n  const linkedList = new LinkedList();\n\n  console.log(linkedList);\n  linkedList.append(2);\n  linkedList.append(6);\n  linkedList.append(24);\n  linkedList.append(152);\n\n  linkedList.insert(3, 18);\n  console.log(linkedList);\n  console.log(linkedList.findIndex(24));  \n```\n\n## 双向链表\n\n双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。\n\n双向链表克服了单链表中访问某个节点前驱节点(插入，删除操作时)，只能从头遍历的问题。\n\n```c\n/*\n * File: doubleLinkedList.js\n * Project: api\n * Author: ruihuag\n * File Created: Thursday, 5th August 2021 4:19:15 pm\n * Modified By: ruihuag\n * Last Modified: Thursday, 5th August 2021 4:20:48 pm\n */\n\n//节点\n\nfunction Node(element) {\n this.element = element;   //当前节点的元素\n this.next = null;         //下一个节点链接\n this.previous = null;         //上一个节点链接\n}\n\n//链表类\n\nfunction LList() {\n this.head = new Node('head');\n this.find = find;\n this.findLast = findLast;\n this.insert = insert;\n this.remove = remove;\n this.display = display;\n this.dispReverse = dispReverse;\n}\n\n//查找元素\n\nfunction find(item) {\n var currNode = this.head;\n while (currNode.element != item) {\n  currNode = currNode.next;\n }\n return currNode;\n}\n\n//查找链表中的最后一个元素\n\nfunction findLast() {\n var currNode = this.head;\n while (!(currNode.next == null)) {\n  currNode = currNode.next;\n }\n return currNode;\n}\n\n\n//插入节点\n\nfunction insert(newElement, item) {\n var newNode = new Node(newElement);\n var currNode = this.find(item);\n newNode.next = currNode.next;\n newNode.previous = currNode;\n currNode.next = newNode;\n}\n\n//显示链表元素\n\nfunction display() {\n var currNode = this.head;\n while (!(currNode.next == null)) {\n  console.debug(currNode.next.element);\n  currNode = currNode.next;\n }\n}\n\n//反向显示链表元素\n\nfunction dispReverse() {\n var currNode = this.findLast();\n while (!(currNode.previous == null)) {\n  console.log(currNode.element);\n  currNode = currNode.previous;\n }\n}\n\n//删除节点\n\nfunction remove(item) {\n var currNode = this.find(item);\n if (!(currNode.next == null)) {\n  currNode.previous.next = currNode.next;\n  currNode.next.previous = currNode.previous;\n  currNode.next = null;\n  currNode.previous = null;\n }\n}\n\nvar fruits = new LList();\n\nfruits.insert('Apple', 'head');\nfruits.insert('Banana', 'Apple');\nfruits.insert('Pear', 'Banana');\nfruits.insert('Grape', 'Pear');\n\nconsole.log(fruits.display());\n// Apple\n// Banana\n// Pear\n// Grape\n\nconsole.log(fruits.dispReverse());\n// Grape\n// Pear\n// Banana\n// Apple\n```\n\n## 环状链表\n\n> 循环列表\n\n![loopLinkedList](../../../../../../Users/ruihuag/Pictures/loopLinkedList.png)\n","children":[]}]},{"name":"队列","path":"../guanruihua.github.io/Knowledge-Reserve/数据结构","data":"","children":[]}]},{"name":"架构&相关","path":"../guanruihua.github.io/Knowledge-Reserve","data":"","children":[{"name":"拓展","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关","data":"","children":[{"name":"编程规范.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/拓展","data":"# 编程规范\n\n## 编程范式\n\n> [命令式编程](https://link.juejin.cn?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FImperative_programming)：通过语句或命令修改程序状态。（eg：JS、Java、Python）\n>\n> [函数式编程](https://link.juejin.cn?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FFunctional_programming)：函数是第一等公民，通过函数调用、组合等完成复杂操作。（eg：科里化、函数组合）\n>\n> [声明式编程](https://link.juejin.cn?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDeclarative_programming)：描述程序逻辑而非控制流。（eg：SQL、HTML、CSS）\n>\n> [响应式编程](https://link.juejin.cn?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FReactive_programming)：基于数据流及其变化传播的声明性编程范式。（eg：React`UI = f(state)`）\n","children":[]}]},{"name":"算法","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关","data":"","children":[{"name":"basis","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/算法","data":"","children":[{"name":"时间复杂度.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/算法/basis","data":"# 时间复杂度\n\n## 常数阶O(1)\n\n```java\nint i = 1;\nint j = 2;\n++i;\nj++;\nint m = i + j;\n```\n\n## 线性阶O(n)\n\n```java\nfor(i=1; i<=n; ++i)\n{\n   j = i;\n   j++;\n}\n```\n\n## 对数阶O(logN)\n\n```java\nint i = 1;\nwhile(i<n)\n{\n    i = i * 2;\n}\n```\n\n## 线性对数阶O(nlogN)\n\n```java\nfor(m=1; m<n; m++)\n{\n    i = 1;\n    while(i<n)\n    {\n        i = i * 2;\n    }\n}\n```\n\n## 平方阶O(n²)\n\n```java\nfor(x=1; i<=n; x++)\n{\n   for(i=1; i<=n; i++)\n    {\n       j = i;\n       j++;\n    }\n}\n\n// O(m*n)\nfor(x=1; i<=m; x++)\n{\n   for(i=1; i<=n; i++)\n    {\n       j = i;\n       j++;\n    }\n}\n```\n\n## 立方阶O(n³)\n\n```java\nfor(i=0;i<n; i++){\n  for(j=0;j<n; j++){\n    for(k=0;k<n; k++){\n      ...\n    }\n  }\n}\n```\n\n## K次方阶O(n^k)\n\n```java\nfunction fn(k) {\n  if (k <= 0) return;\n  for (let i = 0; i < n; i++) {\n    arr.push(i);\n    fn(--k);\n  }\n}\nfn(k);\n\n```\n\n## 指数阶(2^n)\n\n```java\nfunction fn(k) {\n  if (k <= 0) return;\n  for (let i = 0; i < 2; i++) {\n    arr.push(i);\n    fn(--k);\n  }\n}\nfn(n);\n```\n","children":[]},{"name":"空间复杂度.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/算法/basis","data":"# **空间复杂度**\n\n## O(1)\n\n> 代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)\n\n```js\nint i = 1;\nint j = 2;\n++i;\nj++;\nint m = i + j;\n```\n\n## O(n)\n\n> 第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)\n\n```js\nint[] m = new int[n]\nfor(i=1; i<=n; ++i)\n{\n   j = i;\n   j++;\n}\n```\n","children":[]}]},{"name":"排序","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/算法","data":"","children":[{"name":"排序.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/算法/排序","data":"# 排序算法\n\n> 稳定算法 / 非稳定算法: 相同或相等的元素不会发生位置互换为稳定算法\n\n排序算法的稳定性大家应该都知道，通俗地讲就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。在简单形式化一下，如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。\n\n   其次，说一下稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，对基于比较的排序算法而言，元素交换的次数可能会少一些（个人感觉，没有证实）。\n\n回到主题，现在分析一下常见的排序算法的稳定性，每个都给出简单的理由。\n\n(1)冒泡排序\n\n冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。\n\n(2)选择排序\n\n选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n - 1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。\n\n(3)插入排序\n插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。\n\n(4)快速排序\n快速排序有两个方向，左边的i下标一直往右走，当a[i] <= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] > a[center_index]。如果i和j都走不动了，i <= j，交换a[i]和a[j],重复上面的过程，直到i > j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为5 3 3 4 3 8 9 10 11，现在中枢元素5和3（第5个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。\n\n(5)归并排序\n归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序）或者2个序列（1次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。\n\n(6)基数排序\n基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。\n\n(7)希尔排序(shell)\n希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比O(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。\n\n(8)堆排序\n我们知道堆的结构是节点i的孩子为2 *i和2* i + 1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n / 2开始和其子节点共3个值选择最大（大顶堆）或者最小（小顶堆），这3个元素之间的选择当然不会破坏稳定性。但当为n / 2 - 1， n / 2 - 2， ... 1这些个父节点选择元素时，就会破坏稳定性。有可能第n / 2个父节点交换把后面一个元素交换过去了，而第n / 2 - 1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。\n\n综上，得出结论: **选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法**\n\n![img](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif)\n\n![img](https://pic2.zhimg.com/80/v2-e3a121dea092f9ec2ef727ceab030aad_hd.jpg)\n","children":[]}]},{"name":"算法","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/算法","data":"","children":[{"name":"diff","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/算法/算法","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/算法/算法/diff","data":"","children":[]},{"name":"snabbdom.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/算法/算法/diff","data":"","children":[]},{"name":"virtual-dom.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/算法/算法/diff","data":"","children":[]}]},{"name":"index.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/算法/算法","data":"#算法\n\n> [javascript-algorithms/README.zh-CN.md at master · trekhleb/javascript-algorithms (github.com)](https://github.com/trekhleb/javascript-algorithms/blob/master/README.zh-CN.md)\n>\n> [算法 3：最常用的排序——快速排序 - 坐在马桶上学算法 - 极客学院Wiki (jikexueyuan.com)](https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html)\n>\n> [十大经典排序算法（动图演示） - 一像素 - 博客园 (cnblogs.com)](https://www.cnblogs.com/onepixel/articles/7674659.html)\n\n\n\n\n\n","children":[]}]}]},{"name":"设计模式","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关","data":"","children":[{"name":"创建型","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式","data":"","children":[{"name":"单例模式.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/创建型","data":"# 单例模式\n\n- 定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。\n- 适用场景:  一个单一对象。比如：弹窗，无论点击多少次，弹窗只应该被创建一次。\n- 其实单例的核心，就是全局共享一个实例。\n\n```js\nclass CreateUser {\n    constructor(name) {\n        this.name = name;\n        this.getName();\n    }\n    getName() {\n         return this.name;\n    }\n}\n// 代理实现单例模式\nvar ProxyMode = (function() {\n    var instance = null;\n    return function(name) {\n        if(!instance) {\n            instance = new CreateUser(name);\n        }\n        return instance;\n    }\n})();\n// 测试单体模式的实例\nvar a = new ProxyMode(\"aaa\");\nvar b = new ProxyMode(\"bbb\");\n// 因为单体模式是只实例化一次，所以下面的实例是相等的\nconsole.log(a === b);    //true\n```\n\n## 饿汉式\n\n- 在该类创建的时候就进行了实例化。\n\n```javascript\nclass Singleton {\n    private name: string;\n    private static instance: Singleton = new Singleton('singleton');\n    private constructor(name: string) {\n        this.name = name;\n        // TODO 初始化逻辑\n    }\n    public static getInstance(): Singleton {\n        return Singleton.instance;\n    }\n\n    show() {\n        console.log(this.name);\n    }\n}\n\nSingleton.getInstance().show();  // singleton\n```\n\n## 懒汉式\n\n- 在真正调用 getInstance 方法时，类才被真正实例化，更加节约空间。\n\n```javascript\nclass Singleton {\n    constructor(name) {\n        this.name = name;\n        // TODO 初始化逻辑\n    }\n    static getInstance() {\n        if (!Singleton.instance) {\n            Singleton.instance = new Singleton('singleton');\n        }\n        return Singleton.instance;\n    }\n    show() {\n        console.log(this.name);\n    }\n}\nSingleton.getInstance().show(); // singleton\n```\n\n## 模块化实现\n\n- 在项目中使用时，用模块化编程，只需要模块抛出的是一个实例而不是类，那么一样能达到单例效果。\n- 单例是在模块被引入的时候进行实例化的，模块本身其实是可以直接导入或者使用懒加载的\n\n```javascript\n// export.ts\nclass Singleton {\n    protected name: string;\n    constructor(name:string) {\n        this.name = name;\n        // TODO 初始化逻辑\n    }\n\n    show() {\n        console.log(this.name);\n    }\n}\n\nexport default new Singleton('singleton');\n// import.ts\nimport singleton from './export';\n\nsingleton.show();\n```\n","children":[]},{"name":"原型模式.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/创建型","data":"# 原型模式\n\n> 原型模式（Prototype Pattern）: **使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。**\n>\n> **优点：**\n>\n> - 可以利用原型模式简化对象的创建过程，尤其是对一些创建过程繁琐，包含对象层级比较多的对象来说，使用原型模式可以节约系统资源，提高对象生成的效率。\n> - 可以很方便得通过改变值来生成新的对象：有些对象之间的差别可能只在于某些值的不同；用原型模式可以快速复制出新的对象并手动修改值即可。\n>\n> **缺点：**\n>\n> - 对象包含的所有对象都需要配备一个克隆的方法，这就使得在对象层级比较多的情况下，代码量会很大，也更加复杂。\n\n![原型模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/20201202-prototype-pattern.png)\n\n```js\nfunction Dog() {\n    this.name = \"lili\";\n    this.birthYear = 2015;\n    this.sex = \"男\";\n    this.presentYear = 2018;\n\n    this.getDiscription = () => {\n        return `狗狗叫${this.name},性别${this.sex},${this.presentYear}年${this.presentYear - this.birthYear}岁了`\n    }\n}\n\nconst dog = new Dog();\nconsole.log(dog.getDiscription());// 狗狗叫lili,性别男,2018年3岁了\ndog.presentYear = 2020;// 修改了当前年份\nconst dog1 = Object.create(dog);// 通过ES5语法进行创建\n//const dog1 = {}\n//Object.setPrototypeOf(dog1, dog);//通过ES6语法进行创建\nconsole.log(dog.getDiscription());// 狗狗叫lili,性别男,2020年5岁了\nconsole.log(dog1.getDiscription());// 狗狗叫lili,性别男,2020年5岁了\n\n```\n\n```ts\ninterface Prototype {\n    clone():Prototype;\n}\n\nclass Dog implements Prototype {\n    public name: string;\n    public birthYear: number;\n    public sex: string;\n    public presentYear: number;\n    constructor() {\n        this.name = \"lili\";\n        this.birthYear = 2015;\n        this.sex = \"男\";\n        this.presentYear = 2018;\n    }\n\n    public getDiscription(): string {\n        return `狗狗叫${this.name},性别${this.sex},${this.presentYear}年${this.presentYear - this.birthYear}岁了`\n    }\n\n    // 实现复制\n    public clone(): Prototype {\n        return Object.create(this);\n    }\n}\n\n// 使用\nconst dog = new Dog();\nconsole.log(dog.getDiscription());\ndog.presentYear = 2020;\nconst dog1 = Object.create(dog);\nconsole.log(dog1.getDiscription());\n\n```\n","children":[]},{"name":"工厂模式.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/创建型","data":"# 工厂模式\n\n> 工厂，在现实中是生产产品的地方。在 oop 中，就是生产对象的地方。其核心是封装一个生产（new）行为。\n\n## 简单工厂\n\n> - 假如现在你运营了一间餐厅，客人如果要喝饮料，自己制作一杯就好，比如自己制作一杯茶或者一杯果汁。你觉得方便，顾客自己动手，丰衣足食，给你省了很大成本。顾客也觉得方便，想喝的时候自己就可以做，不用麻烦任何人，也不用等待。\n> - 问题: 顾客原本制作茶（new Tea()）时我们是提供的本地茶叶冲泡的茶，但是成本太高，于是想换为绿茶茶包来制作（new GreenTea()）。\n>   - 需要通知所有泡茶的顾客更改他们的制作方式，这样的话，成本是不是太大了呢？ 假设我提供一个饮品机器，能够为我们生产茶和果汁，用户想要什么饮品，按一下对应的按钮就可以。 我们来设计一下 UML 类图：\n\n![image-20210724193926976](工厂模式.assets/image-20210724193926976.png)\n\n这里饮品我们用的接口，当然也可以用一个抽象类。下面是代码实现：\n\n```ts\n\ninterface IDrink {\n    name: string; // 饮品名称\n    make(): void; // 制作饮品\n    show(): void; // 展示饮品\n}\n\n// 茶\nclass Tea implements IDrink {\n    name: string;\n    constructor(name:string) {\n        this.name = name;\n        this.make();\n    }\n    make(): void {\n        console.log('make tea');\n    }\n    show(): void {\n        console.log(`this is ${this.name}`)\n    }\n}\n\n// 果汁\nclass Juice implements IDrink {\n    name: string;\n    constructor(name:string) {\n        this.name = name;\n        this.make();\n    }\n    make(): void {\n        console.log('make juice');\n    }\n    show(): void {\n        console.log(`this is ${this.name}`)\n    }\n}\n\nclass SimpleDrinkFactory {\n    static createDrink(type: string):IDrink  {\n        switch (type) {\n            case 'tea':\n                return new Tea('tea');\n            case 'juice':\n                return new Juice('juice');\n            default:\n                return new Juice('juice');\n        }\n    }\n}\n\n// 告诉简单工厂想要一杯茶\nconst tea: Tea = SimpleDrinkFactory.createDrink('tea');\ntea.show();\n// 告诉简单工厂想要一杯果汁\nconst juice: Juice = SimpleDrinkFactory.createDrink('juice');\njuice.show();\n```\n\n![image-20210724194009593](工厂模式.assets/image-20210724194009593.png)\n\n如果我们要把茶换成绿茶，只需新增一个绿茶类，并且在工厂中对茶的生产做一个修改即可，而不需要修改原来调用工厂生产茶的逻辑。\n\n```javascript\nclass GreenTea extends Tea {\n    make(): void {\n        console.log('make green tea');\n    }\n}\n\nclass SimpleDrinkFactory {\n    static createDrink(type: string): : Tea | Juice  {\n        switch (type) {\n            case 'tea':\n                return new GreenTea('green tea');\n            case 'juice':\n                return new Juice('juice');\n            default:\n               return new Juice('juice');\n        }\n    }\n}\n```\n\n>对产品的生产做了一层封装，隔离了用户和产品的直接关系，用户只需要和工厂打交道即可。\n>\n>注意：\n>\n>1. 理论上，简单工厂可以生成任意不相关的对象(返回 any)，实际上我们还是会把具有相同特征（IDrink）的产品放在一块。\n>2. 简单工厂的灵活性不强，不支持传入不同的参数。比如调用工厂时传入不同的参数，让其在生成产品时去调用，这种在 ts 是很难做到的，但你要说在 js，那就很 easy 了。\n>3. 扩展很麻烦，比如你要新增一种饮品类型，这里就得修改工厂，改造你的饮品机器，加一个按键，违反了开闭原则。 其实简单工厂不属于设计模式的一种，但他的这种思想还是很强大的，运用也很广泛，为我们提供了一种最简单的封装创建行为的方式。\n\n## 工厂方法模式\n\n> - 工厂方法模式(Factory Method Pattern)又称为工厂模式，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，即通过不同的工厂子类来创建不同的产品对象。\n>\n> - 简单工厂扩展时需要修改工厂。这是因为再简单工厂内部我们用到了所有具体的产品，所以我们应该继续抽象，让我们的创建行为依赖一个抽象的工厂，而具体的创建行为由一个具体的工厂子类来实现。\n\n![image-20210724194050436](工厂模式.assets/image-20210724194050436.png)\n\n```typescript\ninterface IDrinkFactory {\n    createDrink(): IDrink;\n}\n\nclass TeaFactory implements IDrinkFactory {\n    createDrink(): Tea {\n        return new Tea('tea');\n    }\n}\n\nclass JuiceFactory implements IDrinkFactory {\n    createDrink(): Juice {\n        return new Juice('juice');\n    }\n}\n\n// 告诉工厂想要一杯茶\nconst tea = new TeaFactory().createDrink();\ntea.show();\n// 告诉工厂想要一杯果汁\nconst juice = new JuiceFactory().createDrink();\njuice.show();\n```\n\n> 这就好比新增一种饮品，我在新增一台机器即可，符合开闭原则。\n>\n> 但是如果我的饮品种类很多，我就要增加很多机器，假设我还有生产食物的需求，我也得为食物生产定制很多的机器。那么我的管理成本会越来越大。\n\n## 抽象工厂模式\n\n> 其实顾客消费时，既有可能消费饮品，也有可能消费食物，如果我们的抽象工厂同时提供这两种产品的创建，那么我们所需要实现的具体工厂就会少很多。也就是我们的工厂支持不同的产品系创建。\n\n![image-20210724194137906](工厂模式.assets/image-20210724194137906.png)\n\n```ts\ninterface IDrink {\n    name: string; // 饮品名称\n    make(): void; // 制作饮品\n    show(): void; // 展示饮品\n}\n\n// 茶\nclass Tea implements IDrink {\n    name: string;\n\n    constructor(name:string) {\n        this.name = name;\n        this.make();\n    }\n\n    make(): void {\n        console.log('make tea');\n    }\n\n    show(): void {\n        console.log(`this is ${this.name}`);\n    }\n}\n\n// 果汁\nclass Juice implements IDrink {\n    name: string;\n\n    constructor(name:string) {\n        this.name = name;\n        this.make();\n    }\n\n    make(): void {\n        console.log('make juice');\n    }\n\n    show(): void {\n        console.log(`this is ${this.name}`);\n    }\n}\n\ninterface IFood {\n    name: string;\n    make(): void; // 制作食品\n    show(): void; // 展示食品\n}\n\n// 炸鸡\nclass FriedChicken implements IFood {\n    name: string;\n\n    constructor(name:string) {\n        this.name = name;\n        this.make();\n    }\n\n    make(): void {\n        console.log('make FriedChicken');\n    }\n\n    show(): void {\n        console.log(`this is ${this.name}`);\n    }\n}\n\n// 汉堡\nclass Hamburg implements IFood {\n    name: string;\n\n    constructor(name:string) {\n        this.name = name;\n        this.make();\n    }\n\n    make(): void {\n        console.log('make hamburg');\n    }\n\n    show(): void {\n        console.log(`this is ${this.name}`);\n    }\n}\n\ninterface IMealFactory {\n    createDrink(): IDrink;\n    createFood(): IFood;\n}\n\nclass MealAFactory implements IMealFactory {\n    createDrink(): Tea {\n        return new Tea('tea');\n    }\n\n    createFood(): FriedChicken {\n        return new FriedChicken('fried chicken');\n    }\n}\n\nclass MealBFactory implements IMealFactory {\n    createDrink(): Juice {\n        return new Juice('juice');\n    }\n\n    createFood(): Hamburg {\n        return new Hamburg('hamburg');\n    }\n}\n\nconst mealAFactory = new MealAFactory();\nmealAFactory.createDrink().show();\nmealAFactory.createFood().show();\nconst mealBFactory = new MealBFactory();\nmealBFactory.createDrink().show();\nmealBFactory.createFood().show();\n```\n\n> 抽象工厂解决了创建不同产品簇的问题，不过抽象工厂在扩展时仍然会产生大量的实体工。\n\n## 小结\n\n> 从工厂模式的三种形态中，我们可以看到。\n>\n> 越抽象就越利于扩展，但同时也增大了代码结构的复杂性和管理难度，另外，越抽象，有时候就意味着约束力更弱。\n>\n> 比如这里具体工厂生产的产品类型，我们使用的具体产品类型来约束，而不是抽象的产品接口来约束，虽然第二种方法扩展和修改起来更方便，但是代码的约束力更弱，可能会写出不符合预期的代码。\n>\n> 没有完美的设计模式，只有合适的设计方案，不要在一开始就追求过度设计。我们只要理解工厂模式的核心就在于封装 new 这个行为。\n","children":[]},{"name":"生成器&创建者模式.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/创建型","data":"# 建造者(创建者)模式\n\n> 工厂模式:\n>\n> - 为我们将客户端的生产行为封装起来，交给了工厂。\n>\n> - 它本质上是服务于客户端的，并没有降低产品生产的难度，产品的生产逻辑仍然在自己的类内部实现。\n> - 对于一些复杂的产品类（工序多，参数多），我们需要在内部维护其复杂的构建逻辑，是很容易出错的。\n>   - 举一个简单的例子，生产牛肉汉堡，我们不管是由客户端去生产，还是工厂帮我们生产，建造的逻辑始终写在其 constructor 内部。\n>   - 全部生产步骤可能包含，做面包，做牛肉，放蔬菜，每个步骤可能有不同的参数控制，比如几片面包，几片牛肉或者几片蔬菜。如果我们发现之前的工序不好，需要调整工序，要么在类内部进行修改（违法开闭），要么新增一个类（成本太大，也不好维护），或者说我们要做猪肉汉堡，步骤和工序是一样的，我们新建一个类时由于步骤复杂，可能漏了或写错了。\n>\n> 建造者模式\n>\n> - 也叫创建者模式，它将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\n> - 创建一个复杂对象的，它将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n> - 比如我规定汉堡的构建工序是可以稳定地划分为，做面包，做肉，放蔬菜的，至于你具体是面包是做成方形的圆形的，肉要是什么类型，蔬菜是什么类型，这是具体的实现步骤，对不同的汉堡具体的实现不一样。\n\n## 建造者模式\n\n![image-20210724195025203](创建者模式.assets/image-20210724195025203.png)\n\n>这里抽象建造者使用接口也是 okay 的。可以看到这里不管抽象的建造者还是具体的建造者依赖（关联）的都是 Hamburg，这个 Hamburg 其实也可以是一个父类或者抽象类。\n\n```ts\nclass Hamburg {\n    name: string;\n    // 可选参数也可以使用 set，但是 ts 中直接在这里声明更方便, 当然如果是 private，需要使用 set 来封装\n    meatType?: string;\n    vegetableType?: string;\n    private breadNum?: number;\n\n  \n    constructor(name: string) { // 如果我们不用建造者模式，那么产品类的 constructor 这里将要传入所有参数\n        this.name = name; // 必选参数可以放在这里，步骤具体实现可变的就抽出来\n    }\n\n    // 利用 ts 的 set 当然也是 okay 的，比如 set num(num){ this.breadNum = num; }\n    setBreadNum(num: number) {\n        this.breadNum = num;\n    }\n}\n\n// 原本放在产品类的构建步骤被转移到了建造者类，由具体的建造者实现\nabstract class HamburgBuilder {\n    abstract buildBread(breadNum: number): void;\n    abstract buildMeat(meatType: string): void;\n    abstract buildVegetable(vegetableTYpe: string): void;\n    abstract createHamburg(): Hamburg;\n}\n\nclass BeefHamburgBuilder extends HamburgBuilder {\n    // 这里如果可以确定 name，就不需要用户再传入了\n    private hamburg: Hamburg = new Hamburg('牛肉汉堡');\n\n    buildBread(breadNum: number): void {\n        console.log(`制作牛肉汉堡需要的 ${breadNum} 片面包`);\n        this.hamburg.setBreadNum(breadNum);\n    }\n\n    buildMeat(meatType: string): void {\n        console.log(`制作牛肉汉堡需要的 ${meatType}`);\n        this.hamburg.meatType = meatType;\n    }\n\n    buildVegetable(vegetableType: string): void {\n        console.log(`制作牛肉汉堡需要的 ${vegetableType}`);\n        this.hamburg.vegetableType = vegetableType;\n    }\n\n    createHamburg(): Hamburg {\n        return this.hamburg;\n    }\n}\n\nclass PorkHamburgBuilder extends HamburgBuilder {\n    private hamburg: Hamburg = new Hamburg('猪肉汉堡');\n\n    buildBread(breadNum: number): void {\n        console.log(`制作猪肉汉堡需要的 ${breadNum} 片面包`);\n        this.hamburg.setBreadNum(breadNum);\n    }\n\n    buildMeat(meatType: string): void {\n        console.log(`制作猪肉汉堡需要的 ${meatType}`);\n        this.hamburg.meatType = meatType;\n    }\n\n    buildVegetable(vegetableType: string): void {\n        console.log(`制作猪肉汉堡需要的 ${vegetableType}`);\n        this.hamburg.vegetableType = vegetableType;\n    }\n\n    createHamburg(): Hamburg {\n        return this.hamburg;\n    }\n}\n\n// 我们用 director 来封装顺序，如果要改变工序，只要新增一个 director 或者新增一个 construct 即可\nclass HamburgDirector {\n    // 顺序1，包含三道工序\n    static construct1(builder: HamburgBuilder, breadNum: number, meatType: string, vegetableType: string): Hamburg {\n        builder.buildBread(breadNum);\n        builder.buildMeat(meatType);\n        builder.buildVegetable(vegetableType);\n        return builder.createHamburg();\n    }\n\n    // 顺序2，包含两道工序\n    static construct2(builder: HamburgBuilder, breadNum: number, meatType: string): Hamburg {\n        builder.buildMeat(meatType);\n        builder.buildBread(breadNum);\n        return builder.createHamburg();\n    }\n}\n\nconst beefHamburgBuilder = new BeefHamburgBuilder();\nconst porkHamburgBuilder = new PorkHamburgBuilder();\n\n\nHamburgDirector.construct1(beefHamburgBuilder, 2, 'beef', 'carrot');\nHamburgDirector.construct2(porkHamburgBuilder, 3, 'pork');\n```\n\n## 小结\n\n> - 建造者模式的核心其实就是将具体的建造过程提取出来，进行封装。构建步骤封装在建造者，构建顺序封装在导演类。\n>\n> - 可以一个导演类对应于一个建造者，也可以对应对个建造者，甚至你如果不用导演类，由客户端来选择构建顺序也是 okay 的。\n","children":[]}]},{"name":"结构型","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式","data":"","children":[{"name":"享元模式.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/结构型","data":"# 享元模式\n\n> 享元（Flyweight）模式的定义：\n>\n> - 运用共享技术来有效地支持大量细粒度对象的复用。\n>\n> - 通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。\n>\n> 享元模式的主要优点是：相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。\n>\n> 其主要缺点是：\n>\n> 1. 为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。\n> 2. 读取享元模式的外部状态会使得运行时间稍微变长。\n>\n> \n>\n> 享元模式的结构与实现\n>\n> 享元模式的定义提出了两个要求，细粒度和共享对象。因为要求细粒度，所以不可避免地会使对象数量多且性质相近，此时我们就将这些对象的信息分为两个部分：**内部状态和外部状态**。\n>\n> - 内部状态指对象共享出来的信息，存储在享元信息内部，并且不回随环境的改变而改变；\n> - 外部状态指对象得以依赖的一个标记，随环境的改变而改变，不可共享。\n>\n> \n> 比如，连接池中的连接对象，保存在连接对象中的用户名、密码、连接URL等信息，在创建对象的时候就设置好了，不会随环境的改变而改变，这些为内部状态。而当每个连接要被回收利用时，我们需要将它标记为可用状态，这些为外部状态。\n>\n> 享元模式的本质是缓存共享对象，降低内存消耗。\n>\n> \n>\n> 模式的结构\n>\n> 享元模式的主要角色有如下。\n>\n> 1. 抽象享元角色（Flyweight）：是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。\n> 2. 具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。\n> 3. 非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。\n> 4. 享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。\n\n![享元模式的结构图](http://c.biancheng.net/uploads/allimg/181115/3-1Q115161342242.gif)\n\n```java\npublic class FlyweightPattern {\n    public static void main(String[] args) {\n        FlyweightFactory factory = new FlyweightFactory();\n        Flyweight f01 = factory.getFlyweight(\"a\");\n        Flyweight f02 = factory.getFlyweight(\"a\");\n        Flyweight f03 = factory.getFlyweight(\"a\");\n        Flyweight f11 = factory.getFlyweight(\"b\");\n        Flyweight f12 = factory.getFlyweight(\"b\");\n        f01.operation(new UnsharedConcreteFlyweight(\"第1次调用a。\"));\n        f02.operation(new UnsharedConcreteFlyweight(\"第2次调用a。\"));\n        f03.operation(new UnsharedConcreteFlyweight(\"第3次调用a。\"));\n        f11.operation(new UnsharedConcreteFlyweight(\"第1次调用b。\"));\n        f12.operation(new UnsharedConcreteFlyweight(\"第2次调用b。\"));\n    }\n}\n\n//非享元角色\nclass UnsharedConcreteFlyweight {\n    private String info;\n\n    UnsharedConcreteFlyweight(String info) {\n        this.info = info;\n    }\n\n    public String getInfo() {\n        return info;\n    }\n\n    public void setInfo(String info) {\n        this.info = info;\n    }\n}\n\n//抽象享元角色\ninterface Flyweight {\n    public void operation(UnsharedConcreteFlyweight state);\n}\n\n//具体享元角色\nclass ConcreteFlyweight implements Flyweight {\n    private String key;\n\n    ConcreteFlyweight(String key) {\n        this.key = key;\n        System.out.println(\"具体享元\" + key + \"被创建！\");\n    }\n\n    public void operation(UnsharedConcreteFlyweight outState) {\n        System.out.print(\"具体享元\" + key + \"被调用，\");\n        System.out.println(\"非享元信息是:\" + outState.getInfo());\n    }\n}\n\n//享元工厂角色\nclass FlyweightFactory {\n    private HashMap<String, Flyweight> flyweights = new HashMap<String, Flyweight>();\n\n    public Flyweight getFlyweight(String key) {\n        Flyweight flyweight = (Flyweight) flyweights.get(key);\n        if (flyweight != null) {\n            System.out.println(\"具体享元\" + key + \"已经存在，被成功获取！\");\n        } else {\n            flyweight = new ConcreteFlyweight(key);\n            flyweights.put(key, flyweight);\n        }\n        return flyweight;\n    }\n}\n```\n\n","children":[]},{"name":"代理模式.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/结构型","data":"# 代理模式\n\n> - 定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。\n> - 代理模式也叫做委托模式，它是一项基本设计技巧\n> - 常用的虚拟代理形式：某一个花销很大的操作，可以通过虚拟代理的方式延迟到这种需要它的时候才去创建（例：使用虚拟代理实现图片懒加载）\n> - 图片懒加载的方式：先通过一张loading图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面。\n> - 使用代理模式实现图片懒加载的优点还有符合单一职责原则。减少一个类或方法的粒度和耦合度。\n\n```js\nlet imgFunc = (function() {\n    var imgNode = document.createElement('img');\n    document.body.appendChild(imgNode);\n    return {\n        setSrc: function(src) {\n            imgNode.src = src;\n        }\n    }\n})();\nlet proxyImage = (function() {\n    var img = new Image();\n    img.onload = function() {\n        imgFunc.setSrc(this.src);\n    }\n    return {\n        setSrc: function(src) {\n            imgFunc.setSrc('./loading,gif');\n            img.src = src;\n        }\n    }\n})();\nproxyImage.setSrc('./pic.png');\n```\n\n> 代理，顾名思义，就是替委托者处理事情。通过代理，客户不必要去接触真实的目标对象，转而去接触目标对象的代理，即可达成目的。\n\n## 静态代理\n\n![image-20210724195552332](代理模式.assets/image-20210724195552332.png)\n\n```typescript\ninterface Subject {\n    doOperation(...items: Array<any>): void;\n}\n\nclass RealSubject implements Subject {\n    doOperation(...items: Array<any>): void {\n        console.log(`真实的目标对象在执行操作，参数：${items}`); // 真实的目标对象在执行操作，参数：do work,sing\n    }\n}\n\nclass MyProxy implements Subject {\n    private target: RealSubject;\n    constructor(target: RealSubject) {\n        this.target = target;\n    }\n    doOperation(...items: Array<any>): void {\n        console.log(`代理对象在执行操作，参数：${items}`); // 代理对象在执行操作，参数：do work,sing\n        this.target.doOperation(...items);\n    }\n}\n\nconst proxy = new MyProxy(new RealSubject());\nproxy.doOperation('do work', 'sing');\n```\n\n> 静态代理让业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。但是它有如下缺点：\n>\n> - 代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。\n> - 代理对象只服务于一种类型的对象，如果要服务多类型的对象。就需要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。如上的代码是只为 Subject 类的访问提供了代理，但是如果还要为其他类如 AnotherSubject 类提供代理的话，就需要我们再次添加代理 AnotherSubject 的代理类。\n\n## 动态代理\n\n> 说到动态代理，ES6 其实提供了 Proxy 对象，用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。这里我们定义 get 行为即可：\n\n```javascript\ninterface Subject {\n    doOperation(...items: Array<any>): void;\n}\n\nclass RealSubject implements Subject {\n    doOperation(...items: Array<any>): void {\n        console.log(`真实的目标对象在执行操作，参数：${items}`, this); // 真实的目标对象在执行操作，参数：do work,sing\n    }\n}\n\nconst proxy = new Proxy(new RealSubject(), {\n    get(target, propKey) {\n        console.log(`代理对象在执行操作 ${propKey}`); // 代理对象在执行操作 doOperation\n        return target[propKey];\n    },\n});\n\nproxy.doOperation('do work', 'sing');\n```\n\n当然，这里动态调用对象方法时使用 Reflect 更佳：\n\n```javascript\ninterface Subject {\n    doOperation(...items: Array<any>): void;\n}\n\nclass RealSubject implements Subject {\n    doOperation(...items: Array<any>): void {\n        console.log(`真实的目标对象在执行操作，参数：${items}`); // 真实的目标对象在执行操作，参数：do work,sing\n    }\n}\n\nconst proxy = new Proxy(new RealSubject(), {\n    get(target, propKey, receiver) {\n        console.log(`代理对象在执行操作 ${propKey}`); // 代理对象在执行操作 doOperation\n        return Reflect.get(target, propKey, receiver);\n    },\n});\n\nproxy.doOperation('do work', 'sing');\n```\n\n不过需要小心的是，虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。\n\n```javascript\nconst target = {\n    m() {\n        console.log(this === proxy);\n    },\n};\nconst handler = {};\n\nconst proxy = new Proxy(target, handler);\n\ntarget.m(); // false\nproxy.m(); // true\n```\n\n有些原生对象的内部属性，只有通过正确的this才能拿到，所以 Proxy 也无法代理这些原生对象的属性。\n\n```javascript\nconst target = new Date();\nconst handler = {};\nconst proxy = new Proxy(target, handler);\n\nproxy.getDate();\n// Uncaught TypeError: this is not a Date object.\n```\n\n上面代码中，getDate 方法只能在 Date 对象实例上面拿到，如果 this 不是 Date对象实例就会报错。这时，this 绑定原始对象，就可以解决这个问题。\n\n```javascript\nconst target = new Date('2015-01-01');\nconst handler = {\n  get(target, prop) {\n    if (prop === 'getDate') {\n      return target.getDate.bind(target);\n    }\n    return Reflect.get(target, prop);\n  }\n};\nconst proxy = new Proxy(target, handler);\n\nproxy.getDate(); // 4\n```\n\n## 小结\n\n代理和装饰器模式比较像，都是在不改变原对象的情况下，又改变了原对象的某些功能。不同的地方是，装饰器主要是对原对象的新增和加强，而代理注重的是对原对象的隐藏和控制。\n","children":[]},{"name":"外观模式.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/结构型","data":"#外观模式\n\n> 外观模式(Facade Pattern,  门面模式 )：外观模式定义了一个高层接口，为子系统中的一组接口提供一个统一的接口。\n>\n> **优点：**\n>\n> - 实现了客户端与子系统间的解耦：客户端无需知道子系统的接口，简化了客户端调用子系统的调用过程，使得子系统使用起来更加容易。同时便于子系统的扩展和维护。\n> - 符合迪米特法则（最少知道原则）：子系统只需要将需要外部调用的接口暴露给外观类即可，而且他的接口则可以隐藏起来。\n>\n> **缺点：**\n>\n> - 违背了开闭原则：在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的代码。\n\n\n\n## 模式结构\n\n> 1. 外观( Facede ) 角色 : 为多个子心痛对外提供一个公共的接口\n> 2. 子系统( Sub System ) 角色 : 实现系统的部分功能, 客户可以通过外观角色访问它\n> 3. 客户( Client )  角色: 通过一个外观角色范文各个子系统的功能\n\n\n\n![外观模式的结构图](http://c.biancheng.net/uploads/allimg/181115/3-1Q115152143509.gif)\n\n```java\npublic class FacadePattern {\n    public static void main(String[] args) {\n        Facade f = new Facade();\n        f.method();\n    }\n}\n\n//外观角色\nclass Facade {\n    private SubSystem01 obj1 = new SubSystem01();\n    private SubSystem02 obj2 = new SubSystem02();\n    private SubSystem03 obj3 = new SubSystem03();\n\n    public void method() {\n        obj1.method1();\n        obj2.method2();\n        obj3.method3();\n    }\n}\n\n//子系统角色\nclass SubSystem01 {\n    public void method1() {\n        System.out.println(\"子系统01的method1()被调用！\");\n    }\n}\n\n//子系统角色\nclass SubSystem02 {\n    public void method2() {\n        System.out.println(\"子系统02的method2()被调用！\");\n    }\n}\n\n//子系统角色\nclass SubSystem03 {\n    public void method3() {\n        System.out.println(\"子系统03的method3()被调用！\");\n    }\n}\n```\n\n","children":[]},{"name":"桥接模式.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/结构型","data":"# 桥接模式\n\n> 桥接模式(Bridge Pattern)：\n>\n> - 将抽象部分与它的实现部分分离,使它们都可以独立地变化\n>\n> **优点：**\n>\n> - 将抽象与实现分离，让二者可以独立变化\n> - 抽象与实现分离，扩展能力强\n> - 符合开闭原则\n> - 符合合成复用原则\n> - 其实现细节对客户透明\n>\n> **缺点：**\n>\n> - 在设计之前，需要识别出两个独立变化的维度。\n>\n> 模式的结构\n>\n> 桥接（Bridge）模式包含以下主要角色。\n>\n> 1. 抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。\n> 2. 扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。\n> 3. 实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。\n> 4. 具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。\n\n![桥接模式的结构图](桥接模式.assets/3-1Q115125253H1.gif)\n\n## Java\n\n```java\npublic class BridgeTest {\n    public static void main(String[] args) {\n        Implementor imple = new ConcreteImplementorA();\n        Abstraction abs = new RefinedAbstraction(imple);\n        abs.Operation();\n    }\n}\n\n//实现化角色\ninterface Implementor {\n    public void OperationImpl();\n}\n\n//具体实现化角色\nclass ConcreteImplementorA implements Implementor {\n    public void OperationImpl() {\n        System.out.println(\"具体实现化(Concrete Implementor)角色被访问\");\n    }\n}\n\n//抽象化角色\nabstract class Abstraction {\n    protected Implementor imple;\n\n    protected Abstraction(Implementor imple) {\n        this.imple = imple;\n    }\n\n    public abstract void Operation();\n}\n\n//扩展抽象化角色\nclass RefinedAbstraction extends Abstraction {\n    protected RefinedAbstraction(Implementor imple) {\n        super(imple);\n    }\n\n    public void Operation() {\n        System.out.println(\"扩展抽象化(Refined Abstraction)角色被访问\");\n        imple.OperationImpl();\n    }\n}\n\n// 相当于 RefinedAbstraction 拥有了 Implementor 的方法等\n\n```\n\n## TS\n\n```typescript\n//实现化角色\ninterface Implementor {\n    OperationImpl():void;\n}\n \n//具体实现化角色\nclass ConcreteImplementorA implements Implementor {\n    public OperationImpl():void {\n        console.log(\"具体实现化(Concrete Implementor)角色被访问\");\n    }\n}\n\n//抽象化角色\nabstract class Abstraction {\n  protected imple: Implementor | null = null;\n  protected Abstraction(imple:Implementor) {\n      this.imple = imple;\n  }\n  public abstract Operation():void;\n}\n\n//扩展抽象化角色\nclass RefinedAbstraction extends Abstraction {\n  protected imple: Implementor | null = null;\n  constructor(imple:Implementor) {\n    super();\n    this.imple = imple;\n  }\n\n  public Operation():void {\n    console.log(\"扩展抽象化(Refined Abstraction)角色被访问\");\n    this.imple?.OperationImpl();\n  }\n}\n\n// 相当于 RefinedAbstraction 拥有了 Implementor 的方法等\nconst imple:Implementor = new ConcreteImplementorA();\nconst abs:Abstraction = new RefinedAbstraction(imple);\nabs.Operation();\n```\n\n运行结果:\n\n```shell\n扩展抽象化(Refined Abstraction)角色被访问\n具体实现化(Concrete Implementor)角色被访问\n```\n","children":[]},{"name":"装饰者模式.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/结构型","data":"#  装饰者模式\n\n> - 定义：在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法。\n> - 适用的场景：原有方法维持不变，在原有方法上再挂载其他方法来满足现有需求；函数的解耦，将函数拆分成多个可复用的函数，再将拆分出来的函数挂载到某个函数上，实现相同的效果但增强了复用性。\n\n\n\n## 例子\n\n> - 先给`Function`的原型链添加`before` 和 `after`\n> - 任何方法都可以通过这来添加\n\n```js\n// 用AOP装饰函数实现装饰者模式\nFunction.prototype.before = function (beforefn) {\n\tvar self = this;    //保存原函数引用\n\treturn function () {  //返回包含了原函数和新函数的 '代理函数'\n\t\tbeforefn.apply(this, arguments);    //执行新函数，修正this\n\t\treturn self.apply(this, arguments);  //执行原函数\n\t}\n}\nFunction.prototype.after = function (afterfn) {\n\tvar self = this;\n\treturn function () {\n\t\tvar ret = self.apply(this, arguments);\n\t\tafterfn.apply(this, arguments);\n\t\treturn ret;\n\t}\n}\nvar func = function () {\n\tconsole.log('2');\n}\n//func1和func3为挂载函数\nvar func1 = function () {\n\tconsole.log('1');\n}\nvar func3 = function () {\n\tconsole.log('3');\n}\n\n\n\nfunc = func.before(func1).after(func3);\nfunc();\n\n/*\n1\n2\n3\n*/\n\n\n/* 传参写法 */\nlet funcB = function () {\n\tconsole.log('bb');\n}\n\nlet func4 = (aa) => {\n\tconsole.log(aa)\n}\n\nfuncA = funcB.before(func4.bind({}, 1)).after(func4.bind({}, 0));\nfuncA();\n\n/*\n1\nbb\n0\n*/\n```\n\n##  小结\n\n> 装饰器模式是一个非常重要的设计模式，在很多场景下可以用来替代继承，增加代码的可维护性。\n","children":[]},{"name":"适配器模式.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/结构型","data":"# 适配器模式\n\n> - 为了解决不兼容的问题, 把一个类的接口换成我们需要的接口\n> - 场景:\n>   - 描述: 多个数据源, 组件只能接受一种数据结构,在不改变组件的内部逻辑, 保持组件的职责\n>   - 处理: 采用适配器模式, 将不同的数据结构适配成要展示组件需要的数据结构\n> - 角色：\n>\n>   - Target（目标）：客户的目标接口，可以是一个抽象类或接口，也可以是具体类。\n>   - Adaptee（适配者）：被适配的角色，是一个已有接口，但不符合客户要求。\n>   - Adapter（适配器）：将已有接口转换成目标接口\n>\n> - 分类：\n>   - 类适配器模式\n>   - 对象适配器模式\n>   - 缺省适配器模式，也叫接口适配器模式\n\n## 类适配器模式\n\nAdapter 可以继承一个已有的 Adaptee，然后实现 Target。这种情况下只能有一个 Adaptee，且 Target 必须是接口。\n\n![image-20210724195222461](适配器模式.assets/image-20210724195222461.png)\n\n```typescript\ninterface PowerTarget {\n    output12V(): string;\n}\n\nclass PowerAdaptee {\n    output220V() {\n        return '220V 交流电';\n    }\n}\n\nconst adapt = (input:string):string => {\n    // TODO 具体转换逻辑\n    console.log(`${input} 被转换成 12V 直流电`);\n    return '12V 直流电';\n};\n\nclass PowerAdapter extends PowerAdaptee implements PowerTarget {\n    public output12V() {\n        const input = this.output220V();\n        console.log(`电源适配器开始工作，获取：${input}`);\n        const output = adapt(input);\n        console.log(`电源适配器工作完成，输出：${output}`);\n        return output;\n    }\n}\n\nconst target: PowerTarget = new PowerAdapter();\ntarget.output12V();\n```\n\n## 对象适配器模式\n\n> Adapter 可以关联个已有的 Adaptee，然后实现 Target。\n>\n> 这种情况下你要依赖多个  Adaptee 实现也是 okay 的，Target 可以是接口也可以是抽象类甚至是类。\n>\n> 不过这里因为是关联，所以改写关联对象的方法就很麻烦了，不像继承那么简单。\n\n![image-20210724195303712](适配器模式.assets/image-20210724195303712.png)\n\n```typescript\ninterface PowerTarget {\n    output12V(): string;\n}\n\nclass PowerAdaptee {\n    output220V(): string {\n        return '220V 交流电';\n    }\n}\n\nconst adapt = (input) => {\n    // TODO 具体转换逻辑\n    console.log(`${input} 被转换成 12V 直流电`);\n    return '12V 直流电';\n};\n\nclass PowerAdapter implements PowerTarget {\n    private powerAdaptee: PowerAdaptee;\n    constructor() {\n        this.powerAdaptee = new PowerAdaptee();\n    }\n    public output12V(): string {\n        const input = this.powerAdaptee.output220V();\n        console.log(`电源适配器开始工作，获取：${input}`);\n        const output = adapt(input);\n        console.log(`电源适配器工作完成，输出：${output}`);\n        return output;\n    }\n}\n\nconst target: PowerTarget = new PowerAdapter();\ntarget.output12V();\n```\n\n## 小结\n\n> 其实还有一种缺省适配器模式，就是只想实现 target 接口定义的部分方法，那么在 adapter 和 target 之间加一层 defaultAdapter，用空方法实现 target 的所有接口，真正的 adapter 就可以选择性的重写 defaultAdapter 中需要去适配的方法了。本质上还是用的类适配器模式和对象适配器模式。 可以看到，适配器模式，也可以看做是对方法的一种抽象，客户依赖的接口不变，但是接口方法的实现可以用一个或多个现成的类来辅助实现。\n","children":[]}]},{"name":"行为型","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式","data":"","children":[{"name":"中介者模式.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/行为型","data":"# 中介者模式\n\n> - 定义：通过一个中介者对象，其他所有的相关对象都通过该中介者对象来通信，而不是相互引用，当其中的一个对象发生改变时，只需要通知中介者对象即可。通过中介者模式可以解除对象与对象之间的紧耦合关系。\n> - 适用的场景：例如购物车需求，存在商品选择表单、颜色选择表单、购买数量表单等等，都会触发change事件，那么可以通过中介者来转发处理这些事件，实现各个事件间的解耦，仅仅维护中介者对象即可。\n\n\n\n```js\nvar goods = {   //手机库存\n    'red|32G': 3,\n    'red|64G': 1,\n    'blue|32G': 7,\n    'blue|32G': 6,\n};\n\n//中介者\nvar mediator = (function() {\n    var colorSelect = document.getElementById('colorSelect');\n    var memorySelect = document.getElementById('memorySelect');\n    var numSelect = document.getElementById('numSelect');\n    return {\n        changed: function(obj) {\n            switch(obj){\n                case colorSelect:\n                    //TODO\n                    break;\n                case memorySelect:\n                    //TODO\n                    break;\n                case numSelect:\n                    //TODO\n                    break;\n            }\n        }\n    }\n})();\n\ncolorSelect.onchange = function() {\n    mediator.changed(this);\n};\nmemorySelect.onchange = function() {\n    mediator.changed(this);\n};\nnumSelect.onchange = function() {\n    mediator.changed(this);\n};\n```\n\n\n\nTS\n\n```typescript\n\nclass User {\n\tprivate name:string = '';\n\n\tpublic getName():string {\n\t\treturn this.name;\n\t}\n\n\tpublic setName(name:string):void {\n\t\tthis.name = name;\n\t}\n\n\tconstructor(name:string){\n\t\tthis.name  = name;\n\t}\n\n\tpublic sendMessage(message:string):void{\n\t\tChatRoom.showMessage(this,message);\n\t}\n}\n\n// 中介类\nclass ChatRoom {\n\tpublic static showMessage(user:User, message:string):void{\n\t\tconsole.log(new Date().toString() + \" [\" + user.getName() +\"] : \" + message);\n\t}\n}\n\nconst robert: User = new User(\"Robert\");\nconst john:User = new User(\"John\");\nrobert.sendMessage(\"Hi! John!\");\njohn.sendMessage(\"Hello! Robert!\");\n```\n\n","children":[]},{"name":"命令模式.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/行为型","data":"# 命令模式\n\n\n\n> 命令模式(Command Pattern)：\n>\n> - 将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。\n> - 其别名为动作(Action)模式或事务(Transaction)模式。\n>\n> \n>\n> **优点：**\n>\n> - 降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。\n> - 新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。\n> - 可以比较容易地设计一个命令队列或宏命令（组合命令）。\n> - 为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案。\n>\n> **缺点：**\n>\n> - 使用命令模式可能会导致某些系统有过多的具体命令类。\n>\n> \n\n![img](https://www.runoob.com/wp-content/uploads/2014/08/20201015-command-1.svg)\n\n## TS\n\n```typescript\n/*\n * @Author: ruihuag\n * @Date: 2021-08-13 10:52:28\n * @LastEditTime: 2021-08-13 11:34:53\n * @LastEditors: ruihuag\n * @Description: 命令模式\n * @FilePath: \\Test-Demo\\Design pattern\\行为型\\命令模式\\index.ts\n * Copyright (c) 2004-2021 i-Sprint Technologies, Inc.\n *  address: \n *  All rights reserved. \n *  \n *  This software is the confidential and proprietary information of \n *  i-Sprint Technologies, Inc. ('Confidential Information').  You shall not \n *  disclose such Confidential Information and shall use it only in \n *  accordance with the terms of the license agreement you entered into \n *  with i-Sprint. \n */\n\ninterface IOrder{\n\texecute: () => void;\n}\n\nclass Order implements IOrder{\n\texecute():void {\n\t\tconsole.log('order execute');\n\t}\n}\n// 请求类\nclass Stock{\n\tprivate name: string = \"ABC\";\n\tprivate quantity: number = 10;\n\tpublic buy(): void{\n\t\tconsole.log(`Stock [Namee:\"${this.name}\", Quantity: \"${this.quantity}\"] bought`);\n\t}\n\tpublic sell(): void{\n\t\tconsole.log(`Stock [Namee:\"${this.name}\", Quantity: \"${this.quantity}\"] sold`);\n\t}\n}\n\ntype TStock = Stock | null| undefined;\n// 实现类\nclass BuyStock implements Order{\n\tprivate abcStock: TStock;\n\tconstructor(abcStock: TStock) {\n\t\tthis.abcStock = abcStock;\n\t}\n\texecute(): void{\n\t\tthis.abcStock?.buy();\n\t}\n}\n\nclass SellStock implements Order{\n\tprivate abcStock: TStock;\n\tconstructor(abcStock: TStock) {\n\t\tthis.abcStock = abcStock;\n\t}\n\texecute(): void{\n\t\tthis.abcStock?.sell();\n\t}\n}\n\nclass Broker{\n\tprivate orderList: Order[] = [];\n\tpublic takeOrder(order:Order):void {\n\t\tthis.orderList.push(order);\n\t}\n\tpublic placeOrders():void {\n\t\tthis.orderList.map((order: Order) => {\n\t\t\torder.execute();\n\t\t})\n\t}\n}\n\nconst abcStock:TStock = new Stock();\nconst buyStockOrder:BuyStock = new BuyStock(abcStock);\nconst sellStockOrder:SellStock = new SellStock(abcStock);\nconst broker = new Broker();\nbroker.takeOrder(buyStockOrder);\nbroker.takeOrder(sellStockOrder);\n\nbroker.placeOrders();\n```\n\n\n\n","children":[]},{"name":"模板方法模式.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/行为型","data":"# 模板方法模式\n\n> 模板方法模式：\n>\n> - 定义一个操作中算法的框架，而将一些步骤延迟到子类中。\n> - 模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n>\n> \n>\n> 模板方法模式在 iOS 中的应用也非常多，如 UIViewController 的生命周期函数，定义在父类，子类可以重写这些函数。\n>\n> 模板方法模式具体应用又分为三类：\n>\n> - 抽象方法：一个抽象方法由抽象类声明、由其具体子类实现。\n> - 具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。\n> - 钩子方法：一个钩子方法由一个抽象类或具体类声明并实现，而其子类可能会加以扩展。通常在父类中给出的实现是一个空实现，并以该空实现作为方法的默认实现，当然钩子方法也可以提供一个非空的默认实现。通过在子类中实现的钩子方法对父类方法的执行进行约束，实现子类对父类行为的反向控制。\n>\n> \n>\n> **优点：**\n>\n> - 在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。\n> - 模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。\n> - 可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。\n> - 在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。\n>\n> **缺点：**\n>\n> - 需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象，此时，可结合桥接模式来进行设计。\n>\n> \n\n![模板模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/template_pattern_uml_diagram.jpg)\n\n```typescript\nabstract class Game{\n\tabstract initialize():void;\n\tabstract startPlay():void;\n\tabstract endPlay():void;\n\tplay(){ // 这里应该是final的\n\t\tthis.initialize();\n\t\tthis.startPlay();\n\t\tthis.endPlay();\n\t}\n}\n\nclass Cricket extends Game {\n\tendPlay():void {\n\t\tconsole.log(\"Cricket Game Finished!\");\n  }\n\tinitialize():void {\n\t\tconsole.log(\"Cricket Game Initialized! Start playing.\");\n\t}\n\tstartPlay():void {\n\t\tconsole.log(\"Cricket Game Started. Enjoy the game!\");\n\t}\n}\n\nclass Football extends Game {\n\tendPlay() {\n\t\tconsole.log(\"Football Game Finished!\");\n\t}\n\tinitialize() {\n\t\tconsole.log(\"Football Game Initialized! Start playing.\");\n\t}\n\tstartPlay() {\n\t\tconsole.log(\"Football Game Started. Enjoy the game!\");\n\t}\n}\n\nconst game1:Game = new Cricket();\ngame1.play();\nconst game2:Game = new Football();\ngame2.play();\n```\n\n","children":[]},{"name":"状态模式.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/行为型","data":"# 状态模式\n\n> 状态模式(State Pattern)：\n>\n> - 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。\n>\n> \n>\n> **举例：**\n>\n> 状态模式用于解决复杂对象的状态转换以及不同状态下行为的封装问题。当系统中某个对象存在多个状态，这些状态之间可以进行转换，所以对象在不同状态下具有不同行为时可以使用状态模式。状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化。\n>\n> \n>\n> **优点：**\n>\n> - 封装了状态的转换规则，在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中。\n> - 将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为。\n> - 允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以让我们避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起。\n> - 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。\n>\n> **缺点：**\n>\n> - 状态模式的使用必然会增加系统中类和对象的个数，导致系统运行开销增大。\n> - 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，增加系统设计的难度。\n> - 状态模式对“开闭原则”的支持并不太好，增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。\n>\n> \n\n\n\n## Java\n\n![学生成绩的状态转换程序的结构图](http://c.biancheng.net/uploads/allimg/181116/3-1Q11615425V39.gif)\n\n```java\npublic class ScoreStateTest {\n    public static void main(String[] args) {\n        ScoreContext account = new ScoreContext();\n        System.out.println(\"学生成绩状态测试：\");\n        account.add(30);\n        account.add(40);\n        account.add(25);\n        account.add(-15);\n        account.add(-25);\n    }\n}\n\n//环境类\nclass ScoreContext {\n    private AbstractState state;\n\n    ScoreContext() {\n        state = new LowState(this);\n    }\n\n    public void setState(AbstractState state) {\n        this.state = state;\n    }\n\n    public AbstractState getState() {\n        return state;\n    }\n\n    public void add(int score) {\n        state.addScore(score);\n    }\n}\n\n//抽象状态类\nabstract class AbstractState {\n    protected ScoreContext hj;  //环境\n    protected String stateName; //状态名\n    protected int score; //分数\n\n    public abstract void checkState(); //检查当前状态\n\n    public void addScore(int x) {\n        score += x;\n        System.out.print(\"加上：\" + x + \"分，\\t当前分数：\" + score);\n        checkState();\n        System.out.println(\"分，\\t当前状态：\" + hj.getState().stateName);\n    }\n}\n\n//具体状态类：不及格\nclass LowState extends AbstractState {\n    public LowState(ScoreContext h) {\n        hj = h;\n        stateName = \"不及格\";\n        score = 0;\n    }\n\n    public LowState(AbstractState state) {\n        hj = state.hj;\n        stateName = \"不及格\";\n        score = state.score;\n    }\n\n    public void checkState() {\n        if (score >= 90) {\n            hj.setState(new HighState(this));\n        } else if (score >= 60) {\n            hj.setState(new MiddleState(this));\n        }\n    }\n}\n\n//具体状态类：中等\nclass MiddleState extends AbstractState {\n    public MiddleState(AbstractState state) {\n        hj = state.hj;\n        stateName = \"中等\";\n        score = state.score;\n    }\n\n    public void checkState() {\n        if (score < 60) {\n            hj.setState(new LowState(this));\n        } else if (score >= 90) {\n            hj.setState(new HighState(this));\n        }\n    }\n}\n\n//具体状态类：优秀\nclass HighState extends AbstractState {\n    public HighState(AbstractState state) {\n        hj = state.hj;\n        stateName = \"优秀\";\n        score = state.score;\n    }\n\n    public void checkState() {\n        if (score < 60) {\n            hj.setState(new LowState(this));\n        } else if (score < 90) {\n            hj.setState(new MiddleState(this));\n        }\n    }\n}\n```\n\n\n\n\n\n## TS\n\n![状态模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/state_pattern_uml_diagram.png)\n\n```typescript\n\tinterface IState {\n\t\tdoAction(context:Context):void;\n\t}\n\n\tclass State implements IState{\n\t\tpublic doAction(context: Context):void {\n\t\t\tconsole.log(context)\n\t\t}\n\t}\n\t\t\n\ttype TState = State | null | undefined;\n\n\t\t\n\tclass Context {\n\t\tprivate state:TState;\n\t\tconstructor(){\n\t\t\t\tthis.state = null;\n\t\t}\n\n\t\tsetState(state:State):void{\n\t\t\t\tthis.state = state;     \n\t\t}\n\t\n\t\tgetState():TState{\n\t\t\t\treturn this.state;\n\t\t}\n\t}\n\n\tclass StartState implements State {\n\t\tdoAction(context:Context):void {\n      console.log(\"Player is in start state\");\n      context.setState(this); \n\t\t}\n\t\tpublic toString():string{\n      return \"Start State\";\n  \t}\n\t}\n\nclass StopState implements State { \n  doAction(context:Context):void {\n      console.log(\"Player is in stop state\");\n      context.setState(this); \n  }\n  public toString():string{\n      return \"Stop State\";\n  }\n}\n\tconst context: Context = new Context();\n\t\n\tconst startState:StartState = new StartState();\n\tstartState.doAction(context);\n\tconsole.log(context.getState()?.toString());\n\n\tconst stopState:StartState = new StopState();\n\tstopState.doAction(context);\n\tconsole.log(context.getState()?.toString());\n```\n\n","children":[]},{"name":"策略模式.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/行为型","data":"# 策略模式\n\n> - 定义: 定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换。\n> - 目的: 将算法和使用算法实现分离\n> - 一个基于策略模式的程序至少由两部分组成。\n>   - 第一个部分是一组策略类（可变），策略类封装了具体的算法，并负责具体的计算过程。\n>   - 第二个部分是环境类Context（不变），Context接受客户的请求，随后将请求委托给某一个策略类。要做到这一点，说明Context中要维持对某个策略对象的引用。\n\n\n\n![](../../../../../../../Users/ruihuag/Pictures/Camera Roll/策略模式.gif)\n\n## JS\n\n```js\n/*策略类*/\nvar levelOBJ = {\n    \"A\": function(money) {\n        return money * 4;\n    },\n    \"B\" : function(money) {\n        return money * 3;\n    },\n    \"C\" : function(money) {\n        return money * 2;\n    } \n};\n/*环境类*/\nvar calculateBouns =function(level,money) {\n    return levelOBJ[level](money);\n};\nconsole.log(calculateBouns('A',10000)); // 40000\n```\n\n\n\n## TS\n\n```typescript\n\n// 抽象策略接口类\ninterface IStrategy{\n\tstrategyMethod: ()=>void; // 策略方法\n}\n\n\n// 抽象策略类(由于ts无法实例化接口而添加)\nclass Strategy implements IStrategy{\n\tpublic strategyMethod() {\n\t\tconsole.log('抽象策略类方法 被访问');\n\t}\n} \n\n// 具体策略类A\nclass ContextStrategyA implements IStrategy{\n\tpublic strategyMethod(){\n\t\tconsole.log('具体策略类A的策略方法 被访问');\n\t}\n}\n\n// 具体策略类B\nclass ContextStrategyB implements IStrategy{\n\tpublic strategyMethod(){\n\t\tconsole.log('具体策略类B的策略方法 被访问');\n\t}\n}\n\n// 具体策略类B\n\n\n\n// 环境类\nclass Context {\n\tprivate stategy = new Strategy();\n\tpublic getStrategy():IStrategy {\n\t\treturn this.stategy;\n\t}\n\tpublic setStategy(stategy:IStrategy ):void{\n\t\tthis.stategy = stategy;\n\t}\n\tpublic stategyMethod() {\n\t\tthis.stategy.strategyMethod();\n\t}\n}\n\n\n// 主函数\nconst a:IStrategy = new ContextStrategyA();\nconst b:IStrategy = new ContextStrategyB();\nconst context: Context = new Context();\n\ncontext.setStategy(a);\ncontext.stategyMethod();\n\ncontext.setStategy(b);\ncontext.stategyMethod();\n\n// 运行结果\n具体策略类A的策略方法 被访问\n具体策略类B的策略方法 被访问\n```\n\n\n\n\n\n\n\n## Java\n\n```java\npublic class StrategyPattern {\n    public static void main(String[] args) {\n        Context c = new Context();\n        Strategy s = new ConcreteStrategyA();\n        c.setStrategy(s);\n        c.strategyMethod();\n        System.out.println(\"-----------------\");\n        s = new ConcreteStrategyB();\n        c.setStrategy(s);\n        c.strategyMethod();\n    }\n}\n\n//抽象策略类\ninterface Strategy {\n    public void strategyMethod();    //策略方法\n}\n\n//具体策略类A\nclass ConcreteStrategyA implements Strategy {\n    public void strategyMethod() {\n        System.out.println(\"具体策略A的策略方法被访问！\");\n    }\n}\n\n//具体策略类B\nclass ConcreteStrategyB implements Strategy {\n    public void strategyMethod() {\n        System.out.println(\"具体策略B的策略方法被访问！\");\n    }\n}\n\n//环境类\nclass Context {\n    private Strategy strategy;\n\n    public Strategy getStrategy() {\n        return strategy;\n    }\n\n    public void setStrategy(Strategy strategy) {\n        this.strategy = strategy;\n    }\n\n    public void strategyMethod() {\n        strategy.strategyMethod();\n    }\n}\n```\n\n","children":[]},{"name":"职责链模式.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/行为型","data":"# 职责链模式\n\n\n\n> 职责链模式(Chain of Responsibility Pattern)：\n>\n> - 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。\n>\n> \n>\n> **举例：**\n>\n> 职责链模式在 iOS 中有大量的应用，比如事件响应链，事件传递下来会先判断该事件是不是应该由自己处理，如果不是由自己处理则传给下一位响应者去处理，如此循环下去。需要注意的是要避免响应链循环调用造成死循环，还有当所有的响应者都无法处理时的情况\n>\n> **优点：**\n>\n> - 职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度。\n> - 请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接。\n> - 在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。\n> - 在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合“开闭原则”的。\n>\n> **缺点：**\n>\n> - 由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理。\n> - 对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。\n> - 如果建链不当，可能会造成循环调用，将导致系统陷入死循环。\n>\n> \n\n![责任链模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/2021-chain-of-responsibility.svg)\n\n\n\n## TS\n\n```typescript\ntype TAbstractLogger = AbstractLogger | null | undefined;\n// 记录器抽象类\nabstract class AbstractLogger {\n\tpublic static INFO:number = 1;\n\tpublic static DEBUG:number = 2;\n\tpublic static ERROR:number = 3;\n\tprotected level:number = -1;\n\t//责任链中的下一个元素\n\tprotected nextLogger:TAbstractLogger;\n\n\tpublic setNextLogger(nextLogger:AbstractLogger):void{\n\t\tthis.nextLogger = nextLogger;\n\t}\n\n\tpublic logMessage(level:number, message:string):void{\n\t\tif (this.level <= level) {\n\t\t\t\tthis.write(message);\n\t\t}\n\t\tif(this.nextLogger !== null){\n\t\t\t\tthis.nextLogger?.logMessage(level, message);\n\t\t}\n\t}\n\t\n\tprotected abstract write(message:string):void;\n}\n\nclass ConsoleLogger extends AbstractLogger {\n\tconstructor(level: number) {\n\t\tsuper();\n\t\tthis.level = level;\n\t}\n\tprotected write(message:string):void {    \n\t\tconsole.log(\"Standard Console::Logger: \" + message);\n\t}\n}\n\nclass ErrorLogger extends AbstractLogger {\n\tconstructor(level: number) {\n\t\tsuper();\n\t\tthis.level = level;\n\t}\n\tprotected write(message:string):void {    \n      console.log(\"Error Console::Logger: \" + message);\n  }\n}\n\nclass FileLogger extends AbstractLogger {\n\tconstructor(level: number) {\n\t\tsuper();\n\t\tthis.level = level;\n\t}\n  protected write(message:string):void {    \n    console.log(\"File::Logger: \" + message);\n\t}\n}\n\nfunction getChainOfLoggers():AbstractLogger{ \n\tconst errorLogger:AbstractLogger = new ErrorLogger(AbstractLogger.ERROR);\n\tconst fileLogger:AbstractLogger = new FileLogger(AbstractLogger.DEBUG);\n\tconst consoleLogger:AbstractLogger = new ConsoleLogger(AbstractLogger.INFO);\n\terrorLogger.setNextLogger(fileLogger);\n\tfileLogger.setNextLogger(consoleLogger);\n\treturn errorLogger;  \n}\n \nconst loggerChain:AbstractLogger = getChainOfLoggers();\nloggerChain.logMessage(AbstractLogger.INFO, \"This is an information.\");\nloggerChain.logMessage(AbstractLogger.DEBUG, \"This is a debug level information.\");\nloggerChain.logMessage(AbstractLogger.ERROR, \"This is an error information.\");\n```\n\n","children":[]},{"name":"观察者(发布-订阅)模式.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/行为型","data":"# 观察者模式\n\n> 观察者模式:\n>\n> - 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n>\n> - 就好比我们去点餐,通知服务员说，餐好了跟我说一下。那么服务员和顾客之间就形成了耦合，首先服务员得知道餐品好了以后通知那些顾客，其次，如果是多位服务员协作，每个服务员都需要知道这些顾客。\n>\n>   但事实上你发现去 kfc 点餐的时候，服务员并没有直接通知我们。而是采用叫号的方式。细想一下，你去 kfc，是不是可以在点餐系统进行排号（网上或者排队，这里抽象一下），餐品好了以后，服务员输入点餐号，点一下完成即可，点餐系统会通知对应的顾客取餐。\n>\n>   这里你和服务员之间的消息通过点餐系统来传递，你并不需要知道是谁点的完成，服务员也不需要知道这份餐品给谁。完美解耦了消息的发送者和接收者。更好地是，我们在点餐或者叫号的时候其实还可以指定行为，比如说 66 号产品好了以后帮我送到 A1 桌。\n>\n>   再比如说炒股的时候，我们可以委托挂单，就是当股票到了某一个价格就帮你买入或者卖出，等等，例子很多\n\n## 使用场景\n\n1. 当一个抽象模型有两个方面，其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。\n2. 当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象需要被改变。\n3. 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，不希望这些对象是紧密耦合的。\n\n##  角色\n\n1. 抽象主题（Subject）： 它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。\n2. 具体主题（Concrete Subject）： 将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。\n3. 抽象观察者（Observer）： 为所有的具体观察者定义一个接口，在得到主题通知时更新自己。\n4. 具体观察者（Concrete Observer）： 实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调。\n\n##  实现\n\n![image-20210724195743639](观察者 模式.assets/image-20210724195743639.png)\n\n\n\n```typescript\ninterface Msg { // Msg 可以按照任意约定的接口格式去约束，这里假设是如下类型消息\n    name: string;\n    value: string;\n}\n\ninterface Subject {\n    registerObserver(observer: Observer): void;\n    removeObserver(observer: Observer): void;\n    notifyObservers(msg: Msg): void;\n}\n\ninterface Observer {\n    update(msg: Msg): void\n}\n\nclass ConcreteSubject implements Subject {\n    private observers: Observer[] = [];\n    private state: object = {};\n    registerObserver(observer: Observer): void {\n        this.observers.push(observer);\n    }\n    removeObserver(observer: Observer): void {\n        const index = this.observers.findIndex(val => val === observer);\n        if (index > -1) {\n            this.observers.splice(index, 1);\n        }\n    }\n    notifyObservers(msg: Msg): void {\n        this.observers.forEach(observer => observer.update(msg));\n    }\n    setState(name, value): void {\n        this.state[name] = value;\n        console.log(`${name}状态更新为：${value}`);\n        console.log('通知所有观察者');\n        this.notifyObservers({\n            name,\n            value,\n        });\n    }\n}\n\nclass ConcreteObserver implements Observer {\n    name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n    update(msg: Msg): void {\n        console.log(`${this.name} 观察到：${msg.name}状态更新为：${msg.value}`);\n    }\n}\n\nconst concreteSubject = new ConcreteSubject();\nconst concreteObserver1 = new ConcreteObserver('小王');\nconst concreteObserver2 = new ConcreteObserver('小明');\n\nconcreteSubject.registerObserver(concreteObserver1);\nconcreteSubject.registerObserver(concreteObserver2);\nconcreteSubject.setState('天气', '多云');\n\nconcreteSubject.removeObserver(concreteObserver2);\nconcreteSubject.setState('天气', '晴');\n```\n\n![image-20210724195806878](观察者 模式.assets/image-20210724195806878.png)\n\n\n\n> 这里的 Msg 其实就是一种约定的消息接口，你甚至可以直接使用 Subject，这样Subject 和 Observer 就是一种双向关系（关联和依赖）。另外，这里的 setState 也只是对变更行为的一种抽象而已，你可以在任何事件或者任何时机通知订阅者进行更新。\n\n## 小结\n\n> 当一个对象密切关注另一个对象的某个状态时，就可以使用观察者模式。\n>\n> 它解除了主题和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖具体。\n>\n> 在使用轮询的地方，我们应该先考虑是否可以使用观察者模式。因为主动观察是优于被动轮询的。\n\n\n\n\n\n# 发布订阅模式\n\n> 发布-订阅是一种消息范式，消息的发布者，不会将消息直接发送给特定的`订阅者`，而是通过消息通道广播出去，然后呢，订阅者通过订阅获取到想要的消息。\n>\n> - 各个模块相互独立\n> - 存在一对多的依赖关系\n> - 依赖模块不稳定, 依赖关系部位定\n> - 各模块由不同的人员, 团队开发\n\n<img src=\"观察者(发布-订阅)模式.assets/d739205f61014be8a8f0756fcf7c1cfatplv-k3u1fbpfcp-zoom-1.image\" alt=\"img\" style=\"zoom:50%;\" />\n\n\n\n<img src=\"观察者(发布-订阅)模式.assets/66f97bd23566468182554fbac39fd009tplv-k3u1fbpfcp-zoom-1.image\" alt=\"img\" style=\"zoom:50%;\" />\n\n> - 建立一个`eventEmitter`\n> - 先通过用户订阅对应的\"内容\"\n> - `eventEmitter`发布内容\n\n## 缩减版\n\n```js\n\tlet eventEmitter = {}; // 公众号对象\n\teventEmitter.list = {}; // 缓存列表, 存放 event 及 fn\n\n\t/* 订阅 */\n\teventEmitter.on = function (event, fn) {\n\t\t(this.list[event] || (this.list[event] = [])).push(fn);\n\t\treturn this;\n\t}\n\n\t/* 发布 */\n\teventEmitter.emit = function () {\n\t\tconst _this = this;\n\t\tlet event = [].shift.call(arguments), /* 使用 shift 获取arguments 第一个参数就是对应的 event 值  */\n\t\t\tfns = [..._this.list[event]];\n\t\tif (!fns || fns.length === 0) return false; /* 如果缓存列表里没有缓存 fn, 就直接返回 false */\n\t\tfns.forEach(fn => { // 遍历 event 值对应的缓存列表, 依次执行fn\n\t\t\tfn.apply(_this, arguments);\n\t\t})\n\t\treturn _this;\n\t}\n\n\t/* 用户一 */\n\tfunction user1(content) {\n\t\tconsole.log('用户1订阅了:', content);\n\t};\n\n\t/* 用户二 */\n\tfunction user2(content) {\n\t\tconsole.log('用户2订阅了:', content);\n\t};\n\n\t// 订阅\n\teventEmitter.on('article', user1);\n\teventEmitter.on('article', user2);\n\n\t// 发布\n\teventEmitter.emit('article', 'Javascript 发布-订阅模式');\n```\n\n\n\n\n\n## 完整版\n\n> node 中 EventEmitter 就是这样一个典型例子。我们来简单实现一个 EventEmitter。\n\n```javascript\ninterface HandlerInfo {\n    handler: Function;\n    once?: boolean;\n}\nclass EventEmitter {\n    private events: Map<string, HandlerInfo[]> = new Map();\n    on(type: string, handler: Function, once?: boolean) {\n        if (!this.events.has(type)) {\n            this.events.set(type, []);\n        }\n        (this.events.get(type) || []).push({\n            handler,\n            once,\n        });\n        return () => {\n            this.off(type, handler);\n        };\n    }\n    once(type: string, handler: Function) {\n        return this.on(type, handler, true);\n    }\n    emit(type: string, ...args) {\n        let i = 0;\n        while (i < (this.events.get(type) || []).length) { // 这里每次都从 this.events 去动态读取，方中途被变更\n            const handlers: HandlerInfo[] = this.events.get(type) || [];\n            const { handler, once } = handlers[i];\n            // 如果是一次性的，应该在调用前删除，防止这里会自己触发自己，导致无限循环或者次序错乱\n            if (once) {\n                handlers.splice(i--, 1);\n            }\n            i++;\n            handler(...args); // 这里 this 就交给传入的 handler 来保证了\n        }\n    }\n    off(type?: string, handler?: Function): void {\n        if (!type) return; // 最好不要默认全部清除，不安全\n        if (!handler) {\n            this.events.set(type, []); // 因为这里是直接赋值清空，所以在 emit 的时候，记得每次都从 events 动态获取\n            return;\n        }\n        this.events.set(type, (this.events.get(type) || []).filter(item => item.handler !== handler));\n    }\n}\n\nconst eventEmitter = new EventEmitter();\n\nclass Person {\n    public name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n    weatherSubscribe(once?: boolean): Function {\n        return eventEmitter.on('weather', (weather) => {\n            switch (weather) {\n                case '雨':\n                    console.log(`${this.name}在家看电影`);\n                    break;\n                default:\n                    console.log(`${this.name}出去玩`);\n            }\n        }, once);\n    }\n    weatherNotify(weather) {\n        eventEmitter.emit('weather', weather);\n    }\n}\n\nconst xiaoWang = new Person('小王');\nconst xiaoMing = new Person('小明');\nconst xiaoZhang = new Person('小张');\n\nxiaoWang.weatherSubscribe(true);\nconst off = xiaoMing.weatherSubscribe();\n\nxiaoZhang.weatherNotify('雨');\nxiaoZhang.weatherNotify('晴');\n\noff();\nxiaoZhang.weatherNotify('晴');\n```\n\n![image-20210724195933611](观察者(发布-订阅)模式.assets/image-20210724195933611.png)\n\n\n\n发布订阅模式可以说是对观察者模式的进一步抽象。\n\n我们通过消息中心对消息进行统一处理，那么这里通知者和消费者的关系其实被弱化了，它们可以是任意对象，通知者和消费者也可以是同一个对象，这种模式甚至在非对象也可以使用，即我们只关注发布和订阅行为本身，而不关心发布订阅者是谁。\n\n","children":[]},{"name":"解释器模式.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/行为型","data":"# 解释器模式\n\n> 解释器模式(Interpreter Pattern)：\n>\n> - 定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。\n>\n> \n>\n> **优点：**\n>\n> - 易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。\n> - 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。\n> - 实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。\n> - 增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则”。\n>\n> **缺点：**\n>\n> - 对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。\n> - 执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。\n>\n> \n\n![解释器模式的 UML 图](https://www.runoob.com/wp-content/uploads/2014/08/interpreter_pattern_uml_diagram.jpg)\n\n## TS\n\n```typescript\ninterface IExpression{\n\tinterpret: (context:string) => boolean;\n}\ntype TExpression = IExpression | null;\n\nclass Expression implements IExpression{\n\tinterpret(context:string):boolean {\n\t\tconsole.log('expression')\n\t\treturn true;\n\t}\n}\n\nclass TerminalExpression implements IExpression{\n\tprivate data: string = '';\n\tpublic interpret(context:string):boolean {\n\t\t// console.log('TerminalExpression interpret')\n\t\treturn context === this.data\n\t}\n\tconstructor(data:string) {\n\t\tthis.data = data;\n\t}\n}\nclass OrExpresssion implements IExpression{\n\tprivate expr1: TExpression = null;\n\tprivate expr2: TExpression = null;\n\tconstructor(expr1:TExpression, expr2:TExpression) {\n\t\tthis.expr1 = expr1;\n\t\tthis.expr2 = expr2;\n\t}\n\tpublic interpret(context: string): boolean {\n\t\t// console.log('OrExpresssion interpret')\n\t\treturn (this.expr1?.interpret(context) || this.expr2?.interpret(context)) ? true : false;\n\t}\n\t\n\n}\nclass AndExpresssion implements IExpression{\n\tprivate expr1: TExpression = null;\n\tprivate expr2: TExpression = null;\n\tpublic interpret(context:string):boolean {\n\t\t// console.log('AndExpression interpret')\n\t\t// return true;\n\t\treturn (this.expr1?.interpret(context) && this.expr2?.interpret(context)) ? true : false;\n\t}\n\t\n\tconstructor(expr1:TExpression, expr2:TExpression) {\n\t\tthis.expr1 = expr1;\n\t\tthis.expr2 = expr2;\n\t}\n}\n\n\n// 开始测试\n\nconst getMaleExpression=():OrExpresssion=>{\n\tlet rebert:TExpression = new TerminalExpression('Robert');\n\tlet john: TExpression = new TerminalExpression('John');\n\treturn new OrExpresssion(rebert, john)\n}\nconst getMarriedWomanExpression=():AndExpresssion=>{\n\tlet julie:TExpression = new TerminalExpression('Julie');\n\tlet married: TExpression = new TerminalExpression('Married');\n\treturn new AndExpresssion(julie, married)\n}\n\n\nconst isMale = getMaleExpression();\nconst isMarriedWoman = getMarriedWomanExpression();\nconsole.log('John is male?', isMale.interpret(\"John\"))\nconsole.log(\"Julie is a married women? \", isMarriedWoman.interpret(\"Married Julie\"));\n```\n\n","children":[]},{"name":"访问者模式.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/行为型","data":"# 访问者模式\n\n\n\n> - 访问者模式(Visitor) : \n>   - 提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作\n>\n> 优点:\n>\n> 1. 扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。\n> 2. 复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。\n> 3. 灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。\n> 4. 符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。\n>\n>\n> 缺点:\n>\n> 1. 增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。\n> 2. 破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。\n> 3. 违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。\n\n![image-20210806181011765](访问者模式.assets/image-20210806181011765.png)\n\n\n\n\n\n```java\npublic class VisitorPattern {\n    public static void main(String[] args) {\n        ObjectStructure os = new ObjectStructure();\n        os.add(new ConcreteElementA());\n        os.add(new ConcreteElementB());\n        Visitor visitor = new ConcreteVisitorA();\n        os.accept(visitor);\n        System.out.println(\"------------------------\");\n        visitor = new ConcreteVisitorB();\n        os.accept(visitor);\n    }\n}\n\n//抽象访问者\ninterface Visitor {\n    void visit(ConcreteElementA element);\n\n    void visit(ConcreteElementB element);\n}\n\n//具体访问者A类\nclass ConcreteVisitorA implements Visitor {\n    public void visit(ConcreteElementA element) {\n        System.out.println(\"具体访问者A访问-->\" + element.operationA());\n    }\n\n    public void visit(ConcreteElementB element) {\n        System.out.println(\"具体访问者A访问-->\" + element.operationB());\n    }\n}\n\n//具体访问者B类\nclass ConcreteVisitorB implements Visitor {\n    public void visit(ConcreteElementA element) {\n        System.out.println(\"具体访问者B访问-->\" + element.operationA());\n    }\n\n    public void visit(ConcreteElementB element) {\n        System.out.println(\"具体访问者B访问-->\" + element.operationB());\n    }\n}\n\n//抽象元素类\ninterface Element {\n    void accept(Visitor visitor);\n}\n\n//具体元素A类\nclass ConcreteElementA implements Element {\n    public void accept(Visitor visitor) {\n        visitor.visit(this);\n    }\n\n    public String operationA() {\n        return \"具体元素A的操作。\";\n    }\n}\n\n//具体元素B类\nclass ConcreteElementB implements Element {\n    public void accept(Visitor visitor) {\n        visitor.visit(this);\n    }\n\n    public String operationB() {\n        return \"具体元素B的操作。\";\n    }\n}\n\n//对象结构角色\nclass ObjectStructure {\n    private List<Element> list = new ArrayList<Element>();\n\n    public void accept(Visitor visitor) {\n        Iterator<Element> i = list.iterator();\n        while (i.hasNext()) {\n            ((Element) i.next()).accept(visitor);\n        }\n    }\n\n    public void add(Element element) {\n        list.add(element);\n    }\n\n    public void remove(Element element) {\n        list.remove(element);\n    }\n}\n```\n\n\n\n运行结果\n\n```shell\n具体访问者A访问-->具体元素A的操作。\n具体访问者A访问-->具体元素B的操作。\n------------------------\n具体访问者B访问-->具体元素A的操作。\n具体访问者B访问-->具体元素B的操作。\n```\n\n\n\n## ts\n\n```typescript\n// 简易版 (由于ts不可以重名方法)\nclass Visitor {\n\t\tvisitStr(str: string) {\n\t\t\tconsole.log(str)\n\t\t}\n\t\tvisitNum(num: number) {\n\t\t\tconsole.log(num)\n\t\t}\n\t\tvisit(obj: any): void {\n\t\t\t// console.log(typeof obj)\n\t\t\tif (typeof obj === 'number') this.visitNum(obj)\n\t\t\tif (typeof obj === 'string') this.visitStr(obj)\n\n\t\t}\n\n\t}\n\n\tlet n: number = 123;\n\tlet s: string = '123str';\n\tconst v = new Visitor();\n\tv.visit(n)\n\tv.visit(s)\n```\n\n","children":[]},{"name":"迭代器模式.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/行为型","data":"# 迭代器模式\n\n\n\n> 迭代器模式(Iterator Pattern): 提供一种方法来访问聚合对象, 而不是暴露这个对象的内部表示, 其名为游标( Cursor )\n>\n> java中的Collection, list, Set, Map 都包含迭代\n>\n> 优点:\n>\n> 1. 访问一个聚合对象的内容而无须暴露它的内部表示。\n> 2. 遍历任务交由迭代器完成，这简化了聚合类。\n> 3. 它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。\n> 4. 增加新的聚合类和迭代器类都很方便，无须修改原有代码。\n> 5. 封装性良好，为遍历不同的聚合结构提供一个统一的接口。\n\n\n\n![image-20210806180459755](迭代器模式.assets/image-20210806180459755-16282443030715.png)\n\n\n\n\n\n# Java\n\n```java\npublic class IteratorPattern {\n    public static void main(String[] args) {\n        Aggregate ag = new ConcreteAggregate();\n        ag.add(\"中山大学\");\n        ag.add(\"华南理工\");\n        ag.add(\"韶关学院\");\n        System.out.print(\"聚合的内容有：\");\n        Iterator it = ag.getIterator();\n        while (it.hasNext()) {\n            Object ob = it.next();\n            System.out.print(ob.toString() + \"\\t\");\n        }\n        Object ob = it.first();\n        System.out.println(\"\\nFirst：\" + ob.toString());\n    }\n}\n\n//抽象聚合\ninterface Aggregate {\n    public void add(Object obj);\n    public void remove(Object obj);\n    public Iterator getIterator();\n}\n\n//具体聚合\nclass ConcreteAggregate implements Aggregate {\n    private List<Object> list = new ArrayList<Object>();\n    public void add(Object obj) {\n        list.add(obj);\n    }\n    public void remove(Object obj) {\n        list.remove(obj);\n    }\n    public Iterator getIterator() {\n        return (new ConcreteIterator(list));\n    }\n}\n\n//抽象迭代器\ninterface Iterator {\n    Object first();\n    Object next();\n    boolean hasNext();\n}\n\n//具体迭代器\nclass ConcreteIterator implements Iterator {\n    private List<Object> list = null;\n    private int index = -1;\n\n    public ConcreteIterator(List<Object> list) {\n        this.list = list;\n    }\n\n    public boolean hasNext() {\n        if (index < list.size() - 1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public Object first() {\n        index = 0;\n        Object obj = list.get(index);\n        ;\n        return obj;\n    }\n\n    public Object next() {\n        Object obj = null;\n        if (this.hasNext()) {\n            obj = list.get(++index);\n        }\n        return obj;\n    }\n}\n```\n\n执行结果\n\n```shell\n聚合的内容有：中山大学    华南理工    韶关学院   \nFirst：中山大学\n```\n\n## TS\n\n\n\n```typescript\ntype TObject = Object | undefined | null | string;\n\n// 抽象迭代器\ninterface IIterator{\n\tfirst: () => TObject;\n\tnext: () => TObject;\n\thasNext: () => boolean;\n}\n\n\n// 具体迭代器\nclass ConcreteIterator implements IIterator{\n\tprivate list: TObject[] = [];\n\tprivate index: number = -1;\n\tpublic constructor(list:Array<TObject>) {\n\t\tthis.list = list;\n\t}\n\tpublic first(): TObject {\n\t\treturn this.list[0];\n\t}\n\tpublic next(): TObject {\n\t\treturn this.list[++this.index]\n\t}\n\tpublic hasNext(): boolean{\n\t\treturn this.index<this.list.length-1;\n\t}\n}\n\n// 抽象聚合接口\ninterface IAggregate{\n\tadd: (obj:TObject) => void;\n\tremove: (obj:TObject) => void;\n\tgetIterator: () => IIterator;\n}\n\n// 抽象聚合类\nclass Aggregate{\n\tpublic add(obj:TObject):void{ };\n\tpublic remove(obj:TObject): void { };\n\tpublic getIterator(): IIterator {\n\t\treturn new ConcreteIterator(new Array());\n\t};\n}\n\n// 具体聚合\nclass ConcreteAggregate implements IAggregate{\n\tprivate list: TObject[] = [];\n\tpublic add(obj:TObject):void{\n\t\tthis.list.push(obj)\n\t};\n\tpublic remove(obj:TObject): void {\n\t\tthis.list = this.list.map(item => {\n\t\t\tif (item === obj) return;\n\t\t\treturn item;\n\t\t}).filter(i => i);\n\t};\n\tpublic getIterator(): IIterator {\n\t\treturn new ConcreteIterator(this.list)\n\t};\n}\n\n\nconst ag: IAggregate = new ConcreteAggregate();\nag.add(\"111\");\nag.add(\"222\");\nag.add(\"333\");\nconst it:IIterator = ag.getIterator();\nwhile (it.hasNext()) {\n\tconsole.log(it.next());\n}\n\n// 输出\n111\n222\n333\n```\n\n","children":[]}]},{"name":"设计原则","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式","data":"","children":[{"name":"依赖倒置.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/设计原则","data":"# 依赖倒置\n\n> - 高层模块不应该依赖低层模块，两者都应该依赖其抽象（模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的）\n> - 抽象不应该依赖细节（接口或抽象类不依赖于实现类）\n> - 细节应该依赖抽象（实现类依赖接口或抽象类）\n> - `依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性`\n>   - 每个类尽量提供接口或抽象类，或者两者都具备。\n>   - 变量的声明类型尽量是接口或者是抽象类。\n>   - 任何类都不应该从具体类派生。\n>   - 使用继承时尽量遵循里氏替换原则。\n\n## 作用\n\n- 依赖倒置原则可以降低类间的耦合性。\n- 依赖倒置原则可以提高系统的稳定性。\n- 依赖倒置原则可以减少并行开发引起的风险。\n- 依赖倒置原则可以提高代码的可读性和可维护性。\n\n\n\n## Eg\n\n分析：本程序反映了 “顾客类”与“商店类”的关系。商店类中有 sell() 方法，顾客类通过该方法购物以下代码定义了顾客类通过韶关网店 ShaoguanShop 购物：\n\n```java\nclass Customer {    \n  public void shopping(ShaoguanShop shop) {        //购物        \n    System.out.println(shop.sell());   \n  }\n}\n```\n\n但是，这种设计存在缺点，如果该顾客想从另外一家商店（如婺源网店 WuyuanShop）购物，就要将该顾客的代码修改如下：\n\n```java\nclass Customer {    \n  public void shopping(WuyuanShop shop) {        //购物        \n    System.out.println(shop.sell());    \n  }\n}\n```\n\n顾客每更换一家商店，都要修改一次代码，这明显违背了开闭原则。存在以上缺点的原因是：顾客类设计时同具体的商店类绑定了，这违背了依赖倒置原则。解决方法是：定义“婺源网店”和“韶关网店”的共同接口 Shop，顾客类面向该接口编程，其代码修改如下：\n\n```java\nclass Customer {   \n\tpublic void shopping(Shop shop) {        \n\t//购物        \n\tSystem.out.println(shop.sell());    \n\t}\n}\n```\n\n这样，不管顾客类 Customer 访问什么商店，或者增加新的商店，都不需要修改原有代码了，其类图如图 1 所示。\n\n\n\n![顾客购物程序的类图](http://c.biancheng.net/uploads/allimg/181113/3-1Q113131610L7.gif)\n图1 顾客购物程序的类图\n\n\n程序代码如下：\n\n```java\npackage principle;\n\npublic class DIPtest {\n    public static void main(String[] args) {\n        Customer wang = new Customer();\n        System.out.println(\"顾客购买以下商品：\");\n        wang.shopping(new ShaoguanShop());\n        wang.shopping(new WuyuanShop());\n    }\n}\n\n//商店\ninterface Shop {\n    public String sell(); //卖\n}\n\n//韶关网店\nclass ShaoguanShop implements Shop {\n    public String sell() {\n        return \"韶关土特产：香菇、木耳……\";\n    }\n}\n\n//婺源网店\nclass WuyuanShop implements Shop {\n    public String sell() {\n        return \"婺源土特产：绿茶、酒糟鱼……\";\n    }\n}\n\n//顾客\nclass Customer {\n    public void shopping(Shop shop) {\n        //购物\n        System.out.println(shop.sell());\n    }\n}\n```\n\n程序的运行结果如下：\n\n```\n顾客购买以下商品：\n韶关土特产：香菇、木耳……\n婺源土特产：绿茶、酒糟鱼……\n```","children":[]},{"name":"六大原则.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/设计原则","data":"# 六大原则\n\n## 单一责任原则\n\n> 接口和方法必须保证单一责任原则, 类不必保证, 只要符合业务即可.\n\n\n\n## 里氏替换原则\n\n> - 如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。\n> - 所有引用基类的地方必须能透明地使用其子类的对象。\n\n## 依赖倒置原则\n\n> - 高层模块不应该依赖低层模块，两者都应该依赖其抽象（模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的）\n> - 抽象不应该依赖细节（接口或抽象类不依赖于实现类）\n> - 细节应该依赖抽象（实现类依赖接口或抽象类）\n\n## 接口隔离原则\n\n> - 客户端不应该依赖它不需要的接口\n> - 类间的依赖关系应该建立在最小的接口上。\n\n## 迪米特原则\n\n> - 每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元\n> - 每个单元只能和它的朋友交谈：不能和陌生单元交谈\n> - 只和自己直接的朋友交谈\n\n## 开闭原则\n\n> - 软件中的对象（类，模块，函数等等）应该对于`扩展是开放`的，但是对于`修改是封闭`的\n\n","children":[]},{"name":"单一责任.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/设计原则","data":"# 单一责任\n\n> - 单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则\n>\n> - 这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分\n> - `一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用`\n\n\n\n## 优点\n\n- 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。\n- 提高类的可读性。复杂性降低，自然其可读性会提高。\n- 提高系统的可维护性。可读性提高，那自然更容易维护了。\n- 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。","children":[]},{"name":"合并复用.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/设计原则","data":"# 合并复用\n\n> - 又名: `组合/聚合复用原则`\n\n## 合成复用原则的重要性\n\n通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。\n\n1. 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为`“白箱”复用`\n2. 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。\n3. 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。\n\n\n采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。\n\n1. 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。\n2. 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。\n3. 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。\n\n## 合成复用原则的实现方法\n\n合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。\n\n\n\n## Eg\n\n![用继承关系实现的汽车分类的类图](http://c.biancheng.net/uploads/allimg/181113/3-1Q113160133151.gif)\n\n![用组合关系实现的汽车分类的类图](http://c.biancheng.net/uploads/allimg/181113/3-1Q11316034X57.gif)","children":[]},{"name":"开闭原则.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/设计原则","data":"# 开闭原则\n\n> - 软件中的对象（类，模块，函数等等）应该对于`扩展是开放`的，但是对于`修改是封闭`\n\n\n\n## 作用\n\n#### 1. 对软件测试的影响\n\n软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。\n\n#### 2. 可以提高代码的可复用性\n\n粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。\n\n#### 3. 可以提高软件的可维护性\n\n遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。\n\n## 实现\n\n可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。\n\n因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。\n\n\n\n## Eg\n\n![Windows的桌面主题类图](http://c.biancheng.net/uploads/allimg/181113/3-1Q113100151L5.gif)","children":[]},{"name":"接口隔离.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/设计原则","data":"# 接口隔离\n\n> - 客户端不应该依赖它不需要的接口\n> - 类间的依赖关系应该建立在最小的接口上。\n\n## 优点\n\n> 1. 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。\n> 2. 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。\n> 3. 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。\n> 4. 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。\n> 5. 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。\n\n\n\n## 实现\n\n> - 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。\n> - 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。\n> - 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。\n> - 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。\n\n\n\n## Eg\n\n![学生成绩管理程序的类图](http://c.biancheng.net/uploads/allimg/181113/3-1Q113141Q0X3.gif)\n\n```java\npackage principle;\n\npublic class ISPtest {\n    public static void main(String[] args) {\n        InputModule input = StuScoreList.getInputModule();\n        CountModule count = StuScoreList.getCountModule();\n        PrintModule print = StuScoreList.getPrintModule();\n        input.insert();\n        count.countTotalScore();\n        print.printStuInfo();\n        //print.delete();\n    }\n}\n\n//输入模块接口\ninterface InputModule {\n    void insert();\n    void delete();\n    void modify();\n}\n\n//统计模块接口\ninterface CountModule {\n    void countTotalScore();\n    void countAverage();\n}\n\n//打印模块接口\ninterface PrintModule {\n    void printStuInfo();\n    void queryStuInfo();\n}\n\n//实现类\nclass StuScoreList implements InputModule, CountModule, PrintModule {\n    private StuScoreList() {\n    }\n\n    public static InputModule getInputModule() {\n        return (InputModule) new StuScoreList();\n    }\n\n    public static CountModule getCountModule() {\n        return (CountModule) new StuScoreList();\n    }\n\n    public static PrintModule getPrintModule() {\n        return (PrintModule) new StuScoreList();\n    }\n\n    public void insert() {\n        System.out.println(\"输入模块的insert()方法被调用！\");\n    }\n\n    public void delete() {\n        System.out.println(\"输入模块的delete()方法被调用！\");\n    }\n\n    public void modify() {\n        System.out.println(\"输入模块的modify()方法被调用！\");\n    }\n\n    public void countTotalScore() {\n        System.out.println(\"统计模块的countTotalScore()方法被调用！\");\n    }\n\n    public void countAverage() {\n        System.out.println(\"统计模块的countAverage()方法被调用！\");\n    }\n\n    public void printStuInfo() {\n        System.out.println(\"打印模块的printStuInfo()方法被调用！\");\n    }\n\n    public void queryStuInfo() {\n        System.out.println(\"打印模块的queryStuInfo()方法被调用！\");\n    }\n}\n```\n\n","children":[]},{"name":"迪米特.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/设计原则","data":"# 迪米特\n\n> - 又名: `最少知识原则`\n> - 每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元\n> - 每个单元只能和它的朋友交谈：不能和陌生单元交谈\n> - 只和自己直接的朋友交谈\n\n\n\n## 优点\n\n> 1. 降低了类之间的耦合度，提高了模块的相对独立性。\n> 2. 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。\n\n\n\n## 实现\n\n> 从迪米特法则的定义和特点可知，它强调以下两点：\n>\n> 1. 从依赖者的角度来说，只依赖应该依赖的对象。\n> 2. 从被依赖者的角度说，只暴露应该暴露的方法。\n>\n> \n> 所以，在运用迪米特法则时要注意以下 6 点。\n>\n> 1. 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。\n> 2. 在类的结构设计上，尽量降低类成员的访问权限。\n> 3. 在类的设计上，优先考虑将一个类设置成不变类。\n> 4. 在对其他类的引用上，将引用其他对象的次数降到最低。\n> 5. 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。\n> 6. 谨慎使用序列化（Serializable）功能。\n\n\n\n## Eg\n\n![明星与经纪人的关系图](http://c.biancheng.net/uploads/allimg/181113/3-1Q113152Q5W1.gif)\n\n```java\npublic class LoDtest {\n    public static void main(String[] args) {\n        Agent agent = new Agent();\n        agent.setStar(new Star(\"林心如\"));\n        agent.setFans(new Fans(\"粉丝韩丞\"));\n        agent.setCompany(new Company(\"中国传媒有限公司\"));\n        agent.meeting();\n        agent.business();\n    }\n}\n\n//经纪人\nclass Agent {\n    private Star myStar;\n    private Fans myFans;\n    private Company myCompany;\n\n    public void setStar(Star myStar) {\n        this.myStar = myStar;\n    }\n\n    public void setFans(Fans myFans) {\n        this.myFans = myFans;\n    }\n\n    public void setCompany(Company myCompany) {\n        this.myCompany = myCompany;\n    }\n\n    public void meeting() {\n        System.out.println(myFans.getName() + \"与明星\" + myStar.getName() + \"见面了。\");\n    }\n\n    public void business() {\n        System.out.println(myCompany.getName() + \"与明星\" + myStar.getName() + \"洽淡业务。\");\n    }\n}\n\n//明星\nclass Star {\n    private String name;\n\n    Star(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n\n//粉丝\nclass Fans {\n    private String name;\n\n    Fans(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n\n//媒体公司\nclass Company {\n    private String name;\n\n    Company(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n```\n\n","children":[]},{"name":"里氏替换.md","path":"../guanruihua.github.io/Knowledge-Reserve/架构&相关/设计模式/设计原则","data":"# 里氏替换\n\n> - 如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。\n> - 所有引用基类的地方必须能透明地使用其子类的对象。\n> - `子类可以扩展父类的功能，但不能改变父类原有的功能`\n>   - 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法\n>   - 子类中可以增加自己特有的方法\n>   - 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松\n>   - 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等\n\n\n\n## 作用\n\n> 1. 里氏替换原则是实现开闭原则的重要方式之一\n> 2. 它克服了继承中重写父类造成的可复用性变差的缺点\n> 3. 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性\n> 4. 加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险\n\n## Eg\n\n![“几维鸟不是鸟”实例的类图](http://c.biancheng.net/uploads/allimg/181113/3-1Q11311094H32.gif)\n\n```java\npublic class LSPtest {\n    public static void main(String[] args) {\n        Bird bird1 = new Swallow();\n        Bird bird2 = new BrownKiwi();\n        bird1.setSpeed(120);\n        bird2.setSpeed(120);\n        System.out.println(\"如果飞行300公里：\");\n        try {\n            System.out.println(\"燕子将飞行\" + bird1.getFlyTime(300) + \"小时.\");\n            System.out.println(\"几维鸟将飞行\" + bird2.getFlyTime(300) + \"小时。\");\n        } catch (Exception err) {\n            System.out.println(\"发生错误了!\");\n        }\n    }\n}\n\n//鸟类\nclass Bird {\n    double flySpeed;\n\n    public void setSpeed(double speed) {\n        flySpeed = speed;\n    }\n\n    public double getFlyTime(double distance) {\n        return (distance / flySpeed);\n    }\n}\n\n//燕子类\nclass Swallow extends Bird {\n}\n\n//几维鸟类\nclass BrownKiwi extends Bird {\n  // 这里重写了 bird的方法, 违背了里斯替换原则, 这里应该不继承, 或者继承一个更加普通的一般的父类类\n    public void setSpeed(double speed) {\n        flySpeed = 0;\n    }\n}\n```\n\n运行结果\n\n```shell\n如果飞行300公里：\n燕子将飞行2.5小时.\n几维鸟将飞行Infinity小时。\n```\n\n![“几维鸟是动物”实例的类图](http://c.biancheng.net/uploads/allimg/181113/3-1Q11311101SN.gif)","children":[]}]}]}]},{"name":"相关技术","path":"../guanruihua.github.io/Knowledge-Reserve","data":"","children":[{"name":"geojson.md","path":"../guanruihua.github.io/Knowledge-Reserve/相关技术","data":"# geoJSON\n\n```json\n{\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n        {\"type\":\"Feature\",\n        \"properties\":{},\n        \"geometry\":{\n            \"type\":\"Point\",\n            \"coordinates\":[105.380859375,31.57853542647338]\n            }\n        }\n    ]\n}\n```\n\n![img](/__assets__/img/2021-12-28-15-53-53.png)\n\n例子图片\n\n*（注：以下geojson的效果截图都来自[geojson.io](https://links.jianshu.com/go?to=http%3A%2F%2Fgeojson.io%2F%23map%3D2%2F20.0%2F0.0)在线生成）*\n\ngeojson将所有的地理要素分为Point、MultiPoint、LineString、MultiLineString、Polygon、MultiPolygon、GeometryCollection。首先是将这些要素封装到单个的geometry里，然后作为一个个的Feature（也就是要素）；要素放到一个要素集合里，从树状结构来理解FeatureCollection就是根节点，表示为：\n\n```json\n{\n  \"type\": \"FeatureCollection\",\n  \"features\": []\n}\n```\n\n所有地理要素放在features的列表里。\n\n### 点要素Point\n\n点要素是最简单的，类型type对应Point，然后坐标是一个1维的数组，里面有两个元素（如果是立体的坐标就是三维x,y,z），分别为经度和纬度。properties里面可以封装各种属性，例如名称、标识颜色等等。\n\n```json\n{\n  \"type\":\"Feature\",\n  \"properties\":{},\n  \"geometry\":{\n    \"type\":\"Point\",\n    \"coordinates\":[105.380859375,31.57853542647338]\n  }\n}\n```\n\n### 多点要素MultiPoint\n\n```json\n{\n    \"type\":\"Feature\",\n    \"properties\":{},\n    \"geometry\":{\n        \"type\":\"MultiPoint\",\n        \"coordinates\":[[105.380859375,31.57853542647338],\n                [105.580859375,31.52853542647338]\n            ]\n        }\n        }\n```\n\n其核心坐标：\n\n```css\n105.380859375,31.57853542647338\n105.580859375,31.52853542647338\n```\n\n### 线要素LineString\n\n线要素就是指线段，记录的是线的端点坐标，可视化时会按照记录顺序联结。对于曲线（如贝塞尔曲线）目前还没有很好的表达，但是在地理数据中，曲线一般会用LineString去拟合，现实地理世界中也没有标准的曲线地理要素。\n\n线要素的坐标coordinates里的二维数组和多点要素基本一样，区别就在type上了。\n\n```json\n{\n\"type\":\"Feature\",\n  \"properties\":{},\n  \"geometry\":{\n    \"type\":\"LineString\",\n    \"coordinates\":[\n      [105.6005859375,30.65681556429287],\n      [107.95166015624999,31.98944183792288],\n      [109.3798828125,30.031055426540206],\n      [107.7978515625,29.935895213372444]\n    ]\n  }\n}\n```\n\n对应的Kml表达：\n\n```xml\n<Placemark>\n    <ExtendedData></ExtendedData>\n    <LineString>\n        <coordinates>108.65753173828125,34.1873818599505 108.72413635253905,34.25154099726973 108.77151489257812,34.16977214177208 108.88481140136719,34.229970811273084\n        </coordinates>\n    </LineString>\n</Placemark>\n```\n\n### MultiLineString\n\n也是一个三维数组（和多边形一样）；\n\n```json\n{\n  \"type\":\"Feature\",\n  \"properties\":{},\n  \"geometry\":{\n    \"type\":\"MultiLineString\",\n    \"coordinates\":\n    [\n        [\n            [105.6005859375,30.65681556429287],\n            [107.95166015624999,31.98944183792288],\n            [109.3798828125,30.031055426540206],\n            [107.7978515625,29.935895213372444]\n        ],\n        [\n            [109.3798828125,30.031055426540206],\n            [107.1978515625,31.235895213372444]\n        ]\n    ]\n  }\n}\n```\n\n### 多边形Polygon\n\n注：单个多边形是一个3维数组，可以包含多个二维数组，这种情况和MultiPolygon效果很像。\n\n```json\n{\n \"type\":\"Feature\",\n \"properties\":{},\n \"geometry\":{\n  \"type\":\"Polygon\",\n  \"coordinates\":[\n     [\n      [106.10595703125,33.33970700424026],\n      [106.32568359375,32.41706632846282],\n      [108.03955078125,32.2313896627376],\n      [108.25927734375,33.15594830078649],\n      [106.10595703125,33.33970700424026]\n     ]\n    ]\n  }\n}\n```\n\n### 多多边形MultiPolygon\n\n#### type 1 两个不会相交的多边形\n\n```json\n{\n  \"type\": \"Feature\",\n  \"properties\": {},\n  \"geometry\": {\n  \"type\": \"MultiPolygon\",\n  \"coordinates\":\n    [ \n        [\n            [\n                [109.2041015625,30.088107753367257],\n                [115.02685546875,30.088107753367257],\n                [115.02685546875,32.7872745269555],\n                [109.2041015625,32.7872745269555],\n                [109.2041015625,30.088107753367257]\n          \n          \n            ]\n        ],\n        [\n            [\n                [112.9833984375,26.82407078047018],\n                [116.69677734375,26.82407078047018],\n                [116.69677734375,29.036960648558267],\n                [112.9833984375,29.036960648558267],\n                [112.9833984375,26.82407078047018]\n            ]\n        ]\n    ]\n  }\n}\n```\n\n![img](/__assets__/img/2021-12-28-15-55-04.png)\n\n两个不相交的多边形\n\n#### type 2 两个镶套的多边形\n\n小的在前面，范围大的在后面，用上4个中括号，但效果不是有洞的\n\n```json\n{\n  \"type\": \"Feature\",\n  \"properties\": {},\n  \"geometry\": {\n    \"type\": \"MultiPolygon\",\n    \"coordinates\":\n    [ \n        [\n            [\n                [101.6455078125,27.68352808378776],\n                [114.78515624999999,27.68352808378776],\n                [114.78515624999999,35.209721645221386],\n                [101.6455078125,35.209721645221386],\n                [101.6455078125,27.68352808378776]\n            ]   \n        ],\n        [\n            [\n                [104.2822265625,30.107117887092357],\n                [108.896484375,30.107117887092357],\n                [108.896484375,33.76088200086917],\n                [104.2822265625,33.76088200086917],\n                [104.2822265625,30.107117887092357]\n            ]\n        ]\n    ]\n  }\n}\n```\n\n![img](/__assets__/img/2021-12-28-15-55-33.png)\n\n两个镶套的多边形\n\n#### type 3 有孔洞的多边形\n\n```json\n{\n  \"type\": \"Feature\",\n  \"properties\": {},\n  \"geometry\": {\n    \"type\": \"MultiPolygon\",\n    \"coordinates\":\n    [ \n      [\n        [\n          [101.6455078125,27.68352808378776],\n          [114.78515624999999,27.68352808378776],\n          [114.78515624999999,35.209721645221386],\n          [101.6455078125,35.209721645221386],\n          [101.6455078125,27.68352808378776]\n        ],\n        [\n          [104.2822265625,30.107117887092357],\n          [108.896484375,30.107117887092357],\n          [108.896484375,33.76088200086917],\n          [104.2822265625,33.76088200086917],\n          [104.2822265625,30.107117887092357]\n        ]\n      ]\n    ]\n  }\n}\n```\n\n![img](/__assets__/img/2021-12-28-15-55-56.png)\n\n有孔洞的多边形\n\n可以仔细去品味type2和type3的区别。它们对应的kml表达区别是比较大的。\n\n### GeometryCollection\n\nGeometryCollection是多种基本地理要素的集合，就是里面可以包含点、线、面要素。\n\n```json\n{\n    \"type\": \"GeometryCollection\",\n    \"geometries\": [\n      {\n        \"type\": \"Point\",\n        \"coordinates\": [108.62, 31.02819]\n      },\n      {\n        \"type\": \"LineString\",\n        \"coordinates\": [\n          [108.896484375,30.1071178870],\n          [108.2184375,30.91717870],\n          [109.5184375,31.2175780]\n        ]\n      }\n    ]\n}\n```\n\nGeometryCollection不需要放在FeatureCollection里：\n\n```json\n{\n  \"type\": \"FeatureCollection\",\n  \"features\": []\n}\n```\n","children":[]},{"name":"HTTP","path":"../guanruihua.github.io/Knowledge-Reserve/相关技术","data":"","children":[{"name":"HTTP.md","path":"../guanruihua.github.io/Knowledge-Reserve/相关技术/HTTP","data":"# HTTP\n\n## 1.1 什么是 HTTP\n\nHTTP 是一个连接客户端，网关和服务器的一个协议。\n\n## 7.2 特点\n\n支持客户/服务器模式：可以连接客户端和服务端；\n 简单快速：请求只需传送请求方法，路径和请求主体；\n 灵活：传输数据类型灵活；\n 无连接：请求结束立即断开；\n 无状态：无法记住上一次请求。\n\n## 7.3 怎么解决无状态和无连接\n\n无状态：HTTP 协议本身无法解决这个状态，只有通过 cookie 和 session 将状态做贮存，常见的场景是登录状态保持；\n\n无连接：可以通过自身属性 Keep-Alive。\n\n## 7.4 请求过程\n\nHTTP(S) 请求地址 → DNS 解析 → 三次握手 → 发送请求 → 四次挥手\n\n三次握手过程图片来源 CSDN） ![3 次握手.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d65b93d07fd74758a60a0ecb9c117200~tplv-k3u1fbpfcp-zoom-1.image) 在这里插入图片描述\n\n1. 四次挥手过（图片来源 CSDN）\n\n![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a12c33ac8d04fec8f21eb5c4fc482ab~tplv-k3u1fbpfcp-zoom-1.image) 在这里插入图片描述\n\n## 7.5 HTTP 0.9~3.0 对比\n\n### 7.5.1 HTTP 0.9\n\n只允许客户端发送 GET 这一种请求；\n 且不支持请求头，协议只支持纯文本；\n 无状态性，每个访问独立处理，完成断开；\n 无状态码。\n\n### 7.5.2 HTTP 1.0\n\n有身份认证，三次握手； 请求与响应支持头域； 请求头内容； |属性名|含义| |--|--|--| |Accept |可接受的 MIME 类型| |Accept-Encoding| 数据可解码的格式| |Accept-Language| 可接受语言| |Connection| 值 keep-alive 是长连接| |Host| 主机和端口| |Pragma| 是否缓存,指定 no-cache 返回刷新| |Referer| 页面路由| |If-Modified-Since| 值为时间|\n\n响应头内容；\n\n|属性名| 含义| |-|-|-| |Connection| 值 keep-alive 是长连接| |Content-Type| 返回文档类型,常见的值有 text/plain,text/html,text/json| |Date| 消息发送的时间| |Server| 服务器名字| |Last-Modified| 值为时间,s 返回的最后修改时间| |Expires| 缓存过期时间,b 和 s 时间做对比| 注意\n\nexpires 是响应头内容，返回一个固定的时间,缺陷是时间到了服务器要重新设置;\n 请求头中如果有 If-Modified-Since，服务器会将时间与 last-modified 对比，相同返回 304;\n 响应对象以一个响应状态行开始;\n 响应对象不只限于超文本;\n 支持 GET、HEAD、POST 方法;\n 有状态码;\n 支持长连接（但默认还是使用短连接）、缓存机制以及身份认证。\n\n### 7.5.3 HTTP 1.1\n\n请求头增加 Cache-Control\n\n|属性名| 含义| |-|-|-| |Cache-Control| 在1.1 引入的方法,指定请求和响应遵循的缓存机制,值有:public(b 和 s 都缓存),private(b 缓存),no-cache(不缓存),no-store(不缓存),max-age(缓存时间,s 为单位),min-fresh(最小更新时间),max-age=3600| |If-None-Match | 上次请求响应头返回的 etag 值响应头增加 Cache-Control，表示所有的缓存机制是否可以缓存及哪种类型 etag 返回的哈希值,第二次请求头携带去和服务器值对比|\n\n注意\n\nCache-Control 的 max-age 返回是缓存的相对时间 Cache-Control 优先级比 expires 高 缺点：不能第一时间拿到最新修改文件\n\n### 7.5.4 HTTP 2.0\n\n采用二进制格式传输;\n 多路复用，其实就是将请求数据分成帧乱序发送到 TCP 中。TCP 只能有一个 steam，所以还是会阻塞;\n 报头压缩;\n 服务器推送主动向 B 端发送静态资源，避免往返延迟。\n\n### 7.5.5 HTTP 3.0\n\n1.是基于 QUIC 协议，基于 UDP\n 2.特点:\n 自定义连接机制：TCP 以 IP/端口标识,变化重新连接握手，UDP 是一 64 位 ID 标识，是无连接；\n 自定义重传机制：TCP 使用序号和应答传输，QUIC 是使用递增序号传输； 无阻塞的多路复用：同一条 QUIC 可以创建多个 steam。\n\n### 7.5.6 HTTPS\n\n1.https 是在 http 协议的基础上加了个 SSL；\n 2.主要包括\u0010：握手(凭证交换和验证)和记录协议(数据进行加密)。\n\n### 7.5.7 缓存\n\n1.按协议分：协议层缓存和非 http 协议缓存：\n 1.1协议层缓存：利用 http 协议头属性值设置；\n 1.2非协议层缓存：利用 meta 标签的 http-equiv 属性值 Expires,set-cookie。\n\n2.按缓存分：强缓存和协商缓存：\n 2.1强缓存：利用 cache-control 和 expires 设置，直接返回一个过期时间，所以在缓存期间不请求，If-modify-since；\n 2.2协商缓存：响应头返回 etag 或 last-modified 的哈希值，第二次请求头 If-none-match 或 IF-modify-since 携带上次哈希值，一致则返回 304。\n\n3.协商缓存对比： etag 优先级高于 last-modified；\n 4.etag 精度高，last-modified 精度是 s，1s 内 etag 修改多少次都会被记录； last-modified 性能好，etag 要得到 hash 值。\n\n5.浏览器读取缓存流程： 会先判断强缓存；再判断协商缓存 etag(last-modified)是否存在；\n 存在利用属性 If-None-match(If-Modified-since)携带值；\n 请求服务器,服务器对比 etag(last-modified)，生效返回 304。\n\nF5 刷新会忽略强缓存不会忽略协商缓存，ctrl+f5 都失效\n\n### 7.5.8 状态码\n\n|序列| 详情| |-|-|-| |1XX(通知)|| |2XX(成功)| 200(成功)、201(服务器创建)、202(服务器接收未处理)、203(非授权信息)、204(未返回内容)、205(重置内容)、206(部分内容)| |3XX(重定向)| 301(永久移动)、302(临时移动)、303(查看其他位置)、304(未修改)、305(使用代理)、307(临时重定向)| |4XX(客户端错误) |400(错误请求)、401(未授权)、403(禁止)、404(未找到)、405(方法禁用)、406(不接受)、407（需要代理授权）| |5XX(服务器错误)| 500(服务器异常)、501（尚未实施）、502（错误网关）、503（服务不可用）、504（网关超时）、505（HTTP 版本不受支持）|\n\n### 7.5.9 浏览器请求分析\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fc332eae3354d06a9802e8a7713594c~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 7.5.10 总结\n\n协议\n\n|版本 |内容| |-|-|-| |http0.9| 只允许客户端发送 GET 这一种请求;且不支持请求头,协议只支持纯文本;无状态性,每个访问独立处理,完成断开;无状态码 http1.0 解决 0.9 的缺点,增加 If-modify-since(last-modify)和 expires 缓存属性| |http1.x| 增加 cache-control 和 If-none-match(etag)缓存属性| |http2.0| 采用二进制格式传输;多路复用;报头压缩;服务器推送| |http3.0| 采用 QUIC 协议,自定义连接机制;自定义重传机制;无阻塞的多路复用| 缓存\n\n|类型| 特性| |-|-|-| |强缓存| 通过 If-modify-since(last-modify)、expires 和 cache-control 设置，属性值是时间，所以在时间内不用请求| |协商缓存| 通过 If-none-match(etag)设置，etag 属性是哈希值，所以要请求和服务器值对比|\n","children":[]},{"name":"HTTP缓存.md","path":"../guanruihua.github.io/Knowledge-Reserve/相关技术/HTTP","data":"# HTTP缓存\n\n## 前言\n\n在请求一个静态文件的时候（图片，css，js）等，这些文件的特点是文件不经常变化，将这些不经常变化的文件存储起来，对客户端来说是一个优化用户浏览体验的方法。那么这个就是客户端缓存的意义了。\n\nHttp 缓存机制作为 web 性能优化的重要手段，对于从事 Web 开发的同学们来说，应该是知识体系库中的一个基础环节，同时对于有志成为前端架构师的同学来说是必备的知识技能。\n\n但是对于很多前端同学来说，仅仅只是知道浏览器会对请求的静态文件进行缓存，但是为什么被缓存，缓存是怎样生效的，却并不是很清楚。\n\n在此，我会尝试用简单明了的文字，像大家系统的介绍HTTP缓存机制，期望对各位正确的理解前端缓存有所帮助。\n\n## 缓存规则解析\n\nHTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(强制缓存，对比缓存)\n\n在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则有个简单了解。\n\n已存在缓存数据时，仅基于强制缓存，请求数据的流程如下：\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/8/22/89f3cf045a8f9788bbc6d7f5d96f4d91~tplv-t2oaga2asx-watermark.awebp)\n\n已存在缓存数据时，仅基于对比缓存，请求数据的流程如下：\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/8/22/46429b684e6f20bb06d2508c2e8c65c6~tplv-t2oaga2asx-watermark.awebp)\n\n对缓存机制不太了解的同学可能会问，基于对比缓存的流程下，不管是否使用缓存，都需要向服务器发送请求，那么还用缓存干什么？\n\n这个问题，我们暂且放下，后文在详细介绍每种缓存规则的时候，会带给大家答案。\n\n我们可以看到两类缓存规则的不同，强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。\n\n两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。\n\n## 强制缓存\n\n从上文我们得知，强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是如何判断缓存数据是否失效呢？\n\n我们知道，在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应header中。\n\n对于强制缓存来说，响应header中会有两个字段来标明失效规则（Expires/Cache-Control）使用chrome的开发者工具，可以很明显的看到对于强制缓存生效时，网络请求的情况。\n\n**Expires**\n\nExpires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。\n\n不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。\n\n另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。\n\n所以HTTP 1.1 的版本，使用Cache-Control替代。\n\n**Cache-Control**\n\nCache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。\n\n​\n\n```\nprivate:             客户端可以缓存\npublic:              客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）\nmax-age=xxx:   缓存的内容将在 xxx 秒后失效\nno-cache:          需要使用对比缓存来验证缓存数据（后面介绍）\nno-store:           所有内容都不会缓存，强制缓存，对比缓存都不会触发\n\n```\n\n（对于前端开发来说，缓存越多越好，so...基本上和它说886）\n\n举个例子：\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/8/22/578c199c387ebd0af406544ab040f325~tplv-t2oaga2asx-watermark.awebp)\n\n图中Cache-Control仅指定了max-age，所以默认为private，缓存时间为31536000秒（365天）也就是说，在365天内再次请求这条数据，都会直接获取缓存数据库中的数据，直接使用。\n\n没懂的话，我们换通俗一点的话来说一遍。当客户端第一次访问资源的时候，服务端在返回资源内容的同时也返回了Expires: Sun, 16 Oct 2016 05:43:02 GMT。\n\n服务端告诉浏览器： 你Y的先把这个文件给我缓存起来，在这个过期时间之前，这个文件都不会变化了，你下次需要这个文件的时候，你就不要过来找我要了，你就去缓存中拿就好了，又快又好。\n\n浏览器回答说：诺。\n\n于是在第二次html页面中又要访问这个资源的时候，并且访问的日期在Sun, 16 Oct 2016 05:43:02 GMT之前，浏览器就不去服务器那边获取文件了，自己从缓存中自食其力了。\n\n但是呢，浏览器毕竟是在客户端的，客户端的时间可是不准确的，用户可以随着自己的喜好修改自己机器的时间，比如我把我机器的时间调成Sun, 16 Oct 2016 05:43:03 GMT，那么呢？我的浏览器就不会再使用缓存了，而每次都去服务器获取文件。于是，服务器怒了：给你个绝对时间，你由于环境被修改没法判断过期，那么我就给你相对时间吧。于是就返回了Cache-Control: max-age:600，浏览器你给我缓存个10分钟去。于是浏览器只有乖乖的缓存10分钟了。\n\n但是问题又来了，如果有的服务器同时设置了Expires和Cache-Control怎么办呢？（不是闲的没事干，而是由于Cache-Controll是HTTP1.1中才有的）那么就是根据更先进的设置Cache-Control来为标准。\n\n好了，现在有个问题，我有个文件可能时不时会更新，服务端非常希望客户端能时不时过来问一下这个文件是否过期，如果没有过期，服务端不返回数据给你，只告诉浏览器你的缓存还没有过期（304）。然后浏览器使用自己存储的缓存来做显示。这个就叫做条件请求。\n\n## 对比缓存\n\n对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。\n\n再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。\n\n对于对比缓存来说，缓存标识的传递是我们着重需要理解的，它在请求header和响应header间进行传递，一共分为两种标识传递，接下来，我们分开介绍。\n\n**Last-Modified  /  If-Modified-Since**\n\nLast-Modified：服务器在响应请求时，告诉浏览器资源的最后修改时间。\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/8/22/53399e6fdae3663582b4eacf6a83ad2c~tplv-t2oaga2asx-watermark.awebp)\n\nIf-Modified-Since：\n\n再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。\n\n服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。\n\n若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/8/22/fd379f9eb07037e7dc3d0854237001cf~tplv-t2oaga2asx-watermark.awebp)\n\n**Etag  /  If-None-Match（优先级高于Last-Modified  /  If-Modified-Since）**\n\n第一次客户端访问资源的时候，服务端返回资源内容的同时返回了ETag：1234，告诉客户端：这个文件的标签是1234，我如果修改了我这边的资源的话，这个标签就会不一样了。\n\n第二次客户端访问资源的时候，由于缓存中已经有了Etag为1234的资源，客户端要去服务端查询的是这个资源有木有过期呢？所以带上了If-None-Match: 1234。告诉服务端：如果你那边的资源还是1234标签的资源，你就返回304告诉我，不需要返回资源内容了。如果不是的话，你再返回资源内容给我就行了。服务端就比较下Etag来看是返回304还是200。\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/8/22/a9f97f1bf78e39d0b5da940feeb07d46~tplv-t2oaga2asx-watermark.awebp)\n\n## 各种刷新\n\n理解了上面的缓存标签之后就很好理解各种刷新了。\n\n刷新有三种\n\n​\n\n```\n浏览器中写地址，回车\nF5\nCtrl+F5\n\n```\n\n假设对一个资源：\n\n浏览器第一次访问，获取资源内容和cache-control: max-age:600，Last_Modify: Wed, 10 Aug 2013 15:32:18 GMT于是浏览器把资源文件放到缓存中，并且决定下次使用的时候直接去缓存中取了。\n\n浏览器url回车\n\n浏览器发现缓存中有这个文件了，好了，就不发送任何请求了，直接去缓存中获取展现。（最快）\n\n下面我按下了F5刷新\n\nF5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since：Wed, 10 Aug 2013 15:32:18 GMT\n\n然后服务器发现：诶，这个文件我在这个时间后还没修改过，不需要给你任何信息了，返回304就行了。于是浏览器获取到304后就去缓存中欢欢喜喜获取资源了。\n\n但是呢，下面我们按下了Ctrl+F5\n\n这个可是要命了，告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作...\n\n还有说一下，那个ETag实际上很少人使用，因为它的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用etag了。\n\n通过网络获取内容既缓慢，成本又高：大的响应需要在客户端和服务器之间进行多次往返通信，这拖延了浏览器可以使用和处理内容的时间，同时也增加了访问者的数据成本。因此，缓存和重用以前获取的资源的能力成为优化性能很关键的一个方面。\n\n## 序\n\n本文用于解决以下六个疑问。\n\n- 与缓存相关的HTTP首部字段主要**有哪些**？\n- 这些HTTP首部字段之间的**联系与区别**？\n- HTTP缓存首部字段的**优先级**？\n- HTTP缓存首部字段的**特点与局限性**？\n- 用户**不同的页面刷新行为的差别**？\n- 在**实践中**我们该用哪些报文头来**控制缓存**呢？\n\n文中使用的1.html以及doge.png如下所示\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title>缓存控制测试</title>\n</head>\n<body>\n    <img src=\"doge.png\">\n</body>\n</html>\n```\n\n![img](http://imweb-io-1251594266.file.myqcloud.com/Fi4kT2Bo5j9leo6R-cpAYDWjYQsT)\n\n## 那些年与缓存相关的HTTP首部字段\n\n我们先来瞅一眼RFC2616规定的47种http报文首部字段中与缓存相关的字段，事先了解一下能让咱在心里有个底：\n\n#### 1.通用首部字段\n\n![img](http://imweb-io-1251594266.file.myqcloud.com/Fn0lDNSZimjgnv4kWcFrWnjHglUL)\n\n#### 2.请求首部字段\n\n![img](http://imweb-io-1251594266.file.myqcloud.com/Fj6XVLriM7AK6edaqOhxq8Om4lSe)\n\n#### 3.响应首部字段\n\n![img](http://imweb-io-1251594266.file.myqcloud.com/FgbZCbHn1jXX1zgb7xl9EzUNOC9q)\n\n#### 4.实体首部字段\n\n![img](http://imweb-io-1251594266.file.myqcloud.com/FtoiFQmDwRbKc5iVUlaVAtnMrm8_)\n\n## 石器时代的缓存方式\n\n在 http1.0 时代，给客户端设定缓存方式可通过两个字段——`Pragma`和`Expires`来规范。虽然这两个字段早可抛弃，但为了做http协议的向下兼容，你还是可以看到很多网站依旧会带上这两个字段。例如在访问 [腾讯课堂](https://ke.qq.com/) 的时候，通过浏览器调试工具可以看到部分HTTP响应是包含Expires头部的。\n\n#### 1.Pragma\n\n当该字段值为`no-cache`的时候（事实上现在RFC中也仅标明该可选值），会知会客户端不要对该资源读缓存，即每次都得向服务器发一次请求才行。\n举个例子：\n![img](http://imweb-io-1251594266.file.myqcloud.com/Fgepo1U4TpvLzrCgijtJgc2HPguc)\n\n通过Fiddler给图片资源额外增加以下头部信息\n\n```\nCache-Control: public, max-age=86400\nPragma: no-cache\n```\n\n前者用来设定缓存资源一天，后者禁用缓存。\n重新访问该页面会发现访问该资源会重新发起一次请求，同时以上例子也能说明**Pragma的优先级是高于Cache-Control**的。\n\n#### 2.Expires\n\n有了Pragma来禁用缓存，自然也需要有个东西来启用缓存和定义缓存时间，对http1.0而言，Expires就是做这件事的首部字段。 Expires的值对应一个GMT（格林尼治时间），比如`Mon, 22 Jul 2002 11:12:01 GMT`来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。\n同样举个例子：\n![img](http://imweb-io-1251594266.file.myqcloud.com/FlqXQRLmgAPjtGcHBkzV1ZowuqzW)\n\n通过Fiddler给图片资源额外加上以下头部信息\n\n```\nExpires: Fri, 11 Jun 2021 11:33:01 GMT\n```\n\n重新访问该页面会发现访问图片资源的时候，会直接从缓存中读取资源内容，而不发起请求。\n![img](http://imweb-io-1251594266.file.myqcloud.com/FtgNGyP0qFhW7GI2KXeGIxv6-zku)\n\n如果Pragma头部和Expires头部同时存在，则起作用的会是Pragma，有兴趣的同学可以自己试一下。\n需要注意的是，响应报文中Expires所定义的缓存时间是相对服务器上的时间而言的，其定义的是资源“失效时刻”，如果客户端上的时间跟服务器上的时间不一致（特别是用户修改了自己电脑的系统时间），那缓存时间可能就没啥意义了。\n\n## Cache-Control\n\n针对上述的“Expires时间是相对服务器而言，无法保证和客户端时间统一”的问题，http1.1新增了 Cache-Control 来定义缓存过期时间。注意：若报文中同时出现了 Expires 和 Cache-Control，则以 Cache-Control 为准。\n也就是说优先级从高到低分别是 **Pragma -> Cache-Control -> Expires** 。\nCache-Control也是一个通用首部字段，这意味着它能分别在请求报文和响应报文中使用。在RFC中规范了 Cache-Control 的格式为：\n\n```\n\"Cache-Control\" \":\" cache-directive\n```\n\n作为请求首部时，cache-directive 的可选值有：\n![img](http://imweb-io-1251594266.file.myqcloud.com/FkctxGN8VXdie7M8Fbx6U5Bpfi4c)\n\n作为响应首部时，cache-directive 的可选值有：\n![img](http://imweb-io-1251594266.file.myqcloud.com/FixnilG9OWm4w4qUNZGKSkYXZ4gu)\n\nCache-Control 允许自由组合可选值，例如：\n\n```\nCache-Control: max-age=3600, must-revalidate\n```\n\n它意味着该资源是从原服务器上取得的，且其缓存（新鲜度）的有效时间为一小时，在后续一小时内，用户重新访问该资源则无须发送请求。 当然这种组合的方式也会有些限制，比如 no-cache 就不能和 max-age、min-fresh、max-stale 一起搭配使用。\n\n## 缓存校验字段\n\n上述的首部字段均能让客户端决定是否向服务器发送请求，比如设置的缓存时间未过期，那么自然直接从本地缓存取数据即可（在chrome下表现为200 from cache），若缓存时间过期了或资源不该直接走缓存，则会发请求到服务器去。\n\n我们现在要说的问题是，**如果客户端向服务器发了请求，那么是否意味着一定要读取回该资源的整个实体内容呢？**\n\n我们试着这么想——客户端上某个资源保存的缓存时间过期了，但这时候其实服务器并没有更新过这个资源，如果这个资源数据量很大，客户端要求服务器再把这个东西重新发一遍过来，是否非常浪费带宽和时间呢？\n\n答案是肯定的，那么是否有办法让服务器知道客户端现在存有的缓存文件，其实跟自己所有的文件是一致的，然后直接告诉客户端说“这东西你直接用缓存里的就可以了，我这边没更新过呢，就不再传一次过去了”。\n\n举例来说：\n\n```\nC：小服，你几岁了？\nS：小客，我18岁了。\n=================================\nC：小服 ，你几岁了？我猜你18岁了。\nS：靠，你知道还问我？（304）\n=================================\nC：小服 ，你几岁了？我猜你18岁了。\nS：小客 ，我19岁了。（200）\n```\n\n为了让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，Http1.1新增了几个首部字段来做这件事情。\n\n### 1. Last-Modified\n\n服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。\n\n```\nLast-Modified: Fri, 22 Jul 2016 01:47:00 GMT\n```\n\n客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回`304`状态码，**内容为空**，这样就节省了传输数据量 。如果两个时间不一致，则服务器会发回该资源并返回`200`状态码，和第一次请求时类似。这样保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。一个`304`响应比一个静态资源通常小得多，这样就节省了网络带宽。\n![img](http://imweb-io-1251594266.file.myqcloud.com/FozLFZKB5y67NUSXLhioLseHJYbE)\n\n至于传递标记起来的最终修改时间的请求报文首部字段一共有两个：\n\n#### ⑴ If-Modified-Since: Last-Modified-value\n\n示例为 If-Modified-Since: Thu, 31 Mar 2016 07:07:52 GMT\n\n该请求首部告诉服务器如果客户端传来的最后修改时间与服务器上的一致，则直接回送`304` 和响应报头即可。\n当前各浏览器均是使用的该请求首部来向服务器传递保存的 Last-Modified 值。\n\n#### ⑵ If-Unmodified-Since: Last-Modified-value\n\n该值告诉服务器，若Last-Modified没有匹配上（资源在服务端的最后更新时间改变了），则应当返回`412`(Precondition Failed) 状态码给客户端。 Last-Modified 存在一定问题，如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。\n\n### 2. ETag\n\n为了解决上述Last-Modified可能存在的不准确的问题，Http1.1还推出了 **ETag 实体首部**字段。 服务器会通过某种算法，给资源计算得出一个唯一标志符（比如md5标志），在把资源响应给客户端的时候，会在实体首部加上“ETag: 唯一标识符”一起返回给客户端。例如：\n\n```\nEtag: \"5d8c72a5edda8d6a:3239\"\n```\n\n客户端会保留该 ETag 字段，并在下一次请求时将其一并带过去给服务器。服务器只需要比较客户端传来的ETag跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。\n如果服务器发现ETag匹配不上，那么直接以常规GET `200`回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回`304`知会客户端直接使用本地缓存即可。\n那么客户端是如何把标记在资源上的 ETag 传回给服务器的呢？请求报文中有两个首部字段可以带上 ETag 值：\n\n#### ⑴ If-None-Match: ETag-value\n\n示例为 If-None-Match: \"5d8c72a5edda8d6a:3239\" 告诉服务端如果 ETag 没匹配上需要重发资源数据，否则直接回送`304` 和响应报头即可。 当前各浏览器均是使用的该请求首部来向服务器传递保存的 ETag 值。\n\n#### ⑵ If-Match: ETag-value\n\n告诉服务器如果没有匹配到ETag，或者收到了“*”值而当前并没有该资源实体，则应当返回`412`(Precondition Failed) 状态码给客户端。否则服务器直接忽略该字段。\n需要注意的是，如果资源是走分布式服务器（比如CDN）存储的情况，需要这些服务器上计算ETag唯一值的算法保持一致，才不会导致明明同一个文件，在服务器A和服务器B上生成的ETag却不一样。\n\n## 缓存头部对比\n\n| 头部          | 优势和特点                                                   | 劣势和问题                                                   |\n| :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| Expires       | 1、HTTP 1.0 产物，可以在HTTP 1.0和1.1中使用，简单易用。 2、以时刻标识失效时间。 | 1、时间是由服务器发送的(UTC)，如果服务器时间和客户端时间存在不一致，可能会出现问题。 2、存在版本问题，到期之前的修改客户端是不可知的。 |\n| Cache-Control | 1、HTTP 1.1 产物，以时间间隔标识失效时间，解决了Expires服务器和客户端相对时间的问题。 2、比Expires多了很多选项设置。 | 1、HTTP 1.1 才有的内容，不适用于HTTP 1.0 。 2、存在版本问题，到期之前的修改客户端是不可知的。 |\n| Last-Modified | 1、不存在版本问题，每次请求都会去服务器进行校验。服务器对比最后修改时间如果相同则返回304，不同返回200以及资源内容。 | 1、只要资源修改，无论内容是否发生实质性的变化，都会将该资源返回客户端。例如周期性重写，这种情况下该资源包含的数据实际上一样的。 2、以时刻作为标识，无法识别一秒内进行多次修改的情况。 3、某些服务器不能精确的得到文件的最后修改时间。 |\n| ETag          | 1、可以更加精确的判断资源是否被修改，可以识别一秒内多次修改的情况。 2、不存在版本问题，每次请求都回去服务器进行校验。 | 1、计算ETag值需要性能损耗。 2、分布式服务器存储的情况下，计算ETag的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时发现ETag不匹配的情况。 |\n\n## 用户刷新/访问行为\n\n我们可以把刷新/访问界面的手段分成三类：\n\n- 在URI输入栏中输入然后回车/通过书签访问\n- F5/点击工具栏中的刷新按钮/右键菜单重新加载\n- Ctl+F5\n\n在浏览器中，有时候你会发现通过不同的手段访问/刷新界面页面的呈现速度是不一样的，那么它们到底有什么区别呢?\n以下对这三种访问情况进行实践与讨论。\n\n准备工作：\n为了模拟第一次访问某网站，清除相关缓存内容。为了方便讨论与对比，以下内容以[腾讯课堂](https://ke.qq.com/) 的index.css文件为例。\n首次访问该网页，查看请求与响应信息可以看到请求头部没有任何关于http缓存相关的信息。而返回的HTTPresponse包含了以下头部信息。\n\n```\nCache-Control: max-age=31104000\nExpires: Thu, 20 Jul 2017 02:18:41 GMT\nLast-Modified: Fri, 15 Jul 2016 04:11:51 GMT\n```\n\n浏览器会对该文件进行缓存，直到该文件过期、用户清空cache或者用户强制刷新资源时间。\n\n#### 1、在URI输入栏中输入然后回车\n\n我们可以看到返回响应码是 `200 OK (from cache)`，浏览器发现该资源已经缓存了而且没有过期（通过Expires头部或者Cache-Control头部），没有跟服务器确认，而是直接使用了浏览器缓存的内容。其中响应内容和之前的响应内容一模一样，例如其中的Date时间是上一次响应的时间。\n![img](http://imweb-io-1251594266.file.myqcloud.com/FjNVji6ipMDCWCoe2jXfzgqFbF8k)\n\n所以我们也能看到该资源的Size为from cache\n![img](http://imweb-io-1251594266.file.myqcloud.com/FiZd35wOPT30xVsbf8aWSSY8v_Cu)\n\n#### 2、F5/点击工具栏中的刷新按钮/右键菜单重新加载\n\nF5的作用和直接在URI输入栏中输入然后回车是不一样的，F5会让浏览器**无论如何都发一个HTTP Request给Server**，即使先前的响应中有Expires头部。所以，当我在当前 [腾讯课堂](https://ke.qq.com/) 网页中按F5的时候，浏览器会发送一个HTTP Request给Server，但是包含这样的Headers:\n\n```\nCache-Control: max-age=0\nIf-Modified-Since: Fri, 15 Jul 2016 04:11:51 GMT\n```\n\n其中Cache-Control是Chrome强制加上的，而If-Modified-Since是因为获取该资源的时候包含了Last-Modified头部，浏览器会使用If-Modified-Since头部信息重新发送该时间以确认资源是否需要重新发送。 实际上Server没有修改这个index.css文件，所以返回了一个`304(Not Modified)`，这样的响应信息很小，所消耗的route-trip不多，网页很快就刷新了。\n![img](http://imweb-io-1251594266.file.myqcloud.com/FoGcVs6BvMvNLNM7KSvwEuHBaqDt)\n\n上面的例子中没有ETag，如果Response中包含ETag，F5引发的Http Request中也是会包含If-None-Match的。\n\n#### 3、Ctl+F5\n\n那么Ctrl+F5呢？ Ctrl+F5要的是**彻底的从Server拿一份新的资源过来**，所以不光要发送HTTP request给Server，而且这个请求里面连If-Modified-Since/If-None-Match都没有，这样就逼着Server不能返回304，而是把整个资源原原本本地返回一份，这样，Ctrl+F5引发的传输时间变长了，自然网页Refresh的也慢一些。我们可以看到该操作返回了200，并刷新了相关的缓存控制时间。\n![img](http://imweb-io-1251594266.file.myqcloud.com/FonZrh_J5auduA4JaqZKW9hZqXrG)\n\n实际上，为了保证拿到的是从Server上最新的，Ctrl+F5不只是去掉了If-Modified-Since/If-None-Match，还需要添加一些HTTP Headers。按照HTTP/1.1协议，Cache不光只是存在Browser终端，从Browser到Server之间的中间节点(比如Proxy)也可能扮演Cache的作用，为了防止获得的只是这些中间节点的Cache，需要告诉他们，别用自己的Cache敷衍我，往Upstream的节点要一个最新的copy吧。\n在Chrome 51 中会包含两个头部信息， 作用就是让中间的Cache对这个请求失效，这样返回的绝对是新鲜的资源。\n\n```\nCache-Control: no-cache\nPragma: no-cache\n```\n\n#### 4、综上\n\n![img](http://imweb-io-1251594266.file.myqcloud.com/FgtfwfAjs5EBAEIa9KFi25acNk7d)\n\n## 缓存实践\n\n综上对各种HTTP缓存控制头部的对比以及用户可能出现的浏览器刷新行为的讨论，当我们在一个项目上做http缓存的应用时，我们实际上还是会把上述提及的大多数首部字段均使用上。\n\n#### 1、Expires / Cache-Control\n\nExpires用时刻来标识失效时间，不免收到时间同步的影响，而Cache-Control使用时间间隔很好的解决了这个问题。 但是 Cache-Control 是 HTTP1.1 才有的，不适用于 HTTP1.0，而 Expires 既适用于 HTTP1.0，也适用于 HTTP1.1，所以说在大多数情况下同时发送这两个头会是一个更好的选择，当客户端两种头都能解析的时候，会优先使用 Cache-Control。\n\n#### 2、Last-Modified / ETag\n\n二者都是通过某个标识值来请求资源， 如果服务器端的资源没有变化，则自动返回 HTTP 304 （Not Changed）状态码，内容为空，这样就节省了传输数据量。而当资源发生比那话后，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。\n其中Last-Modified使用文件最后修改作为文件标识值，它无法处理文件一秒内多次修改的情况，而且只要文件修改了哪怕文件实质内容没有修改，也会重新返回资源内容；ETag作为“被请求变量的实体值”，其完全可以解决Last-Modified头部的问题，但是其计算过程需要耗费服务器资源。\n\n#### 3、from-cache / 304\n\nExpires和Cache-Control都有一个问题就是服务端作为的修改，如果还在缓存时效里，那么客户端是不会去请求服务端资源的（非刷新），这就存在一个资源版本不符的问题，而强制刷新一定会发起HTTP请求并返回资源内容，无论该内容在这段时间内是否修改过；而Last-Modified和Etag每次请求资源都会发起请求，哪怕是很久都不会有修改的资源，都至少有一次请求响应的消耗。\n对于所有可缓存资源，指定一个Expires或Cache-Control max-age以及一个Last-Modified或ETag至关重要。同时使用前者和后者可以很好的相互适应。\n前者不需要每次都发起一次请求来校验资源时效性，后者保证当资源未出现修改的时候不需要重新发送该资源。而在用户的不同刷新页面行为中，二者的结合也能很好的利用HTTP缓存控制特性，无论是在地址栏输入URI然后输入回车进行访问，还是点击刷新按钮，浏览器都能充分利用缓存内容，避免进行不必要的请求与数据传输。\n\n#### 4、避免304\n\n同学们是否还记得我们在讨论用户刷新页面行为中体积的**index.css**文件，它实际上被命名为**index.03d344bd.css**。而细心的同学也会发现它的Expires和Cache-Control时间出奇的长，这难道不会导致用户无法得到其最近的内容吗？\n![img](http://imweb-io-1251594266.file.myqcloud.com/Fr3W_zspqBLLzZUz6vCVJm3sgIEJ)\n\n其做法实际上很简单，它把服务侧ETag的那一套理论搬到了前端来使用。 页面的静态资源以版本形式发布，常用的方法是在文件名或参数带上一串md5或时间标记符：\n\n```\nhttps://hm.baidu.com/hm.js?e23800c454aa573c0ccb16b52665ac26\nhttp://tb1.bdstatic.com/tb/_/tbean_safe_ajax_94e7ca2.js\nhttp://img1.gtimg.com/ninja/2/2016/04/ninja145972803357449.jpg\n```\n\n可以看到上面的例子中有不同的做法，有的在URI后面加上了md5参数，有的将md5值作为文件名的一部分，有的将资源放在特性版本的目录中。\n\n那么在**文件没有变动**的时候，浏览器不用发起请求直接可以使用缓存文件；而在**文件有变化**的时候，由于文件版本号的变更，导致文件名变化，请求的url变了，自然文件就更新了。这样能确保客户端能及时从服务器收取到新修改的文件。通过这样的处理，增长了静态资源，特别是图片资源的缓存时间，避免该资源很快过期，客户端频繁向服务端发起资源请求，服务器再返回304响应的情况（有Last-Modified/Etag）。\n\n结论：\n\n- 需要兼容HTTP1.0的时候需要使用Expires，不然可以考虑直接使用Cache-Control\n- 需要处理一秒内多次修改的情况，或者其他Last-Modified处理不了的情况，才使用ETag，否则使用Last-Modified。\n- 对于所有可缓存资源，需要指定一个Expires或Cache-Control，同时指定Last-Modified或者Etag。\n- 可以通过标识文件版本名、加长缓存时间的方式来减少304响应。\n","children":[]}]},{"name":"Python","path":"../guanruihua.github.io/Knowledge-Reserve/相关技术","data":"","children":[{"name":"basis.md","path":"../guanruihua.github.io/Knowledge-Reserve/相关技术/Python","data":"# Python\r\n\r\n## print()函数输出\r\n\r\n> `print(输出的内容)`\r\n\r\n## ASCII 码\r\n\r\n> `chr(56)` => 8\r\n> `print (\"\\u4e2d\\u56fd\\\")` => 中国\r\n\r\n![](./__assets__/basis-2022-03-08-14-12-06.png)\r\n\r\n## 保留字和标识符\r\n\r\n![](./__assets__/basis-2022-03-08-15-15-07.png)\r\n\r\n## 类型转换函数\r\n\r\n| 函数                   | 描述                                               |\r\n| :--------------------- | :------------------------------------------------- |\r\n| int(x)                 | 将 x 转换为整数类型                                |\r\n| float(x)               | 将 x 转换为浮点数类型                              |\r\n| complex(real [, imag]) | 创建一个复数                                       |\r\n| str(x)                 | 将 x 转换为字符串                                  |\r\n| repr(x)                | 将 x 转换为表达式字符串                            |\r\n| eval(str)              | 计算在字符串中的有效 Python 表达式，并返回一个对象 |\r\n| chr(x)                 | 将整数 x 转换为一个字符                            |\r\n| ord(x)                 | 将一个字符 x 转换为它所对应的整数值                |\r\n| hex(x)                 | 将一个整数 x 转换为一个十六进制字符串              |\r\n| oct(x)                 | 将一个整数 x 转换为一个八进制的字符串              |\r\n\r\n## 流程控制\r\n\r\n> 跳转语句 `break` 和 `continue`\r\n\r\n### if & else & elif\r\n\r\n```txt\r\nif 表达式:\r\n  # 语句块1\r\nelse \r\n  # 语句块2\r\n```\r\n\r\n```txt\r\nif 表达式:\r\n  # 语句块1\r\nelif\r\n  # 语句块2\r\nelse \r\n  # 语句块3\r\n```\r\n\r\n#### 简写\r\n\r\n##### Exmple\r\n\r\n简写前\r\n\r\n```py\r\na = -9\r\nif a > 0:\r\n b = a\r\nelse: \r\n b = -a\r\nprint(b)\r\n```\r\n\r\n简写\r\n\r\n```py\r\na = -9\r\nb = a if a>0 else -a\r\nprint(b)\r\n```\r\n\r\n### while\r\n\r\n```py\r\nwhile 条件表达式: \r\n 循环体\r\n```\r\n\r\n### for\r\n\r\n```py\r\nfor 迭代变量 in 对象: \r\n 循环体\r\n```\r\n","children":[]},{"name":"格式化","path":"../guanruihua.github.io/Knowledge-Reserve/相关技术/Python","data":"","children":[{"name":"pylint.md","path":"../guanruihua.github.io/Knowledge-Reserve/相关技术/Python/格式化","data":"# pylint\r\n\r\n> 生成配置文件: `pylint --persistent=n --generate-rcfile > pylintrc`\r\n\r\n```py\r\n# 添加忽略规则\r\ndisable=raw-checker-failed,\r\n        bad-inline-option,\r\n        locally-disabled,\r\n        file-ignored,\r\n        suppressed-message,\r\n        useless-suppression,\r\n        deprecated-pragma,\r\n        use-symbolic-message-instead,\r\n        unspecified-encoding\r\n```\r\n","children":[]}]}]},{"name":"rgb.md","path":"../guanruihua.github.io/Knowledge-Reserve/相关技术","data":"\r\n# RGB\r\n\r\n> R: 红\r\n> G: 绿\r\n> B: 蓝\r\n\r\n## 常见颜色\r\n\r\n| 值          | 颜色   |       | 效果                                                          |\r\n| :---------- | :----- | :---- | :------------------------------------------------------------ |\r\n| 255,255,255 | 白     |       | <div class='colorItem' style=\"background:rgb(255,255,255)\" /> |\r\n| 127,127,127 | 灰     |       | <div class='colorItem' style=\"background:rgb(127,127,127)\" /> |\r\n| 0,0,0       | 黑     |       | <div class='colorItem' style=\"background:rgb(0,0,0)\" />       |\r\n| 255,0,0     | 红     |       | <div class='colorItem' style=\"background:rgb(255,0,0)\" />     |\r\n| 0,255,0     | 绿     |       | <div class='colorItem' style=\"background:rgb(0,255,0)\" />     |\r\n| 0,0,255     | 蓝     |       | <div class='colorItem' style=\"background:rgb(0,0,255)\" />     |\r\n| 0,255,255   | 青     | 蓝+绿 | <div class='colorItem' style=\"background:rgb(0,255,255)\" />   |\r\n| 255,0,255   | 洋红   | 红+蓝 | <div class='colorItem' style=\"background:rgb(255,0,255)\" />   |\r\n| 255,255,0   | 黄     | 红+绿 | <div class='colorItem' style=\"background:rgb(255,255,0)\" />   |\r\n| 255,127,0   | 橙     |       | <div class='colorItem' style=\"background:rgb(255,127,0)\" />   |\r\n| 127,0,255   | 紫     |       | <div class='colorItem' style=\"background:rgb(127,0,255)\" />   |\r\n| 0,255,128   | 粉绿   |       | <div class='colorItem' style=\"background:rgb(0,255,128)\" />   |\r\n| 0,128,255   | 湖蓝   |       | <div class='colorItem' style=\"background:rgb(0,128,255)\" />   |\r\n| 128,255,0   | 草绿   |       | <div class='colorItem' style=\"background:rgb(128,255,0)\" />   |\r\n| 255,0,128   | 玫瑰红 |       | <div class='colorItem' style=\"background:rgb(255,0,128)\" />   |\r\n\r\n<style>\r\ndiv.colorItem{ width:10px;height:10px; }\r\n</style>\r\n","children":[]},{"name":"unicode.md","path":"../guanruihua.github.io/Knowledge-Reserve/相关技术","data":"# UniCode 表\r\n\r\n## 字母和数字相关\r\n\r\n| 字符  | 十进制 | 十六进制 |\r\n| :---- | :----- | :------- |\r\n| `A-Z` | 65 - 90  | 41 - 5A    |\r\n| `a-z` | 97 - 122 | 61 - 7A    |\r\n| `0-9` | 48 - 57  | 30 - 39    |\r\n","children":[]},{"name":"Unity","path":"../guanruihua.github.io/Knowledge-Reserve/相关技术","data":"","children":[{"name":"c#.md","path":"../guanruihua.github.io/Knowledge-Reserve/相关技术/Unity","data":"# `C#`\n\n| 运算符   | 描述                                   | 实例                                                         |\n| :------- | :------------------------------------- | :----------------------------------------------------------- |\n| sizeof() | 返回数据类型的大小。                   | sizeof(int)，将返回 4.                                       |\n| typeof() | 返回 class 的类型。                    | typeof(StreamReader);                                        |\n| &        | 返回变量的地址。                       | &a; 将得到变量的实际地址。                                   |\n| *        | 变量的指针。                           | *a; 将指向一个变量。                                         |\n| ? :      | 条件表达式                             | 如果条件为真 ? 则为 X : 否则为 Y                             |\n| is       | 判断对象是否为某一类型。               | If( Ford is Car) // 检查 Ford 是否是 Car 类的一个对象。      |\n| as       | 强制转换，即使转换失败也不会抛出异常。 | Object obj = new StringReader(\"Hello\"); StringReader r = obj as StringReader; |\n","children":[]},{"name":"unity.md","path":"../guanruihua.github.io/Knowledge-Reserve/相关技术/Unity","data":"# Unity\n\n<img src=\"Untitled.assets/image-20211231142355446.png\" alt=\"image-20211231142355446\" style=\"zoom:50%;\" />\n","children":[]},{"name":"vscode运行C#.md","path":"../guanruihua.github.io/Knowledge-Reserve/相关技术/Unity","data":"# vscode 运行`c#`\n\n### 1、下载SDK\n\n首先下载 .NET Core SDK 。下载地址如下:\n\n[.NET Downloads for Windows](https://www.microsoft.com/net/download/windows)\n\n安装SDK：\n\n![img](/__assets__/img/2021-12-28-22-02-54.png)\n\n安装完成后调出控制台 输入 :\n\n```shell\ndotnet --version\n```\n\n弹出版本信息 说明安装成功\n![](/__assets__/img/2021-12-28-22-03-22.png)\n\n### 2、安装C#语言支持\n\n在VS Code里找插件，安装C#的支持。\n![](/__assets__/img/2021-12-28-22-05-05.png)\n\n## 二、快速创建C#控制台\n\n输入\n\n```shell\ndotnet new console -o D:\\study\\NetCore\n```\n\n讲解一下，new是新建，console是控制台，-o是IO路径，后面的是我准备安放的路径，D盘的study目录下，项目名称是NetCore\n![](/__assets__/img/2021-12-28-22-05-23.png)\n\n输出上述文字说明项目创建成功.\n\n把这个文件夹拖进VS Code，或用打开vscode打开项目文件夹D:\\study\\NetCore。\n![](/__assets__/img/2021-12-28-22-12-34.png)\n\n这时右下角弹出通知提示，问你要不要为这个项目创建编译和调试文件，这里要选择“Yes”。\n\n![img](https://www.kmbox.cn/uploads/allimg/200220/1-200220151603332.png)\n\n这样就会自动配置好tasks.json 编译配置文件和launch.json调试配置文件。\n![](/__assets__/img/2021-12-28-22-12-55.png)\n\n直接使用终端在项目该目录下执行dotnet run，即可执行，或者按F5运行，然后选择Net Core调式器，在代码左边打个断点，可以发现，左方的Debug有变量的变化显示，上方也有断点进出的快捷键。\n![](/__assets__/img/2021-12-28-22-13-06.png)\n\n### 格式化代码\n\n比如我的代码很乱，如下图\n\n![img](https://img2018.cnblogs.com/blog/793293/201905/793293-20190515224448776-1346059103.png)\n\n安装C# FixFormat插件\n![](/__assets__/img/2021-12-28-22-12-05.png)\n\n只需要右键，格式化代码，选择C# FixFormat方式格式化即可\n\n切换默认的格式化工具成FixFormat：\n![](/__assets__/img/2021-12-28-22-10-58.png)\n![](/__assets__/img/2021-12-28-22-10-16.png)\n\n格式化文档：\n![](/__assets__/img/2021-12-28-22-08-46.png)\n\n## 三、快速创建 MVC\n\n1. 打开VS Code, 定位到你想要的文件夹 D:\\study\\NetCore\\MVC\n\n![](/__assets__/img/2021-12-28-22-07-35.png)\n2. 使用快捷键 Ctrl + `, 这时候右下角会弹出终端窗口\n![](/__assets__/img/2021-12-28-22-07-26.png)\n\n3、使用 dotnet new mvc -n myapp\n\n```shell\ndotnet new mvc -n myapp\n```\n\n![](/__assets__/img/2021-12-28-22-07-11.png)\n\n4.按F5 启动调试\n\n右下角弹出通知提示，问你要不要为这个项目创建编译和调试文件，这里要选择“Yes”。\n![](/__assets__/img/2021-12-28-22-06-23.png)\n![](/__assets__/img/2021-12-28-22-06-34.png)\n","children":[]}]},{"name":"计网","path":"../guanruihua.github.io/Knowledge-Reserve/相关技术","data":"","children":[{"name":"CDN","path":"../guanruihua.github.io/Knowledge-Reserve/相关技术/计网","data":"","children":[{"name":"index","path":"../guanruihua.github.io/Knowledge-Reserve/相关技术/计网/CDN","data":"","children":[]},{"name":"index.md","path":"../guanruihua.github.io/Knowledge-Reserve/相关技术/计网/CDN","data":"# CDN\n\n> - CDN ( Content Delivery Network ): 内容分发网络\n>   - 在构建在现有的互联网基础之上的一层的智能虚拟网络, 通过咋网络各处部署节点服务器, 实现将资源站内容分发至所有的CDN节点, 是用户可以就近获得所需的内容.\n>   - CDN工作原理: 将全球各地的CDN节点上, 用户请求资源时, 就近返回节点的资源, 而不需要每个用户的请求都回您的源站获取, 避免网络拥塞, 缓解源站压力, 提交用户体验\n> - 以前是通过IP来互相访问, IP不好记, 便有了域名.\n> - 常见的DNS解析服务商有：阿里云解析，万网解析，DNSPod，新网解析，Route53（AWS），Dyn，Cloudflare等。\n> - TLD: 顶级域名\n> - 优点:\n>   - 减低延迟, 提高访问网站速度\n>   - 缓解源站压力\n>   - 缓解骨干网的压力\n>   - 优化网上热点内容\n>     - eg: 热点内容的服务器都在北京，如果我想获取热点内容，我就需要发送请求到北京的服务器，但若有了cdn，我只需要就近服务器获取热点内容，这样就分摊优化热点内容的分布了。\n\n![](index.assets/1022.jpg)\n\n>- 浏览器域名解析过程( CDN加速前 )\n> - 系统DNS缓存,hosts文件\n> - 路由器DNS缓存\n> - 本地DNS服务器,ISP运营服务提供者\n> - 本地DNS服务器, 请求根域名服务器,13个,不是只有13台服务器, 拿到DNS记录\n> - 本地DNS服务器拿到顶级域名域名服务器ip, 就去请求顶级域名服务器\n> - 本地DNS服务器工具拿到的耳机域名服务器的ip, 就去请求二级域名服务器\n> - 直到X级域名服务器返回我们目标域名对应的ip地址后, 本地DNS服务器缓存该DNS记录, 然后返回路由器\n> - 客户端拿到ip地址, 利用该ip地址, 封装并发起http/http2请求\n> - 前面四步是递归查询, 一单缓存可用, 就可直接返回, 不会在进行后续步骤, 后面迭代查询, 最终获取ip地址, 才会返回\n\n## CDN节点缓存策略\n\n> - CDN通过在现有网络中增加一层新的缓存节点，将源站的资源发布到最接近用户的网络节点，使得客户端在请求时直接访问到就近的CDN节点并命中该资源，减少回源情况，提高网站访问速度。\n> - cdn缓存服务器还会根据不同运营商做区分，因为跨运营商需要在交换点进行转换，如果同个运营商则不需要转换，尽量会选择同一运营商的cdn缓存服务器来获取数据或回源。\n> - CDN缓存一般分3层，客户端、CDN Cache L1、CDN Cache L2，当然也可以只有2层。\n\n![](index.assets/111.jpg)\n\n## CDN工作原理\n\n![](index.assets/640-1621930139989.jpg)\n","children":[]},{"name":"question.md","path":"../guanruihua.github.io/Knowledge-Reserve/相关技术/计网/CDN","data":"# CDN-question\n\n## 加速域名、CNAME域名、边缘节点、源站是什么意思？\n\n> （1）加速域名：即您需要使用CDN加速的域名，也是您的客户访问时直接请求访问的域名。\n>\n> （2）CNAME域名：在美团云 CDN 控制台创建加速域名后，域名审核通过后系统会给域名分配一个“CNAME域名”。用户需要在域名服务商处，配置一条 CNAME 记录，将加速域名CNAME至CNAME域名，记录生效后，域名解析过程中会将解析请求正式转向美团云CDN，该域名所有的请求都将转向美团云CDN的节点。\n>\n> （3）边缘节点：边缘节点是离用户最近的节点，是直接响应用户请求，将请求内容缓存并返回给用户的节点，以此来快速响应用户请求。与边缘节点相对应的是中间层节点，中间层节点是源站和边缘节点的一个中间层的回源服务器，中间层节点可缓存边缘节点的回源访问，降低源站的访问压力。\n>\n> （4）源站：即您的业务服务器，当节点没有缓存用户请求的内容时，节点会返回源站获取数据并返回给用户。\n\n## 接入CDN的域名有什么要求吗？\n\n> 接入CDN进行加速的域名，需要在工信部完成备案，源站的业务内容必须合法。\n\n## CDN加速域名是否支持泛域名？\n\n> 美团云CDN当前已支持接入泛域名，您可在新建加速域名时以泛域名的形式（例如：*.example.com）创建域名。\n\n## CDN节点上的缓存内容是实时更新的吗？\n\n> 不会实时更新，CDN节点上的缓存内容，是根据您在控制台配置的缓存过期时间来更新缓存，若您需要实时更新某个文件的缓存，您可以通过刷新或者预热的方式来进行。","children":[]}]},{"name":"http协议.md","path":"../guanruihua.github.io/Knowledge-Reserve/相关技术/计网","data":"# HTTP协议\n\n## http协议的主要特点\n\n> 简单快速、灵活、无连接、无状态HTTP三点注意事项：\n\n- HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n- HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。\n- HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。\n\n## 请求报文\n\n> 一个HTTP请求报文由请求行（request line）、请求头（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。\n\n### 请求行\n\n> 请求行：包括请求方法字段、URL字段和HTTP协议版本，如：GET /index.html HTTP/1.1。\n\n### 请求头\n\n> 请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：\n>\n> - User-Agent：产生请求的浏览器类型。\n>   Accept：客户端可识别的内容类型列表。\n>   Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。\n>   Content-Type：请求体的MIME类型 （用于POST和PUT请求中）。如：Content-Type: application/x-www-form-urlencoded\n\n### 空行\n\n> 最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。\n\n### 请求数据\n\n> 请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。\n\n## 响应报文\n\n> 包括：状态行、响应头、空行、响应正文。\n\n## HTTP 状态码\n\n> HTTP状态码的英文为HTTP Status Code。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。\n>\n>  \n>\n> 1xx：指示信息--表示请求已接收，继续处理。\n> 2xx：成功--表示请求已被成功接收、理解、接受。\n> 3xx：重定向--要完成请求必须进行更进一步的操作。\n> 4xx：客户端错误--请求有语法错误或请求无法实现。\n> 5xx：服务器端错误--服务器未能实现合法的请求。\n>\n> 常见状态代码、状态描述的说明如下。\n>\n> 200 OK：客户端请求成功。\n> 400 Bad Request：客户端请求有语法错误，不能被服务器所理解。\n> 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。\n> 403 Forbidden：服务器收到请求，但是拒绝提供服务。\n> 404 Not Found：请求资源不存在，举个例子：输入了错误的URL。\n> 500 Internal Server Error：服务器发生不可预期的错误。\n> 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。\n\n## 优化\n\nDNS 预解析\n\n```js\n<!--在head标签中，越早越好-->\n<link rel=\"dns-prefetch\" href=\"//example.com\">\n```\n\nHTTP预连接\n\n```js\n<link rel=\"preconnect\" href=\"//example.com\">\n<link rel=\"preconnect\" href=\"//cdn.example.com\" crossorigin>\n```\n","children":[]},{"name":"计网.md","path":"../guanruihua.github.io/Knowledge-Reserve/相关技术/计网","data":"# 计算机网络\n\n## TCP连接\n\n### 三次握手四次挥手\n\n> - 为了准确无误地把数据送达目标处， TCP协议 采用了三次握手策略。\n>   用 TCP协议 把数据包送出去后， TCP协议 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。\n>   握手过程使用了 TCP协议 的标志： SYN 和 ACK 。\n\n#### 三次握手\n\n> - 发送端首先发送一个带有 SYN 标志的数据包给对方。\n> - 接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。\n>   最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。\n>   若是在握手过程中某个阶段莫名中断， TCP协议 会再次以相同的顺序发送相同的数据包。\n\n#### 四次挥手\n\n> 第一次：主动关闭方发送一个 FIN ，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被关闭方：我已经不会再给你发送数据了。\n> 第二次：被动关闭方接收到 FIN 包之后，发送一个 ACK 给对方，确认序号为序号+1.\n> 第三次：被动关闭方发送一个 FIN ，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发完了，不会再给你发送数据了。\n> 第四次：主动关闭方收到 FIN 后，发送一个 ACK 给被动关闭方，确认序号为收到序号+1。\n\n## 一次完整的http流程步骤\n\n> 域名解析\n> 发起TCP的三次握手\n> 建立TCP连接后发起 http 请求\n> 服务器响应 http 请求，浏览器得到HTML代码\n> 浏览器解析HTML代码，并请求HTML代码中的资源\n> 浏览器对页面进行渲染呈现给用户\n> 连接结束\n\n## 五层协议\n\n> 应用层（FTP、Telnet、SMTP、RIP、NFS、DNS）\n>\n> - 应用层的任务是通过应用进程间的交互来完成特定网络应用。\n>\n> 运输层（TCP、UDP）\n>\n> - 运输层的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务\n>\n> 网络层（IP、ICMP、ARP、RARP）\n>\n> - 网络层负责为分组交换网上的不同主机提供通信服务。\n>\n> 数据链路层\n>\n> - 数据链路层通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。\n>\n> 物理层\n>\n> - 物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。\n\n## http和 https\n\n> http 协议通常承载于 TCP协议 之上，在 http 和 TCP协议 之间添加一个安全协议层(SSL或TSL)，这个时候就成了我们常说的 https 。\n>\n> https 协议需要CA申请证书，一般免费证书比较少，所以需要一定费用。\n> http 是超文本传输协议，信息是明文传输， https 则是具有安全性的SSL加密传输协议\n> http 和 https 使用的是完全不同的连接方式，使用的端口号也不一样，前者是80，后者是443\n> http 连接很简单，是无状态的； https协议 是由 http+SSL协议 构建的可进行加密传输、身份认证的网络协议，比较安全。\n> 谷歌搜索引擎算法中，比起同等 http 网站，采用 https 加密的网站在搜索结果中排名会更高\n\n## TCP与UDP\n\n### 用户数据协议UDP\n\n> 提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。\n\n> UDP是无连接的；\n> UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态；\n> UDP是面向报文的；\n> UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；\n> UDP支持一对一、一对多、多对一和多对多的交互通信；\n> UDP的首部开销小，只有8个字节，比 TCP协议 的20个字节的首部要短。\n\n### 传输控制协议TCP\n\n> 提供面向连接的，可靠的数据传输服务。\n\n> TCP是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；\n> 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；\n> TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；\n> TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；\n> 面向字节流。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。\n\n## 协议\n\n> ICMP协议： 因特网控制报文协议。它是 TCP/IP协议族 的一个子协议，用于在IP主机、路由器之间传递控制消息。\n> TFTP协议： 是 TCP/IP协议族 中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。\n> HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。\n> DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。\n\n## http状态码\n\n2开头 （请求成功）表示成功处理了请求的状态代码。\n200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。\n201   （已创建）  请求成功并且服务器创建了新的资源。\n202   （已接受）  服务器已接受请求，但尚未处理。\n203   （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。\n204   （无内容）  服务器成功处理了请求，但没有返回任何内容。\n205   （重置内容） 服务器成功处理了请求，但没有返回任何内容。\n206   （部分内容）  服务器成功处理了部分 GET 请求。\n\n3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。\n300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者选择一项操作，或提供操作列表供请求者选择。\n301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应时，会自动将请求者转到新位置。\n302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。\n304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。\n305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。\n307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n\n4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。\n400   （错误请求） 服务器不理解请求的语法。\n401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。\n403   （禁止） 服务器拒绝请求。\n404   （未找到） 服务器找不到请求的网页。\n405   （方法禁用） 禁用请求中指定的方法。\n406   （不接受） 无法使用请求的内容特性响应请求的网页。\n407   （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。\n408   （请求超时）  服务器等候请求时发生超时。\n409   （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。\n410   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。\n411   （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。\n412   （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。\n413   （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。\n414   （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。\n415   （不支持的媒体类型） 请求的格式不受请求页面的支持。\n416   （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。\n417   （未满足期望值） 服务器未满足\"期望\"请求标头字段的要求。\n\n5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。\n500   （服务器内部错误）  服务器遇到错误，无法完成请求。\n501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。\n502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。\n503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。\n504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。\n505   （ http  版本不受支持） 服务器不支持请求中所用的  http协议  版本。\n\n## get请求传参长度的误区\n\n http协议   未规定  GET  和  POST  的长度限制；\nGET  的最大长度显示是因为 浏览器和 web服务器限制了 URL的长度；\n不同的浏览器和WEB服务器，限制的最大长度不一样；\n要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte；\n10.DNS服务器\n将网址/域名解析成 IP 地址。\ndns是一个域名系统，是万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。\n通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。\n在解析域名时，可以首先采用静态域名解析的方法，如果静态域名解析不成功，再采用动态域名解析的方法，域名是互联网上的身份标识，是不可重复的唯一标识资源；\n某个区域的资源记录通过手动或自动方式更新到单个主名称服务器（称为主 DNS服务器）上，主 DNS 服务器可以是一个或几个区域的权威名称服务器。\n11.从url到页面展现，这之中发生了什么？\n\n输入url：如 <http://www.baidu.com> 。其中 http 为协议， www.baidu.com 为网络地址，一般网络地址可以为域名或IP地址，此处为域名。使用域名是为了方便记忆，但是为了让计算机理解这个地址还需要把它解析为IP地址。\n应用层DNS解析域名：客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直至找到或到根节点。\n应用层发送 http 请求： http 请求包括请求报头和请求主体两个部分，其中请求报头包含了至关重要的信息，包括请求的方法（ GET / POST ）、目标url、遵循的协议（ http / https / ftp…），返回的信息是否需要缓存，以及客户端是否发送cookie等。\n传输层TCP传输报文： TCP协议 为传输报文提供可靠的字节流服务，它为了方便传输，将大块的数据分割成以报文段为单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。 TCP协议 通过“三次握手”等方法保证传输的安全可靠：\n网络层 IP协议 查询MAC地址:  IP协议 的作用是把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址。IP地址和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。 ARP协议 可以将IP地址解析成对应的MAC地址。\n数据到达数据链路层: 在找到对方的MAC地址后，就将数据发送到数据链路层传输。\n服务器接收数据: 接收端的服务器在链路层接收到数据包，再层层向上直到应用层, 这过程中包括在运输层通过 TCP协议 讲分段的数据包重新组成原来的 http 请求报文。\n服务器响应请求: 服务接收到客户端发送的 http 请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息——状态码。\n服务器返回相应文件：请求成功后，服务器会返回相应的HTML文件。接下来就到了页面的渲染阶段了。\n解析HTML以构建 DOM树  –> 构建渲染树 –> 布局渲染树 –> 绘制渲染树。\nDOM树 是由HTML文件中的标签排列组成，渲染树是在 DOM树 中加入CSS或HTML中的style样式而形成。\n在浏览器还没接收到完整的HTML文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送 http 请求重复上述的步骤。在收到CSS文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一+ 过程中可能会触发页面的重绘或重排。\n","children":[]}]}]},{"name":"计算机专业术语.md","path":"../guanruihua.github.io/Knowledge-Reserve","data":"# 计算机专业术语\r\n\r\n| 术语                                                     |                                                     |                                   |                     |\r\n| -------------------------------------------------------- | --------------------------------------------------- | --------------------------------- | ------------------- |\r\n| AGP                                                      | Accelerated Graphics Port                           | 图形加速接口                      |\r\n| Access Time                                              | 存取时间                                            |\r\n| Address                                                  | 地址                                                |\r\n| ANSI                                                     | American National Standards Institute               | 美国国家标准协会                  |\r\n| ASCII                                                    | American Standard Code for Information Interchange  |\r\n| Async SRAM                                               | 异步静态内存                                        |\r\n| BSB                                                      | Backside Bus                                        |\r\n| Bandwidth                                                | 带宽                                                |\r\n| Bank                                                     | 内存库                                              |\r\n| Bank Schema                                              | 存储体规划                                          |\r\n| Base Rambus                                              | 初级的Rambus内存                                    |\r\n| Baud                                                     | 波特                                                |\r\n| BGA                                                      | Ball Grid Array                                     | 球状引脚栅格阵列封装技术          |\r\n| Binary                                                   | 二进制                                              |\r\n| BIOS                                                     | Basic Input-Output System                           | 基本输入/输出系统                 |\r\n| Bit                                                      | 位、比特                                            |\r\n| BLP                                                      | 底部引出塑封技术                                    |\r\n| Buffer                                                   | 缓冲区                                              |\r\n| Buffered Memory                                          | 带缓冲的内存                                        |\r\n| BEDO                                                     | Burst EDO RAM                                       | 突发模式EDO随机存储器             |\r\n| Burst Mode                                               | 突发模式                                            |\r\n| Bus                                                      | 总线                                                |\r\n| Bus Cycle                                                | 总线周期                                            |\r\n| Byte                                                     | 字节                                                |\r\n| Cacheability                                             | 高速缓存能力                                        |\r\n| Cache Memory                                             | 高速缓存存储器                                      |\r\n| CAS                                                      | Column Address Strobe                               | 列地址选通脉冲                    |\r\n| CL                                                       | CAS Latency                                         | 列地址选通脉冲时间延迟            |\r\n| CDRAM                                                    | Cache DRAM                                          | 快取动态随机存储器                |\r\n| Checksum                                                 | 检验和，校验和                                      |\r\n| Chipset                                                  | 芯片组                                              |\r\n| Chip-Scale Package                                       | CSP                                                 | 芯片级封装                        |\r\n| Compact Flash                                            | 紧凑式闪存                                          |\r\n| Concurrent Rambus                                        | 并发式总线式内存                                    |\r\n| Continuity RIMM                                          | C-RIMM                                              | 连续性总线式内存模组              |\r\n| CMOS                                                     | Complementary Metal-Oxide-Semicomductor             | 互补金属氧化物半导体用于晶体管    |\r\n| CPU                                                      | Central Processing Unit                             | 中央处理单元                      |\r\n| Credit Card Memory                                       | 信用卡内存                                          |\r\n| DDR                                                      | Double Data Rate SDRAM                              | 双数据输出同步动态存储器          |\r\n| Desktop                                                  | 台式机，桌上型电脑                                  |\r\n| Die                                                      | 模子，芯片颗粒                                      |\r\n| DIME                                                     | Direct Memory Execution                             |\r\n| DIMM                                                     | Dual-In line Memory Module                          | 双边接触内存模组                  |\r\n| Direct Rambus                                            | 直接总线式随机存储器                                |\r\n| DIP                                                      | Dual In-line Package                                | 双列直插式封装，双入线封装        |\r\n| Direct RDRAM                                             | 直接总线式动态随机存储器                            |\r\n| DMA                                                      | Direct Memory Access                                | 直接内存存取                      |\r\n| DRAM                                                     | Dynamic Random-Access Memory                        | 动态随机存储器                    |\r\n| Dual Independent Bus                                     | DI                                                  | 双重独立总线                      |\r\n| ECC                                                      | Error Correcting Code                               | 错误更正码，纠错码                |\r\n| FPM DRAM                                                 | Fast Page Mode DRAM                                 | 快速翻页动态存储器                |\r\n| EDO DRAM                                                 | Extended Data Out DRAM                              | 扩展数据输出动态存储器.           |\r\n| SDRAM                                                    | Synchronous DRAM                                    | 同步动态存储器                    |\r\n| RDRAM                                                    | Rambus DRAM                                         | 总线式动态随机存储器              |\r\n| DDR                                                      | Double Data Rate SDRAM                              | 双数据输出同步动态存储器          |\r\n| parity                                                   | 奇偶校验                                            |\r\n| ECC                                                      | Error Correcting Code                               | 错误更正码                        |\r\n| Simm                                                     | Single-In line Memory Module                        | 即单边接触内存模组                |\r\n| SPD                                                      | Serial Presence Detect                              |\r\n| refresh                                                  | 刷新率                                              |\r\n| Flash Memory                                             | 闪烁存储器                                          |\r\n| SRAM                                                     | Static DRAM                                         | 静态内存                          |\r\n| PCMCIA                                                   | Personal Computer Memory Card International         |\r\n| JEDEC                                                    | Joint Electron Device Engineering Council           | 电子元件工业联合会                |\r\n| RAM                                                      | Random Access Memory                                | 随机存储器，即人们常说的“内存”    |\r\n| ROM                                                      | Read Only Memory                                    | 只读存储器                        |\r\n| EDO                                                      | Extended Data Output，扩充数据输出                  |\r\n| SDRAM                                                    | Synchronous Dynamic Random Access Memory            | 同步动态随机存储器                |\r\n| Cache                                                    |\r\n| PCI                                                      | Peripheral Component Interconnection，局部总线      |\r\n| Seagate                                                  | 美国希捷硬盘生产商                                  |\r\n| Quantum                                                  | 定量，总量                                          |\r\n| Maxtor                                                   | 水晶                                                |\r\n| LD                                                       | Laser Disk                                          | 镭射光盘，又称激光视盘            |\r\n| CD                                                       | Compact Disc                                        | 压缩光盘，又称激光唱盘            |\r\n| CD-ROM                                                   | Compact Disc Read Only Memory                       | 压缩光盘  只读记忆  存储          |\r\n| VCD                                                      | Video Compact Disc                                  | 视频压缩光盘                      |\r\n| DVD                                                      | Digital Versatile Disc                              |                                   |\r\n| TFT                                                      | 有源矩阵彩色显示器，简称TFT显示器，专用于笔记本电脑 |\r\n| Databuffer                                               | 数据缓冲器                                          |\r\n| Datacompression                                          | 数据压缩                                            |\r\n| DCE                                                      | Data Communication equipment                        | 数据通信设备                      |\r\n| DTE                                                      | Data Terminal equipment                             | 数据终端设备                      |\r\n| Errorcorrection                                          | 差错控制                                            |\r\n| Filetransferprotocol                                     | 文件转换协议                                        |\r\n| Flowcontrol                                              | 数据流控制                                          |\r\n| activate                                                 | 激活                                                |\r\n| Active client                                            | 活动客户                                            |\r\n| Active document                                          | 活动文档                                            |\r\n| Active Group,The                                         |\r\n| Active platform                                          | 活动平台                                            |\r\n| Active server                                            | 活动服务器                                          |\r\n| ASP                                                      | Active Server Page                                  |\r\n| apartment model multi-threading                          | 套间模式多线程                                      |\r\n| apartment threaded                                       | 套间线程化                                          |\r\n| API                                                      | Application Programming Interface                   | API                               | 应用程序编程接口    |\r\n| Applet                                                   | 小应用程序                                          |\r\n| asynchronous call                                        | 异步调用                                            |\r\n| Asynchronous Transfer Mode                               | ATM                                                 | 异步传输模式                      |\r\n| bandwidth                                                | 带宽                                                |\r\n| bind                                                     | 捆绑                                                |\r\n| bytecode                                                 | 字节代码                                            |\r\n| cache                                                    | 高速缓存                                            |\r\n| call                                                     | 调用                                                |\r\n| Certificate Authority                                    | 认证                                                |\r\n| class identifier                                         | 类标识符                                            |\r\n| class library                                            | 类库                                                |\r\n| class object                                             | 类对象                                              |\r\n| Component Object Model                                   | COM                                                 | 组件对象模型                      |\r\n| Common Gateway Interface                                 | CGI                                                 | 通用网关接口                      |\r\n| communications protocol                                  | 通信协议                                            |\r\n| compound document                                        | 复合文档                                            |\r\n| Computer Aided Software Engineering                      | CASE                                                | 计算机辅助软件工程                |\r\n| container application                                    | 包容器应用程序                                      |\r\n| context object                                           | 上下文对象                                          |\r\n| control                                                  | 控件                                                |\r\n| cursor engine                                            | 光标引擎                                            |\r\n| Data Access Object                                       | DAO                                                 | 数据访问对象                      |\r\n| data dictionary                                          | 数据词典                                            |\r\n| dataspace                                                | 数据空地                                            |\r\n| deadlocks                                                | 死锁                                                |\r\n| debugger                                                 | 调试器                                              |\r\n| default catalog                                          | 默认目录册                                          |\r\n| design-time ActiveX control                              | 设计时ActiveX控件                                   |\r\n| Distributed Computing Environment                        | DCE                                                 | 分布式计算环境                    |\r\n| Distributed Component Object Model                       | DCOM                                                | 分布式组件对象模型                |\r\n| distributed processing                                   | 分布式处理                                          |\r\n| domain name                                              | 域名                                                |\r\n| Domain Name Service                                      | DNS                                                 | 域名服务                          |\r\n| e-commerce                                               | 电子商务                                            |\r\n| event                                                    | 事件                                                |\r\n| event handlers                                           | 事件处理函数                                        |\r\n| FAQ Frequently Asked Questions                           | 经常被询问的问题                                    |\r\n| File Transfer Protocol                                   | FTP                                                 | 文件传输协议                      |\r\n| firewall                                                 | 防火墙                                              |\r\n| function                                                 | 函数                                                |\r\n| globally unique identifier                               | GUID                                                | 全局唯一标识符                    |\r\n| graphical user interface                                 | GUI                                                 | 图形用户界面                      |\r\n| Graphics Interchange Format                              | GIF                                                 | 图形交换格式                      |\r\n| impersonate                                              | 模仿                                                |\r\n| in-process                                               | 进程内                                              |\r\n| Indexed Sequential Access Method                         | ISAM                                                | 索引顺序访问方法                  |\r\n| inheritance                                              | 继承                                                |\r\n| instance                                                 | 实例                                                |\r\n| instantiate                                              | 实例化                                              |\r\n| Integrated Services Digital Network                      | ISDN                                                | 综合业务数字网                    |\r\n| interface                                                | 接口                                                |\r\n| International Standards Organization                     | ISO                                                 | 国际标准组织                      |\r\n| Internet Database Connector                              | IDC                                                 | Internet数据库连接器              |\r\n| Internet Engineering Task Force                          | IETF                                                |\r\n| Internet Protocol                                        | IP                                                  | Internet协议                      |\r\n| Internet Server Application Program Interface            | ISAPI                                               | Internet服务器应用程序接口        |\r\n| intranet                                                 | 企业内部互联网                                      |\r\n| Java Database Connectivity                               | JDBC                                                | Java数据库连通性                  |\r\n| Joint Photographic Experts Group                         | JPEG                                                | 联合图像专家组                    |\r\n| Just-in-time                                             | JIT object activation                               | 及时对象激活                      |\r\n| latency                                                  | 等待时间                                            |\r\n| Lightweight Directory Access Protocol                    | LDAP                                                | 轻目录访问协议                    |\r\n| Local Area Network                                       | LAN                                                 | 局域网                            |\r\n| Mail Messaging Applications Programming Interface        | 邮件消息发送应用程序编程接口                        |\r\n| marshal                                                  | 调度                                                |\r\n| master index                                             | 主索引                                              |\r\n| message queuing                                          | 消息队列                                            |\r\n| method                                                   | 方法                                                |\r\n| Microsoft Transaction Server                             | MTS                                                 | Microsoft事务处理服务器           |\r\n| Multipurpose Internet Mail Extensions                    | 多用途Internet邮件扩充协议                          |\r\n| moniker                                                  | 别名                                                |\r\n| multi-tasking                                            | 多任务                                              |\r\n| multi-threading                                          | 多线程                                              |\r\n| multi-tier architecture                                  | 多级体系                                            |\r\n| Network News Transfer Protocol                           | NNTP                                                | 网络新闻传输协议                  |\r\n| node                                                     | 节点                                                |\r\n| Object Linking and Embedding                             | OLE                                                 | 对象链接和嵌入                    |\r\n| Object Management Group                                  | OMG                                                 | 对象管理组织                      |\r\n| Object Request Broker                                    | ORB                                                 | 对象请求代理器                    |\r\n| constructor                                              | 建构式                                              |\r\n| declaration                                              | 宣告式                                              |\r\n| definition                                               | 定义式                                              |\r\n| destructor                                               | 解构式                                              |\r\n| expression                                               | 算式, 运算式                                        |\r\n| function                                                 | 函式                                                |\r\n| pattern                                                  | 范式、模式、样式                                    |\r\n| program                                                  | 程式                                                |\r\n| signature                                                | 标记式                                              |\r\n| assembly                                                 | 配件                                                |\r\n| component                                                | 组件                                                |\r\n| construct                                                | 构件                                                |\r\n| control                                                  | 控件                                                |\r\n| event                                                    | 事件                                                |\r\n| hardware                                                 | 硬件                                                |\r\n| object                                                   | 物件                                                |\r\n| part                                                     | 零件、部件                                          |\r\n| singleton                                                | 单件                                                |\r\n| software                                                 | 软件                                                |\r\n| work                                                     | 工件、机件                                          |\r\n| adapter                                                  | 配接器                                              |\r\n| allocator                                                | 配置器                                              |\r\n| compiler                                                 | 编译器                                              |\r\n| container                                                | 容器                                                |\r\n| iterator                                                 | 迭代器                                              |\r\n| linker                                                   | 联连                                                |\r\n| listener                                                 | 监听器                                              |\r\n| class                                                    | 类别                                                |\r\n| type                                                     | 型别                                                |\r\n| generalized                                              | 泛化                                                |\r\n| specialized                                              | 特化                                                |\r\n| overloaded                                               | 多载化                                              | 重载                              |\r\n| polymorphism                                             | 多型                                                |\r\n| genericity                                               | 泛型                                                |\r\n| process                                                  | 行程                                                | 进程                              |\r\n| thread                                                   | 线程                                                | 大陆用语                          |\r\n| programming                                              | 编程                                                |\r\n| `# define`                                               | 定义 预定义                                         |\r\n| `abstract`                                               | 抽象的 抽象的                                       |\r\n| `abstraction`                                            | 抽象体、抽象物、抽象性 抽象体、抽象物、抽象性       |\r\n| `access`                                                 | 存取、取用 存取、访问                               |\r\n| access level                                             | 存取级别 访问级别                                   |\r\n| access function                                          | 存取函式 访问函数                                   |\r\n| activate                                                 | 活化 激活                                           |\r\n| active                                                   | 作用中的                                            |\r\n| adapter                                                  | 配接器 适配器                                       |\r\n| address                                                  | 位址 地址                                           |\r\n| address space                                            | 位址空间，定址空间                                  |\r\n| address-of operator                                      | 取址运算子 取地址操作符                             |\r\n| aggregation                                              | 聚合                                                |\r\n| algorithm                                                | 演算法 算法                                         |\r\n| allocate                                                 | 配置 分配                                           |\r\n| allocator                                                | 空间 配置器 分配器                                  |\r\n| application                                              | 应用程式 应用、应用程序                             |\r\n| application framework                                    | 应用程式框架、应用框架 应用程序框架                 |\r\n| architecture                                             | 架构、系统架构 体系结构                             |\r\n| argument                                                 | 传给函式的值                                        | parameter 叁数                    |\r\n| array                                                    | 阵列 数组                                           |\r\n| arrow operator arrow                                     | 箭头                                                | 运算子 箭头操作符                 |\r\n| assembly                                                 | 装配件                                              |\r\n| assembly language                                        | 组合语言 汇编语言                                   |\r\n| assert                                                   | ion                                                 | 断言                              |\r\n| assign                                                   | 指派、指定、设值、赋值 赋值                         |\r\n| assignment                                               | 指派、指定 赋值、分配                               |\r\n| assignment operator                                      | 指派                                                | 赋值                              | 运算子 = 赋值操作符 |\r\n| associated                                               | 相应的、相关的 相关的、关联、相应的                 |\r\n| associative container                                    | 关联式容器                                          | 对应 sequential container         | 关联式容器          |\r\n| atomic                                                   | 不可分割的 原子的                                   |\r\n| attribute                                                | 属性 属性、特性                                     |\r\n| audio                                                    | 音讯 音频                                           |\r\n| A.I.                                                     | 人工智慧 人工智能                                   |\r\n| backward compatible                                      | 回溯相容 向下兼容                                   |\r\n| bandwidth                                                | 频宽 带宽                                           |\r\n| base class                                               | 基础类别 基类                                       |\r\n| base type                                                | 基础型别                                            | 等同於 base class                 |\r\n| benefit                                                  | 利益 收益                                           |\r\n| best viable function                                     | 最佳可行函式 最佳可行函式                           |\r\n| 从 viable functions 中挑出的最佳吻合者                   |\r\n| binary search                                            | 二分搜寻法 二分查找                                 |\r\n| binary tree                                              | 二元树 二叉树                                       |\r\n| binary function                                          | 二元函式 双叁函数                                   |\r\n| binary operator                                          | 二元运算子 二元操作符                               |\r\n| binding                                                  | 系结 绑定                                           |\r\n| bit                                                      | 位元 位                                             |\r\n| bit field                                                | 位元栏 ? 位域                                       |\r\n| bitmap                                                   | 位元图 ? 位图                                       |\r\n| bitwise                                                  | 以 bit 为单元逐一┅ ?                                |\r\n| bitwise copy 以 bit 为单元进行复制；位元逐一复制 位拷贝  |\r\n| block 区块,区段 块、区块、语句块                         |\r\n| boolean 布林值                                           | 真假值，true 或 false                               | 布尔值                            |\r\n| border 边框、框线 边框                                   |\r\n| brace                                                    | curly brace                                         | 大括弧、大括号 花括弧、花括号     |\r\n| bracket                                                  | square brakcet                                      | 中括弧、中括号 方括弧、方括号     |\r\n| breakpoint 中断点 断点                                   |\r\n| build 建造、构筑、建置                                   | MS 用语                                             |\r\n| build-in 内建 内置                                       |\r\n| bus 汇流排 总线                                          |\r\n| business 商务,业务 业务                                  |\r\n| buttons 按钮 按钮                                        |\r\n| byte 位元组                                              | 由 8 bits 组成                                      | 字节                              |\r\n| cache 快取 高速缓存                                      |\r\n| call 呼叫、叫用 调用                                     |\r\n| callback 回呼 回调                                       |\r\n| call operator call                                       | 函式呼叫, 运算子 调用操作符                         |\r\n| 同 function call operator                                |\r\n| candidate function 候选函式 候选函数                     |\r\n| 在函式多载决议程序中出现的候选函式                       |\r\n| chain 串链                                               | 例 chain of function calls                          | 链                                |\r\n| character 字元 字符                                      |\r\n| check box 核取方块                                       | i.e. check button                                   | 复选框                            |\r\n| checked exception 可控式异常                             | Java                                                |\r\n| check button 方钮                                        | i.e. check box                                      | 复选按钮                          |\r\n| child class 子类别                                       | 或称为derived class, subtype                        | 子类                              |\r\n| class 类别 类                                            |\r\n| class body 类别本体 类体 ?                               |\r\n| class declaration 类别宣告、类别宣告式 类声明            |\r\n| class definition 类别定义、类别定义式 类定义             |\r\n| class derivation list 类别衍化列 类继承列表              |\r\n| class head 类别表头 类头 ?                               |\r\n| class hierarchy 类别继承体系, 类别阶层 类层次体系        |\r\n| class library 类别程式库、类别库 类库                    |\r\n| class template 类别模板、类别范本 类模板                 |\r\n| class template partial specializations                   |\r\n| 类别模板偏特化 类模板部分特化                            |\r\n| class template specializations                           |\r\n| 类别模板特化 类模板特化                                  |\r\n| cleanup 清理、善後 清理、清除                            |\r\n| client 客端、客户端、客户 客户                           |\r\n| client-server 主从架构 客户/服务器                       |\r\n| clipboard 剪贴簿 剪贴板                                  |\r\n| clone 复制 克隆                                          |\r\n| collection 群集 集合                                     |\r\n| combo box 复合方块、复合框 组合框                        |\r\n| command line 命令列 命令行                               | 系统文字模式下的整行执行命令                        |\r\n| communication 通讯 通讯                                  |\r\n| compatible 相容 兼容                                     |\r\n| compile time 编译期 编译期、编译时                       |\r\n| compiler 编译器 编译器                                   |\r\n| component 组件 组件                                      |\r\n| composition 复合、合成、组合 组合                        |\r\n| computer 电脑、计算机 计算机、电脑                       |\r\n| concept 概念 概念                                        |\r\n| concrete 具象的 实在的                                   |\r\n| concurrent 并行 并发                                     |\r\n| configuration 组态 配置                                  |\r\n| connection 连接，连线                                    | 网络,资料库                                         | 连接                              |\r\n| constraint 约束                                          | 条件                                                |\r\n| construct 构件 构件                                      |\r\n| container 容器 容器                                      |\r\n| 存放资料的某种结构如 list, vector...                     |\r\n| containment 内含 包容                                    |\r\n| context 背景关系、周遭环境、上下脉络 环境、上下文        |\r\n| control 控制元件、控件 控件                              |\r\n| console 主控台 控制台                                    |\r\n| const 常数                                               | constant 的缩写，C++ 关键字                         |\r\n| constant 常数                                            | 相对於 variable                                     | 常量                              |\r\n| constructor                                              | ctor                                                | 建构式 构造函数                   |\r\n| 与class 同名的一种 member functions                      |\r\n| copy                                                     | v                                                   | 复制、拷贝 拷贝                   |\r\n| copy                                                     | n                                                   | 复件, 副本                        |\r\n| cover 涵盖 覆盖                                          |\r\n| create 创建、建立、产生、生成 创建                       |\r\n| creation 产生、生成 创建                                 |\r\n| cursor 游标 光标                                         |\r\n| custom 订制、自定 定制                                   |\r\n| data 资料 数据                                           |\r\n| database 资料库 数据库                                   |\r\n| database schema 数据库结构纲目                           |\r\n| data member 资料成员、成员变数 数据成员、成员变量        |\r\n| data structure 资料结构 数据结构                         |\r\n| datagram 资料元 数据报文                                 |\r\n| dead lock 死结 死锁                                      |\r\n| debug 除错 调试                                          |\r\n| debugger 除错器 调试器                                   |\r\n| declaration 宣告、宣告式 声明                            |\r\n| deduction 推导                                           | 例                                                  | template argument deduction       | 推导、推断          |\r\n| default 预设 缺省、默认                                  |\r\n| defer 延缓 推迟                                          |\r\n| definition 定义、定义区、定义式 定义                     |\r\n| delegate 委派、委托、委任 委托                           |\r\n| delegation                                               | 同上                                                |\r\n| demarshal 反编列 散集                                    |\r\n| dereference 提领                                         | 取出指标所指物体的内容                              | 解叁考                            |\r\n| dereference operator dereference                         | 提领                                                | 运算子 *解叁考操作符              |\r\n| derived class 衍生类别 派生类                            |\r\n| design by contract 契约式设计                            |\r\n| design pattern 设计范式、设计样式 设计模式               |\r\n| ※ 最近我比较喜欢「设计范式」一词                         |\r\n| destroy 摧毁、销毁                                       |\r\n| destructor                                               | dtor                                                | 解构式 析构函数                   |\r\n| device 装置、设备 设备                                   |\r\n| dialog 对话窗、对话盒 对话框                             |\r\n| directive 指令                                           | 例                                                  | using directive                   | 编译                | 指示符   |\r\n| directory 目录 目录                                      |\r\n| disk 碟 盘                                               |\r\n| dispatch 分派 分派                                       |\r\n| distributed computing 分布式计算                         | 分布式电算                                          | 分布式计算                        |\r\n| 分散式计算                                               | 分散式电算                                          |\r\n| document 文件 文档                                       |\r\n| dot operator dot                                         | 句点                                                | 运算子 .                          | 圆                  | 点操作符 |\r\n| driver 驱动程式 驱动                                     | 程序                                                |\r\n| dynamic binding 动态系结 动态绑定                        |\r\n| efficiency 效率 效率                                     |\r\n| efficient 高效 高效                                      |\r\n| end user 终端用户                                        |\r\n| entity 物体 实体、物体                                   |\r\n| encapsulation 封装 封装                                  |\r\n| enclosing class 外围类别                                 | 与巢状类别 nested class 有关                        | 外围类                            |\r\n| enum                                                     | enumeration                                         | 列举                              | 一种 C++ 资料型别   | 枚举     |\r\n| enumerators 列举元                                       | enum 型别中的成员                                   | 枚举成员、枚举器                  |\r\n| equal 相等 相等                                          |\r\n| equality 相等性 相等性                                   |\r\n| equality operator equality                               | 等号                                                | 运算子 == 等号操作符              |\r\n| equivalence 等价性、等同性、对等性 等价性                |\r\n| equivalent 等价、等同、对等 等价                         |\r\n| escape code 转义码 转义码                                |\r\n| evaluate 评估、求值、核定 评估                           |\r\n| event 事件 事件                                          |\r\n| event driven 事件驱动的 事件驱动的                       |\r\n| exception 异常情况 异常                                  |\r\n| exception declaration                                    | 异常宣告, ref. C++ Primer 3/e, 11.3                 | 异常声明                          |\r\n| exception handling                                       | 异常处理、异常处理机制 异常处理、异常处理机制       |\r\n| exception specification                                  | 异常规格, ref. C++ Primer 3/e, 11.4                 | 异常规范                          |\r\n| exit 退离                                                | 指离开函式时的那一个执行点                          | 退出                              |\r\n| explicit 明白的、明显的、显式 显式                       |\r\n| export 汇出 引出、导出                                   |\r\n| expression 运算式、算式 表达式                           |\r\n| facility 设施、设备 设施、设备                           |\r\n| feature 特性                                             |\r\n| field 栏位,资料栏                                        | Java                                                | 字段, 值域                        | Java                |\r\n| file 档案 文件                                           |\r\n| firmware 韧体 固件                                       |\r\n| flag 旗标 标记                                           |\r\n| flash memory 快闪记忆体 闪存                             |\r\n| flexibility 弹性 灵活性                                  |\r\n| flush 清理、扫清 刷新                                    |\r\n| font 字型 字体                                           |\r\n| form 表单                                                | programming 用语                                    | 窗体                              |\r\n| formal parameter 形式叁数 形式叁数                       |\r\n| forward declaration 前置宣告 前置声明                    |\r\n| forwarding 转呼叫,转发 转发                              |\r\n| forwarding function 转呼叫函式,转发函式 转发函数         |\r\n| fractal 碎形 分形                                        |\r\n| framework 框架 框架                                      |\r\n| full specialization 全特化                               | ref. partial specialization                         | ?                                 |\r\n| function 函式、函数 函数                                 |\r\n| function call operator 同 call operator                  |\r\n| function object 函式物件                                 | ref. C++ Primer 3/e, 12.3                           | 函数对象                          |\r\n| function overloaded resolution                           |\r\n| 函式多载决议程序 函数重载解决                            | 方案                                                |\r\n| functionality 功能、机能 功能                            |\r\n| function template 函式模板、函式范本 函数模板            |\r\n| functor 仿函式 仿函式、函子                              |\r\n| game 游戏 游戏                                           |\r\n| generate 生成                                            |\r\n| generic 泛型、一般化的 一般化的、通用的、泛化            |\r\n| generic algorithm 泛型演算法 通用算法                    |\r\n| getter                                                   | 相对於 setter                                       | 取值函式                          |\r\n| global 全域的                                            | 对应於 local                                        | 全局的                            |\r\n| global object 全域物件 全局对象                          |\r\n| global scope resolution operator                         |\r\n| 全域生存空间                                             | 范围决议                                            | 运算子  全局范围解析操作符        |\r\n| group 群组 ?                                             |\r\n| group box 群组方块 分组框                                |\r\n| guard clause 卫述句                                      | Refactoring, p250                                   | 卫语句                            |\r\n| GUI 图形介面 图形界面                                    |\r\n| hand shaking 握手协商                                    |\r\n| handle 识别码、识别号、号码牌、权柄 句柄                 |\r\n| handler 处理常式 处理函数                                |\r\n| hard-coded 编死的 硬编码的                               |\r\n| hard-copy 硬拷图 屏幕截图                                |\r\n| hard disk 硬碟 硬盘                                      |\r\n| hardware 硬体 硬件                                       |\r\n| hash table 杂凑表 哈希表、散列表                         |\r\n| header file 表头档、标头档 头文件                        |\r\n| heap 堆积 堆                                             |\r\n| hierarchy 阶层体系 层次结构                              | 体系                                                |\r\n| hook 挂钩 钩子                                           |\r\n| hyperlink 超链结 超链接                                  |\r\n| icon 图示、图标 图标                                     |\r\n| IDE 整合开发环境 集成开发环境                            |\r\n| identifier 识别字、识别符号 标识符                       |\r\n| if and only if 若且唯若 当且仅当                         |\r\n| Illinois 伊利诺 伊利诺斯                                 |\r\n| image 影像 图象                                          |\r\n| immediate base 直接的                                    | 紧临的                                              | 上层 base class 直接上层基类      |\r\n| immediate derived 直接的                                 | 紧临的                                              | 下层 derived class 直接下层派生类 |\r\n| immutability 不变性                                      |\r\n| immutable 不可变                                         | 的                                                  |\r\n| implement 实作、实现 实现                                |\r\n| implementation 实作品、实作体、实作码、实件 实现         |\r\n| implicit 隐喻的、暗自的、隐式 隐式                       |\r\n| import 汇入 导入                                         |\r\n| increment operator 累加运算子 ++ 增加操作符              |\r\n| infinite loop 无穷回圈 无限循环                          |\r\n| infinite recursive 无穷递回 无限递归                     |\r\n| information 资讯 信息                                    |\r\n| infrastructure 公共基础建设                              |\r\n| inheritance 继承、继承机制 继承、继承机制                |\r\n| inline 行内 内联                                         |\r\n| inline expansion 行内展开 内联展开                       |\r\n| initialization 初始化                                    | 动作                                                | 初始化                            |\r\n| initialization list 初值列 初始值列表                    |\r\n| initialize 初始化 初始化                                 |\r\n| inner class 内隐类别 内嵌类                              |\r\n| instance 实体 实例                                       |\r\n| 根据某种表述而实际产生的「东西」                         |\r\n| instantiated 具现化、实体化                              | 常应用於 template                                   | 实例化                            |\r\n| instantiation 具现体、具现化实体                         | 常应用於 template                                   | 实例                              |\r\n| integer                                                  | integral                                            | 整数                              | 的                  | 整型     | 的 |\r\n| integrate 整合 集成                                      |\r\n| interacts 交谈、互动 交互                                |\r\n| interface 介面 接口                                      |\r\n| for GUI 介面 界面                                        |\r\n| interpreter 直译器 解释器                                |\r\n| invariants 恒常性,约束条件 约束条件                      |\r\n| invoke 唤起 调用                                         |\r\n| iterate 迭代                                             | 回圈一个轮回一个轮回地进行                          | 迭代                              |\r\n| iterative 反覆的，迭代的                                 |\r\n| iterator 迭代器                                          | 一种泛型指标                                        | 迭代器                            |\r\n| iteration 迭代                                           | 回圈每次轮回称为一个 iteration                      | 迭代                              |\r\n| item 项目、条款 项、条款、项目                           |\r\n| laser 雷射 激光                                          |\r\n| level 阶 层                                              | 级                                                  | ?                                 |\r\n| 例 high level 高阶 高层                                  |\r\n| library 程式库、函式库 库、函数库                        |\r\n| lifetime 生命期、寿命 生命期、寿命                       |\r\n| link 联结、连结 连接,链接                                |\r\n| linker 联结器、连结器 连接器                             |\r\n| literal constant 字面常数                                | 例 3.14 或 \"hi\" 这等常数值                          | 字面常数                          |\r\n| list 串列                                                | linked-list                                         | 列表、表、链表                    |\r\n| list box 列表方块、列表框 列表框                         |\r\n| load 载入 装载                                           |\r\n| loader 载入器 装载器、载入器                             |\r\n| local 区域的                                             | 对应於 global                                       | 局部的                            |\r\n| local object 区域物件 局部对象                           |\r\n| lock 机锁                                                |\r\n| loop 回圈 循环                                           |\r\n| lvalue 左值 左值                                         |\r\n| macro 巨集 宏                                            |\r\n| magic number 魔术数字 魔法数                             |\r\n| maintain 维护 维护                                       |\r\n| manipulator 操纵器                                       | iostream 预先定义的一种东西                         | 操纵器                            |\r\n| marshal 编列 列集                                        |\r\n| 叁考 demarshal                                           |\r\n| mechanism 机制 机制                                      |\r\n| member 成员 成员                                         |\r\n| member access operator 成员取用运算子                    | 有 dot 和 arrow 两种                                | 成员存取操作符                    |\r\n| member function 成员函式 成员函数                        |\r\n| member initialization list                               |\r\n| 成员初值列 成员初始值列表                                |\r\n| memberwise 以 member 为单元┅、members 逐一┅ 以成员为单位 |\r\n| memberwise copy 以 members 为单元逐一复制                |\r\n| memory 记忆体 内存                                       |\r\n| menu 表单、选单 菜单                                     |\r\n| message 讯息 消息                                        |\r\n| message based 以讯息为基础的 基於消息的                  |\r\n| message loop 讯息回圈 消息环                             |\r\n| method                                                   | java                                                | 方法、行为、函式 方法             |\r\n| meta 元例 meta-programming 超编程 元编程                 |\r\n| micro 微 微                                              |\r\n| middleware 中介层 中间件                                 |\r\n| modeling 模塑                                            |\r\n| modeling language 塑模语言，建模语言                     |\r\n| modem 数据机 调制解调器                                  |\r\n| module 模组 模块                                         |\r\n| modifier 饰词 修饰符                                     |\r\n| most derived class 最末层衍生类别 最底层的派生类         |\r\n| mouse 滑鼠 鼠标                                          |\r\n| mutable 可变的 可变的                                    |\r\n| multi-tasking 多工 多任务                                |\r\n| namespace 命名空间 名字空间、命名空间                    |\r\n| native 原生的 本地的、固有的                             |\r\n| nested class 巢状类别 嵌套类                             |\r\n| network 网路 网络                                        |\r\n| network card 网路卡 网卡                                 |\r\n| object 物件 对象                                         |\r\n| object based 以物件为基础的 基於对象的                   |\r\n| object file 目的档 目标文件                              |\r\n| object model 物件模型 对象模型                           |\r\n| object oriented 物件导向的 面向对象的                    |\r\n| online 线上 在线                                         |\r\n| opaque 不透明的                                          |\r\n| operand 运算元 操作数                                    |\r\n| operating system                                         | OS                                                  | 作业系统 操作系统                 |\r\n| operation                                                | 操作、操作行为 操作                                 |\r\n| operator                                                 | 运算子 操作符、运算符                               |\r\n| option                                                   | 选项，可选方案 选项                                 |\r\n| ordinary                                                 | 常规的 常规的                                       |\r\n| overflow                                                 | 上限溢位                                            |\r\n| underflow                                                | 溢出 , 下溢                                         |\r\n| overhead                                                 | 额外负担、额外开销 额外开销                         |\r\n| overload                                                 | 多载化、多载化、重载 重载                           |\r\n| overloaded function                                      | 多载化函式 重载的函数                               |\r\n| overloaded operator                                      | 多载化运算子 被重载的操作符                         |\r\n| overloaded set                                           | 多载集合 重载集合                                   |\r\n| override                                                 | 重写                                                |\r\n| package 套件 包                                          |\r\n| pair 对组                                                |\r\n| palette 调色盘、组件盘、工具箱                           |\r\n| pane 窗格 窗格                                           |\r\n| 有时为嵌板之意，例 Java Content Pane                     |\r\n| parallel 平行 并行                                       |\r\n| parameter 叁数                                           | 函式叁数列上的变数                                  | 叁数、形式叁数、形叁              |\r\n| parameter list 叁数列 叁数列表                           |\r\n| parent class 父类别                                      | 或称 base class                                     | 父类                              |\r\n| parentheses 小括弧、小括号 圆括弧、圆括号                |\r\n| parse 解析 解析                                          |\r\n| part 零件 部件                                           | ?                                                   |\r\n| partial specialization 偏特化                            | ref. C++ Primer 3/e, 16.10                          | 局部特化                          |\r\n| ref. full specialization                                 |\r\n| pass by address 传址                                     | 函式引数的传递方式                                  | 非正式用语                        | 传地址              |\r\n| pass by reference 传址                                   | 函式引数的一种传递方式                              | 传地址, 按引用传递                |\r\n| pass by value 传值                                       | 函式引数的一种传递方式                              | 按值传递                          |\r\n| pattern 范式、样式 模式                                  |\r\n| ※ 最近我比较喜欢「范式」一词                             |\r\n| performance 效率、性能兼而有之 性能                      |\r\n| persistence 永续性 持久性                                |\r\n| pixel 图素、像素 像素                                    |\r\n| placement delete ref. C++ Primer 3/e, 15.8.2             |\r\n| placement new ref. C++ Primer 3/e, 15.8.2                |\r\n| platform 平台 平台                                       |\r\n| pointer 指标 指针                                        |\r\n| 址位器                                                   | 和址叁器 reference 形成对映，满好                   |\r\n| poll 轮询 轮询                                           |\r\n| polymorphism 多型 多态                                   |\r\n| pop up 冒起式、弹出式 弹出式                             |\r\n| port 埠 端口                                             |\r\n| postfix 後置式、後序式 後置式                            |\r\n| precedence 优先序                                        | 通常用於运算子的优先执行次序                        |\r\n| prefix 前置式、前序式 前置式                             |\r\n| preprocessor 前处理器 预处理器                           |\r\n| prime 质数 素数                                          |\r\n| primitive type 基本型别                                  | 不同於 base class,基础类别                          |\r\n| print 列印 打印                                          |\r\n| printer 印表机 打印机                                    |\r\n| priority 优先权                                          | 通常用於执行绪获得 CPU 时间的优先次序               |\r\n| procedure 程序 过程                                      |\r\n| procedural 程序性的、程序式的 过程式的、过程化的         |\r\n| process 行程 进程                                        |\r\n| profile 评测 评测                                        |\r\n| profiler 效能                                            | 效率                                                | 评测器 效能                       | 性能                | 评测器   |\r\n| programmer 程式员 程序员                                 |\r\n| programming 编程、程式设计、程式化 编程                  |\r\n| progress bar 进度指示器 进度指示器                       |\r\n| project 专案 项目、工程                                  |\r\n| property ??? 属性                                        |\r\n| protocol 协定 协议                                       |\r\n| pseudo code 假码、虚拟码、伪码 伪码                      |\r\n| qualified 经过资格修饰                                   | 例如加上 scope 运算子                               | 限定 ?                            |\r\n| qualifier 资格修饰词、饰词 限定修饰词 ?                  |\r\n| quality 品质 质量                                        |\r\n| queue 伫列 队列                                          |\r\n| radian 径度 弧度                                         |\r\n| radio button 圆钮 单选按钮                               |\r\n| raise 引发                                               | 常用来表示发出一个 exception                        | 引起、引发                        |\r\n| random number 随机数、乱数 随机数                        |\r\n| range 范围、区间                                         | 用於 STL 时                                         | 范围、区间                        |\r\n| rank 等级、分等                                          | ref. C++Primer 3/e 9,15章                           | 等级                              |\r\n| raw 生鲜的、未经处理的 未经处理的                        |\r\n| record 记录 记录                                         |\r\n| recordset 记录集 记录集                                  |\r\n| recursive 递回 递归                                      |\r\n| re-direction 重导向 重定向                               |\r\n| refactoring 重构、重整 重构                              |\r\n| refer 取用 叁考                                          |\r\n| refer to 指向、指涉、指代                                |\r\n| reference                                                | C++ 中类似指标的东西，相当於 \"化身\"                 | 引用、叁考                        |\r\n| 址叁器, see pointer                                      |\r\n| register 暂存器 寄存器                                   |\r\n| reflection 反射 反射、映像                               |\r\n| relational database 关联式资料库 关系数据库              |\r\n| represent 表述，表现 表述，表现                          |\r\n| resolve 决议                                             | 为算式中的符号名称寻找 解析                         |\r\n| 对应之宣告式的过程                                       |\r\n| resolution 决议程序、决议过程 解析过程                   |\r\n| resolution 解析度 分辨率                                 |\r\n| restriction 局限                                         |\r\n| return 传回、回返 返回                                   |\r\n| return type 回返型别 返回类型                            |\r\n| return value 回返值 返回值                               |\r\n| robust 强固、稳健 健壮                                   |\r\n| robustness 强固性、稳健性 健壮性                         |\r\n| routine 常式 例程                                        |\r\n| runtime 执行期 运行期、运行时                            |\r\n| common language runtime                                  | CLR                                                 | 译为「通用语言执行层」            |\r\n| rvalue                                                   | 右值                                                | 右值                              |\r\n| save 储存 存储                                           |\r\n| schedule 排程 调度                                       |\r\n| scheduler 排程器 调度程序                                |\r\n| scheme 结构纲目、组织纲目                                |\r\n| scroll bar 卷轴 滚动条                                   |\r\n| scope 生存空间、生存范围、范畴、作用域 生存空间          |\r\n| scope operator 生存空间                                  | 范围决议                                            | 运算子  生存空间操作符            |\r\n| scope resolution operator                                |\r\n| 生存空间决议运算子 生存空间解析操作符                    |\r\n| 与scope operator同                                       |\r\n| screen 萤幕 屏幕                                         |\r\n| search 搜寻 查找                                         |\r\n| semantics 语意 语义                                      |\r\n| sequential container 序列式容器 顺序式容器               | 对应於 associative container                        |\r\n| server 伺服器、伺服端 服务器、服务端                     |\r\n| serial 串行                                              |\r\n| serialization 次第读写,序列化 序列化                     |\r\n| serialize                                                |\r\n| setter                                                   | 相对於 getter                                       | 设值函式                          |\r\n| signal 信号                                              |\r\n| signature 标记式、签名式、署名式 签名                    |\r\n| slider 滚轴 滑块                                         |\r\n| slot 条孔、槽 槽                                         |\r\n| smart pointer 灵巧指标、精灵指标 智能指针                |\r\n| snapshot 萤幕快照                                        | 图                                                  | 屏幕截图                          |\r\n| specialization 特殊化、特殊化定义、特殊化宣告 特化       |\r\n| specification 规格 规格、规范                            |\r\n| splitter 分裂视窗 切分窗口                               |\r\n| software 软体 软件                                       |\r\n| solution 解法,解决方案 方案                              |\r\n| source 原始码 源码、源代码                               |\r\n| stack 堆叠 栈                                            |\r\n| stack unwinding 堆叠辗转开解                             | 此词用於 exception 主题                             | 栈辗转开解*                       |\r\n| standard library 标准程式库                              |\r\n| standard template library 标准模板程式库                 |\r\n| statement 述句 语句、声明                                |\r\n| status bar 状态列、状态栏 状态条                         |\r\n| STL 见 standard template library                         |\r\n| stream 资料流、串流 流                                   |\r\n| string 字串 字符串                                       |\r\n| subroutine                                               |\r\n| subscript operator 下标运算子 [ ] 下标操作符             |\r\n| subtype 子型别 子类型                                    |\r\n| support 支援 支持                                        |\r\n| suspend 虚悬 挂起                                        |\r\n| symbol 符号 记号                                         |\r\n| syntax 语法 语法                                         |\r\n| tag 标签 标记                                            |\r\n| target 标的                                              | 例 target pointer                                   | 标的指标                          | 目标                |\r\n| task switch 工作切换 任务切换                            |\r\n| template 模板、范本 模板                                 |\r\n| template argument deduction                              |\r\n| 模板引数推导 模板叁数推导                                |\r\n| template explicit specialization                         |\r\n| 模板显式特化                                             | 版本                                                | 模板显式特化 ?                    |\r\n| template parameter 模板叁数 模板叁数                     |\r\n| temporary object 暂时物件 临时对象                       |\r\n| text 文字 文本                                           |\r\n| text file 程式本文档                                     | 放置程式原始码的档案                                | 文本文件                          |\r\n| thread 执行绪 线程                                       |\r\n| thread safe 多绪安全 多线程安全                          |\r\n| throw 丢掷                                               | 常指发出一个 exception                              | 丢掷、引发                        |\r\n| token 语汇单元 符号、标记                                |\r\n| transaction 交易 事务                                    |\r\n| transparent                                              | ly                                                  | 透通的                            | 地                  |\r\n| traverse 巡访                                            | 来回走动                                            | 遍历                              |\r\n| trigger 触发 触发                                        |\r\n| type 型别 类型                                           |\r\n| UML unified modeling language 统一建模语言               |\r\n| unary function 一元函式 单叁函数                         |\r\n| unary operator 一元运算子 一元操作符                     |\r\n| underflow 下限溢位                                       | 相对於 overflow                                     | 下溢                              |\r\n| unchecked exception 不可控异常                           | Java                                                |\r\n| unqualified 未经资格修饰                                 | 而直接取用                                          | ?                                 |\r\n| unwinding ref. stack unwinding ?                         |\r\n| user                                                     | 使用者、用户 用户                                   |\r\n| user interface                                           | 使用者介面、用户介面、人机介面 用户界面             |\r\n| variable 变数                                            | 相对於常数 const                                    | 变量                              |\r\n| vector 向量                                              | 一种容器，有点类似 array                            | 向量、矢量                        | ?                   |\r\n| viable 可实行的、可行的 可行的                           |\r\n| viable function 可行函式 可行函数                        | 从 candidate functions 中挑出者                     |\r\n| video 视讯 视频                                          |\r\n| view                                                     |                                                     | 视图                              |\r\n| document/view                                            | 文档/视图                                           |\r\n| virtual function                                         | 虚拟函式 虚函数                                     |\r\n| virtual machine                                          | 虚拟机器 虚拟机                                     |\r\n| virtual memory                                           | 虚拟记忆体 虚内存, 虚存                             |\r\n| volatile                                                 | 易挥发的、易变的                                    |\r\n| vowel                                                    | 母音 元音字母                                       |\r\n| window                                                   | 视窗 窗口                                           |\r\n| window function                                          | 视窗函式 窗口函数                                   |\r\n| window procedure                                         | 视窗函式 窗口过程                                   |\r\n| word processor                                           | 文书处理器 字处理器                                 |\r\n| wrapper                                                  | 外覆、外包 包装                                     |\r\n| cover                                                    | 涵盖 覆盖                                           |\r\n| indicate                                                 | 显示 表明                                           |\r\n| level                                                    | 层次,层级 级别                                      |\r\n| advanced                                                 | 进阶 高端                                           |\r\n| Online Analytical Processing                             | OLAP                                                | 联机分析处理                      |\r\n| Open Database Connectivity                               | ODBC                                                | 开放数据库连通性                  |\r\n| Open Group, The                                          | 开放组织                                            |\r\n| Open Software Foundation                                 | OSF                                                 | 开放软件基金会                    |\r\n| out-of-process                                           | 进程外                                              |\r\n| Point-to-Point Protocol                                  | PPP                                                 | 点对点协议                        |\r\n| Point-to-Point Tunneling Protocol                        | PPTP                                                | 点对点连通协议                    |\r\n| pooling                                                  | 缓冲池                                              |\r\n| Post Office Protocol version 3                           | POP3                                                | 邮政协议版本3                     |\r\n| Private Communications Technology                        | PCT 1.0                                             | 个人通信技术                      |\r\n| property                                                 | 属性                                                |\r\n| protocol                                                 | 协议                                                |\r\n| proxy server                                             | 代理服务器                                          |\r\n| Public Key Certificate Standard                          | PKCS                                                | 公共密钥许可标准                  |\r\n| race condition                                           | 接力                                                |\r\n| Remote Data Object                                       | RDO                                                 | 远程数据对象                      |\r\n| Remote Procedure Call                                    | RPC                                                 | 远程过程调用                      |\r\n| router                                                   | 路由器                                              |\r\n| RTP/RTCP                                                 | 分别为实时协议和实时控制协议                        |\r\n| scalability                                              | 可伸缩性                                            |\r\n| script                                                   | 脚本                                                |\r\n| Secure Electronic Payment Process                        | SEPP                                                | 安全电子支付过程                  |\r\n| Secure Electronic Transaction                            | SET                                                 | 安全电子事务处理                  |\r\n| Secure Sockets Layer 3.0                                 | SSL                                                 | 安全套接层3.0                     |\r\n| Secure Transaction Technology                            | STT                                                 | 安全事务处理技术                  |\r\n| server                                                   | 服务器                                              |\r\n| server-side include                                      | SSI                                                 | 服务器方包含                      |\r\n| ServerName                                               | 服务器名                                            |\r\n| Simple Mail Transfer Protocol                            | SMTP                                                | 简单邮件传输协议                  |\r\n| single-threaded                                          | 单线程                                              |\r\n| Standard Generalized Markup Language                     | SGML                                                | 通用标记语言标准                  |\r\n| stored procedure                                         | 存储过程                                            |\r\n| Structured Query Language                                | SQL                                                 | 结构查询语言                      |\r\n| Symmetric Multiprocessing                                | SMP                                                 | 对称式多处理                      |\r\n| synchronous                                              | 同步                                                |\r\n| transaction                                              | 事务处理                                            |\r\n| Transaction Processing                                   | TP                                                  | 事务处理                          |\r\n| type library                                             | 类型库                                              |\r\n| Virtual Machine                                          | 虚拟机                                              |\r\n| Virtual Realty Modeling Language                         | VRML                                                | 虚拟现实模型语言                  |\r\n| Virtual Root                                             | 虚拟根                                              |\r\n| Visual Basic for Application                             | VBA                                                 | 应用程序的Visual Basic            |\r\n| 数据                                                     | Data                                                |\r\n| 信息                                                     | Information                                         |\r\n| 数据库DB                                                 | Data Base                                           |\r\n| 数据库管理系统DBMS                                       | Data Base Management System                         |\r\n| 数据库系统DBS                                            | Data Base System                                    |\r\n| 数据库应用程序接口API                                    | Application Programming Interface                   |\r\n| 数据库应用程序AP                                         | Application Program                                 |\r\n| 数据仓库                                                 | Data Warehouse                                      |\r\n| 数据发掘                                                 | Data Mining                                         |\r\n| 信息发掘                                                 | Information Mining                                  |\r\n| 数据模式                                                 | Data Model                                          |\r\n| 数据模型                                                 | Data Model                                          |\r\n| 字段                                                     | Field                                               |\r\n| 片段                                                     | Segment                                             |\r\n| 数据项                                                   | Data Item                                           |\r\n| 记录                                                     | Record                                              |\r\n| 域                                                       | Domain                                              |\r\n| 关系                                                     | Relation                                            |\r\n| 元组                                                     | Tuple                                               |\r\n| 属性                                                     | Attribute                                           |\r\n| 关键字                                                   | Primary Key                                         |\r\n| 外部关键字                                               | Forgien Key                                         |\r\n| 网络库                                                   | Net-Library                                         |\r\n| 主数据文件                                               |\r\n| 辅数据文件                                               |\r\n| 日志文件                                                 | LOG File                                            |\r\n| ODBC                                                     | Open Database Connection                            | 开放数据库互连                    |\r\n| SQL                                                      | Structured Query Language                           | 结构化查询语言                    |\r\n| 视图                                                     | View                                                |\r\n| 游标                                                     | CURSOR                                              |\r\n| 完整性约束                                               | Integrity Constraint                                |\r\n| 触发器                                                   | Trigger                                             |\r\n| 存储过程                                                 | Stored Procedure                                    |\r\n| 数据模式                                                 | Data Schema                                         |\r\n| 关系模式                                                 | Relation Schema                                     |\r\n| 数据依赖                                                 | Data Dependency                                     |\r\n| 函数依赖                                                 | Functional Dependency                               |\r\n| 规范化                                                   | Normalization                                       |\r\n| 原子聚合                                                 | Atom Aggregation                                    |\r\n| 数据流图                                                 | Data Flow Diagram                                   |\r\n| 数据字典                                                 | Data Dictionary                                     |\r\n| 数据库操纵语言DML                                        |\r\n| 事务                                                     | transaction                                         |\r\n| 共享锁                                                   | shared lock                                         |\r\n| 独占锁                                                   | exclusive lock                                      |\r\n| 复制                                                     | replication                                         |\r\n| 快照复制                                                 | Snapshot Replication                                |\r\n| 合并复制                                                 | Merge Replication                                   |\r\n| 数据市场                                                 | Data Mart                                           |\r\n| 决策支持系统DSS                                          | Decision Support System                             |\r\n| 维度                                                     | Dimension                                           |\r\n| 粒度                                                     | Granularity                                         |\r\n| 索引                                                     | Indexing                                            |\r\n| 多维数据分析                                             | Multidimensional data analysis                      |\r\n| 在线事务处理OLTP                                         | On-Line Transaction Processing                      |\r\n| 在线分析处理OLAP                                         | On-Line Analytical Processing                       |\r\n| 面向主题                                                 | Subject Oriented                                    |\r\n| 对称多处理器SMP                                          | Symmetric MultiProcessors                           |\r\n| 同义词                                                   | Synonyms                                            |\r\n| 瀑布开发方法                                             | Waterfall Development Method                        |\r\n| 加速键或快捷键                                           | accelerate key                                      |\r\n| 带重音的字符                                             | accented character                                  |\r\n| 校准                                                     | alignment，对齐                                     |\r\n| 双向语言                                                 | bi-directional language                             |\r\n| 编译版本                                                 | build                                               |\r\n| 版本环境                                                 | build environment                                   |\r\n| 版本健康检查                                             | build sanity check                                  |\r\n| 级连样式表                                               | cascading style sheet -CSS                          |\r\n| 字符集                                                   | character set                                       |\r\n| 附属条目                                                 | collateral                                          |\r\n| 计算机辅助翻译                                           | Computer Aided Translation-CAT                      |\r\n| 串联                                                     | Concatenation                                       |\r\n| 控制语言                                                 | Controlled language                                 |\r\n| 外观测试                                                 | cosmetic testing                                    |\r\n| 桌面排版                                                 | desktop publishing-DTP                              |\r\n| 双字节字符集                                             | double bytes character set-DBCS                     |\r\n| 双字节支持能力                                           | double-byte enablement                              |\r\n| 动态网站                                                 | dynamic web site                                    |\r\n| 可扩展标示语言                                           | Extensible Markup Language-XML                      |\r\n| 法语/意大利语/德语/西班牙语                              | French/Italian/Germany/Spanish-FIGS                 |\r\n| 全部匹配                                                 | full match                                          |\r\n| 功能测试                                                 | functional testing                                  |\r\n| 模糊匹配                                                 | fuzzy matching                                      |\r\n| 全球化                                                   | globalization                                       |\r\n| 术语表                                                   | glossary                                            |\r\n| 硬编码                                                   | hard-coding                                         |\r\n| 帮助编译器                                               | help compiler                                       |\r\n| 启动会议                                                 | kick-off meeting                                    |\r\n| 分层图像                                                 | layered graphic                                     |\r\n| 重复利用                                                 | leverage                                            |\r\n| 语言测试                                                 | linguistic testing                                  |\r\n| 本地化行业标准组织                                       | Localization Industry Standard Association-LISA     |\r\n| 本地化                                                   | localization-l10n                                   |\r\n| 本地化工具包                                             | localization kit                                    |\r\n| 本地化测试                                               | localization testing                                |\r\n| 本地化服务商                                             | localization vendor                                 |\r\n| 机器翻译                                                 | machine translation-MT                              |\r\n| 标识语言                                                 | markup language                                     |\r\n| 多字节字符集                                             | multi-byte character set                            |\r\n| 外包                                                     | outsourcing                                         |\r\n| 便携式文档格式                                           | Portable document Format-PDF                        |\r\n| 伪翻译                                                   | pseudo translation                                  |\r\n| 质量保证                                                 | quality assurance-QA                                |\r\n| 报价单                                                   | Request for quotation-RFQ                           |\r\n| 投入回报率                                               | Return of Investment-ROI                            |\r\n| 调整                                                     | resizing                                            |\r\n| 资源动态链接库                                           | Resource-only .dll                                  |\r\n| 屏幕捕捉                                                 | screen capture, screenshot                          |\r\n| 校对                                                     | proofreading                                        |\r\n| 同时发布                                                 | simultaneous ship-simship                           |\r\n| 软件一致性检查                                           | software consistency check                          |\r\n| 标准通用标识语言                                         | Standard Generalized Markup Language-SGML           |\r\n| 术语管理系统                                             | terminology management system-TMS                   |\r\n| 文字扩展                                                 | text expansion                                      |\r\n| 通用字符集                                               | Unicode                                             |\r\n","children":[]}]},{"name":"OpenSource","path":"../guanruihua.github.io","data":"","children":[{"name":"fakingjs","path":"../guanruihua.github.io/OpenSource","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/OpenSource/fakingjs","data":"# 描述\r\n\r\n- 虚拟数据生成\r\n\r\n## 使用\r\n\r\n```shell\r\nnpm install fakingjs\r\n```\r\n\r\n```js\r\nimport { Fake } from 'fakingjs'\r\n\r\nFake(\"@name\")\r\n=> 'Ruihuag'\r\n```\r\n\r\n## 说明\r\n\r\n```js\r\nFake({\r\n  'name|rule|key1,key2,key3...|[DictionaryKey]':'@name'\r\n})\r\n```\r\n\r\n- `name`: 表示当前属性真正name\r\n- `rule` : 指定生成数量等规则\r\n- `key1,key2,key3...`: 表示当前属性为对象, 并且指定多个key, 且值为 `@name`\r\n- `@name`: 数据规则\r\n\r\n## 规则使用\r\n\r\n```js\r\nFake(\"@name\")\r\n=> 'Ruihuag'\r\n```\r\n\r\n## `name|number`\r\n\r\n```js\r\n Fake({ 'name': '@name' })\r\n Fake({ 'name|1': 1 })\r\n Fake({ 'name|1': '@name' })\r\n Fake({ 'name|3': '@name' })\r\n Fake({ 'name|3': 1 })\r\n =>\r\n  { name: 'Ruihuag' }\r\n  { name: 1 }\r\n  { name: 'Jose' }\r\n  { name: 'FrankGaryDavid' }\r\n  { name: 4 }\r\n\r\n```\r\n\r\n## 范围 `name|2-222`\r\n\r\n```js\r\nFake({\"name|3-5\":\"@name\"})\r\n=> { name: [ 'Jeffrey', 'Jose', 'Gary', 'William' ] }\r\n```\r\n\r\n## 指定数量 `name|12`\r\n\r\n```js\r\nFake({\"name|3\":\"@name\"})\r\n=>  { name: [ 'Christopher', 'Daniel', 'Richard' ] }\r\n```\r\n\r\n## 多用一\r\n\r\n### 基础使用 `{'name||key1,key2,key3':'@name'}`\r\n\r\n```js\r\n{name: { key1: 'Mark', key2: 'Jason', key3: 'Thomas' }`}\r\n```\r\n\r\n### 指定数量 `{'name|2|key1,key2,key3': \"@name\"}`\r\n\r\n```js\r\n{\r\n  name: [\r\n    { key1: 'Mark', key2: 'Donald', key3: 'Michael' },\r\n    { key1: 'George', key2: 'Jose', key3: 'Edward' },\r\n  ]\r\n}\r\n```\r\n\r\n### 数量范围组 `{'name|2-5|key1,key2,key3': \"@name\"}`\r\n\r\n```js\r\n{\r\n  name: [\r\n    { key1: 'Jason', key2: 'Kenneth', key3: 'Scott' },\r\n    { key1: 'Mark', key2: 'Donald', key3: 'Michael' },\r\n    { key1: 'George', key2: 'Jose', key3: 'Edward' },\r\n  ]\r\n}\r\n```\r\n\r\n## 多用一 并转子串\r\n\r\n### 基础 `{'name||key1,key2,key3|JsonString':'@name'}`\r\n\r\n```js\r\n{\r\n  name: '{\"key1\":\"Joseph\",\"key2\":\"Michael\",\"key3\":\"Jose\"}'\r\n}\r\n```\r\n\r\n### 指定数量 `{'name|2|key1,key2,key3|JsonString': \"@name\"}`\r\n\r\n```js\r\n{\r\n  name: '[{\"key1\":\"Anthony\",\"key2\":\"Eric\",\"key3\":\"Edward\"},{\"key1\":\"Thomas\",\"key2\":\"Eric\",\"key3\":\"Edward\"}]'\r\n}\r\n```\r\n\r\n### 数量范围 `{'name|2-5|key1,key2,key3|JsonString': \"@name\"}`\r\n\r\n```js\r\n{ name: '{\"key1\":\"James\",\"key2\":\"Jeffrey\",\"key3\":\"William\"}' }\r\n```\r\n\r\n## 自定义规则\r\n\r\n- 优先级最高, 会覆盖包原本规则\r\n\r\n```js\r\nimport { Fake, initDictionary, dictionary } from '../src'\r\n\r\n// 可以查看已经设置的规则字典\r\ndictionary\r\n\r\ninitDictionary({\r\n  'aaa': 'ababab',\r\n  'bbb': function (a = '1', b = '2') {\r\n    return a + '---' + b\r\n  }\r\n})\r\n\r\nFake('@bbb(123,456)') // 123---456\r\nFake('@aaa') // ababab\r\n\r\n```\r\n\r\n## 操作符\r\n\r\n### 基础数据类型\r\n\r\n|     操作符     |        描述        |     结果     |\r\n| :------------: | :----------------: | :----------: |\r\n|    `@char`     |        字符        |     `A`      |\r\n|   `@boolean`   |       布尔值       |    `true`    |\r\n|   `@string`    |       字符串       | `wg0DGEE1s[` |\r\n| `@string(3,5)` | 指定范围长度字符串 |    `wg0D`    |\r\n|     `@num`     |        数字        |     520      |\r\n|  `@num(5,10)`  |    指定范围数字    |      5       |\r\n|    `@float`    |       浮点型       |    13.14     |\r\n\r\n### 名称\r\n\r\n|  操作符   |     描述     |      结果 |\r\n| :-------: | :----------: | --------: |\r\n|  `@name`  |    英文名    | `Ruihuag` |\r\n| `@cname`  |    中文名    |  `关瑞毕` |\r\n| `@first`  | 英文名称的名 |  `Sandra` |\r\n|  `@last`  | 英文名称的姓 |    `Jose` |\r\n| `@cfirst` |    中文姓    |      `关` |\r\n| `@clast`  |    中文名    |    `瑞毕` |\r\n\r\n### 文本\r\n\r\n|     操作符      |  描述  |                                                                                                                                                                                                                                                                                                                                                                                                                               结果                                                                                                                                                                                                                                                                                                                                                                                                                               |\r\n| :-------------: | :----: | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |\r\n|    `@title`     |  标题  |                                                                                                                                                                                                                                                                                                                                                                                                                            `土好保观`                                                                                                                                                                                                                                                                                                                                                                                                                            |\r\n| `@title(3,30)`  |  标题  |                                                                                                                                                                                                                                                                                                                                                                                                    `传年圆美石所技道只式器知老引明说外海专性油复队运构科文重`                                                                                                                                                                                                                                                                                                                                                                                                    |\r\n|    `@cword`     | 中文字 |                                                                                                                                                                                                                                                                                                                                                                                                                               `厂`                                                                                                                                                                                                                                                                                                                                                                                                                               |\r\n| `@sentence(2)`  |  句子  |                                                                                                                                                                                                                                                                                                                                                                                  `Enim ad aute eiusmod enim occaecat. Aliqua anim dolore eiusmod officia commodo amet nostrud.`                                                                                                                                                                                                                                                                                                                                                                                  |\r\n|   `@sent(2)`    |  句子  |                                                                                                                                                                                                                                                                                                                                                                                  `Enim ad aute eiusmod enim occaecat. Aliqua anim dolore eiusmod officia commodo amet nostrud.`                                                                                                                                                                                                                                                                                                                                                                                  |\r\n| `@paragraph(2)` | 自然段 | <div style=\"text-align:left;\">&nbsp;&nbsp;&nbsp;&nbsp;Laboris ex ad duis reprehenderit deserunt enim. In laboris Lorem est pariatur eu officia incididunt ipsum sint adipisicing nisi ullamco ut do. Quis ullamco tempor exercitation duis elit duis duis adipisicing. Occaecat pariatur reprehenderit consectetur amet non cillum velit eu cupidatat ad. Reprehenderit excepteur sint commodo officia adipisicing id labore veniam amet irure. Cillum nisi voluptate exercitation minim in ut aliquip laborum duis. Lorem veniam amet magna labore reprehenderit culpa adipisicing eiusmod ipsum exercitation.</br>&nbsp;&nbsp;&nbsp;&nbsp;Eiusmod minim aliqua dolor nostrud et. Mollit ad ex laborum ea deserunt incididunt pariatur. Ipsum exercitation Lorem consectetur dolor incididunt excepteur labore proident cupidatat dolore consequat dolor.</div> |\r\n|   `@para(2)`    | 自然段 | <div style=\"text-align:left;\">&nbsp;&nbsp;&nbsp;&nbsp;Laboris ex ad duis reprehenderit deserunt enim. In laboris Lorem est pariatur eu officia incididunt ipsum sint adipisicing nisi ullamco ut do. Quis ullamco tempor exercitation duis elit duis duis adipisicing. Occaecat pariatur reprehenderit consectetur amet non cillum velit eu cupidatat ad. Reprehenderit excepteur sint commodo officia adipisicing id labore veniam amet irure. Cillum nisi voluptate exercitation minim in ut aliquip laborum duis. Lorem veniam amet magna labore reprehenderit culpa adipisicing eiusmod ipsum exercitation.</br>&nbsp;&nbsp;&nbsp;&nbsp;Eiusmod minim aliqua dolor nostrud et. Mollit ad ex laborum ea deserunt incididunt pariatur. Ipsum exercitation Lorem consectetur dolor incididunt excepteur labore proident cupidatat dolore consequat dolor.</div> |\r\n\r\n### 居住地址\r\n\r\n| 操作                   | 描述           | 结果                                            |\r\n| :--------------------- | :------------- | :---------------------------------------------- |\r\n| `region`               | 地区           | 西北                                            |\r\n| `province`             | 省             | 广东省                                          |\r\n| `city`                 | 城市           | 韶关市                                          |\r\n| `district`             | 区域           | 洮北区                                          |\r\n| `address`              | 地址           | 安徽省宣城市宣州区1d8街道6e路69号99栋36单元78号 |\r\n| `address(RR PP CC DD)` | 地址(指定格式) | 东北 山西省 吕梁市 汾阳市                       |\r\n\r\n 补充:\r\n\r\n- `RR`: 地区  \r\n- `PP`: 省\r\n- `CC`: 城市\r\n- `DD`: 地区\r\n\r\n### 其他地址\r\n\r\n| 操作      | 描述    | 结果                                    |\r\n| :-------- | :------ | :-------------------------------------- |\r\n| `@ip`     | ip      | 242.86.47.174                           |\r\n| `@ip6()`  | ipv6    | e60b:3d50:be5c:ea37:3005:8a35:846e:1aeb |\r\n| `@domain` | web地址 | opubztw.xxq                             |\r\n| `@email`  | 邮箱    | cxydhhsfxqzki@nipik.ftnyl               |\r\n\r\n### 颜色\r\n\r\n- 待开发\r\n- color, hex, rgb, rgba, hsl\r\n\r\n### 图片\r\n\r\n#### `@image([text[,size[,background[,foreground[,format]]]]])`\r\n\r\n- 图片链接\r\n- `text = ''`: 文字\r\n- `size = '200x200'` :图片大小\r\n- `background = '000'`: 背景图片\r\n- `foreground = 'fff'`: 文字颜色\r\n- `format: '' | 'png' | 'gif' | 'jpg' = ''` : 图片格式\r\n\r\n#### 时间\r\n\r\n| 操作符                       | 描述           | 结果                  |\r\n| :--------------------------- | :------------- | :-------------------- |\r\n| `@now`                       | 现在           | `2022-06-08 16:58:16` |\r\n| `@now(YYYY-MM-DD HH:mm:ss)`  | 现在           | `2022-06-08 16:58:16` |\r\n| `@date`                      | 随机日期       | `2021-09-27`          |\r\n| `@date(YYYY-MM-DD)`          | 随机日期       | `2022-03-28`          |\r\n| `@date(YYYY-MM-DD HH:mm:ss)` | 随机日期       | `2020-03-24 22:58:16` |\r\n| `@time`                      | 随机时间       | `22:58:16`            |\r\n| `@time(HH:mm:ss)`            | 随机时间       | `04:58:16`            |\r\n| `@time(YYYY-MM-DD HH:mm:ss)` | 随机时间       | `2020-06-27 22:58:16` |\r\n| `@timeStamp`                 | 随机时间戳     | `1604703768135`       |\r\n| `@nowTimeStamp`              | 当前时间时间戳 | `1604703768135`       |\r\n\r\n### 特殊\r\n\r\n|                    操作符                     | 描述  |                  结果                  |\r\n| :-------------------------------------------: | :---: | :------------------------------------: |\r\n|                     `@id`                     |  id   |           `3191230364936506`           |\r\n|                    `@uuid`                    | uuid  | `326be748-57bd-c2d0-84f4-99bb488a4292` |\r\n| `@uuid(xxxxxxxx-xxxx-xxxx-yxxx-xxxxxxxxxxxx)` | uuid  | `326be748-57bd-c2d0-84f4-99bb488a4292` |\r\n","children":[]},{"name":"README.md","path":"../guanruihua.github.io/OpenSource/fakingjs","data":"# 描述\r\n\r\n- 虚拟数据生成\r\n\r\n## 使用\r\n\r\n```shell\r\nnpm install fakingjs\r\n```\r\n\r\n```js\r\nimport { Fake } from 'fakingjs'\r\n\r\nFake(\"@name\")\r\n=> 'Ruihuag'\r\n```\r\n\r\n## 说明\r\n\r\n```js\r\nFake({\r\n  'name|rule|key1,key2,key3...|[DictionaryKey]':'@name'\r\n})\r\n```\r\n\r\n- `name`: 表示当前属性真正name\r\n- `rule` : 指定生成数量等规则\r\n- `key1,key2,key3...`: 表示当前属性为对象, 并且指定多个key, 且值为 `@name`\r\n- `@name`: 数据规则\r\n\r\n## 规则使用\r\n\r\n```js\r\nFake(\"@name\")\r\n=> 'Ruihuag'\r\n```\r\n\r\n## `name|number`\r\n\r\n```js\r\n Fake({ 'name': '@name' })\r\n Fake({ 'name|1': 1 })\r\n Fake({ 'name|1': '@name' })\r\n Fake({ 'name|3': '@name' })\r\n Fake({ 'name|3': 1 })\r\n =>\r\n  { name: 'Ruihuag' }\r\n  { name: 1 }\r\n  { name: 'Jose' }\r\n  { name: 'FrankGaryDavid' }\r\n  { name: 4 }\r\n\r\n```\r\n\r\n## 范围 `name|2-222`\r\n\r\n```js\r\nFake({\"name|3-5\":\"@name\"})\r\n=> { name: [ 'Jeffrey', 'Jose', 'Gary', 'William' ] }\r\n```\r\n\r\n## 指定数量 `name|12`\r\n\r\n```js\r\nFake({\"name|3\":\"@name\"})\r\n=>  { name: [ 'Christopher', 'Daniel', 'Richard' ] }\r\n```\r\n\r\n## 多用一\r\n\r\n### 基础使用 `{'name||key1,key2,key3':'@name'}`\r\n\r\n```js\r\n{name: { key1: 'Mark', key2: 'Jason', key3: 'Thomas' }`}\r\n```\r\n\r\n### 指定数量 `{'name|2|key1,key2,key3': \"@name\"}`\r\n\r\n```js\r\n{\r\n  name: [\r\n    { key1: 'Mark', key2: 'Donald', key3: 'Michael' },\r\n    { key1: 'George', key2: 'Jose', key3: 'Edward' },\r\n  ]\r\n}\r\n```\r\n\r\n### 数量范围组 `{'name|2-5|key1,key2,key3': \"@name\"}`\r\n\r\n```js\r\n{\r\n  name: [\r\n    { key1: 'Jason', key2: 'Kenneth', key3: 'Scott' },\r\n    { key1: 'Mark', key2: 'Donald', key3: 'Michael' },\r\n    { key1: 'George', key2: 'Jose', key3: 'Edward' },\r\n  ]\r\n}\r\n```\r\n\r\n## 多用一 并转子串\r\n\r\n### 基础 `{'name||key1,key2,key3|JsonString':'@name'}`\r\n\r\n```js\r\n{\r\n  name: '{\"key1\":\"Joseph\",\"key2\":\"Michael\",\"key3\":\"Jose\"}'\r\n}\r\n```\r\n\r\n### 指定数量 `{'name|2|key1,key2,key3|JsonString': \"@name\"}`\r\n\r\n```js\r\n{\r\n  name: '[{\"key1\":\"Anthony\",\"key2\":\"Eric\",\"key3\":\"Edward\"},{\"key1\":\"Thomas\",\"key2\":\"Eric\",\"key3\":\"Edward\"}]'\r\n}\r\n```\r\n\r\n### 数量范围 `{'name|2-5|key1,key2,key3|JsonString': \"@name\"}`\r\n\r\n```js\r\n{ name: '{\"key1\":\"James\",\"key2\":\"Jeffrey\",\"key3\":\"William\"}' }\r\n```\r\n\r\n## 自定义规则\r\n\r\n- 优先级最高, 会覆盖包原本规则\r\n\r\n```js\r\nimport { Fake, initDictionary, dictionary } from '../src'\r\n\r\n// 可以查看已经设置的规则字典\r\ndictionary\r\n\r\ninitDictionary({\r\n  'aaa': 'ababab',\r\n  'bbb': function (a = '1', b = '2') {\r\n    return a + '---' + b\r\n  }\r\n})\r\n\r\nFake('@bbb(123,456)') // 123---456\r\nFake('@aaa') // ababab\r\n\r\n```\r\n\r\n## 操作符\r\n\r\n### 基础数据类型\r\n\r\n|     操作符     |        描述        |     结果     |\r\n| :------------: | :----------------: | :----------: |\r\n|    `@char`     |        字符        |     `A`      |\r\n|   `@boolean`   |       布尔值       |    `true`    |\r\n|   `@string`    |       字符串       | `wg0DGEE1s[` |\r\n| `@string(3,5)` | 指定范围长度字符串 |    `wg0D`    |\r\n|     `@num`     |        数字        |     520      |\r\n|  `@num(5,10)`  |    指定范围数字    |      5       |\r\n|    `@float`    |       浮点型       |    13.14     |\r\n\r\n### 名称\r\n\r\n|  操作符   |     描述     |      结果 |\r\n| :-------: | :----------: | --------: |\r\n|  `@name`  |    英文名    | `Ruihuag` |\r\n| `@cname`  |    中文名    |  `关瑞毕` |\r\n| `@first`  | 英文名称的名 |  `Sandra` |\r\n|  `@last`  | 英文名称的姓 |    `Jose` |\r\n| `@cfirst` |    中文姓    |      `关` |\r\n| `@clast`  |    中文名    |    `瑞毕` |\r\n\r\n### 文本\r\n\r\n|     操作符      |  描述  |                                                                                                                                                                                                                                                                                                                                                                                                                               结果                                                                                                                                                                                                                                                                                                                                                                                                                               |\r\n| :-------------: | :----: | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |\r\n|    `@title`     |  标题  |                                                                                                                                                                                                                                                                                                                                                                                                                            `土好保观`                                                                                                                                                                                                                                                                                                                                                                                                                            |\r\n| `@title(3,30)`  |  标题  |                                                                                                                                                                                                                                                                                                                                                                                                    `传年圆美石所技道只式器知老引明说外海专性油复队运构科文重`                                                                                                                                                                                                                                                                                                                                                                                                    |\r\n|    `@cword`     | 中文字 |                                                                                                                                                                                                                                                                                                                                                                                                                               `厂`                                                                                                                                                                                                                                                                                                                                                                                                                               |\r\n| `@sentence(2)`  |  句子  |                                                                                                                                                                                                                                                                                                                                                                                  `Enim ad aute eiusmod enim occaecat. Aliqua anim dolore eiusmod officia commodo amet nostrud.`                                                                                                                                                                                                                                                                                                                                                                                  |\r\n|   `@sent(2)`    |  句子  |                                                                                                                                                                                                                                                                                                                                                                                  `Enim ad aute eiusmod enim occaecat. Aliqua anim dolore eiusmod officia commodo amet nostrud.`                                                                                                                                                                                                                                                                                                                                                                                  |\r\n| `@paragraph(2)` | 自然段 | <div style=\"text-align:left;\">&nbsp;&nbsp;&nbsp;&nbsp;Laboris ex ad duis reprehenderit deserunt enim. In laboris Lorem est pariatur eu officia incididunt ipsum sint adipisicing nisi ullamco ut do. Quis ullamco tempor exercitation duis elit duis duis adipisicing. Occaecat pariatur reprehenderit consectetur amet non cillum velit eu cupidatat ad. Reprehenderit excepteur sint commodo officia adipisicing id labore veniam amet irure. Cillum nisi voluptate exercitation minim in ut aliquip laborum duis. Lorem veniam amet magna labore reprehenderit culpa adipisicing eiusmod ipsum exercitation.</br>&nbsp;&nbsp;&nbsp;&nbsp;Eiusmod minim aliqua dolor nostrud et. Mollit ad ex laborum ea deserunt incididunt pariatur. Ipsum exercitation Lorem consectetur dolor incididunt excepteur labore proident cupidatat dolore consequat dolor.</div> |\r\n|   `@para(2)`    | 自然段 | <div style=\"text-align:left;\">&nbsp;&nbsp;&nbsp;&nbsp;Laboris ex ad duis reprehenderit deserunt enim. In laboris Lorem est pariatur eu officia incididunt ipsum sint adipisicing nisi ullamco ut do. Quis ullamco tempor exercitation duis elit duis duis adipisicing. Occaecat pariatur reprehenderit consectetur amet non cillum velit eu cupidatat ad. Reprehenderit excepteur sint commodo officia adipisicing id labore veniam amet irure. Cillum nisi voluptate exercitation minim in ut aliquip laborum duis. Lorem veniam amet magna labore reprehenderit culpa adipisicing eiusmod ipsum exercitation.</br>&nbsp;&nbsp;&nbsp;&nbsp;Eiusmod minim aliqua dolor nostrud et. Mollit ad ex laborum ea deserunt incididunt pariatur. Ipsum exercitation Lorem consectetur dolor incididunt excepteur labore proident cupidatat dolore consequat dolor.</div> |\r\n\r\n### 居住地址\r\n\r\n| 操作                   | 描述           | 结果                                            |\r\n| :--------------------- | :------------- | :---------------------------------------------- |\r\n| `region`               | 地区           | 西北                                            |\r\n| `province`             | 省             | 广东省                                          |\r\n| `city`                 | 城市           | 韶关市                                          |\r\n| `district`             | 区域           | 洮北区                                          |\r\n| `address`              | 地址           | 安徽省宣城市宣州区1d8街道6e路69号99栋36单元78号 |\r\n| `address(RR PP CC DD)` | 地址(指定格式) | 东北 山西省 吕梁市 汾阳市                       |\r\n\r\n 补充:\r\n\r\n- `RR`: 地区  \r\n- `PP`: 省\r\n- `CC`: 城市\r\n- `DD`: 地区\r\n\r\n### 其他地址\r\n\r\n| 操作      | 描述    | 结果                                    |\r\n| :-------- | :------ | :-------------------------------------- |\r\n| `@ip`     | ip      | 242.86.47.174                           |\r\n| `@ip6()`  | ipv6    | e60b:3d50:be5c:ea37:3005:8a35:846e:1aeb |\r\n| `@domain` | web地址 | opubztw.xxq                             |\r\n| `@email`  | 邮箱    | cxydhhsfxqzki@nipik.ftnyl               |\r\n\r\n### 颜色\r\n\r\n- 待开发\r\n- color, hex, rgb, rgba, hsl\r\n\r\n### 图片\r\n\r\n#### `@image([text[,size[,background[,foreground[,format]]]]])`\r\n\r\n- 图片链接\r\n- `text = ''`: 文字\r\n- `size = '200x200'` :图片大小\r\n- `background = '000'`: 背景图片\r\n- `foreground = 'fff'`: 文字颜色\r\n- `format: '' | 'png' | 'gif' | 'jpg' = ''` : 图片格式\r\n\r\n#### 时间\r\n\r\n| 操作符                       | 描述           | 结果                  |\r\n| :--------------------------- | :------------- | :-------------------- |\r\n| `@now`                       | 现在           | `2022-06-08 16:58:16` |\r\n| `@now(YYYY-MM-DD HH:mm:ss)`  | 现在           | `2022-06-08 16:58:16` |\r\n| `@date`                      | 随机日期       | `2021-09-27`          |\r\n| `@date(YYYY-MM-DD)`          | 随机日期       | `2022-03-28`          |\r\n| `@date(YYYY-MM-DD HH:mm:ss)` | 随机日期       | `2020-03-24 22:58:16` |\r\n| `@time`                      | 随机时间       | `22:58:16`            |\r\n| `@time(HH:mm:ss)`            | 随机时间       | `04:58:16`            |\r\n| `@time(YYYY-MM-DD HH:mm:ss)` | 随机时间       | `2020-06-27 22:58:16` |\r\n| `@timeStamp`                 | 随机时间戳     | `1604703768135`       |\r\n| `@nowTimeStamp`              | 当前时间时间戳 | `1604703768135`       |\r\n\r\n### 特殊\r\n\r\n|                    操作符                     | 描述  |                  结果                  |\r\n| :-------------------------------------------: | :---: | :------------------------------------: |\r\n|                     `@id`                     |  id   |           `3191230364936506`           |\r\n|                    `@uuid`                    | uuid  | `326be748-57bd-c2d0-84f4-99bb488a4292` |\r\n| `@uuid(xxxxxxxx-xxxx-xxxx-yxxx-xxxxxxxxxxxx)` | uuid  | `326be748-57bd-c2d0-84f4-99bb488a4292` |\r\n","children":[]}]},{"name":"README.md","path":"../guanruihua.github.io/OpenSource","data":"# [ruihuag](https://guanruihua.github.io/#/)\r\n","children":[]},{"name":"unit-testing-js","path":"../guanruihua.github.io/OpenSource","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/OpenSource/unit-testing-js","data":"# 描述\r\n\r\n- 添加测试用例来执行是否符合预期\r\n- 快速生成想要的测试用例\r\n\r\n## `test`\r\n\r\n- 参数\r\n  - `param` `name` `{string}` 用例名\r\n  - `param` `func` `{Func}` 待测试的方法\r\n  - `params` `...cases` `{...CaseUnit}` 测试用例\r\n\r\n```ts\r\ntest(name, func, {...} ...)\r\n// 可以打印出相应的结果\r\n```\r\n","children":[]},{"name":"README.md","path":"../guanruihua.github.io/OpenSource/unit-testing-js","data":"# unit-testing-js\r\n\r\n![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg) [![npm version](https://img.shields.io/npm/v/unit-testing-js.svg?style=flat)](https://www.npmjs.com/package/unit-testing-js)\r\n\r\n- 添加测试用例来执行是否符合预期\r\n- 快速生成想要的测试用例\r\n\r\n## `test`\r\n\r\n- 参数\r\n  - `param` `name` `{string}` 用例名\r\n  - `param` `func` `{Func}` 待测试的方法\r\n  - `params` `...cases` `{...CaseUnit}` 测试用例\r\n\r\n```ts\r\ntest(name, func, {...},{...}, ...)\r\n// 可以打印出相应的结果\r\n```\r\n\r\n### example\r\n\r\n> 每一个测试用例单独配置\r\n\r\n```js\r\n// 待测试方法\r\nfunction tobe(a,b){\r\n  return a === b\r\n}\r\n\r\n// 配置测试用例\r\ntest('<name>', tobe, \r\n  { params, [1, 1], tobe: true},\r\n  { params, [1, 1], tobe: true},\r\n  // ...\r\n)\r\n```\r\n\r\n## UnitTest\r\n\r\n> 通过配置每一个参数位, 从而生成测试用例来进行测试\r\n\r\n```js\r\nimport { UnitTest } from 'unit-testing-js'\r\n\r\n// 待测试方法\r\nfunction tobe(a, b, c) {\r\n return a === b && b === c\r\n}\r\n\r\n// 生成测试方法\r\n\r\nUnitTest(tobe, 'tobe')\r\n// 设置方法默认返回值\r\n .setDefaultValue(false)\r\n//  设置函数第一个参数\r\n .addParam(1)\r\n// 设置 函数 第二, 三个参数, 由于是两个数组, 就是设置两个参数, 且每一个参数都是有数组级的可能性\r\n .addParamMap(\r\n  [1, 2],\r\n  [1, 3, 1]\r\n )\r\n//  通过参数设置结果\r\n .setMapValues(\r\n  [1, 1, 1], true\r\n )\r\n//  添加测试用例, 测试顺序下标 需要注意\r\n//  .addCases(...)\r\n //  通过测试用例顺序设置结果\r\n // .tobe(...)\r\n // 通过测试用例下标设置结果\r\n // .setIndexValues({...})\r\n//  生成测试用例\r\n .buildCases()\r\n//  选择打印配置项目, 一般选择打印测试用例\r\n//  .log('cases')\r\n// 开始测试\r\n .run()\r\n```\r\n\r\n## loadModule\r\n\r\n> - 当测试模块太多了, 就会打印太多\r\n> - 加载测试模块\r\n> - 只会打印有错误的模块\r\n\r\n```js\r\nimport { loadModule, TestSetting } from '../src'\r\n\r\n// 设置测试结果汇总\r\nTestSetting.set('isSummary', true)\r\n\r\nloadModule(async () => {\r\n import('./demo/01')\r\n import('./demo/02')\r\n import('./demo/03')\r\n//  ...\r\n})\r\n```\r\n","children":[]}]},{"name":"_sidebar.md","path":"../guanruihua.github.io/OpenSource","data":"* [fakingjs](fakingjs/index.md)\n  * [home](fakingjs/index.md)\n* [unit-testing-js](unit-testing-js/index.md)\n  * [home](unit-testing-js/index.md)\n","children":[]}]},{"name":"package.json","path":"../guanruihua.github.io","data":"{\n  \"name\": \"guanruihua.github.io\",\n  \"version\": \"0.2.0\",\n  \"description\": \"博客\",\n  \"author\": \"ruihuag\",\n  \"license\": \"MIT\",\n  \"scripts\": {\n    \"push\": \"bash ./push.bat\",\n    \"build\": \"node config/build/build-sidebar-lv2.js\",\n    \"build:lv1\": \"node config/build/build-sidebar-lv1.js\",\n    \"build:os\": \"node config/build/build-sidebar-OpenSource.js\",\n    \"build:package\": \"nodemon config/build/getPackageDocs.js\",\n    \"update\":\"node config/update-module.js\",\n    \"dev\": \"nodemon config/build/build-sidebar-lv2.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/guanruihua/guanruihua.github.io.git\"\n  },\n  \"files\": [\n    \"package.json\",\n    \"README.md\",\n    \"LICENSE\",\n    \"index.js\"\n  ],\n  \"bugs\": {\n    \"url\": \"https://github.com/guanruihua/guanruihua.github.io/issues\"\n  },\n  \"homepage\": \"https://github.com/guanruihua/guanruihua.github.io\",\n  \"keywords\": [\n    \"note\"\n  ]\n}","children":[]},{"name":"Pending.md","path":"../guanruihua.github.io","data":"# Pending\n\n## 待完成\n\n [linear-gradient](https://developer.mozilla.org/zh-CN/docs/Web/CSS/gradient/linear-gradient)\n\nechart\n\n## 地图相关\n\n<https://blog.csdn.net/qq_42683219/article/details/106390151>\n\n## 组件\n\n> - 滑动登录\n\n## 二维码\n\n<https://cloud.tencent.com/developer/article/1010480>\n\n<https://juejin.cn/post/6900150859171430413>\n\n## 待开始\n\nseo优化 学习, 结合多语言优化\n判断元素出现在可视区域中的方案\ngetBoundingClientRect\nIntersectionObserve\n> [Cookie](https://juejin.cn/post/6844904102544031757)\n> [大文件断点切片](juejin.cn/post/7080527713399750692)\n><https://juejin.cn/post/7085654890671767559#heading-9>\n>navigator.geolocation.getCurrentPosition\n>\n\n ```js\ndata:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQAQMAAADdiHD7AAAABlBMVEUAAABTU1OoaSf/AAAAAXRSTlMAQObYZgAAAFJJREFUeF7t0cENgDAMQ9FwYgxG6WjpaIzCCAxQxVggFuDiCvlLOeRdHR9yzjncHVoq3npu+wQUrUuJHylSTmBaespJyJQoObUeyxDQb3bEm5Au81c0pSCD8HYAAAAASUVORK5CYII\n ```\n","children":[]},{"name":"React","path":"../guanruihua.github.io","data":"","children":[{"name":"antd","path":"../guanruihua.github.io/React","data":"","children":[{"name":"v2","path":"../guanruihua.github.io/React/antd","data":"","children":[{"name":"select.md","path":"../guanruihua.github.io/React/antd/v2","data":"# Select\r\n\r\n## Select自带的搜索功能很多时候需要结合后端的接口，输入一个关键字的时候会自动更新选择器的选项\r\n\r\n> 选择器选项必须和每次更新的数据挂钩, 这个值可以通过state,也可以通过props拿到\r\n>\r\n> 再结合循环的方法例如map遍历渲染options\r\n\r\n```jsx\r\n  <Select\r\n  mode=\"multiple\"         //多选模式\r\n  placeholder=\"请选择\"\r\n  filterOption={false}    //关闭自动筛选\r\n  onSearch={this.handleSearch}\r\n>\r\n  {\r\n    list.map((item, index) => (\r\n      <Option key={index} value={item}>{item}</Option>\r\n    ))\r\n  }\r\n</Select>\r\n```\r\n\r\n> 若`filterOption`默认为`true`, 当你输入内容时候,会先在已有选项里面寻找符合项, 无论是否找到，都会重新渲染Options,这样你接口请求的数据的渲染被覆盖了, 自然看不到结果了。所以需要把它关掉\r\n","children":[]}]}]},{"name":"basis","path":"../guanruihua.github.io/React","data":"","children":[{"name":"createElement.md","path":"../guanruihua.github.io/React/basis","data":"# React.createElement\n\n> 参数:\n>\n> 1. 必填,  传入类HTML标签的名称\n> 2. 选填,  属性, 例如:className\n> 3. 选填,  子节点, eg: 要显示的文本内容\n\n```jsx\nimport React, { Component } from 'react'\n// 3 \nfunction Content3 () {\n  return React.createElement('div', null, 'content3')\n}\n\nclass Index extends Component {\n  render() {\n    let child1 = React.createElement('li', null, 'one' )\n    let child2 = React.createElement('li', null, 'two')\n    let content = React.createElement('ul', { className : 'teststyle'}, child1, child2) //1 \n    let content2 = React.createElement('ul', { className : 'teststyle'}, [child1, child2]) //2\n    return (\n      <div>\n        Index\n        {content}\n        { content2 }\n        <Content3 />\n      </div>\n    )\n  }\n}\n\nexport default Index;\n```\n\n![Snipaste_2020-12-10_10-35-35](https://gitee.com/grh-gitee/picgo/raw/master/Snipaste_2020-12-10_10-35-35.png)\n","children":[]},{"name":"react-basis.md","path":"../guanruihua.github.io/React/basis","data":"# React-basis\n\n> 1. Facebook开源的一个js库\n> 2. 一个用来动态构建用户界面的js库\n> 3. 特点:\n>    1. Declarative( 声明式编码) - 采用声明式范式, 可以轻松描述应用\n>    2. Component-based(组件化编码) - 是代码更加容易得到复用\n>    3. 支持客户端与服务器渲染\n>    4. 高效 - 通过对DOM的模拟, 最大限度减少与DOM的交互\n>    5. 单向数据流 - 减少重复代码\n> 4. 高效的原因:\n>    1. 虚拟( virtual ) DOM, 不直接操作DOM\n>    2. 高效的DOM Diff算法, 最小化重绘(减少页面更新的区域)\n\n## JSX\n\n> 1. 全称: JavaScript XML\n> 2. react定义的一种类似XML的JS拓展语法: XML + JS\n> 3. 作用 : 用来创建react虚拟DOM( 元素 )对象\n> 4. 编码相关:\n>    1. js中直接可以套标签, 标签套js需要放在{}中\n>    2. 解析显示js数组时, 会中东遍历显示\n> 5. 注意:\n>    1. 标签必须要有结束\n>    2. class属性必须改成className\n>    3. 标签的style属性值必须为: `{{color:'red', width: 12}}`\n\n## 组件化与组件化\n\n1. 组件化\n   1. 当应用的js都是以模块来编写的, 这个应用就是一个模块化的应用\n   2. 就是把重负的部分提炼出来, 一个一个能使用\n   3. 例如Dialog, 各种自定义UI组件, 能在项目或不同项目重复使用等\n   4. 目的:复用, 解耦\n   5. 依赖:组件之间低依赖, 比较独立\n   6. 架构定位:纵向分层 (位于架构底层, 被其他成所依赖)\n2. 模块化\n   1. 但应用是以多组件的方式实现功能, 改应用就是一该组件化的应用\n   2. \"业务框架\" 或者\"业务模块\", 也可理解为\"框架\",\n   3. 就是把功能进行划分, 将同一个类型的代码整合在一起, 所有模块的工鞥相对复杂, 都属于一个业务\n   4. 使用: 按照项目功能需求划分成不同类型的业务框架(注册, 登录, 外卖,等)\n   5. 目的: 隔离/封装(高内聚)\n   6. 依赖: 模块之间有依赖的关系, 可通过路由器进行模块之间的耦合关系\n   7. 架构定位: 横向分块(位于架构业务框架层 )\n3. 两者区别\n\n## 环境搭建\n\n- 引用ReactCDN资源\n\n```html\n<script crossorigin src=\"https://unpkg.com/react@16/umd/react.development.js\"></script> \n<script crossorigin src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"></script>\n```\n\n- 通过npm(包管理),安装React\n\n`$npm install --save react react`\n\n`$npm install --save react react-dom`\n\n- 利用脚手架create-react-app\n\n`$ npm install -g create-react-app`\n\n`$ create-react-app my-app`\n\n`$ cd my-app/ $ npm start`\n\n- 启动IP和端口号\n\n`在node_modules/react-script/scripts/start.js中设置(60和61行) const DEFAULT_PORT = parseInt(process.env.PORT, 10) || 3000; const HOST = process.env.HOST || '0.0.0.0';`\n\n## 项目根目录中的文件介绍\n\n- **README.md** :这个文件主要作用就是对项目的说明，已经默认写好了一些东西，你可以简单看看。如果是工作中，你可以把文件中的内容删除，自己来写这个文件，编写这个文件可以使用Markdown的语法来编写。\n- **package.json**: 这个文件是webpack配置和项目包管理文件，项目中依赖的第三方包（包的版本）和一些常用命令配置都在这个里边进行配置，当然脚手架已经为我们配置了一些了，目前位置，我们不需要改动。如果你对webpack了解，对这个一定也很熟悉。\n- **package-lock.json**：这个文件用一句话来解释，就是锁定安装时的版本号，并且需要上传到git，以保证其他人再npm install 时大家的依赖能保证一致。\n- **gitignore**: 这个是git的选择性上传的配置文件，比如一会要介绍的node_modules文件夹，就需要配置不上传。\n- **node_modules**:这个文件夹就是我们项目的依赖包，到目前位置，脚手架已经都给我们下载好了，你不需要单独安装什么。\n- **public**：公共文件，里边有公用模板和图标等一些东西。\n- **src**： 主要代码编写文件，这个文件夹里的文件对我们来说最重要，都需要我们掌握。\n\n### public文件夹介绍\n\n这个文件都是一些项目使用的公共文件，也就是说都是共用的\n\n- **favicon.ico**: 这个是网站或者说项目的图标，一般在浏览器标签页的左上角显示。\n- **index.html**: 首页的模板文件\n- **mainifest.json**：移动端配置文件\n\n### src文件夹介绍\n\n这个目录里边放的是我们开放的源代码，我们平时操作做最多的目录。\n\n- **index.js**: 这个就是项目的入口文件\n- **index.css**：这个是index.js里的CSS文件。\n- **app.js**: 这个文件相当于一个方法模块，也是一个简单的模块化编程。\n- **serviceWorker.js**:这个是用于写移动端开发的，PWA必须用到这个文件，有了这个文件，就相当于有了离线浏览的功能。\n\n## 组件的介绍\n\n### 入口文件的编写\n\n写一个项目的时候一般要从入口文件进行编写的，在src目录下，index.js文件就是入口文件\n\n```\nimport React from 'react' // 引入react\nimport ReactDOM from 'react-dom' // 引入react-dom\nimport App from './App' // 引入App模块\nReactDOM.render(<App />,document.getElementById('root')) // 将App模块渲染到了 root ID上面\n\n```\n\n### App组件的编写\n\n```jsx\nimport React from 'react'\n// JSX语法\nclass App extends React.Component{\n    render(){\n        return (\n            <div>\n                我是APP组件\n            </div>\n        )\n    }\n}\nexport default App;\n```\n\n### React中JSX语法简介\n\n```\nJSX就是Javascript和XML结合的一种格式。React发明了JSX，\n可以方便的利用HTML语法来创建虚拟DOM，当遇到<，JSX就当作HTML解析，\n遇到{就当JavaScript解析.\n```\n\n### 组件和普通JSX语法区别\n\n这个说起来也只有简单的一句话，就是你自定义的组件必须首写字母要进行大写，而JSX是小写字母开头的。\n\n### JSX中使用三元运算符\n\n在JSX中也是可以使用js语法的\n\n```jsx\nimport React from 'react'\n// JSX语法\nclass App extends React.Component{\n    render(){\n        return (\n            <div>\n                <div>{false ? '不显示我' : '显示的我'}</div>\n                我是APP组件\n            </div>\n        )\n    }\n}\nexport default App;\n```\n\n### 组件外层包裹原则\n\n1. react和vue组件模板最外层必须有且只有一个元素\n2. 去除这个最外层包裹的标签, 使用\n   - `<React.Fragment> </React.Fragment>`\n   - `<></>`\n\n## 响应式设计和数据绑定\n\n> react不建议你直接操作DOM元素, 而是通过数据进行驱动, 改变界面中的效果\n\n## react基础\n\n### 创建组件方法\n\n#### 函数式定义的**无状态组件**\n\n> 主要负责根据props来展示, 不涉及到要state状态的操作\n>\n> 1. 组件不会被实例化, 整体渲染性能得到提升\n>    - 精简到成一个render方法的函数来实现, 无实例化过程, 就不需要分配多余的内存, 从而性能得到一定的提升\n> 2. 组件不能访问this对象\n> 3. 组件无法访问生命周期的方法\n> 4. 无状态组件只能访问输入端饿props, 同样的props会得到同样的渲染结果, 不会有副作用\n\n```jsx\nfunction HelloComponent(props, /* context */) {\n  return <div>Hello {props.name}</div>\n}\nReactDOM.render(<HelloComponent name=\"Sebastian\" />, mountNode) \n```\n\n#### es5原生方式`React.createClass`定义的组件\n\n> - 会自绑定函数导致不必要的性能开销, 增加代码过时的肯能性\n> - 基本弃用\n\n```jsx\nvar InputControlES5 = React.createClass({\n    propTypes: {//定义传入props中的属性各种类型\n        initialValue: React.PropTypes.string\n    },\n    defaultProps: { //组件默认的props对象\n        initialValue: ''\n    },\n    // 设置 initial state\n    getInitialState: function() {//组件相关的状态对象\n        return {\n            text: this.props.initialValue || 'placeholder'\n        };\n    },\n    handleChange: function(event) {\n        this.setState({ //this represents react component instance\n            text: event.target.value\n        });\n    },\n    render: function() {\n        return (\n            <div>\n                Type something:\n                <input onChange={this.handleChange} value={this.state.text} />\n            </div>\n        );\n    }\n});\nInputControlES6.propTypes = {\n    initialValue: React.PropTypes.string\n};\nInputControlES6.defaultProps = {\n    initialValue: ''\n};\n```\n\n#### es6形式的`extends React.Component`定义的组件\n\n> - 目前最推荐的有状态的组件, 最终会取代`React.createClass`形式, 相对于`React.createClass`可以更好实现代码复用\n> - 定义方法的命名规则: `handle+方法名`,   可以省略`function`关键字\n>   - 还要在`constructor` 下进行注册 : `this.handleXXX = this.handleXXX.bind(this);`\n>   - 或者直接 在组件中 `click= { ()=> this.hanhdleXXX }`\n\n```jsx\nclass InputControlES6 extends React.Component {\n    constructor(props) {\n        super(props);\n        // 设置 initial state\n        this.state = {\n            text: props.initialValue || 'placeholder'\n        };\n        // ES6 类中函数必须手动绑定\n        this.handleChange = this.handleChange.bind(this);\n    }\n    handleChange(event) {\n        this.setState({\n            text: event.target.value\n        });\n    }\n    render() {\n        return (\n            <div>\n                Type something:\n                <input onChange={this.handleChange}\n               value={this.state.text} />\n            </div>\n        );\n    }\n}\nInputControlES6.propTypes = {\n    initialValue: React.PropTypes.string\n};\nInputControlES6.defaultProps = {\n    initialValue: ''\n};\n```\n\n#### React.ceateClass 和 React.Component区别\n\n##### 函数this自绑定\n\n> React.ceateClass : 每一成员函数的this都有React自动绑定, 任何时候使用, 直接使用this.method即可, 函数中的this会被成功设置\n>\n> React.Component : 创建组件, 其成员函数不会自动绑定this, 需要开发者手动绑定, 否则this不嗯呢获取当前组件实例对象, 需要绑定\n\n```jsx\nconst Contacts = React.createClass({  \n  handleClick() {\n    console.log(this); // React Component instance 可以成功获取到this对象\n  },\n  render() {\n    return (\n      <div onClick={this.handleClick}></div>\n    );\n  }\n});\n```\n\n```jsx\nclass Contacts extends React.Component {  \n  constructor(props) {\n    super(props);\n  }\n  handleClick() {\n    console.log(this); // null 获取不到\n  }\n  render() {\n    return (\n      <div onClick={this.handleClick}></div>\n    );\n  }\n \n// 手动绑定\n  constructor(props) {\n    super(props);\n    this.handleClick = this.handleClick.bind(this); //构造函数中绑定\n  }\n  <div onClick={this.handleClick.bind(this)}></div> //使用bind来绑定\n  <div onClick={()=>this.handleClick()}></div> //使用arrow function来绑定\n```\n\n##### 组件属性类型propTypes及其默认props属性defaultProps配置不同\n\n> - `React.createClass`在创建组件时，有关组件props的属性类型及组件默认的属性会作为**组件实例的属性**来配置，其中defaultProps是使用`getDefaultProps`的方法来获取默认组件属性的\n>\n> - `React.Component`在创建组件时配置这两个对应信息时，他们是作为**组件类的属性**，不是组件实例的属性，也就是所谓的**类的静态属性**来配置的\n\n```jsx\nconst TodoItem = React.createClass({\n    propTypes: { // as an object\n        name: React.PropTypes.string\n    },\n    getDefaultProps(){   // return a object\n        return {\n            name: ''    \n        }\n    }\n    render(){\n        return <div></div>\n    }\n})\n\nclass TodoItem extends React.Component {\n    static propTypes = {//类的静态属性\n        name: React.PropTypes.string\n    };\n\n    static defaultProps = {//类的静态属性\n        name: ''\n    };\n\n    ...\n}\n```\n\n##### 组件初始化状态state的配置不同\n\n> `React.createClass`创建的组件，其状态state是通过`getInitialState`方法来配置组件相关的状态；\n> `React.Component`创建的组件，其状态state是在`constructor`中像初始化组件属性一样声明的。\n\n```jsx\nconst TodoItem = React.createClass({\n    // return an object\n    getInitialState(){ \n        return {\n            isEditing: false\n        }\n    }\n    render(){\n        return <div></div>\n    }\n})\nclass TodoItem extends React.Component{\n    constructor(props){\n        super(props);\n        this.state = { // define this.state in constructor\n            isEditing: false\n        } \n    }\n    render(){\n        return <div></div>\n    }\n}\n```\n\n##### Mixins的支持不同\n\n> [`Mixins`](https://facebook.github.io/react/docs/reusable-components-zh-CN.html#mixins)(混入)是面向对象编程OOP的一种实现，其作用是为了复用共有的代码，将共有的代码通过抽取为一个对象，然后通过`Mixins`进该对象来达到代码复用。具体可以参考[React Mixin的前世今生](http://www.w3ctech.com/topic/1599)。\n>\n> `React.createClass`在创建组件时可以使用`mixins`属性，以数组的形式来混合类的集合。\n>\n> `React.Component` : 不支持Mixins, React开发者社区提供一个全新的方式来取代`Mixins`,那就是**Higher-Order Components**，具体细节可以参考[这篇文章](https://leozdgao.me/chushi-hoc/)\n\n```jsx\nvar SomeMixin = {  \n  doSomething() {\n\n  }\n};\nconst Contacts = React.createClass({  \n  mixins: [SomeMixin],\n  handleClick() {\n    this.doSomething(); // use mixin\n  },\n  render() {\n    return (\n      <div onClick={this.handleClick}></div>\n    );\n  }\n});\n```\n\n### jsx代码注释\n\n```jsx\n {/* 正确注释的写法 */}\n { // 正确注释的写法 }\n```\n\n### 组件的三大属性\n\n#### state\n\n```jsx\n1. 组件被称为\"状态机\", 页面的显示是根据组件的state属性的数据来显示\n2. 初始化指定:\n    constructor() {\n      super()\n      this.state = {\n        stateName1 : stateValue1,\n        stateName2 : stateValue2\n      }\n    }\n3. 读取显示: \n    this.state.stateName1\n4. 更新状态-->更新界面 : \n    this.setState({stateName1 : newValue})\n```\n\n#### props\n\n> 所有组件标签的属性的集合对象\n> 给标签指定属性, 保存外部数据(可能是一个function)\n> 在组件内部读取属性: this.props.propertyName\n> 作用: 从目标组件外部向组件内部传递数据\n\n```jsx\n对props中的属性值进行类型限制和必要性限制\nPerson.propTypes = {\n  name: React.PropTypes.string.isRequired,\n  age: React.PropTypes.number.isRequired\n}\n扩展属性: 将对象的所有属性通过props传递\n  <Person {...person}/>\n```\n\n##### 父传子\n\n```jsx\n// 父组件\n<childItem myName={this.state.myName}/>\n\n// 子组件\n<div>{this.props.myName}</div>}\n```\n\n##### 子传父\n\n> 1. 先在父组件定义可以改变数据的方法pranentChange(且要注册), 和数据myName\n> 2. 子组件通过`this.props.myName`拿到数据, 且要在constructor注册或绑定一下父组件的方法\n\n```jsx\n// 子组件\nclass childItem extends React.Component{\n    constructor (props) {\n        super(props)\n        this.changeParent = this.changeParent.bind(this)\n    }\n    return (\n        <React.Fragment>\n            <div onClick={this.changeParent}>{this.props.myName}</div>\n        </React.Fragment>\n    )\n    changeParent () {\n        // 调用父组件传递过来的方法\n        this.props.pranentChange()\n    }\n}\nexport default childItem;\n```\n\n```jsx\n// 父组件\n\n// 引入子组件\nimport childItem from './childItem'\n// JSX语法\nclass parentItem extends React.Component{\n    constractor (props) {\n        super(props)\n        this.state = {\n            myName: '只会番茄炒蛋'\n        }\n        this.pranentChange = this.pranentChange.bind(this)\n    }\n    return (\n        <React.Fragment>\n            {/* 使用了子组件 */}\n            <childItem \n                pranentChange={this.pranentChange}\n                myName={this.state.myName}\n            />\n        </React.Fragment>\n    )\n    pranentChange () {\n        this.setState({\n            myName: '番茄炒蛋少放糖'\n        })\n    }\n}\nexport default parentItem;\n```\n\n#### PropTypes检验传递值\n\n> 在传输数据中,最好要加入数据校验\n>\n> 加入校验, 不按照校验以后, 会有warning警告\n\n```jsx\n// 子组件\nimport React from 'react'\n// 引入效验\nimport PropTypes from 'prop-types'\n// JSX语法\nclass childItem extends React.Component{\n    constructor (props) {\n        super(props)\n        this.changeParent = this.changeParent.bind(this)\n    }\n    return (\n        <React.Fragment>\n            <div onClick={this.changeParent}>{this.props.myName}</div>\n        </React.Fragment>\n    )\n    changeParent () {\n        // 调用父组件传递过来的方法\n        this.props.pranentChange()\n    }\n}\nchildItem.prorTypes = {\n    myName: PropTypes.string, // 效验传入的内容必须是一个字符串\n    pranentChange: PropTypes.func // 效验传入的内容必须是一个function\n}\nexport default childItem;\n```\n\n##### 必传值的校验---isRequired\n\n> 不传递带有isRequired的数据, 就会报错\n\n```jsx\nchildItem.prorTypes = {\n    // 效验传入的内容必须是一个字符串并且必须传入值\n    newName:PropTypes.string.isRequired, \n}\n```\n\n##### 使用默认值---defaultProps\n\n> 设置默认值\n\n```jsx\nchildItem.defaultProps = {\n // 子组件使用父组件传递的值, 但是他自己又个默认的值\n  newName: '啦啦啦',\n}\n```\n\n#### ref\n\n> 组件内包含ref属性的标签元素的集合对象\n> 给操作目标标签指定ref属性, 打一个标识\n> 在组件内部获得标签对象: this.refs.refName(只是得到了标签元素对象)\n> 作用: 找到组件内部的真实dom元素对象, 进而操作它\n\n```jsx\nimport React from 'react'\n// JSX语法\nclass parentItem extends React.Component{\n    constractor (props) {\n        super(props)\n        this.state = {\n            myName: '只会番茄炒蛋'\n        }\n        this.inputChange = this.inputChange.bind(this)\n    }\n    return (\n        <React.Fragment>\n            <input \n                value={this.state.myName}\n                onChange={this.inputChange}\n            ></input>\n        </React.Fragment>\n    )\n    inputChange (e) {\n        console.log(e.target.value)// 获取input输入的值\n    }\n}\nexport default parentItem;\n```\n\n```jsx\nimport React from 'react'\n// JSX语法\nclass parentItem extends React.Component{\n    constractor (props) {\n        super(props)\n        this.state = {\n            myName: '只会番茄炒蛋'\n        }\n        this.inputChange = this.inputChange.bind(this)\n    }\n    return (\n        <React.Fragment>\n            <input \n                value={this.state.myName}\n                onChange={this.inputChange}\n                ref={input => {this.input = input}}\n            ></input>\n        </React.Fragment>\n    )\n    inputChange (e) {\n        console.log(this.input.value)\n    }\n}\nexport default parentItem;\n```\n\n### 基础\n\n1. react的入口\n\n``` js\n// 无状态函数\nfunction MyCompontent(props) {\n return <h1>组件</h1>\n}\n// 复杂组件\nclass MyComponent extends React.Componet  {\n  render() {\n    return <h1>组件</h1>\n  }\n}\n// 渲染组件标签\nReactDOM.render(\n    element,\n  document.getElementById('root')\n);  \n/*\n等到虚拟DOM对象, 将虚拟DOM 并解析为真实DOM, 插入到指定的页面元素中\n*/\n```\n\nelement就是通过 ReactDOM.render() 的方法来将其渲染到页面上\n\n2. 自己创建element\n\n```js\nconst element = (\n <h1>\n  Hello, {formatName(user)}!\n </h1>\n);\n```\n\n3. JSX代表Object\n   下面两段代码完全一样\n\n```js\nconst element = (\n  <h1 className=\"greeting\">\n    Hello, world!\n  </h1>\n);\n```\n\n```js\nconst element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n);\n```\n\n4. 计时器的使用\n\n```js\nsetInterval(tick, 1000);///每一秒调用一次tick方法\n```\n\n5. 组件&Props\n\n   - 函数定义\n\n      ```js\n      function welcome(props){ return (<h1>{props.name}</h1>)}\n      ```\n\n   - 类定义组件\n\n      ```js\n      class welcome extends React.Component{\n          render(){\n              return (<h1>{this.props.name}</h1>);\n          }\n      }\n      ```\n\n   - 组件渲染\n\n   ```js\n       const element = <div />;\n       const element = <welcome name = \"guanruihua\" />\n   ```\n\n   - 组合组件\n\n   ```js\n       function Welcome(props) {\n         return <h1>Hello, {props.name}</h1>;\n       }\n       \n       function App() {\n         return (\n           <div>\n             <Welcome name=\"Sara\" />\n             <Welcome name=\"Cahal\" />\n             <Welcome name=\"Edite\" />\n           </div>\n         );\n       }\n       \n       ReactDOM.render(\n         <App />,\n         document.getElementById('root')\n       );\n   ```\n\n   - 提取组件\n\n   ```jsx\n   //方法一\n   function Comment(props) {\n     return (\n       <div className=\"Comment\">\n         <div className=\"UserInfo\">\n           <img className=\"Avatar\"\n             src={props.author.avatarUrl}\n             alt={props.author.name}\n           />\n           <div className=\"UserInfo-name\">\n             {props.author.name}\n           </div>\n         </div>\n         <div className=\"Comment-text\">\n           {props.text}\n         </div>\n         <div className=\"Comment-date\">\n           {formatDate(props.date)}\n         </div>\n       </div>\n     );\n   }\n   //提取组件\n   function Avatar(props) {\n     return (\n       <img className=\"Avatar\"\n         src={props.user.avatarUrl}\n         alt={props.user.name}\n       />\n     );\n   }\n   \n   \n   //方法二\n               \n       \n       function Comment(props) {\n         return (\n           <div className=\"Comment\">\n             <div className=\"UserInfo\">\n               <Avatar user={props.author} />\n               <div className=\"UserInfo-name\">\n                 {props.author.name}\n               </div>\n             </div>\n             <div className=\"Comment-text\">\n               {props.text}\n             </div>\n             <div className=\"Comment-date\">\n               {formatDate(props.date)}\n             </div>\n           </div>\n         );\n       }\n       \n       \n       \n       function UserInfo(props) {\n         return (\n           <div className=\"UserInfo\">\n             <Avatar user={props.user} />\n             <div className=\"UserInfo-name\">\n               {props.user.name}\n             </div>\n           </div>\n           );\n       }\n   ```\n\n### css\n\n```js\n//基于class--(className)\n<style>.title{...}</title>\n\n<div className=\"title\"></div>\n\n//基与inner css行间样式(json)\n<div style = {{color:'red'}}></div>\n\n//原型链和全局变量\nvar color={color:'red'}  \n<div style={color}>react全局行间样式</div>\n\nApp.prototype.col={\n    color:pink  \n}\n\n<div style={this.col}>原型样式</div>\n\n```\n\n## 动画react-transition-group\n\n### 安装\n\n```visual basic\nnpm install react-transition-group -S\n```\n\n> 三大核心库\n>\n> - Transition\n> - CSSTransition\n> - TransitionGroup\n\n### 使用CSSTransition\n\n```jsx\nimport { CSSTranstion } from 'react-transition-group';\n\nrender() {\n return (\n    <div>\n      <CSSTransition \n        in={this.state.isShow}   //用于判断是否出现的状态\n        timeout={2000}           //动画持续时间\n        classNames=\"boss-text\"   //className值，防止重复\n        >\n        <div>BOSS级人物-孙悟空</div>\n      </CSSTransition>\n      <div>\n        <button onClick={this.toToggole}>召唤Boss</button>\n      </div>\n    </div>\n  );\n}\n```\n\n- xxx-enter: 进入（入场）前的CSS样式；\n- xxx-enter-active:进入动画直到完成时之前的CSS样式;\n- xxx-enter-done:进入完成时的CSS样式;\n- xxx-exit:退出（出场）前的CSS样式;\n- xxx-exit-active:退出动画知道完成时之前的的CSS样式。\n- xxx-exit-done:退出完成时的CSS样式。\n\n```css\n.input {border:3px solid #ae7000}\n\n.boss-text-enter{\n    opacity: 0;\n}\n.boss-text-enter-active{\n    opacity: 1;\n    transition: opacity 2000ms;\n\n}\n.boss-text-enter-done{\n    opacity: 1;\n}\n.boss-text-exit{\n    opacity: 1;\n}\n.boss-text-exit-active{\n    opacity: 0;\n    transition: opacity 2000ms;\n\n}\n.boss-text-exit-done{\n    opacity: 0;\n}\n```\n\n#### unmountOnExit 属性\n\n> 加上这个, 元素退场, 会自动吧DOM 也删除\n\n```jsx\n <CSSTransition \n   in={this.state.isShow}   //用于判断是否出现的状态\n   timeout={2000}           //动画持续时间\n   classNames=\"boss-text\"   //className值，防止重复\n   unmountOnExit\n   >\n  <div>BOSS级人物-孙悟空</div>\n</CSSTransition>\n```\n\n### 使用TransitionGroup\n\n```jsx\nimport { CSSTransition , TransitionGroup } from 'react-transition-group'\n\n\n// 原code\n<ul ref={(ul)=>{this.ul=ul}}>\n    <TransitionGroup>\n        <li>1</li>\n        <li>2</li>\n        <li>3</li>\n    </TransitionGroup>\n</ul> \n  \n// add TransitionGroup\n  \n<ul ref={(ul)=>{this.ul=ul}}>\n    <TransitionGroup>\n        <CSSTransition\n            timeout={1000}\n            classNames='boss-text'\n            unmountOnExit\n            appear={true}\n            key={index+item}\n        >\n            <li>1</li>\n        </CSSTransition>\n        <CSSTransition\n            timeout={1000}\n            classNames='boss-text'\n            unmountOnExit\n            appear={true}\n            key={index+item}\n        >\n            <li>2</li>\n        </CSSTransition>\n    </TransitionGroup>\n</ul> \n```\n\n## 列表& keys\n\n### 使用map()函数可以让数组中每一项翻倍\n\n```\nconst numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map((number) => number * 2);\n//即[2,4,6,8,10]\n```\n\n1. #### 渲染多个组件\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\nconst listItems = numbers.map((number) =>\n  <li>{number}</li>\n);\n\nReactDOM.render(\n  <ul>{listItems}</ul>,\n  document.getElementById('root')\n);\n//生成了一个1到5的数字列表\n```\n\n2. #### 基础列表组件\n\n```js\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    <li = {number.toString()}>//给每一个列表分配一个key\n        {number}\n    </li>\n  );\n  return (\n    <ul>{listItems}</ul>\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  <NumberList numbers={numbers} />,\n  document.getElementById('root')\n);\n//输出一个无序列表\n```\n\n3. #### Keys(可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化)\n\n```js\n<li key={number.toString()}>\n    {number}\n</li>\n\n//给每个元素都带有一个独一无二的key\nconst todoItems = todos.map((todo) =>\n<li key={todo.id}>\n    {todo.text}\n</li>\n\n//当元素没有确定的id时，你可以使用他的序列号索引index作为key  \nconst todoItems = todos.map((todo, index) =>\n  // Only do this if items have no stable IDs\n  <li key={index}>\n    {todo.text}\n  </li>\n);\n```\n\n4. #### 用Keys提取组件(元素的key只有在它和它的兄弟节点对比时才有意义)\n\n```js\nfunction ListItem(props) {\n  // 对啦！这里不需要指定key:\n  return <li>{props.value}</li>;\n}\n\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    // 又对啦！key应该在数组的上下文中被指定\n    <ListItem key={number.toString()}\n              value={number} />\n  );\n  return (\n    <ul>\n      {listItems}\n    </ul>\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  <NumberList numbers={numbers} />,\n  document.getElementById('root')\n);\n```\n\n5. #### 元素的Key再他的兄弟元素之间应该唯一(不需要是全局唯一的)\n\n```js\nfunction Blog(props) {\n  const sidebar = (\n    <ul>\n      {props.posts.map((post) =>\n        <li key={post.id}>\n          {post.title}\n        </li>\n      )}\n    </ul>\n  );\n  const content = props.posts.map((post) =>\n    <div key={post.id}>\n      <h3>{post.title}</h3>\n      <p>{post.content}</p>\n    </div>\n  );\n  return (\n    <div>\n      {sidebar}\n      <hr />\n      {content}\n    </div>\n  );\n}\n\nconst posts = [\n  {id: 1, title: 'Hello World', content: 'Welcome to learning React!'},\n  {id: 2, title: 'Installation', content: 'You can install React from npm.'}\n];\nReactDOM.render(\n  <Blog posts={posts} />,\n  document.getElementById('root')\n);\n```\n\n6. #### 在jsx中嵌入map()\n\n```jsx\n//声明了一个单独的listItems变量并将其包含在JSX中\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    <ListItem key={number.toString()}\n              value={number} />\n  );\n  return (\n    <ul>\n      {listItems}\n    </ul>\n  );\n}\n\n\n//JSX允许在大括号中嵌入任何表达式，所以我们可以在map()中这样使用：\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  return (\n    <ul>\n      {numbers.map((number) =>\n        <ListItem key={number.toString()}\n                  value={number} />\n      )}\n    </ul>\n  );\n}\n\n\n```\n\n## 表单\n\n> 获取到表单输入的数据 : event.tatget.value\n\n### 受控组件\n\n```jsx\nclass NameForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {value: ''};\n\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event) {\n    this.setState({value: event.target.value});\n  }\n\n  handleSubmit(event) {\n    alert('A name was submitted: ' + this.state.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          Name:\n          <input type=\"text\" value={this.state.value}  \n          onChange={this.handleChange} />\n        </label>\n        <input type=\"submit\" value=\"Submit\" />\n      </form>\n    );\n  }\n}\n```\n\n```\n//使用”受控组件”,每个状态的改变都有一个与之相关的处理函数。这样就可以直接修改或验证用户输入。例如，我们如果想限制输入全部是大写字母\nhandleChange(event) {\n  this.setState({value: event.target.value.toUpperCase()});\n}\n```\n\n### textarea标签\n\n#### `<textarea>`会用value属性来代替\n\n```jsx\nclass EssayForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      value: 'Please write an essay about your favorite DOM element.'\n    };\n\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event) {\n    this.setState({value: event.target.value});\n  }\n\n  handleSubmit(event) {\n    alert('An essay was submitted: ' + this.state.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          Name:\n          <textarea value={this.state.value} onChange={this.handleChange} />\n        </label>\n        <input type=\"submit\" value=\"Submit\" />\n      </form>\n    );\n  }\n}\n```\n\n### select标签\n\n```js\nclass FlavorForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {value: 'coconut'};\n\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event) {\n    this.setState({value: event.target.value});\n  }\n\n  handleSubmit(event) {\n    alert('Your favorite flavor is: ' + this.state.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          Pick your favorite La Croix flavor:\n          <select value={this.state.value} onChange={this.handleChange}>\n            <option value=\"grapefruit\">Grapefruit</option>\n            <option value=\"lime\">Lime</option>\n            <option value=\"coconut\">Coconut</option>\n            <option value=\"mango\">Mango</option>\n          </select>\n        </label>\n        <input type=\"submit\" value=\"Submit\" />\n      </form>\n    );\n  }\n}\n```\n\n### file input 标签\n\n```jsx\n<input type=\"file\">   \n//value是只读\n//是一个非受控组件\n```\n\n##### 多个输入的解决方法\n\n```jsx\n//当你有处理多个受控的input元素时，  //你可以通过给每个元素添加一个name属性，来让处理函数根据 event.target.name的值来选择做什么。\nclass Reservation extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      isGoing: true,\n      numberOfGuests: 2\n    };\n\n    this.handleInputChange = this.handleInputChange.bind(this);\n  }\n\n  handleInputChange(event) {\n    const target = event.target;\n    const value = target.type === 'checkbox' ? target.checked : target.value;\n    const name = target.name;\n\n    this.setState({\n      [name]: value\n    });\n  }\n\n  render() {\n    return (\n      <form>\n        <label>\n          Is going:\n          <input\n            name=\"isGoing\"\n            type=\"checkbox\"\n            checked={this.state.isGoing}\n            onChange={this.handleInputChange} />\n        </label>\n        <br />\n        <label>\n          Number of guests:\n          <input\n            name=\"numberOfGuests\"\n            type=\"number\"\n            value={this.state.numberOfGuests}\n            onChange={this.handleInputChange} />\n        </label>\n      </form>\n    );\n  }\n}\n```\n\n## react-webpack前言\n\n### 安装webpack\n\n1. 在所要安装目录输入npm -v和node -v查看配置是否有问题  \n2. 输入npm init -y创建package.json\n3. 输入npm install webpack --save-dev\n4. 安装webpack-cli\n5. npm install --global webpack\n6. npm install --global webpack-cli  \n7. 最后用webpack -v查看版本\n\n### 安装插件\n\n1. html-webpack-plugin\n2. 安装指令:npm i --save-dev html-webpack-plugin\n\n### 配置文件\n\n```\n\"dev\" : \"webpack --mode development\",//b不会压缩js代码\n\"build\": \"webpack --mode production\",//压缩js代码\n```\n\n//ISC  \n\n```\n\"build\": \"webpack --mode production --config scripts/webpack.config.js\",  \n```\n\n## State&生命周期\n\n>props:只读\n>\n>state:可读写\n\n### 组件的生命周期\n\n- 挂载期:一个组件实例初次被创建的过程\n- 更新期:组件在创建后再次渲染的过程\n- 卸载期:组件在使用完后被销毁的过程\n- 组件的挂载\n  - constructor:构造函数,初始化状态\n  - getInitialState:设置状态机\n  - getDefaultProps:获取默认的props\n  - componentWillMount:首次渲染前执行\n  - render:渲染组件\n  - componentDidMount:render渲染后执行的操作\n- 组件的更新\n  - componentWillRexeiveProps:当父组件更新子组件的state\n  - shouldComponentUpdate:决定组件state或props的改变是否需要重新渲染\n  - componentWillUpdate:重新渲染props或state前\n  - componentDidUpdate:重新渲染props或state后\n- 错误处理\n  - static getDerivedStateFromError() : 在后代组件抛出错误后被调用\n  - componentDidCatch() : 会在\"提交\" 阶段被调用\n\n<img src=\"https://user-gold-cdn.xitu.io/2019/9/5/16d004e82c3c92bb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" style=\"zoom: 33%;\" />\n\n```jsx\nfunction tick() {\n  const element = (\n    <div>\n      <h1>Hello, world!</h1>\n      <h2>It is {new Date().toLocaleTimeString()}.</h2>\n    </div>\n  );\n  ReactDOM.render(\n    element,\n    document.getElementById('root')\n  );\n}\n\nsetInterval(tick, 1000);\n```\n\n### 使Clock组件真正可重用和封装  \n\n```jsx\nfunction Clock(props) {\n  return (\n    <div>\n      <h1>Hello, world!</h1>\n      <h2>It is {props.date.toLocaleTimeString()}.</h2>\n    </div>\n  );\n}\n\nfunction tick() {\n  ReactDOM.render(\n    <Clock date={new Date()} />,\n    document.getElementById('root')\n  );\n}\n\nsetInterval(tick, 1000);\n```\n\n### 将函数转换为类\n\n```basis\n1. 创建一个名称扩展为 React.Component 的ES6 类\n2. 创建一个叫做render()的空方法\n3. 将函数体移动到 render() 方法中\n4. 在 render() 方法中，使用 this.props 替换 props\n5. 删除剩余的空函数声明  \n```\n\n```\nclass Clock extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.props.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n```\n\n#### 使用类就允许我们使用其它特性，例如局部状态、生命周期钩子\n\n### 为类添加局部变量\n\n```jsx\n//2. 添加一个类构造函数来初始化状态 this.state  \nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n//1. 在 render() 方法中使用 this.state.date 替代 this.props.date \n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n//3. 从 <Clock /> 元素移除 date 属性：\nReactDOM.render(\n  <Clock />,\n  document.getElementById('root')\n);\n\n```\n\n### 将生命周期方法添加到类中\n\n###### 挂载:每当Clock组件第一次加载到DOM中的时候，我们都想生成定时器\n\n###### 卸载:每当Clock生成的这个DOM被移除的时候，我们也会想要清除定时器  \n\n```\n//生命周期钩子\n\n\ncomponentDidMount() {\n    this.timerID = setInterval(\n        () => this.tick(),\n        1000\n    );\n}\n//卸载计时器\ncomponentWillUnmount() {\n    clearInterval(this.timerID);\n}\n```\n\n#### state\n\n1. 只可以使用setState()来更新state\n2. 状态更新可能是异步的(多个setState()可以调用合并成一个来提高性能)\n3. 状态更新合并,调用setState()可以将你提供的对象合并到当前状态 x\n\n## 事件处理\n\n```jsx\n//事件命名方式为驼峰命名法\n<button onClick={activateLasers}>\n  Activate Lasers\n</button>\n\n```\n\n### preventDefault事件的使用\n\n###### 在 React 中另一个不同是你不能使用返回 false 的方式阻止默认行为\n\n```\nfunction ActionLink() {\n  function handleClick(e) {\n    e.preventDefault();//防止发生默认事件\n    console.log('The link was clicked.');\n  }\n\n  return (\n    <a href=\"#\" onClick={handleClick}>\n      Click me\n    </a>\n  );\n}\n```\n\n###### 向事件处理程序传递参数\n\n```\n<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>\n<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>\n```\n\n1. 上述两种方式是等价的，分别通过 arrow functions 和  Function.prototype.bind 来为事件处理函数传递参数。  \n2. 通过箭头函数的方式,事件对象必须显式的传递\n3. 通过bind方式,事件对象以及更加多的参数会被隐式地进行传递\n\n```jsx\nclass Popper extends React.Component{\n    constructor(){\n        super();\n        this.state = {name:'Hello world!'};\n    }\n    \n    preventPop(name, e){    //事件对象e要放在最后\n        e.preventDefault();\n        alert(name);\n    }\n    \n    render(){\n        return (\n            <div>\n                <p>hello</p>\n                {/* Pass params via bind() method. */}\n                <a href=\"https://reactjs.org\"  \n                onClick={this.preventPop.bind(this,this.state.name)}>Click</a>\n            </div>\n        );\n    }\n}\n```\n\n## 条件渲染\n\n### 通过if或条件运算符来创建表示当前状态的元素\n\n1. 元素变量:用变量的方式来存储元素,有条件地渲染组件的一部分\n2. 与运算符(&&)\n\n```\n{unreadMessages.length > 0 &&<h2>You have {unreadMessages.length} unread messages.</h2>  \n//如果条件是 true，&& 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。\n```\n\n3. 三目运算符 condition ? true : false\n4. 防止组件渲染(让 render 方法返回 null 而不是它的渲染结果即可实现组件隐藏,即使被其他组件渲染)  \n   ```if(true) return null;```\n\n## Redux数据管理\n\n四个重要的概念\n\n- Dispatcher:处理动作的一个分发器,四Flux引用程序中的数据流的中心枢纽,主要是将收到的行为分发给Store\n\n  - Store:对数据进行管理\n\n- View:React组件,主要负责View层\n\n- Action:提供给Dispatcher,传递数据给Store\n\n<img src=\"https://images.gitee.com/uploads/images/2020/0520/090214_f65ca3e8_6545143.png\" style=\"zoom:50%;\" />\n\n## Babel\n\n### Babel安装\n\n`npm install babel-bli -g`\n\n//eg：es6.js\n\n```js\nlet numbers  = [1,2,3] \nlet doubleNumbers = numbers.map((number)  => number *2); \nconsole.log(doubleNumbers);\n```\n\n编译`babel es6.js -o compiled.js`(要先配置文件.babelrc)\n\n```\n.babelrc {    \n \"presets\":[],    \n \"plugins\":[] \n}\n```\n\n安装预设`npm install --save-dev babel-preset-es2015`\n\n3. 然后把preset添加到配置文件中\n\n```xml\n.babelrc {    \n \"presets\":['es2015'],    \n \"plugins\":[] \n}\n```\n\n- 再次运行，打开compiled.js文件\n- 安装object-rest-spread插件\n-\n  1. npm install babel-plugin-transform-object-rest-spraed --save-dev\n  2. 添加到配置文件\n\n//.babelrc {    \"presets\":['es2015'],    \"plugins\":['transform-object-rest-spraed'] }\n\n对象展开符的代码\n\nlet mike = {name:'mike',age:40}; mike = {..mike, sex, 'male' };\n\n## 状态提升\n\n> - 主要概念 :   将多个组件需要的共享状态提升到它们最近的父组件上, 在父组件上改变这个状态后, 然后通过props分发给只组件\n>\n> - 实现过程 : 一般是通过将父组件的方法传给子组件, 然后通过子组件来触发, 修改父组件的state, 然后再通过props分发给子组件\n\n### 温度计算器\n\n```jsx\nimport React from 'react'\n// 展示温度有没有超过一百度\nfunction BoilingVerdict(props) {\n  return (props.celsius >= 100 ? <p>The water would boil.</p>:<p>The water would not boil</p>)\n}\n\nconst scaleNames = {\n  c : 'Celsius',\n  f : 'Fahrenheit', \n}\n// 定义子组件\n// 1. 主要负责展示温度\n// 2. 通过修改input的数据来触发父组件的方法来修改父组件的state, 然后再通过props传输给子组件, 然后达到修改温度的效果\nclass TemperatureInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      temperature : ''\n    } \n    this.handleChanage = this.handleChanage.bind(this);\n  }\n  handleChanage (e) {\n    // this.setState({temperature: e.target.value })\n    this.props.onTemperatureChange(e.target.value )\n  }\n  render() {\n    // const temperature = this.state.temperature\n    const temperature = this.props.temperature\n    const scale = this.props.scale\n    return (\n      <fieldset>\n        <legend>Enter temperature in {scaleNames[scale]} </legend>\n        <input value={temperature} onChange={this.handleChanage} />\n      </fieldset>\n    )\n  }\n}\n// 父组件\n// 1. 用于展示两个子组件\n// 2. 定义修改state的方法, 通过props来传输给子组件来调用\n// 3. 通过调用温度转换的方法, 给两个子组件传输的不同的变量值\nclass Calculator extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      temperature: '',\n      scale: 'c',\n    }\n    this.handleCelsiusChange = this.handleCelsiusChange.bind(this)\n    this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this)\n  }\n  handleCelsiusChange(temperature) {\n    this.setState({scale: 'c' , temperature})\n  }\n  handleFahrenheitChange(temperature) {\n    this.setState({ scale: 'f', temperature })\n  }\n  render() {\n    const {temperature, scale } = this.state;\n    const celsius = scale === 'f' ? tryConvert(temperature, toCelsius ) : temperature; \n    const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit ) : temperature ;\n    return (\n      <div className = {styles.layout}>\n        <TemperatureInput \n          temperature = {celsius}\n          onTemperatureChange = {this.handleCelsiusChange}\n          scale = \"c\" /><br/>\n        <TemperatureInput\n          temperature = {fahrenheit} \n          onTemperatureChange = {this.handleFahrenheitChange}\n          scale = \"f\" /><br/>\n        <BoilingVerdict celsius = {celsius} />\n      </div>\n    )\n  }\n}\n// 华氏度 => 摄氏度\nfunction toCelsius(fahrenheit) {\n  return (fahrenheit - 32 ) * 5 / 9;\n}\n// 摄氏度 => 华氏度\nfunction toFahrenheit(celsius) {\n  return (celsius * 9 / 5 ) + 32;\n}\n\n// temperature : 需要转换的温度\n// convert : 转换温度实收需要用到的函数\n// 判断是否为空\n// 数据处理\nfunction tryConvert(temperature, convert) {\n  const input = parseFloat(temperature)\n  if(Number.isNaN(input)) {\n    return '';\n  }\n  const output = convert(input)\n  // Math.round : 四舍五入\n  const rounded = Math.round( output * 1000 ) / 1000;\n  return rounded.toString();\n}\n\nexport default Calculator;\n```\n\n## 组合&继承\n\n###### 包含关系\n\n1. 通过组件方式传出子元素\n\n```jsx\nfunction FancyBorder(props) {\n  return (\n    <div className={'FancyBorder FancyBorder-' + props.color}>\n      {props.children}\n    </div>\n  );\n}\n```\n\n2. 通过其他组件来嵌套JSX来传递组件\n\n```jsx\nfunction WelcomeDialog() {\n  return (\n    <FancyBorder color=\"blue\">\n      <h1 className=\"Dialog-title\">\n        Welcome\n      </h1>\n      <p className=\"Dialog-message\">\n        Thank you for visiting our spacecraft!\n      </p>\n    </FancyBorder>\n  );\n}\n```\n\n3. 特殊实例\n\n```jsx\nfunction Dialog(props) {\n  return (\n    <FancyBorder color=\"blue\">\n      <h1 className=\"Dialog-title\">\n        {props.title}\n      </h1>\n      <p className=\"Dialog-message\">\n        {props.message}\n      </p>\n    </FancyBorder>\n  );\n}\n\nfunction WelcomeDialog() {\n  return (\n    <Dialog\n      title=\"Welcome\"\n      message=\"Thank you for visiting our spacecraft!\" />\n  );\n}\n```\n\n## React.lazy\n\n> 注意:\n>\n> `React.lazy` 和 Suspense 技术**还不支持服务端渲染。**如果你想要在使用服务端渲染的应用中使用，我们推荐 [Loadable Components](https://github.com/gregberge/loadable-components) 这个库。它有一个很棒的[服务端渲染打包指南](https://loadable-components.com/docs/server-side-rendering/)。\n\n```\nimport OtherComponent from './OtherComponent';\n```\n\n```\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\n```\n\n## Emit\n\n> 用于兄弟组件中通信\n>\n> 事件总线机制\n\nbus.js\n\n```jsx\nimport { EventEmitter } from 'events'\nexport default new EventEmitter();\n```\n\nindex.js\n\n```jsx\nimport Bus from './bus';\nimport React, { Component } from 'react'\n\nclass Index extends Component {\n  state = {\n    bus: '000',\n  }\n  render() {\n    Bus.addListener('handleChangeData', (msg) => {\n      this.setState({\n        bus: msg,\n      })\n    })\n    return (\n      <div>\n        Index{this.state.bus}\n        <button onClick = {()=>Bus.emit('handleChangeData', 'btnData')}>bus</button>//可以放到其他组件进行触发\n      </div>\n    )\n  }\n}\n\nexport default Index;\n```\n\n## EventEmitter\n\n> 自定义订阅类\n\n### 定义\n\n```js\n// 发布订阅类\nclass EventEmitter {\n  _event = {}\n\n  // on 函数用于绑定\n  // 注册事件监听; type 事件类型，handle 处理函数\n  on(eventName, handle) {\n      let listeners = this._event[eventName];\n      if (!listeners || !listeners.length) {\n          this._event[eventName] = [handle];\n          return;\n      }\n      listeners.push(handle);\n  }\n  // off 用于移除\n  // 移除事件监听；type 事件类型，handle 处理函数\n  off(eventName, handle) {\n      let listeners = this._event[eventName];\n      this._event[eventName] = listeners.filter(l => l !== handle);\n      // this._event[eventName]=[]\n  }\n  // emit 用于分发消息; // 触发一个事件\n  emit(eventName, ...args) {\n      const listeners = this._event[eventName];\n      if (listeners && listeners.length) {\n          for (const l of listeners) {\n              l(...args);\n          }\n      }\n  }\n}\nconst event = new EventEmitter;\nexport default event;\n```\n\n### 使用\n\n```jsx\nevent.on('drink', (person) => {\n      console.log(person + '喝水')\n})\nevent.on('eat', (person) => {\n  console.log(person + '吃东西')\n})\nevent.emit('drink', '我') // 我喝水\nevent.emit('drink', '我') // 我喝水\nevent.emit('eat', '其它人') // 其它人吃东西\nevent.emit('eat', '其它人') // 其它人吃东西\nevent.emit('buy', '其它人') //其它人买东西\nevent.emit('buy', '其它人') //这里不会再次触发buy事件，因为once只能触发一次\nevent.off('eat') //移除eat事件\nevent.emit('eat', '其它人') //这里不会触发eat事件，因为已经移除了\n```\n\n## react-demo-井字棋案例\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\n\nfunction Square(props) {\n  return (\n    <button className=\"square\" onClick={props.onClick}>\n      {props.value}\n    </button>\n  );\n}\n\nclass Board extends React.Component {\n  renderSquare(i) {\n    return (\n      <Square\n        value={this.props.squares[i]}\n        onClick={() => this.props.onClick(i)}\n      />\n    );\n  }\n\n  render() {\n    return (\n      <div>\n        <div className=\"board-row\">\n          {this.renderSquare(0)}\n          {this.renderSquare(1)}\n          {this.renderSquare(2)}\n        </div>\n        <div className=\"board-row\">\n          {this.renderSquare(3)}\n          {this.renderSquare(4)}\n          {this.renderSquare(5)}\n        </div>\n        <div className=\"board-row\">\n          {this.renderSquare(6)}\n          {this.renderSquare(7)}\n          {this.renderSquare(8)}\n        </div>\n      </div>\n    );\n  }\n}\n\nclass Game extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      history: [\n        {\n          squares: Array(9).fill(null)\n        }\n      ],\n      stepNumber: 0,\n      xIsNext: true\n    };\n  }\n\n  handleClick(i) {\n    const history = this.state.history.slice(0, this.state.stepNumber + 1);\n    const current = history[history.length - 1];\n    const squares = current.squares.slice();\n    if (calculateWinner(squares) || squares[i]) {\n      return;\n    }\n    squares[i] = this.state.xIsNext ? \"X\" : \"O\";\n    this.setState({\n      history: history.concat([\n        {\n          squares: squares\n        }\n      ]),\n      stepNumber: history.length,\n      xIsNext: !this.state.xIsNext\n    });\n  }\n\n  jumpTo(step) {\n    this.setState({\n      stepNumber: step,\n      xIsNext: (step % 2) === 0\n    });\n  }\n\n  render() {\n    const history = this.state.history;\n    const current = history[this.state.stepNumber];\n    const winner = calculateWinner(current.squares);\n\n    const moves = history.map((step, move) => {\n      const desc = move ?\n        'Go to move #' + move :\n        'Go to game start';\n      return (\n        <li key={move}>\n          <button onClick={() => this.jumpTo(move)}>{desc}</button>\n        </li>\n      );\n    });\n\n    let status;\n    if (winner) {\n      status = \"Winner: \" + winner;\n    } else {\n      status = \"Next player: \" + (this.state.xIsNext ? \"X\" : \"O\");\n    }\n\n    return (\n      <div className=\"game\">\n        <div className=\"game-board\">\n          <Board\n            squares={current.squares}\n            onClick={i => this.handleClick(i)}\n          />\n        </div>\n        <div className=\"game-info\">\n          <div>{status}</div>\n          <ol>{moves}</ol>\n        </div>\n      </div>\n    );\n  }\n}\n\n// ========================================\n\nReactDOM.render(<Game />, document.getElementById(\"root\"));\n\nfunction calculateWinner(squares) {\n  const lines = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [2, 4, 6]\n  ];\n  for (let i = 0; i < lines.length; i++) {\n    const [a, b, c] = lines[i];\n    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\n      return squares[a];\n    }\n  }\n  return null;\n}\n\n```\n","children":[]}]},{"name":"begin.md","path":"../guanruihua.github.io/React","data":"# 创建项目\n\n## [create-app-react](https://create-react-app.bootcss.com/)\n\n> 1. 先全局安装`npm install -g create-react-app`\n> 2. `npx create-react-app [项目名]`\n> 3. 进入到项目`cd [项目名]`\n> 4. `npm start`\n\n## [umi](https://umijs.org/zh-CN/docs/getting-started)\n\n> 1. 全局安装`dva+umi`\n>\n>    1. dva: `npm install -g umi`\n>    2. umi: `npm install -g dva-cli`\n>\n> 2. 通过脚手架创建项目\n>\n>    1. `mkdir [项目名] && cd [项目名]`\n>\n>    2. `npm create umi`\n>\n>    3. ```shell\n>       ? Select the boilerplate type (Use arrow keys)\n>         ant-design-pro  - Create project with an layout-only ant-design-pro boilerplate, use together with umi block.\n>       ❯ app             - Create project with a simple boilerplate, support typescript.\n>         block           - Create a umi block.\n>         library         - Create a library with umi.\n>         plugin          - Create a umi plugin.\n>       ```\n>\n>    4. ```shell\n>       ? Do you want to use typescript? (y / N)\n>       ```\n>\n>    5. ```shell\n>       ? What functionality do you want to enable? (Press <space> to select, <a> to toggle all, <i> to invert selection)\n>       ❯◯ antd\n>        ◯ dva\n>        ◯ code splitting\n>        ◯ dll\n>       ```\n","children":[]},{"name":"hook","path":"../guanruihua.github.io/React","data":"","children":[{"name":"context","path":"../guanruihua.github.io/React/hook","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/React/hook/context","data":"# Context\n\n- Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法\n- 可以跨层级传输数据\n\n```tsx\nconst MyContext: React.Context<string> = React.createContext('defaultValue');\nconst MyContext2: React.Context<string> = React.createContext('defaultValue2');\n\nfunction PageChild2() {\n\n return <MyContext.Consumer>\n  {(c1: string) => (\n   <MyContext2.Consumer>\n    {(c2: string) => (\n     <div>{`c1:${c1}; c2:${c2}`}</div>\n    )}\n   </MyContext2.Consumer>\n  )}\n </MyContext.Consumer>\n}\n\n\nclass PageChild extends React.Component {\n render() {\n  return <div>child {JSON.stringify(this.context)}</div>\n }\n}\n\nPageChild.contextType = MyContext;\n\n\nfunction Page(props: any) {\n return (\n  <MyContext.Provider value={'newValue'}>\n   <MyContext2.Provider value={'newValue2'}>\n    <PageChild />\n    <PageChild2 />\n   </MyContext2.Provider>\n  </MyContext.Provider>\n );\n}\n```\n","children":[]}]},{"name":"hook.md","path":"../guanruihua.github.io/React/hook","data":"# React-hook\n\n> - 在不编写class的情况下使用state以及其他特性\n>\n> - 只能在非状态组件使用\n\n## 基础Hook\n\n### useState\n\n> `const [ stateName,  setStateName ] = useState(initialState)`\n>\n> 用于解决非状态组件修改非状态组件的变量不会重新渲染的问题\n\n惰性初始化\n\n```js\nconst [ state, setState ] = useState( ()=> {\n  const initialState = someExpensiveComputaion( props );\n  return initialState;\n})\n```\n\n### useEffect\n\n> 相当`componentDidMout`, `componentDidUpdate`\n\n传递一个空数组`([])` 作为第二参数, 这里可以添加需要监听的参数, 只有参数发生改变才会触发;\n\n```js\nuseEffect( ()=> {\n  ...\n}, []);\n```\n\n```js\n// 不建议这样子使用, doSomething 使用 someProp\nfunction Example1({ someProp }){\n  function doSomething() {\n    console.log( someProp )\n  }\n\n  useEffect( () =>{\n    doSomething();\n  }, []);\n\n  return <p>{{ someProp }}</p>\n}\n\n// 建议使用effect 仅仅用到了someProp\nfunction Example2({ someProp }){\n  useEffect( ()=> {\n    function doSomething(){\n      console.log(someProp)\n    }\n    doSomething();\n  }, [someProp]);\n\n  return <p>{{ someProp }}</p>\n}\n```\n\n### useContext && createContext\n\n> - 用来处理多层级传递数据的方法\n> - 在传统方式, 跨组件传递数据需要通过props往下传\n\n```ts\n// 返回值{ Provider, Consumer }\nconst ThemeContext = React.createContext();\n```\n\n```tsx\nimport React  from 'react';\nimport './App.css';\n//创建context\nconst numberContext = React.createContext();\n//它返回一个具有两个值的对象\n//{Provider ， Consumer}\nfunction App(){\n  //使用Provider为所有子孙提供value值\n  return (\n    <numberContext.Provider value={12}>\n        <div>\n        <ShowAn />\n        </div>\n    </numberContext.Provider>\n  )\n}\n\nfunction ShowAn(){\n  //使用Consumer从上下文获取value\n  return(\n    <numberContext.Consumer>\n      {value=><div>the answer is {value}</div>}\n    </numberContext.Consumer>\n  )\n}\nexport default App;\n```\n\n```js\nimport React, { useContext, useState } from 'react';\n\nconst ThemeContext = React.createContext(0);\n\nconst Son = () => {\n const value = useContext(ThemeContext)\n console.log(value);\n return(\n  <p>son</p>\n )\n}\n\nconst ContextComponent = () => {\n return (\n  <Son/>\n )\n} \n\nconst ContextPage = () => {\n const [ count, setCount] = useState(1);\n return(\n  <div>\n   <ThemeContext.Provider value={count}>\n    <ContextComponent />\n   </ThemeContext.Provider>\n   <button onClick={()=> setCount(count + 1)}>\n    Click me\n   </button>\n  </div>\n )\n}\n\n\nexport default ContextPage;\n```\n\n## 额外Hook\n\n### useReducer\n\n> - 和useState类似\n> - 比useState更加适用场景:例如state逻辑处理较复杂且包含多个子值, 或者下一个state依赖于之前的state等\n\n#### 基础用法\n\n```js\nimport { useReducer } from 'react';\n\n// state 是原来的 状态, action:dispatch传输的参数\n// return 的值就是要更新成新的state的值\nconst reducer = (state, action) => {\n switch(action.type) {\n  case 'increment':\n   return { count: state.count + 1 };\n  case 'decrement':\n   return { count: state.count - 1 };\n  default:\n   throw new Error();\n }\n}\n\nconst UseReducer = () => {\n let initialState = {\n  count: 0,\n }\n const [ state, dispatch ] = useReducer(reducer, initialState );\n\n return (\n  <div>\n   <div>useReducer Count:{state.count}</div>\n   <button onClick={ ()=> { dispatch({ type: 'decrement'}); }}>useReducer 减少</button>\n   <button onClick={ ()=>{ dispatch({ type: 'increment'}); }}>useReducer 增加</button>\n  </div>\n )\n}\n\nexport default UseReducer;\n```\n\n#### 惰性初始化\n\n```js\nconst initCount =0 \nconst init = initCount => {\n  return { count: initCount }\n}\nconst reducer = (state, action)=>{\n  switch(action.type){\n    case 'increment':\n      return {count: state.count + 1}\n    case 'decrement':\n      return {count: state.count - 1}\n    case 'reset':\n      return init(action.paylod || 0)\n    default:\n      throw new Error();\n  }\n}\nconst UseReducer = () => {\n  const [state, dispatch] = useReducer(reducer,initCount,init)\n\n  return (\n    <div className=\"App\">\n      <div>useReducer Count:{state.count}</div>\n      <button onClick={()=>{dispatch({type:'decrement'})}}>useReducer 减少</button>\n      <button onClick={()=>{dispatch({type:'increment'})}}>useReducer 增加</button>\n      <button onClick={()=>{dispatch({type:'reset',paylod:10 })}}>useReducer 重置为10</button>\n    </div>\n  );\n}\nexport default UseReducer;\n\n```\n\n### Memo\n\n> 当父组件重新渲染时, **子组件也会重新渲染**, 即使子组件的props和state都没有发生改变\n\n```js\nimport { memo, useState } from 'react';\n\n// 子组件\nconst Child = ({count}) => {\n  console.log(`${count} ChildComp...`);\n  return (<div>ChildComp...</div>);\n};\n\nconst ChildComp = memo(Child)\n// 父组件\nconst Parent = () => {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <div>hello world {count}</div>\n      <button onClick={() => { setCount(count => count + 1); }}>点击增加</button>\n      <ChildComp count = {count}/>\n    </div>\n  );\n};\n\nexport default Parent;\n```\n\n- React.memo与PureComponent的区别：\n  - 服务对象不同：PureComponent 服务与类组件，React.memo既可以服务于类组件，也可以服务与函数式组件，useMemo服务于函数式组件（后续讲到）\n  - 针对的对象不同：PureComponent针对的是props和state，React.memo只能针对props来决定是否渲染\n\n- `memo(ChildComponent, callback:(pre, next)=>void)`\n  - `memo`:返回 true 组件不渲染 ， 返回 false 组件重新渲染\n  - `shouldComponentUpdate`: 返回 true 组件渲染 ， 返回 false 组件不渲染\n\n### useMemo\n\n> 目的: 减少子组件数据没有改变也发生重新绘制\n>\n> useMemo\n>\n> - 第一个参数: 是个函数, 返回对象只想同一个引用, 不会创建新对象\n> - 第二个参数: 是个数组, 只有数组的边来跟发生改变时候, 第一个参数的函数才会返回一个新的对象\n>\n> memo:　只要父组重绘，子组件也会发生重绘\n\n```js\nimport React, { memo, useMemo, useState } from 'react';\n\n// 子组件\nconst ChildComp = ({ info }) => {\n console.log( info )\n const { name, age, count } = info;\n  console.log('ChildComp...' + `${count}---${age}---${name}`);\n  return (<div>ChildComp...</div>);\n};\n\nconst MemoChildComp = memo(ChildComp);\n\n// 父组件\nconst Parent = () => {\n  const [count, setCount] = useState(0);\n  const [name] = useState('jack');\n  const [age] = useState(11);\n  \n  // 使用 useMemo 将对象属性包一层\n  const info = useMemo(() => ({ name, age, count }), [name, age, count]);\n\n  return (\n    <div>\n      <div>hello world {count}</div>\n      <button onClick={() => { setCount(count => count + 1); }}>点击增加</button>\n      <MemoChildComp info={info}/>\n    </div>\n  );\n};\n\nexport default Parent;\n```\n\n### useCallback\n\n> - 当给子组件添加方法的时候, 当只触发了該方法也会导致子组件重绘\n>\n> - 给該方法用useCallback包含就不会导致子组件重新渲染( 和useMemo 类似 )\n\n```js\nimport React, { memo, useCallback, useMemo, useState } from 'react';\n\n// 子组件\nconst ChildComp = (props) => {\n  console.log('ChildComp...');\n  return (<div>ChildComp...</div>);\n};\n\nconst MemoChildComp = memo(ChildComp);\n\n// 父组件\nconst Parent = () => {\n  const [count, setCount] = useState(0);\n  const [name] = useState('jack');\n  const [age] = useState(11);\n  const info = useMemo(() => ({ name, age }), [name, age]);\n  const changeName = useCallback( () => {\n    console.log('输出名称...');\n  },[]);\n\n  return (\n    <div className=\"App\">\n      <div>hello world {count}</div>\n      <div onClick={() => { setCount(count => count + 1); }}>点击增加</div>\n      <MemoChildComp info={info} changeName={changeName}/>\n    </div>\n  );\n};\n\nexport default Parent;\n```\n\n### useRef\n\n> - 就像是一个变量, 类似this, 他就像一个盒子, 可以存放任何东西,  createRef每次渲染都会返回一点新的引用, 而useRef每次都会返回相同的引用\n\n```js\nimport { useRef, useEffect, useState  } from 'react'\n\nconst Page1 = () => {\n const myRef = useRef(null);\n useEffect( ()=> {\n  myRef?.current?.focus();\n })\n\n return (\n  <div>\n   <span>UseRef:</span>\n   <input ref={myRef} type=\"text\" />\n  </div>\n )\n}\n\nconst Page2 = () => {\n const myRef2 = useRef(0);\n const [count, setCount] = useState(0)\n useEffect( ()=> {\n  myRef2.current = count;\n })\n function handleClick() {\n  setTimeout(()=> {\n   console.log(count); \n   console.log(myRef2.current);\n  })\n }\n return (\n  <div>\n   <button onClick={()=> setCount(count + 1)}>点击count</button>\n   <button onClick={()=> handleClick() }>查看</button>\n  </div>\n )\n}\n```\n\n### useImperativeHandle\n\n> - 使用场景：通过 ref 获取到的是整个 dom 节点，通过 useImperativeHandle 可以控制只暴露一部分方法和属性，而不是整个 dom 节点。\n>\n> - `useImperativeHandle(ref, createHandle, [deps])`\n>\n> - ref：定义 current 对象的 ref createHandle：一个函数，返回值是一个对象，即这个 ref 的 current\n>\n> - 对象 [deps]：即依赖列表，当监听的依赖发生变化，useImperativeHandle 才会重新将子组件的实例属性输出到父组件\n>\n> - ref 的 current 属性上，如果为空数组，则不会重新输出。\n> - 直接转发 ref 是将 React.forwardRef 中函数上的 ref 参数直接应用在了返回元素的 ref 属性上，其实父、子组件引用的是同一个 ref 的 current 对象，官方不建议使用这样的 ref 透传，而使用 useImperativeHandle 后，可以让父、子组件分别有自己的 ref，通过 React.forwardRef 将父组件的 ref 透传过来，通过 useImperativeHandle 方法来自定义开放给父组件的 current\n\n```jsx\nimport React, { useCallback, useRef, useImperativeHandle } from 'react';\n\n// 实现 ref 的转发\nconst FancyButton = React.forwardRef((props, ref) => (\n <div>\n  <input ref={ref} type=\"text\" />\n  <button>{props.children}</button>\n </div>\n));\n\n// 父组件中使用子组件的 ref\nfunction App() {\n const ref = useRef();\n const handleClick = useCallback(() => ref.current.focus(), [ref]);\n\n return (\n  <div>\n   <FancyButton ref={ref}>Click Me</FancyButton>\n   <button onClick={handleClick}>获取焦点</button>\n  </div>\n )\n}\n\nconst FancyInput = React.forwardRef((props, ref) => {\n const inputRef = useRef();\n useImperativeHandle(ref, () => ({\n  focus: () => {\n   inputRef.current.focus();\n  }\n }));\n\n return <input ref={inputRef} type=\"text\" />\n});\n\nconst App2 = props => {\n const fancyInputRef = useRef();\n\n return (\n  <div>\n   <FancyInput ref={fancyInputRef} />\n   <button\n    onClick={() => fancyInputRef.current.focus()}\n   >父组件调用子组件的 focus</button>\n  </div>\n )\n}\n\n// eslint-disable-next-line import/no-anonymous-default-export\nexport default () => {\n return (\n  <div><App /><App2 /></div>\n )\n}\n```\n\n### useLayoutEffect\n\n> 其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect，这里不再举例。\n>\n> - useLayoutEffect 和平常写的 Class 组件的 componentDidMount 和 componentDidUpdate 同时执行；\n> - useEffect 会在本次更新完成后，也就是第 1 点的方法执行完成后，再开启一次任务调度，在下次任务调度中执行 useEffect；\n\n```js\n/*\n * @Author: ruihuag \n * @Date: 2021-06-01 15:59:09 \n * @Last Modified by: ruihuag\n * @Last Modified time: 2021-06-01 16:00:18\n * @desciption: \n 就是useLayoutEffect 的执行时机要早于 useEffect，useLayoutEffect的执行在类组件生命周期前，useEffect 的执行在类组件生命周期后，官方的建议是要求我们尽量使用useEffect，以避免阻塞视觉更新，如果是将代码从类组件重构为 React Hooks，并且使用 useEffect出现问题，再考虑使用 useLayoutEffect，服务端渲染时使用useLayoutEffect 会触发警告。\n */\n\nimport React, { useState, useEffect, useLayoutEffect } from 'react';\n\nfunction Com() {\n useEffect(() => {\n  console.log('useEffect 执行...');\n  return () => {\n   console.log('useEffect 销毁...');\n  }\n });\n\n useLayoutEffect(() => {\n  console.log('useLayoutEffect 执行...');\n  return () => {\n   console.log('useLayoutEffect 销毁...');\n  }\n });\n\n return (\n  <div>\n   {console.log('Com 渲染')}\n   <h2>Com1</h2>\n  </div>\n )\n}\n\nconst App = props => {\n const [count, setCount] = useState(0)\n return (\n  <div>\n   <Com />\n   {count}\n   <button onClick={() => setCount(count + 1)}>count + 1</button>\n  </div>\n )\n}\n\nexport default App;\n```\n","children":[]},{"name":"Umi-hooks.md","path":"../guanruihua.github.io/React/hook","data":"# Umi-hooks\n\n> [usePrevious (umijs.org)](https://hooks.umijs.org/zh-CN/hooks/state/use-previous)\n","children":[]}]},{"name":"package.md","path":"../guanruihua.github.io/React","data":"# package 推荐\n\n## loadable-components\n\n> 动态注册组件\n\n## react-hook-form\n\n> 结合 form 使用\n> [react-hook-form](https://react-hook-form.com/api/useform/register)\n\n## react-virtualized\n\n> <https://github.com/bvaughn/react-virtualized>\n","children":[]},{"name":"question","path":"../guanruihua.github.io/React","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/React/question","data":"# Question\n\n## TypeError: this.getOptions is not a function 的解决\n\n> 问题的出现：\n>\n> - 在进行 react 项目开发的时候，出现了这个错误，`TypeError: this.getOptions is not a function`，如下所示：\n>\n> 问题的分析及解决：\n>\n> - 问题的分析：这个实际上就是 `less-loader` 的版本过高，不兼容 `getOptions` 函数方法，所以需要对 `less-loader` 进行降级处理\n> - 问题的解决：通过 `npm uninstall less-loader` 命令卸载原版本的 `less-loader`，然后 通过 `npm install less-loader@5.0.0` 命令下载降级版本的 less-loader，这个问题就可以解决了\n","children":[]}]},{"name":"react-demo.md","path":"../guanruihua.github.io/React","data":"# react-demo\n\n### 例子1 modal 简单实现\n\n- Modal 方法组件 (使用副作用useEffect 实现禁止滚动)\n\n```js\nimport React, { useEffect, useState } from 'react';\nimport { createPortal } from \"react-dom\";\nimport \"./index.css\"\n\nconst Modal = function (props) {\n    const { children, visible, closeModal } = props;\n    const [bodyOverFlow, setBodyOverFlow] = useState(false);\n    function handleClick(e) {\n        if (e.target === e.currentTarget) {\n            closeModal();\n        }\n    }\n    const node = createPortal(\n        <div className='modalRoot' onClick={(e) => handleClick(e)}>{children}</div>,\n        document.body\n    );\n    useEffect(() => {\n        console.log(\"初始化\")\n        setBodyOverFlow(window.getComputedStyle(document.body).overflow);\n    }, [])\n    useEffect(() => {\n        if(visible){\n            document.body.style.cssText = 'width: calc(100% - 17px);overflow:hidden';\n        }else{\n            document.body.style.cssText = `overflow:${bodyOverFlow}`;\n        }\n    }, [visible,bodyOverFlow])\n    return <React.Fragment>{visible && node}</React.Fragment>\n}\nexport default React.memo(Modal);\n```\n\n- button 方法组件（hook - 使用了useState）\n\n```js\nimport React, { useState } from 'react';\nimport Modal from \"../modal\";\nimport \"./index.css\";\n\nconst ButtonComponent = function () {\n    /**\n     * 定义visible状态\n     */\n    const [modalVisible, setModalVisible] = useState(false);\n    const modalConfig = {\n        visible: modalVisible,\n        closeModal: () => {\n            setModalVisible(false)\n        }\n    }\n    const modalChildren = <div className={\"container\"}>\n        <div className={\"closeBtn\"} onClick={() => setModalVisible(false)}></div>\n    </div>\n    return <div className={'mainContainer'}><button onClick={() => setModalVisible(true)}>点击打开</button><Modal {...modalConfig}>{modalChildren}</Modal></div>\n}\n\nexport default React.memo(ButtonComponent);\n```\n\n- App.js\n\n```js\nimport React from 'react';\nimport Button from \"./component/button\";\nimport './App.css';\n\nexport default class App extends React.Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <Button></Button>\n      </div>\n    );\n  }\n}\n```\n\n1. 这个例子只使用了hook中的useState,以及useEffect 较为简单\n2. 使用了Portals 将modal的Dom节点放置在body的直接资子元素的位置\n\n### 例子2 获取滚动条的宽度\n\n- 使用场景\n\n```\n在打开modal层时 将body的overflow设置为了hidden 所以页面会往右边闪动。闪动的距离为滚动条的宽度\n处理方式: 在body的width设置为calc(100%+滚动条的宽度)即可。\n```\n\n- 思路\n\n```\n通过给body动态添加一个dom节点，计算这个dom节点的offsetWidth和clientWidth的差(即滚动条的宽度)\n然后通过dom.remove() 删除这个都节点\n```\n\n- useGetScrollBarWidth/index.js\n\n```js\nimport React, { useEffect, useState } from 'react';\n\n/**\n * 自定义hook - 获取滚动条的宽度\n * @returns {*[]}\n */\nconst useGetScrollBarWidth = function() {\n  const [scrollBarWidth, setScrollBarWidth] = useState(0);\n  useEffect(() => {\n    const bodyEl = document.body;\n    const tempEl = document.createElement('p');\n    const styles = {\n      width: '100px',\n      height: '100px',\n      overflowY: 'scroll'\n    };\n    for (let i in styles) {\n      tempEl.style[i] = styles[i];\n    }\n    bodyEl.appendChild(tempEl);\n    setScrollBarWidth(tempEl.offsetWidth - tempEl.clientWidth);\n    tempEl.remove();\n  }, []);\n\n  return [scrollBarWidth];\n};\n\nexport default useGetScrollBarWidth;\n```\n\n### 例子3 绑定监听事件\n\n```js\nimport React, { useState, useEffect, useRef } from 'react';\n\nconst useEventListener = function(eventName, handler, element = document) {\n  const savedhandler = useRef();\n  /**\n   * 当handler 发生变化时  修改 存储在savedhandler中的回调函数\n   */\n  useEffect(\n    () => {\n      savedhandler.current = handler;\n    },\n    [handler]\n  );\n  /**\n   * 当eventName和element 发生变化时 调用\n   */\n  useEffect(\n    () => {\n      // 判断当前element是否支持addEventListern\n      const isSupport = element && element.addEventListener;\n      /**\n       * 如果当前元素不支持 - 直接返回false 跳出函数\n       */\n      if (!isSupport) return false;\n\n      /**\n       * 将事件对象传入handler函数\n       * @param e\n       */\n      const eventListern = e => {\n        savedhandler.current(e);\n      };\n\n      element.addEventListener(eventName, eventListern);\n      /**\n       * UmMount时 - 清除监听器\n       */\n      return () => element.removeEventListener(eventName, eventListern);\n    },\n    [eventName, element]\n  );\n};\nexport default useEventListener;\n```\n","children":[]},{"name":"react-v18.md","path":"../guanruihua.github.io/React","data":"# react v18\r\n\r\n## Render\r\n\r\n- `legacy` 模式： `ReactDOM.render(, rootNode)` (react17)\r\n- `blocking` 模式： `ReactDOM.createBlockingRoot(rootNode).render()` (迁移到concurrent 模式的过渡模式)\r\n- `concurrent` 模式： `ReactDOM.createRoot(rootNode).render()` (reac18, 使用react17 Api 会有警告)\r\n\r\n### Spa\r\n\r\n```tsx\r\n// React 17\r\nconst root = document.getElementById('root')!;\r\nReactDOM.render(<App />, root, () => {\r\n  console.log('渲染完成');\r\n});\r\n\r\n// React 18\r\nconst AppWithCallback: React.FC = () => {\r\n  useEffect(() => {\r\n    console.log('渲染完成');\r\n  }, []);\r\n  return <App />;\r\n};\r\nconst root = document.getElementById('root')!;\r\nReactDOM.createRoot(root).render(<AppWithCallback />);\r\n```\r\n\r\n### SSR\r\n\r\n```tsx\r\n// React 17\r\nimport ReactDOM from 'react-dom';\r\n ReactDOM.hydrate(<App />, document.getElementById('root'));\r\n\r\n// React 18\r\nimport ReactDOM from 'react-dom/client';\r\nReactDOM.hydrateRoot(document.getElementById('root'), <App />);\r\n```\r\n\r\n## lazy\r\n\r\n- 动态加载组件\r\n- 缩减bundle的体积\r\n- 懒加载组件\r\n\r\n```jsx\r\nconst LazyCom = lazy(()=>import('./com'))\r\n```\r\n\r\n## Suspense\r\n\r\n- 在服务器上添加对Suspense支持, 并发渲染特性拓展\r\n- 配合`lazy`使用, 可以实现到动态加载组件\r\n\r\n```tsx\r\n<Suspense fallback={<Loading/>}>\r\n <LazyCom />\r\n</Suspense>\r\n```\r\n\r\n### ## Suspense 修改\r\n\r\n```tsx\r\n// React 17\r\nconst App = () => {\r\n  return (\r\n    <Suspense fallback={<Loading />}> // <--- 这个边界被使用，显示 Loading 组件\r\n      <Suspense>                      // <--- 这个边界被跳过，没有 fallback 属性\r\n        <Page />\r\n      </Suspense>\r\n    </Suspense>\r\n  );\r\n};\r\n\r\n// React 18\r\nconst App = () => {\r\n  return (\r\n    <Suspense fallback={<Loading />}> // <--- 不使用\r\n      <Suspense>                      // <--- 这个边界被使用，将 fallback 渲染为 null\r\n        <Page />\r\n      </Suspense>\r\n    </Suspense>\r\n  );\r\n};\r\n\r\n```\r\n\r\n## flushSync\r\n\r\n- 多个`setState`依然会执行, 可控制不需要精准控制的批量更新\r\n- 减少==渲染次数==\r\n- [详细说明](https://github.com/reactwg/react-18/discussions/21)\r\n\r\n### 重新渲染两次\r\n\r\n```tsx\r\nimport React, { useState } from \"react\"\r\nimport { flushSync } from 'react-dom'\r\n\r\nexport default function Demo() {\r\n console.log('App组件渲染了！');\r\n const [count1, setCount1] = useState(0);\r\n const [count2, setCount2] = useState(0);\r\n return (\r\n  <button\r\n   onClick={() => {\r\n     setCount1(count => count + 1);\r\n     setCount2(count => count + 1);\r\n   }}\r\n  >\r\n   <div>count1： {count1}</div>\r\n   <div>count2： {count2}</div>\r\n  </button>\r\n );\r\n\r\n}\r\n```\r\n\r\n```tsx\r\nimport React, { useState } from \"react\"\r\nimport { flushSync } from 'react-dom'\r\n\r\nexport default function Demo() {\r\n console.log('App组件渲染了！');\r\n const [count1, setCount1] = useState(0);\r\n const [count2, setCount2] = useState(0);\r\n return (\r\n  <button\r\n   onClick={() => {\r\n    flushSync(() => {\r\n     setCount1(count => count + 1);\r\n     // setCount2(count => count + 1);\r\n    });\r\n    flushSync(() => {\r\n     setCount2(count => count + 1);\r\n    });\r\n   }}\r\n  >\r\n   <div>count1： {count1}</div>\r\n   <div>count2： {count2}</div>\r\n  </button>\r\n );\r\n\r\n}\r\n```\r\n\r\n### 重新渲染一次\r\n\r\n```tsx\r\nimport React, { useState } from \"react\"\r\nimport { flushSync } from 'react-dom'\r\n\r\nexport default function Demo() {\r\n console.log('App组件渲染了！');\r\n const [count1, setCount1] = useState(0);\r\n const [count2, setCount2] = useState(0);\r\n return (\r\n  <button\r\n   onClick={() => {\r\n    flushSync(() => {\r\n     setCount1(count => count + 1);\r\n     setCount2(count => count + 1);\r\n    });\r\n    // flushSync(() => {\r\n    //  setCount2(count => count + 1);\r\n    // });\r\n   }}\r\n  >\r\n   <div>count1： {count1}</div>\r\n   <div>count2： {count2}</div>\r\n  </button>\r\n );\r\n\r\n}\r\n```\r\n\r\n## React空组件返回值\r\n\r\n- 只允许 `null` ( react17 )\r\n- 允许`null`, `undifined` ( react8 )\r\n\r\n## [Strict Mode](https://github.com/reactwg/react-18/discussions/96)\r\n\r\n- 严格模式下 React组件渲染两次, 取消一次渲染的控制台日志( react17 )\r\n- 取消该限制, 若安装 `React DevTools` 第二次渲染的日志显示灰色\r\n\r\n## useId\r\n\r\n- 用于客户端和服务端生成唯一ID\r\n- 支持同一个组件在客户端和服务端生成相同的唯一的 ID，避免 hydration 的不兼容，这解决了在 React 17 及 17 以下版本中已经存在的问题。因为我们的服务器渲染时提供的 HTML 是无序的，useId 的原理就是每个 id 代表该组件在组件树中的层级结构。\r\n\r\n```tsx\r\nfunction NameFields() {\r\n  const id = useId();\r\n  return (\r\n    <div>\r\n      <label htmlFor={id + '-firstName'}>First Name</label>\r\n      <div>\r\n        <input id={id + '-firstName'} type=\"text\" />\r\n      </div>\r\n      <label htmlFor={id + '-lastName'}>Last Name</label>\r\n      <div>\r\n        <input id={id + '-lastName'} type=\"text\" />\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\n```\r\n\r\n> 整个表单创建一个基本 ID，然后通过附加后缀从该表单派生更多 id，而不是为 N 个不同的 id 生成单独的钩子 N 次\r\n> id 全局唯一, 后缀局部唯一, 及派生id全局唯一\r\n\r\n## useSyncExternalStore\r\n\r\n- 由 useMutableSource 改变而来，主要用来解决外部数据撕裂问题\r\n- 一般由第三方状态管理库使用, 日常开发使用useState已经可以解决并发特性下撕裂问题\r\n  - 比如`redux`: 自己再外部维护一个store对象, 脱离了React管理\r\n\r\n## useInsertionEffect\r\n\r\n- 只建议 `css-in-js` 库来使用\r\n- 执行再`DOM`生成之后\r\n\r\n```tsx\r\nconst useCSS = rule => {\r\n  useInsertionEffect(() => {\r\n    if (!isInserted.has(rule)) {\r\n      isInserted.add(rule);\r\n      document.head.appendChild(getStyleForRule(rule));\r\n    }\r\n  });\r\n  return rule;\r\n};\r\n\r\nconst App: React.FC = () => {\r\n  const className = useCSS(rule);\r\n  return <div className={className} />;\r\n};\r\n\r\nexport default App;\r\n```\r\n\r\n## Concurrent Mode\r\n\r\n- 并发模式\r\n- 同步不可终端更新(React 17)\r\n- 异步可中断更新(React 18 )\r\n\r\n## transition\r\n\r\n- `useDeferredValue`, 返回一个延迟响应的值, 让一个state延迟生效\r\n- 和`useTransition`: 相似\r\n\r\n```tsx\r\n// useTransiton\r\nconst [isPending, startTransition] = useTransition();\r\n\r\nconst getList = async () => {\r\n  const res: IRes = await request.get({...});\r\n  const list = res?.Response?.Data;\r\n  startTransition( () => { \r\n      setList(list as IDetail[]); \r\n  });\r\n};\r\n  \r\n//useDeferredValue\r\nconst deferredList = useDeferredValue(list);\r\n```\r\n\r\n- 可以将原一个长任务, 分成多个多任务+一个长任务\r\n","children":[]},{"name":"README.md","path":"../guanruihua.github.io/React","data":"# [ruihuag](https://guanruihua.github.io/#/)\r\n","children":[]},{"name":"router","path":"../guanruihua.github.io/React","data":"","children":[{"name":"react_router.md","path":"../guanruihua.github.io/React/router","data":"# react_router\n\n## router路由传参数\n\n## 路由配置方法\n\n### 标签\n\n```jsx\nimport { IndexRoute } from 'react-router'\n \nconst Dashboard = React.createClass({\n  render() {\n    return <div>Welcome to the app!</div>\n  }\n})\n \nReact.render((\n  <Router>\n    <Route path=\"/\" component={App}>\n      <IndexRoute component={Dashboard} />\n      <Route path=\"about\" component={About} />\n      <Route path=\"inbox\" component={Inbox}>\n        <Route path=\"messages/:id\" component={Message} />\n      </Route>\n    </Route>\n  </Router>\n), document.body)\n```\n\n### 对象\n\n```jsx\nconst routeConfig = [\n  { path: '/',\n    component: App,\n    indexRoute: { component: Dashboard },\n    childRoutes: [\n      { path: 'about', component: About },\n      { path: 'inbox',\n        component: Inbox,\n        childRoutes: [\n          { path: '/messages/:id', component: Message }\n        ]\n      }\n    ]\n  }\n]\n \nReact.render(<Router routes={routeConfig} />, document.body)\n```\n\n### useParams\n\n> `useParams` : 通过对`url`进行取值\n\n```jsx\nimport { BrowserRouter as Router, Link, Route, Switch, useParams } from 'react-router-dom';\n\nfunction RouterParams() {\n  let { id,name } = useParams()\n  console.log(useParams());\n  return (<>\n      <h1>ID: {id}</h1>\n      <h1>Name: {name}</h1>\n  </>)\n}\n\nfunction App() {\n  return (\n    <Router>\n      <div>\n        <h2>Params </h2>\n        <Link to=\"/aa/ac\">aa</Link>\n        <Link to=\"/bb/bc\">bb</Link>\n        <Switch>\n          <Route path=\"/:id/:name\" children={<RouterParams />} />\n        </Switch>\n      </div>\n    </Router>\n  )\n}\n```\n\n|        | id   | name |\n| ------ | ---- | ---- |\n| 点击aa | aa   | ac   |\n| 点击bb | bb   | bc   |\n\n## API\n\n### Hooks\n\n> - useHistory : 允许访问可能用于导航的历史记录\n> - useLocation : 返回当前URL的位置对象,\n> - useParams : 返回参数键/值对的对象\n> - useRouteMatch : 尝试以与匹配方式匹配当前URL, 主要访问匹配数据而不实际呈现\n>   - 不采用任何参数, 返回当前匹配对象`<Route>`\n>   - 采用单个参数, 与matchPath 的参数相同,\n\n### BrowerRouter\n\n> - `basename : string`  => 所有位置基本URl\n> - `forRefresh : bool` =>    是否强制刷新刷新\n> - `getUserConfirmation : func` =>  用于确认导航的函数\n> - `keyLength : number` => location.key 默认6\n> - `children : node`\n>   - 要呈现的子元素\n>   - `React<16` : 必须使用单个元素, 因为渲染方法不能返回多个元素, 如果需要多个元素, 可以尝试将他们包装在一个额外的元素\n\n### HashRouter\n\n>- `basename : string`\n>- `getUserConfirmation: func`\n>- `hashType:string`\n>- `children:node`\n\n### Link\n\n> - `to: string`\n>\n>   - ```jsx\n>     <Link to=\"/courses?sort=name\" />\n>     ```\n>\n> - `to :object`\n>\n>   - ```jsx\n>     <Link\n>       to={{\n>         pathname: \"/courses\",\n>         search: \"?sort=name\",\n>         hash: \"#the-hash\",\n>         state: { fromDashboard: true }\n>       }}\n>     />\n>     ```\n>\n> - `to: func`\n>\n>   - ```jsx\n>     <Link to={location => ({ ...location, pathname: \"/courses\" })} />\n>     <Link to={location => `${location.pathname}?sort=name`} />\n>     ```\n>\n> - `replace:bool`\n>\n>   - 取代当前堆栈中的当前链接, 不是添加一个\n>\n> - `innerRef: func`\n>\n>   - ```jsx\n>     <Link\n>       to=\"/\"\n>       innerRef={node => {\n>         // `node` refers to the mounted DOM element\n>         // or null when unmounted\n>       }}\n>     />\n>     ```\n>\n> - `innerRef: RefObject`\n>\n>   - ```jsx\n>     let anchorRef = React.createRef()\n>     <Link to=\"/\" innerRef={anchorRef} />\n>     ```\n>\n> - `component:React.Component`\n>\n>   - ```jsx\n>     const FancyLink = React.forwardRef((props, ref) => (\n>       <a ref={ref} {...props}>💅 {props.children}</a>\n>     ))\n>     <Link to=\"/\" component={FancyLink} />\n>     ```\n\n### NavLink\n\n> - `activeClassName: string`\n> - `activeStyle:objecct`\n> - `exact:bool`\n> - `strict: bool`\n> - `isActive:func`\n> - `location: object`\n> - `aria-current: string`\n\n### MemoryRouter\n\n> - `initialEntries: array`\n>\n>   - ```js\n>     <MemoryRouter\n>      initialEnriies={[\"/one\", \"/two\", { pathname: \"/three\"}]}\n>      initialIndex={1} //在数组中初始位置索引\n>     >\n>         <App />\n>     </MemoryRotuer>\n>     ```\n>\n>\n>\n> - `initialIndex: number`\n>\n> - `getUserConfirmation: func`\n>\n> - `keyLength: number`\n>\n> - `children: node`\n\n### Redirect\n\n> - `to : string`\n>\n>   - ```jsx\n>     <Redirect to=\"/somewhere/else\" />\n>     ```\n>\n> - `to: object`\n>\n>   - ```jsx\n>     <Redirect\n>       to={{\n>         pathname: \"/login\",\n>         search: \"?utm=your+face\",\n>         state: { referrer: currentLocation }\n>       }}\n>     />\n>     ```\n>\n> - `push: bool`\n>\n>   - 重新加入一个history, 而不是取代当前的\n>\n>   - ```jsx\n>     <Redirect push to=\"/somewhere/else\" />\n>     ```\n>\n> - `from: string`\n>\n>   - 重定向`old-path` 跳转到`new-path`\n>\n>   - ```jsx\n>     <Switch>\n>       <Redirect from=\"/old-path\" to=\"/new-path\" />\n>       <Route path=\"/new-path\">\n>         <Place />\n>       </Route>\n>     </Switch>\n>     ```\n>\n> - `exact : bool`\n>\n>   - true : 完全匹配\n>\n>   - |  path  | location.pathname |  exact  | matches? |\n>     | :----: | :---------------: | :-----: | :------: |\n>     | `/one` |    `/one/two`     | `true`  |    no    |\n>     | `/one` |    `/one/two`     | `false` |   yes    |\n>\n> - `strict: bool`\n>\n>   - |  path   | location.pathname | matches? |\n>     | :-----: | :---------------: | :------: |\n>     | `/one/` |      `/one`       |    no    |\n>     | `/one/` |      `/one/`      |   yes    |\n>     | `/one/` |    `/one/two`     |   yes    |\n>\n> - `sensitive : bool`\n>\n>   - 区分大小写\n>\n>   - |  path  | location.pathname | sensitive | matches? |\n>     | :----: | :---------------: | :-------: | :------: |\n>     | `/one` |      `/one`       |  `true`   |   yes    |\n>     | `/One` |      `/one`       |  `true`   |    no    |\n>     | `/One` |      `/one`       |  `false`  |   yes    |\n\n### Route\n\n> - Route render methods\n>\n>   - `<Route component/>`\n>   - `<Route render/>`\n>   - `<Route children> fucntion`\n>\n> - Route props\n>\n>   - match\n>   - location\n>   - history\n>\n> - component `<Route path=\"/user/:username\" component={User} />`\n>\n> - `render: func`\n>\n> - `children: func`\n>\n> - `path: string | string[]` :\n>\n>   ```jsx\n>   <Route path={[\"/users/:id\", \"/profile/:id\"]}>\n>     <User />\n>   </Route>\n>   ```\n>\n> - `exact : bool`\n>\n>   - true : 完全匹配\n>\n>   - |  path  | location.pathname |  exact  | matches? |\n>     | :----: | :---------------: | :-----: | :------: |\n>     | `/one` |    `/one/two`     | `true`  |    no    |\n>     | `/one` |    `/one/two`     | `false` |   yes    |\n>\n> - `strict: bool`\n>\n>   - |  path   | location.pathname | matches? |\n>     | :-----: | :---------------: | :------: |\n>     | `/one/` |      `/one`       |    no    |\n>     | `/one/` |      `/one/`      |   yes    |\n>     | `/one/` |    `/one/two`     |   yes    |\n>\n> - `sensitive : bool`\n>\n>   - 区分大小写\n>\n>   - |  path  | location.pathname | sensitive | matches? |\n>     | :----: | :---------------: | :-------: | :------: |\n>     | `/one` |      `/one`       |  `true`   |   yes    |\n>     | `/One` |      `/one`       |  `true`   |    no    |\n>     | `/One` |      `/one`       |  `false`  |   yes    |\n\n### Router\n\n> - 是一个低级接口, 一般需要用一个高级Router代替\n>   - `<BrowserRouter>`\n>   - `<HashRouter>`\n>   - `<MenoryRouter>`\n>   - `<NativeRouter>`\n>   - `<StaticRouter>`\n> - 属性\n>   - `history: object`\n>   - `children:node`\n\n```js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Router } from \"react-router\";\nimport { createBrowserHistory } from \"history\";\n\nconst history = createBrowserHistory();\n\nReactDOM.render(\n  <Router history={history}>\n    <App />\n  </Router>,\n  node\n);\n```\n\n### StaticRouter\n\n> - `basename:string`\n> - `location:`\n>   - `string`\n>   - `object`\n> - `context:object`\n> - `children: node`\n\n### Switch\n\n> - `location:object`\n> - `children:node`\n\n### generatePath\n\n> - 用于生成路由的URL\n> - `pattern: string`\n> - `params:object`\n>\n> ```js\n> generatePath(\"/user/:id/:entity(posts|comments)\", { id: 1 });\n> ```\n\n### history\n\n> ‎管理 JavaScript 中的会话历史记录。\n>\n> ‎`history`‎ 以下术语：‎\n>\n> - ‎\"浏览器历史记录\" - 特定于 DOM 的实现，在支持 HTML5 历史记录 API 的 Web 浏览器中非常有用‎\n> - ‎\"哈希历史记录\" - 针对旧版 Web 浏览器的 DOM 特定实现‎\n> - ‎\"内存历史记录\" - 内存历史记录实现，在测试和非 DOM 环境（如 React Native）中非常有用‎\n>\n> `history`‎对象通常具有以下属性和方法：‎\n>\n> - `length`‎- （数字） 历史记录堆栈中的条目数‎\n> - `action`‎- （字符串） 当前操作 （或‎`PUSH``REPLACE``POP`)\n> - location（对象） 当前位置。可能具有以下属性：‎\n>   - `pathname`‎- （字符串） URL 的路径‎\n>   - `search`‎- （字符串） URL 查询字符串‎\n>   - `hash`‎- （字符串） URL 哈希片段‎\n>   - `state`‎- （对象）特定位置状态，例如 当此位置被推送到堆栈上时。仅在浏览器和内存历史记录中可用。‎`push(path, state)`\n> - `push(path, [state])`‎- （函数） 将新条目推送到历史记录堆栈‎\n> - `replace(path, [state])`‎- （函数） 替换历史记录堆栈上的当前条目‎\n> - `go(n)`‎- （函数） 按条目移动历史记录堆栈中的指针‎`n`\n> - `goBack()`‎- （功能） 等效于‎`go(-1)`\n> - `goForward()`‎- （功能） 等效于‎`go(1)`\n> - `block(prompt)`‎- （功能） 阻止导航（‎[‎请参阅历史记录文档‎](https://github.com/ReactTraining/history/blob/master/docs/blocking-transitions.md))\n\n```jsx\nimport { createBrowserHistory } from \"history\";\nconst customHistory = createBrowserHistory();\nReactDOM.render(<Router history={customHistory} />, node);\n```\n\n### location\n\n> 返回当前app在哪里\n\n一个Location对象\n\n```js\n{\n  key: 'ac3df4', // not with HashHistory!\n  pathname: '/somewhere',\n  search: '?some=search-string',\n  hash: '#howdy',\n  state: {\n    [userDefined]: true\n  }\n}\n```\n\n> - [Route component](https://reactrouter.com/web/api/Route/component) as `this.props.location`\n> - [Route render](https://reactrouter.com/web/api/Route/render-func) as `({ location }) => ()`\n> - [Route children](https://reactrouter.com/web/api/Route/children-func) as `({ location }) => ()`\n> - [withRouter](https://reactrouter.com/web/api/withRouter) as `this.props.location`\n\n### match\n\n> - `params` - (object) 从URL解析所得到的键/值对相对应的动态路径的部分\n> - `isExact` - (boolean) 如果匹配整个URL`true`\n> - `path` - (string) 路径模式用于匹配。 有助于建立嵌套的 `<Route>`\n> - `url` - (string) 匹配URL的一部分。 有助于建立嵌套的`<Link>`\n\n> - [Route component](https://reactrouter.com/web/api/Route/component) as `this.props.match`\n> - [Route render](https://reactrouter.com/web/api/Route/render-func) as `({ match }) => ()`\n> - [Route children](https://reactrouter.com/web/api/Route/children-func) as `({ match }) => ()`\n> - [withRouter](https://reactrouter.com/web/api/withRouter) as `this.props.match`\n> - [matchPath](https://reactrouter.com/web/api/matchPath) as the return value\n> - [useRouteMatch](https://reactrouter.com/web/api/hooks/useroutematch) as the return value\n\n### matchPath\n\n> - pathname : 匹配路径名\n>   - 如果在与节点的服务器上使用node.js , 则为`req.path`\n> - props\n> - returns\n\n### withRotuer\n\n> - 可以通过高阶组件访问历史记录的属性和最接近的`<Route>`的匹配项, 每单呈现, 都会将更新或传递给包装的组件\n> - 包装组件的所有非反应特定静态方法和属性将自动复制到\"已连接\"组件\n\n### Prompt\n\n> - 从核心提示符重新导出\n","children":[]},{"name":"v6.md","path":"../guanruihua.github.io/React/router","data":"\n# react-router-dom\n\n## 修改\n\n> Switch 修改为 Rotues\n> 添加 Navigateg\n> 移除 ## Redirec\n\n代替\n\n```js\n<Router>\n    <Routes>\n        <Route path='/login' element={<Login/>}/>\n        <Route path='/admin' element={<Admin/>}/>\n        <Route path=\"*\" element={<Navigate to=\"/login\" />} />\n    </Routes>\n</Router>\n```\n\n## 配置路由\n\n```tsx\n<BrowserRouter>\n    <Routes>\n      <Route path=\"/\" element={<App />} />\n      <Route path=\"expenses\" element={<Expenses />} />\n      <Route path=\"invoices\" element={<Invoices />} />\n    </Routes>\n  </BrowserRouter>,\n```\n\n## 使用 URL 参数加载数据\n\n```tsx\n<Routes>\n  <Route path=\"/\" element={<App />}>\n    <Route path=\"expenses\" element={<Expenses />} />\n    <Route path=\"invoices\" element={<Invoices />}>\n      <Route path=\":invoiceId\" element={<Invoice />} />\n    </Route>\n    <Route\n      path=\"*\"\n      element={\n        <main style={{ padding: \"1rem\" }}>\n          <p>There's nothing here!</p>\n        </main>\n      }\n    />\n  </Route>\n</Routes>\n```\n\n## 索引\n\n```tsx\n<Routes>\n  <Route path=\"/\" element={<App />}>\n    <Route path=\"expenses\" element={<Expenses />} />\n    <Route path=\"invoices\" element={<Invoices />}>\n      <Route\n        index\n        element={\n          <main style={{ padding: \"1rem\" }}>\n            <p>Select an invoice</p>\n          </main>\n        }\n      />\n      <Route path=\":invoiceId\" element={<Invoice />} />\n    </Route>\n    <Route\n      path=\"*\"\n      element={\n        <main style={{ padding: \"1rem\" }}>\n          <p>There's nothing here!</p>\n        </main>\n      }\n    />\n  </Route>\n</Routes>\n```\n","children":[]}]},{"name":"SSR","path":"../guanruihua.github.io/React","data":"","children":[{"name":"next.md","path":"../guanruihua.github.io/React/SSR","data":"# Next.js\r\n\r\n>[Next.js](https://www.nextjs.cn/)\r\n> 基于 React 的SSR 框架\r\n","children":[]}]},{"name":"type","path":"../guanruihua.github.io/React","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/React/type","data":"# React Type\n\n```js\nexport type ReactNode =\n  | React$Element<any>\n  | ReactPortal\n  | ReactText\n  | ReactFragment\n  | ReactProvider<any>\n  | ReactConsumer<any>;\n\nexport type ReactEmpty = null | void | boolean;\n\nexport type ReactFragment = ReactEmpty | Iterable<React$Node>;\n\nexport type ReactNodeList = ReactEmpty | React$Node;\n\nexport type ReactText = string | number;\n\nexport type ReactProvider<T> = {\n  $$typeof: Symbol | number,\n  type: ReactProviderType<T>,\n  key: null | string,\n  ref: null,\n  props: {\n    value: T,\n    children?: ReactNodeList,\n    ...\n  },\n  ...\n};\n\nexport type ReactProviderType<T> = {\n  $$typeof: Symbol | number,\n  _context: ReactContext<T>,\n  ...\n};\n\nexport type ReactConsumer<T> = {\n  $$typeof: Symbol | number,\n  type: ReactContext<T>,\n  key: null | string,\n  ref: null,\n  props: {\n    children: (value: T) => ReactNodeList,\n    unstable_observedBits?: number,\n    ...\n  },\n  ...\n};\n\nexport type ReactContext<T> = {\n  $$typeof: Symbol | number,\n  Consumer: ReactContext<T>,\n  Provider: ReactProviderType<T>,\n  _calculateChangedBits: ((a: T, b: T) => number) | null,\n  _currentValue: T,\n  _currentValue2: T,\n  _threadCount: number,\n  // DEV only\n  _currentRenderer?: Object | null,\n  _currentRenderer2?: Object | null,\n  // This value may be added by application code\n  // to improve DEV tooling display names\n  displayName?: string,\n  ...\n};\n\nexport type ReactPortal = {\n  $$typeof: Symbol | number,\n  key: null | string,\n  containerInfo: any,\n  children: ReactNodeList,\n  // TODO: figure out the API for cross-renderer implementation.\n  implementation: any,\n  ...\n};\n\nexport type RefObject = {|\n  current: any,\n|};\n\nexport type EventPriority = 0 | 1 | 2;\n\nexport const DiscreteEvent: EventPriority = 0;\nexport const UserBlockingEvent: EventPriority = 1;\nexport const ContinuousEvent: EventPriority = 2;\n\nexport type ReactFundamentalComponentInstance<C, H> = {|\n  currentFiber: Object,\n  instance: mixed,\n  prevProps: null | Object,\n  props: Object,\n  impl: ReactFundamentalImpl<C, H>,\n  state: Object,\n|};\n\nexport type ReactFundamentalImpl<C, H> = {\n  displayName: string,\n  reconcileChildren: boolean,\n  getInitialState?: (props: Object) => Object,\n  getInstance: (context: C, props: Object, state: Object) => H,\n  getServerSideString?: (context: C, props: Object) => string,\n  getServerSideStringClose?: (context: C, props: Object) => string,\n  onMount: (context: C, instance: mixed, props: Object, state: Object) => void,\n  shouldUpdate?: (\n    context: C,\n    prevProps: null | Object,\n    nextProps: Object,\n    state: Object,\n  ) => boolean,\n  onUpdate?: (\n    context: C,\n    instance: mixed,\n    prevProps: null | Object,\n    nextProps: Object,\n    state: Object,\n  ) => void,\n  onUnmount?: (\n    context: C,\n    instance: mixed,\n    props: Object,\n    state: Object,\n  ) => void,\n  onHydrate?: (context: C, props: Object, state: Object) => boolean,\n  onFocus?: (context: C, props: Object, state: Object) => boolean,\n  ...\n};\n\nexport type ReactFundamentalComponent<C, H> = {|\n  $$typeof: Symbol | number,\n  impl: ReactFundamentalImpl<C, H>,\n|};\n\nexport type ReactScope = {|\n  $$typeof: Symbol | number,\n|};\n\nexport type ReactScopeQuery = (\n  type: string,\n  props: {[string]: mixed, ...},\n  instance: mixed,\n) => boolean;\n\nexport type ReactScopeInstance = {|\n  DO_NOT_USE_queryAllNodes(ReactScopeQuery): null | Array<Object>,\n  DO_NOT_USE_queryFirstNode(ReactScopeQuery): null | Object,\n  containsNode(Object): boolean,\n  getChildContextValues: <T>(context: ReactContext<T>) => Array<T>,\n|};\n\n// Mutable source version can be anything (e.g. number, string, immutable data structure)\n// so long as it changes every time any part of the source changes.\nexport type MutableSourceVersion = $NonMaybeType<mixed>;\n\nexport type MutableSourceGetSnapshotFn<\n  Source: $NonMaybeType<mixed>,\n  Snapshot,\n> = (source: Source) => Snapshot;\n\nexport type MutableSourceSubscribeFn<Source: $NonMaybeType<mixed>, Snapshot> = (\n  source: Source,\n  callback: (snapshot: Snapshot) => void,\n) => () => void;\n\nexport type MutableSourceGetVersionFn = (\n  source: $NonMaybeType<mixed>,\n) => MutableSourceVersion;\n\nexport type MutableSource<Source: $NonMaybeType<mixed>> = {|\n  _source: Source,\n\n  _getVersion: MutableSourceGetVersionFn,\n\n  // Tracks the version of this source at the time it was most recently read.\n  // Used to determine if a source is safe to read from before it has been subscribed to.\n  // Version number is only used during mount,\n  // since the mechanism for determining safety after subscription is expiration time.\n  //\n  // As a workaround to support multiple concurrent renderers,\n  // we categorize some renderers as primary and others as secondary.\n  // We only expect there to be two concurrent renderers at most:\n  // React Native (primary) and Fabric (secondary);\n  // React DOM (primary) and React ART (secondary).\n  // Secondary renderers store their context values on separate fields.\n  // We use the same approach for Context.\n  _workInProgressVersionPrimary: null | MutableSourceVersion,\n  _workInProgressVersionSecondary: null | MutableSourceVersion,\n\n  // DEV only\n  // Used to detect multiple renderers using the same mutable source.\n  _currentPrimaryRenderer?: Object | null,\n  _currentSecondaryRenderer?: Object | null,\n|};\n\n// The subset of a Thenable required by things thrown by Suspense.\n// This doesn't require a value to be passed to either handler.\nexport interface Wakeable {\n  then(onFulfill: () => mixed, onReject: () => mixed): void | Wakeable;\n  // Special flag to opt out of tracing interactions across a Suspense boundary.\n  __reactDoNotTraceInteractions?: boolean;\n}\n\n// The subset of a Promise that React APIs rely on. This resolves a value.\n// This doesn't require a return value neither from the handler nor the\n// then function.\nexport interface Thenable<+R> {\n  then<U>(\n    onFulfill: (value: R) => void | Thenable<U> | U,\n    onReject: (error: mixed) => void | Thenable<U> | U,\n  ): void | Thenable<U>;\n}\n\n```\n","children":[]}]},{"name":"typescript","path":"../guanruihua.github.io/React","data":"","children":[{"name":"react使用ts.md","path":"../guanruihua.github.io/React/typescript","data":"# react 使用 TS\n\n## 组件声明\n\n在React中，组件的声明方式有两种：函数组件和类组件， 来看看这两种类型的组件声明时是如何定义TS类型的。\n\n### 类组件 Component\n\n> 类组件的定义形式有两种：`React.Component<P, S={}>` 和 `React.PureComponent<P, S={} SS={}>`，它们都是泛型接口，接收两个参数，第一个是props类型的定义，第二个是state类型的定义，这两个参数都不是必须的，没有时可以省略：\n\n```ts\ninterface IProps {\n  name: string;\n}\n\ninterface IState {\n  count: number;\n}\n\nclass App extends React.Component<IProps, IState> {\n  state = {\n    count: 0\n  };\n\n  render() {\n    return (\n      <div>\n        {this.state.count}\n        {this.props.name}\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n### 类组件 PureComponent\n\n> `React.PureComponent<P, S={} SS={}>` 也是差不多的：\n>`class App extends React.PureComponent<IProps, IState> {}`\n>`React.PureComponent`是有第三个参数的，它表示`getSnapshotBeforeUpdate`的返回值\n>那PureComponent和Component 的区别是什么呢？它们的主要区别是PureComponent中的shouldComponentUpdate 是由自身进行处理的，不需要我们自己处理，所以PureComponent可以在一定程度上提升性能。\n\n有时候可能会见到这种写法，实际上和上面的效果是一样的：\n\n```tsx\nimport React, {PureComponent, Component} from \"react\";\nclass App extends PureComponent<IProps, IState> {}\nclass App extends Component<IProps, IState> {}\n```\n\n那如果定义时候我们不知道组件的props的类型，只有在调用时才知道组件类型，该怎么办呢？这时泛型就发挥作用了：\n\n```tsx\n// 定义组件\nclass MyComponent<P> extends React.Component<P> {\n  internalProp: P;\n  constructor(props: P) {\n    super(props);\n    this.internalProp = props;\n  }\n  render() {\n    return (\n      <span>hello world</span>\n    );\n  }\n}\n\n// 使用组件\ntype IProps = { name: string; age: number; };\n\n<MyComponent<IProps> name=\"React\" age={18} />;          // Success\n<MyComponent<IProps> name=\"TypeScript\" age=\"hello\" />;  // Error\n```\n\n### 函数组件\n\n> 通常情况下，函数组件我是这样写的：\n\n```ts\ninterface IProps {\n  name: string\n}\n\nconst App = (props: IProps) => {\n  const {name} = props;\n\n  return (\n    <div className=\"App\">\n      <h1>hello world</h1>\n      <h2>{name}</h2>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n> 除此之外，函数类型还可以使用`React.FunctionComponent<P={}>`来定义，也可以使用其简写`React.FC<P={}>`，两者效果是一样的。它是一个泛型接口，可以接收一个参数，参数表示props的类型，这个参数不是必须的。它们就相当于这样：\n> `type React.FC<P = {}> = React.FunctionComponent<P>`\n\n最终的定义形式如下：\n\n```tsx\ninterface IProps {\n  name: string\n}\n\nconst App: React.FC<IProps> = (props) => {\n  const {name} = props;\n  return (\n    <div className=\"App\">\n      <h1>hello world</h1>\n      <h2>{name}</h2>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n当使用这种形式来定义函数组件时，props中默认会带有children属性，它表示该组件在调用时，其内部的元素，来看一个例子，首先定义一个组件，组件中引入了Child1和Child2组件：\n\n```tsx\nimport Child1 from \"./child1\";\nimport Child2 from \"./child2\";\n\ninterface IProps {\n  name: string;\n}\nconst App: React.FC<IProps> = (props) => {\n  const { name } = props;\n  return (\n    <Child1 name={name}>\n      <Child2 name={name} />\n      TypeScript\n    </Child1>\n  );\n};\n\nexport default App;\n```\n\nChild1组件结构如下：\n\n```tsx\n\ninterface IProps {\n  name: string;\n}\nconst Child1: React.FC<IProps> = (props) => {\n  const { name, children } = props;\n  console.log(children);\n  return (\n    <div className=\"App\">\n      <h1>hello child1</h1>\n      <h2>{name}</h2>\n    </div>\n  );\n};\n\nexport default Child1;\n```\n\n我们在Child1组件中打印了children属性，它的值是一个数组，包含Child2对象和后面的文本：\n\n![](/__assets__/img/2022-02-08-17-20-14.png)\n\n使用 React.FC 声明函数组件和普通声明的区别如下：\n\nReact.FC 显式地定义了返回类型，其他方式是隐式推导的；\nReact.FC 对静态属性：displayName、propTypes、defaultProps 提供了类型检查和自动补全；\nReact.FC 为 children 提供了隐式的类型（ReactElement | null）。\n那如果我们在定义组件时不知道props的类型，只有调用时才知道，那就还是用泛型来定义props的类型。对于使用function定义的函数组件：\n\n```tsx\n\n// 定义组件\nfunction MyComponent<P>(props: P) {\n  return (\n   <span>\n     {props}\n    </span>\n  );\n}\n\n// 使用组件\ntype IProps = { name: string; age: number; };\n\n<MyComponent<IProps> name=\"React\" age={18} />;          // Success\n<MyComponent<IProps> name=\"TypeScript\" age=\"hello\" />;  // Error\n```\n\n如果使用箭头函数定义的函数组件，直接这样调用时错误的：\n\n```tsx\n\nconst MyComponent = <P>(props: P) {\n  return (\n   <span>\n     {props}\n    </span>\n  );\n}\n```\n\n必须使用extends关键字来定义泛型参数才能被成功解析：\n\n```tsx\n\nconst MyComponent = <P extends any>(props: P) {\n  return (\n   <span>\n     {props}\n    </span>\n  );\n}\n```\n\n## React内置类型\n\n### JSX.Element\n\n先来看看JSX.Element类型的声明：\n\n```tsx\ndeclare global {\n  namespace JSX {\n    interface Element extends React.ReactElement<any, any> { }\n  }\n}\n```\n\n可以看到，JSX.Element是ReactElement的子类型，它没有增加属性，两者是等价的。也就是说两种类型的变量可以相互赋值。​\n\nJSX.Element 可以通过执行 React.createElement 或是转译 JSX 获得：\n\n```tsx\n\nconst jsx = <div>hello</div>\nconst ele = React.createElement(\"div\", null, \"hello\");\n```\n\n### React.ReactElement\n\n> React 的类型声明文件中提供了 React.ReactElement＜T＞，它可以让我们通过传入＜T/＞来注解类组件的实例化，它在声明文件中的定义如下：\n\n```tsx\n\ninterface ReactElement<P = any, T extends string | JSXElementConstructor<any> = string | JSXElementConstructor<any>> {\n   type: T;\n   props: P;\n   key: Key | null;\n}\n```\n\nReactElement是一个接口，包含type,props,key三个属性值。该类型的变量值只能是两种： null 和 ReactElement实例。​\n\n通常情况下，函数组件返回ReactElement（JXS.Element）的值。\n\n### React.ReactNode\n\nReactNode类型的声明如下：\n\n```tsx\n\ntype ReactText = string | number;\ntype ReactChild = ReactElement | ReactText;\n\ninterface ReactNodeArray extends Array<ReactNode> {}\ntype ReactFragment = {} | ReactNodeArray;\ntype ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined;\n```\n\n可以看到，ReactNode是一个联合类型，它可以是string、number、ReactElement、null、boolean、ReactNodeArray。由此可知。ReactElement类型的变量可以直接赋值给ReactNode类型的变量，但反过来是不行的。\n\n类组件的 render 成员函数会返回 ReactNode 类型的值：\n\n```tsx\n\nclass MyComponent extends React.Component {\n render() {\n     return <div>hello world</div>\n    }\n}\n// 正确\nconst component: React.ReactNode<MyComponent> = <MyComponent />;\n// 错误\nconst component: React.ReactNode<MyComponent> = <OtherComponent />;\n```\n\n上面的代码中，给component变量设置了类型是Mycomponent类型的react实例，这时只能给其赋值其为MyComponent的实例组件。​\n\n通常情况下，类组件通过 render() 返回 ReactNode的值。\n\n### CSSProperties\n\n先来看看React的声明文件中对CSSProperties 的定义：\n\n```tsx\n\nexport interface CSSProperties extends CSS.Properties<string | number> {\n  /**\n\n* The index signature was removed to enable closed typing for style\n* using CSSType. You're able to use type assertion or module augmentation\n* to add properties or an index signature of your own.\n*\n* For examples and more information, visit:\n* <https://github.com/frenic/csstype#what-should-i-do-when-i-get-type-errors>\n   */\n}\n```\n\nReact.CSSProperties是React基于TypeScript定义的CSS属性类型，可以将一个方法的返回值设置为该类型：\n\n```tsx\nimport * as React from \"react\";\n\nconst classNames = require(\"./sidebar.css\");\n\ninterface Props {\n  isVisible: boolean;\n}\n\nconst divStyle = (props: Props): React.CSSProperties => ({\n  width: props.isVisible ? \"23rem\" : \"0rem\"\n});\n\nexport const SidebarComponent: React.StatelessComponent<Props> = props => (\n  <div id=\"mySidenav\" className={classNames.sidenav} style={divStyle(props)}>\n    {props.children}\n  </div>\n);\n```\n\n这里divStyle组件的返回值就是React.CSSProperties类型。\n\n我们还可以定义一个CSSProperties类型的变量：\n\n```tsx\n\nconst divStyle: React.CSSProperties = {\n    width: \"11rem\",\n    height: \"7rem\",\n    backgroundColor: `rgb(${props.color.red},${props.color.green}, ${props.color.blue})`\n};\n\n```\n\n这个变量可以在HTML标签的style属性上使用：\n\n`<div style={divStyle} />`\n\n在React的类型声明文件中，style属性的类型如下：\n\n`style?: CSSProperties | undefined;`\n\n## React Hooks\n\n### useState\n\n默认情况下，React会为根据设置的state的初始值来自动推导state以及更新函数的类型：\n\n![](/__assets__/img/2022-02-08-17-48-31.png)\n\n如果已知state 的类型，可以通过以下形式来自定义state的类型：\n\n```tsx\nconst [count, setCount] = useState<number>(1)\n```\n\n如果初始值为null，需要显式地声明 state 的类型：\n\n```tsx\nconst [count, setCount] = useState<number | null>(null);\n```\n\n如果state是一个对象，想要初始化一个空对象，可以使用断言来处理：\n\n```tsx\nconst [user, setUser] = React.useState<IUser>({} as IUser);\n```\n\n> 空对象{}断言为IUser接口就是欺骗了TypeScript的编译器，由于后面的代码可能会依赖这个对象，所以应该在使用前及时初始化 user 的值，否则就会报错。\n\n下面是声明文件中 useState 的定义：\n\n```tsx\nfunction useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>];\n// convenience overload when first argument is omitted\n/**\n* Returns a stateful value, and a function to update it.\n*\n* @version 16.8.0\n* @see <https://reactjs.org/docs/hooks-reference.html#usestate>\n*/\n\nfunction useState<S = undefined>(): [S | undefined, Dispatch<SetStateAction<S | undefined>>];\n/**\n* An alternative to `useState`.\n*\n* `useReducer` is usually preferable to `useState` when you have complex state logic that involves\n* multiple sub-values. It also lets you optimize performance for components that trigger deep\n* updates because you can pass `dispatch` down instead of callbacks.\n*\n* @version 16.8.0\n* @see <https://reactjs.org/docs/hooks-reference.html#usereducer>\n*/\n```\n\n可以看到，这里定义两种形式，分别是有初始值和没有初始值的形式。\n\n### useEffect\n\n> useEffect的主要作用就是处理副作用，它的第一个参数是一个函数，表示要清除副作用的操作，第二个参数是一组值，当这组值改变时，第一个参数的函数才会执行，这让我们可以控制何时运行函数来处理副作用：\n\n```tsx\nuseEffect(\n  () => {\n    const subscription = props.source.subscribe();\n    return () => {\n      subscription.unsubscribe();\n    };\n  },\n  [props.source]\n);\n```\n\n当函数的返回值不是函数或者effect函数中未定义的内容时，如下：\n\n```tsx\nuseEffect(\n    () => {\n      subscribe();\n      return null;\n    }\n);\n```\n\nTypeScript就会报错：\n\n![](/__assets__/img/2022-02-08-17-54-57.png)\n\n来看看useEffect在类型声明文件中的定义：\n\n```tsx\n// Destructors are only allowed to return void.\ntype Destructor = () => void | { [UNDEFINED_VOID_ONLY]: never };\n\n// NOTE: callbacks are _only_ allowed to return either void, or a destructor.\ntype EffectCallback = () => (void | Destructor);\n\n// TODO (TypeScript 3.0): ReadonlyArray<unknown>\ntype DependencyList = ReadonlyArray<any>;\n\nfunction useEffect(effect: EffectCallback, deps?: DependencyList): void;\n// NOTE: this does not accept strings, but this will have to be fixed by removing strings from type Ref<T>\n/**\n* `useImperativeHandle` customizes the instance value that is exposed to parent components when using\n* `ref`. As always, imperative code using refs should be avoided in most cases.\n*\n* `useImperativeHandle` should be used with `React.forwardRef`.\n*\n* @version 16.8.0\n* @see <https://reactjs.org/docs/hooks-reference.html#useimperativehandle>\n*/\n```\n\n> useEffect的第一个参数只允许返回一个函数\n\n### useRef\n\n当使用 useRef 时，我们可以访问一个可变的引用对象。可以将初始值传递给 useRef，它用于初始化可变 ref 对象公开的当前属性。当我们使用useRef时，需要给其指定类型：\n\n```tsx\nconst nameInput = React.useRef<HTMLInputElement>(null)\n```\n\n这里给实例的类型指定为了input输入框类型。​\n\n当useRef的初始值为null时，有两种创建的形式，第一种：\n\n```tsx\nconst nameInput = React.useRef<HTMLInputElement>(null)\nnameInput.current.innerText = \"hello world\";\n```\n\n这种形式下，ref1.current是只读的（read-only），所以当我们将它的innerText属性重新赋值时会报以下错误：\n\n```tsx\nCannot assign to 'current' because it is a read-only property.\n```\n\n那该怎么将current属性变为动态可变得的，先来看看类型声明文件中 useRef 是如何定义的：\n\n```tsx\n\n function useRef<T>(initialValue: T): MutableRefObject<T>;\n // convenience overload for refs given as a ref prop as they typically start with a null value\n /**\n\n* `useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\n* (`initialValue`). The returned object will persist for the full lifetime of the component.\n*\n* Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\n* value around similar to how you’d use instance fields in classes.\n*\n* Usage note: if you need the result of useRef to be directly mutable, include `| null` in the type\n* of the generic argument.\n*\n* @version 16.8.0\n* @see <https://reactjs.org/docs/hooks-reference.html#useref>\n   */\n```\n\n这段代码的第十行的告诉我们，如果需要useRef的直接可变，就需要在泛型参数中包含'| null'，所以这就是当初始值为null的第二种定义形式：\n\n```ts\nconst nameInput = React.useRef<HTMLInputElement | null>(null);\n```\n\n这种形式下，`nameInput.current`就是可写的。不过两种类型在使用时都需要做类型检查：\n\n```ts\nnameInput.current?.innerText = \"hello world\";\n```\n\n那么问题来了，为什么第一种写法在没有操作current时没有报错呢？因为useRef在类型定义式具有多个重载声明，第一种方式就是执行的以下函数重载：\n\n```ts\n\nfunction useRef<T>(initialValue: T|null): RefObject<T>;\n// convenience overload for potentially undefined initialValue / call with 0 arguments\n// has a default to stop it from defaulting to {} instead\n/**\n\n* `useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\n* (`initialValue`). The returned object will persist for the full lifetime of the component.\n*\n* Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\n* value around similar to how you’d use instance fields in classes.\n*\n* @version 16.8.0\n* @see <https://reactjs.org/docs/hooks-reference.html#useref>\n  */\n```\n\n从上useRef的声明中可以看到，function useRef的返回值类型化是MutableRefObject，这里面的T就是参数的类型T，所以最终nameInput 的类型就是React.MutableRefObject。​\n\n注意，上面用到了HTMLInputElement类型，这是一个标签类型，这个操作就是用来访问DOM元素的。\n\n### useCallback\n\n先来看看类型声明文件中对useCallback的定义：\n\n```ts\n\n function useCallback<T extends (...args: any[]) => any>(callback: T, deps: DependencyList): T;\n /**\n\n* `useMemo` will only recompute the memoized value when one of the `deps` has changed.\n*\n* Usage note: if calling `useMemo` with a referentially stable function, also give it as the input in\n* the second argument.\n* ```ts\n* function expensive () { ... }\n* function Component () {\n*  const expensiveResult = useMemo(expensive, [expensive])\n*  return ...\n* }\n* ```\n* @version 16.8.0\n* @see <https://reactjs.org/docs/hooks-reference.html#usememo>  */\n\n```\n\nuseCallback接收一个回调函数和一个依赖数组，只有当依赖数组中的值发生变化时才会重新执行回调函数。来看一个例子：\n\n```ts\nconst add = (a: number, b: number) => a + b;\n\nconst memoizedCallback = useCallback(\n  (a) => {\n    add(a, b);\n  },\n  [b]\n);\n```\n\n这里我们没有给回调函数中的参数a定义类型，所以下面的调用方式都不会报错：\n\n```ts\nmemoizedCallback(\"hello\");\nmemoizedCallback(5)\n```\n\n尽管add方法的两个参数都是number类型，但是上述调用都能够用执行。所以为了更加严谨，我们需要给回调函数定义具体的类型：\n\n```ts\nconst memoizedCallback = useCallback(\n  (a: number) => {\n    add(a, b);\n  },\n  [b]\n);\n```\n\n这时候如果再给回调函数传入字符串就会报错了：\n\n![](/__assets__/img/2022-02-09-09-58-19.png)\n\n所有，需要注意，在使用useCallback时需要给回调函数的参数指定类型。\n\n### useMemo\n\n先来看看类型声明文件中对useMemo的定义：\n\n```ts\nfunction useMemo<T>(factory: () => T, deps: DependencyList | undefined): T;\n/**\n* `useDebugValue` can be used to display a label for custom hooks in React DevTools.\n*\n* NOTE: We don’t recommend adding debug values to every custom hook.\n* It’s most valuable for custom hooks that are part of shared libraries.\n*\n* @version 16.8.0\n* @see <https://reactjs.org/docs/hooks-reference.html#usedebugvalue>\n*/\n```\n\nuseMemo和useCallback是非常类似的，但是它返回的是一个值，而不是函数。所以在定义useMemo时需要定义返回值的类型：\n\n```ts\nlet a = 1;\nsetTimeout(() => {\n  a += 1;\n}, 1000);\n\nconst calculatedValue = useMemo<number>(() => a ** 2, [a]);\n```\n\n如果返回值不一致，就会报错：\n\n```ts\nconst calculatedValue = useMemo<number>(() => a + \"hello\", [a]);\n// 类型“() => string”的参数不能赋给类型“() => number”的参数\n```\n\n### useContext\n\nuseContext需要提供一个上下文对象，并返回所提供的上下文的值，当提供者更新上下文对象时，引用这些上下文对象的组件就会重新渲染：\n\n```ts\nconst ColorContext = React.createContext({ color: \"green\" });\n\nconst Welcome = () => {\n  const { color } = useContext(ColorContext);\n  return <div style={{ color }}>hello world</div>;\n};\n```\n\n在使用useContext时，会自动推断出提供的上下文对象的类型，所以并不需要我们手动设置context的类型。当前，我们也可以使用泛型来设置context的类型：\n\n```ts\ninterface IColor {\n color: string;\n}\n\nconst ColorContext = React.createContext<IColor>({ color: \"green\" });\n\n下面是useContext在类型声明文件中的定义：\n\nfunction useContext<T>(context: Context<T>/_, (not public API) observedBits?: number|boolean_/): T;\n/**\n* Returns a stateful value, and a function to update it.\n* @version 16.8.0\n* @see <https://reactjs.org/docs/hooks-reference.html#usestate>\n*/\n```\n\n### useReducer\n\n有时我们需要处理一些复杂的状态，并且可能取决于之前的状态。这时候就可以使用useReducer，它接收一个函数，这个函数会根据之前的状态来计算一个新的state。其语法如下：\n\n```ts\nconst [state, dispatch] = useReducer(reducer, initialArg, init);\n```\n\n来看下面的例子：\n\n```ts\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case 'increment':\n      return {count: state.count + 1};\n    case 'decrement':\n      return {count: state.count - 1};\n    default:\n      throw new Error();\n  }\n}\n\nconst Counter = () => {\n  const initialState = {count: 0}\n  const [state, dispatch] = useReducer(reducer, initialState);\n  \n  return (\n    <>\n      Count: {state.count}\n      <button onClick={() => dispatch({type: 'increment'})}>+</button>\n      <button onClick={() => dispatch({type: 'decrement'})}>-</button>\n    </>\n  );\n}\n```\n\n当前的状态是无法推断出来的，可以给reducer函数添加类型，通过给reducer函数定义state和action来推断 useReducer 的类型，下面来修改上面的例子：\n\n```ts\ntype ActionType = {\n  type: 'increment' | 'decrement';\n};\n\ntype State = { count: number };\n\nconst initialState: State = {count: 0}\nconst reducer = (state: State, action: ActionType) => {\n  // ...\n}\n\n```\n\n这样，在Counter函数中就可以推断出类型。当我们视图使用一个不存在的类型时，就会报错：\n\n```ts\n\ndispatch({type: 'reset'});\n// Error! type '\"reset\"' is not assignable to type '\"increment\" | \"decrement\"'\n\n```\n\n除此之外，还可以使用泛型的形式来实现reducer函数的类型定义：\n\n```ts\ntype ActionType = {\n  type: 'increment' | 'decrement';\n};\n\ntype State = { count: number };\n\nconst reducer: React.Reducer<State, ActionType> = (state, action) => {\n  // ...\n}\n\n```\n\n其实dispatch方法也是有类型的：\n\n![](/__assets__/img/2022-02-09-10-09-36.png)\n\n可以看到，dispatch的类型是：React.Dispatch，上面示例的完整代码如下：\n\n```ts\nimport React, { useReducer } from \"react\";\n\ntype ActionType = {\n  type: \"increment\" | \"decrement\";\n};\n\ntype State = { count: number };\n\nconst Counter: React.FC = () => {\n  const reducer: React.Reducer<State, ActionType> = (state, action) => {\n    switch (action.type) {\n      case \"increment\":\n        return { count: state.count + 1 };\n      case \"decrement\":\n        return { count: state.count - 1 };\n      default:\n        throw new Error();\n    }\n  };\n\n  const initialState: State = {count: 0}\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  return (\n    <>\n      Count: {state.count}\n      <button onClick={() => dispatch({ type: \"increment\" })}>+</button>\n      <button onClick={() => dispatch({ type: \"decrement\" })}>-</button>\n    </>\n  );\n};\n\nexport default Counter;\n```\n\n## 事件处理\n\n### Event 事件类型\n\n> Event是一个对象，并且有很多属性，这时很多人就会把 event 类型定义为any，这样的话TypeScript就失去了它的意义，并不会对event事件进行静态检查，如果一个键盘事件触发了下面的方法，也不会报错：\n\n```ts\nconst handleEvent = (e: any) => {\n    console.log(e.clientX, e.clientY)\n}\n```\n\n由于Event事件对象中有很多的属性，所以我们也不方便把所有属性及其类型定义在一个interface中，所以React在声明文件中给我们提供了Event事件对象的类型声明。\n\n常见的Event 事件对象如下：\n\n- 剪切板事件对象：`ClipboardEvent<T = Element>`\n- 拖拽事件对象：`DragEvent<T = Element>`\n- 焦点事件对象：`FocusEvent<T = Element>`\n- 表单事件对象：`FormEvent<T = Element>`\n- Change事件对象：`ChangeEvent<T = Element>`\n- 键盘事件对象：`KeyboardEvent<T = Element>`\n- 鼠标事件对象：`MouseEvent<T = Element, E = NativeMouseEvent>`\n- 触摸事件对象：`TouchEvent<T = Element>`\n- 滚轮事件对象：`WheelEvent<T = Element>`\n- 动画事件对象：`AnimationEvent<T = Element>`\n- 过渡事件对象：`TransitionEvent<T = Element>`\n可以看到，这些Event事件对象的泛型中都会接收一个Element元素的类型，这个类型就是我们绑定这个事件的标签元素的类型，标签元素类型将在下面的第五部分介绍。\n\n来看一个简单的例子：\n\n```ts\n\ntype State = {\n  text: string;\n};\n\nconst App: React.FC = () => {  \n  const [text, setText] = useState<string>(\"\")\n\n  const onChange = (e: React.FormEvent<HTMLInputElement>): void => {\n    setText(e.currentTarget.value);\n  };\n  \n  return (\n    <div>\n      <input type=\"text\" value={text} onChange={onChange} />\n    </div>\n  );\n}\n```\n\n这里就给onChange方法的事件对象定义为了FormEvent类型，并且作用的对象时一个HTMLInputElement类型的标签（input标签）​\n\n可以来看下MouseEvent事件对象和ChangeEvent事件对象的类型声明，其他事件对象的声明形似也类似：\n\n```ts\n\ninterface MouseEvent<T = Element, E = NativeMouseEvent> extends UIEvent<T, E> {\n  altKey: boolean;\n  button: number;\n  buttons: number;\n  clientX: number;\n  clientY: number;\n  ctrlKey: boolean;\n  /**\n    * See [DOM Level 3 Events spec](https://www.w3.org/TR/uievents-key/#keys-modifier). for a list of valid (case-sensitive) arguments to this method.\n    */\n  getModifierState(key: string): boolean;\n  metaKey: boolean;\n  movementX: number;\n  movementY: number;\n  pageX: number;\n  pageY: number;\n  relatedTarget: EventTarget | null;\n  screenX: number;\n  screenY: number;\n  shiftKey: boolean;\n}\n\ninterface ChangeEvent<T = Element> extends SyntheticEvent<T> {\n  target: EventTarget & T;\n}\n```\n\n在很多事件对象的声明文件中都可以看到 EventTarget 的身影。这是因为，DOM的事件操作（监听和触发），都定义在EventTarget接口上。EventTarget 的类型声明如下：\n\n```ts\ninterface EventTarget {\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject | null, options?: boolean | AddEventListenerOptions): void;\n    dispatchEvent(evt: Event): boolean;\n    removeEventListener(type: string, listener?: EventListenerOrEventListenerObject | null, options?: EventListenerOptions | boolean): void;\n}\n```\n\n比如在change事件中，会使用的e.target来获取当前的值，它的的类型就是EventTarget。来看下面的例子：\n\n```ts\n<input\n onChange={e => onSourceChange(e)}\n placeholder=\"最多30个字\"\n/>\n\nconst onSourceChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (e.target.value.length > 30) {\n      message.error('请长度不能超过30个字，请重新输入');\n      return;\n    }\n    setSourceInput(e.target.value);\n};\n```\n\n这里定义了一个`input`输入框，当触发`onChange`事件时，会调用`onSourceChange`方法，该方法的参数e的类型就是：`React.ChangeEvent`，而`e.target`的类型就是`EventTarget`：\n\n![](/__assets__/img/2022-02-09-10-26-49.png)\n\n在来看一个例子：\n\n```ts\nquestionList.map(item => (\n    <div\n     key={item.id}\n   role=\"button\"\n   onClick={e => handleChangeCurrent(item, e)}\n    >\n    // 组件内容...\n    </div>\n)\n\nconst handleChangeCurrent = (item: IData, e: React.MouseEvent<HTMLDivElement>) => {\n    e.stopPropagation();\n    setCurrent(item);\n};\n```\n\n这点代码中，点击某个盒子，就将它设置为当前的盒子，方便执行其他操作。当鼠标点击盒子时，会触发handleChangeCurren方法，该方法有两个参数，第二个参数是event对象，在方法中执行了e.stopPropagation();是为了阻止冒泡事件，这里的stopPropagation()实际上并不是鼠标事件MouseEvent的属性，它是合成事件上的属性，来看看声明文件中的定义：\n\n```ts\n\ninterface MouseEvent<T = Element, E = NativeMouseEvent> extends UIEvent<T, E> {\n  //...\n}\n\ninterface UIEvent<T = Element, E = NativeUIEvent> extends SyntheticEvent<T, E> {\n  //...\n}\n\ninterface SyntheticEvent<T = Element, E = Event> extends BaseSyntheticEvent<E, EventTarget & T, EventTarget> {}\n\ninterface BaseSyntheticEvent<E = object, C = any, T = any> {\n  nativeEvent: E;\n  currentTarget: C;\n  target: T;\n  bubbles: boolean;\n  cancelable: boolean;\n  defaultPrevented: boolean;\n  eventPhase: number;\n  isTrusted: boolean;\n  preventDefault(): void;\n  isDefaultPrevented(): boolean;\n  stopPropagation(): void;\n  isPropagationStopped(): boolean;\n  persist(): void;\n  timeStamp: number;\n  type: string;\n}\n```\n\n可以看到，这里的`stopPropagation()`是一层层的继承来的，最终来自于`BaseSyntheticEvent`合成事件类型。原生的事件集合`SyntheticEvent`就是继承自合成时间类型。`SyntheticEvent<T = Element, E = Event>`泛型接口接收当前的元素类型和事件类型，如果不介意这两个参数的类型，完全可以这样写：\n\n```ts\n<input\n  onChange={(e: SyntheticEvent<Element, Event>)=>{\n    //...\n  }}\n/>\n```\n\n### 事件处理函数类型\n\n> 说完事件对象类型，再来看看事件处理函数的类型。React也为我们提供了贴心的提供了事件处理函数的类型声明，来看看所有的事件处理函数的类型声明：\n\n```tsx\ntype EventHandler<E extends SyntheticEvent<any>> = { bivarianceHack(event: E): void }[\"bivarianceHack\"];\ntype ReactEventHandler<T = Element> = EventHandler<SyntheticEvent<T>>;\n// 剪切板事件处理函数\ntype ClipboardEventHandler<T = Element> = EventHandler<ClipboardEvent<T>>;\n// 复合事件处理函数\ntype CompositionEventHandler<T = Element> = EventHandler<CompositionEvent<T>>;\n// 拖拽事件处理函数\ntype DragEventHandler<T = Element> = EventHandler<DragEvent<T>>;\n// 焦点事件处理函数\ntype FocusEventHandler<T = Element> = EventHandler<FocusEvent<T>>;\n// 表单事件处理函数\ntype FormEventHandler<T = Element> = EventHandler<FormEvent<T>>;\n// Change事件处理函数\ntype ChangeEventHandler<T = Element> = EventHandler<ChangeEvent<T>>;\n// 键盘事件处理函数\ntype KeyboardEventHandler<T = Element> = EventHandler<KeyboardEvent<T>>;\n// 鼠标事件处理函数\ntype MouseEventHandler<T = Element> = EventHandler<MouseEvent<T>>;\n// 触屏事件处理函数\ntype TouchEventHandler<T = Element> = EventHandler<TouchEvent<T>>;\n// 指针事件处理函数\ntype PointerEventHandler<T = Element> = EventHandler<PointerEvent<T>>;\n// 界面事件处理函数\ntype UIEventHandler<T = Element> = EventHandler<UIEvent<T>>;\n// 滚轮事件处理函数\ntype WheelEventHandler<T = Element> = EventHandler<WheelEvent<T>>;\n// 动画事件处理函数\ntype AnimationEventHandler<T = Element> = EventHandler<AnimationEvent<T>>;\n// 过渡事件处理函数\ntype TransitionEventHandler<T = Element> = EventHandler<TransitionEvent<T>>;\n```\n\n> T 的类型也都是Element，指的是触发该事件的HTML标签元素的类型\n\nEventHandler会接收一个E，它表示事件处理函数中 Event 对象的类型。bivarianceHack 是事件处理函数的类型定义，函数接收一个 Event 对象，并且其类型为接收到的泛型变量 E 的类型, 返回值为 void。​\n\n还看上面的那个例子：\n\n```ts\ntype State = {\n  text: string;\n};\n\nconst App: React.FC = () => {  \n  const [text, setText] = useState<string>(\"\")\n\n  const onChange: React.ChangeEventHandler<HTMLInputElement> = (e) => {\n    setText(e.currentTarget.value);\n  };\n  \n  return (\n    <div>\n      <input type=\"text\" value={text} onChange={onChange} />\n    </div>\n  );\n}\n```\n\n这里给onChange方法定义了方法的类型，它是一个ChangeEventHandler的类型，并且作用的对象时一个HTMLImnputElement类型的标签（input标签）。\n\n## HTML标签类型\n\n### 常见标签类型\n\n在项目的依赖文件中可以找到HTML标签相关的类型声明文件：\n\n![](/__assets__/img/2022-02-09-10-39-01.png)\n\n所有的HTML标签的类型都被定义在 `intrinsicElements` 接口中，常见的标签及其类型如下：\n\n```tsx\na: HTMLAnchorElement;\nbody: HTMLBodyElement;\nbr: HTMLBRElement;\nbutton: HTMLButtonElement;\ndiv: HTMLDivElement;\nh1: HTMLHeadingElement;\nh2: HTMLHeadingElement;\nh3: HTMLHeadingElement;\nhtml: HTMLHtmlElement;\nimg: HTMLImageElement;\ninput: HTMLInputElement;\nul: HTMLUListElement;\nli: HTMLLIElement;\nlink: HTMLLinkElement;\np: HTMLParagraphElement;\nspan: HTMLSpanElement;\nstyle: HTMLStyleElement;\ntable: HTMLTableElement;\ntbody: HTMLTableSectionElement;\nvideo: HTMLVideoElement;\naudio: HTMLAudioElement;\nmeta: HTMLMetaElement;\nform: HTMLFormElement;\n```\n\n`Event`事件类型和事件处理函数类型中都使用到了标签的类型。上面的很多的类型都需要传入一个`ELement`类型的泛型参数，这个泛型参数就是对应的标签类型值，可以根据标签来选择对应的标签类型。这些类型都继承自`HTMLElement`类型，如果使用时对类型类型要求不高，可以直接写`HTMLELement`\n\n```tsx\n<Button\n type=\"text\"\n onClick={(e: React.MouseEvent<HTMLElement>) => {\n  handleOperate();\n  e.stopPropagation();\n}}\n  >\n    <img\n src={cancelChangeIcon}\n alt=\"\"\n    />\n    取消修改\n</Button>\n```\n\n> 其实，在直接操作DOM时也会用到标签类型，虽然我们现在通常会使用框架来开发，但是有时候也避免不了直接操作DOM。比如我在工作中，项目中的某一部分组件是通过npm来引入的其他组的组件，而在很多时候，我有需要动态的去个性化这个组件的样式，最直接的办法就是通过原生JavaScript获取到DOM元素，来进行样式的修改，这时候就会用到标签类型。​\n\n来看下面的例子：\n\n```js\ndocument.querySelectorAll('.paper').forEach(item => {\n  const firstPageHasAddEle = (item.firstChild as HTMLDivElement).classList.contains('add-ele')\n  if (firstPageHasAddEle) {\n    item.removeChild(item.firstChild as ChildNode);\n  }\n})\n```\n\n> 将item.firstChild断言成了HTMLDivElement类型，如果不断言，item.firstChild的类型就是ChildNode，而ChildNode类型中是不存在classList属性的，所以就就会报错，当我们把他断言成HTMLDivElement类型时，就不会报错了。很多时候，标签类型可以和断言（as）一起使用。​\n>\n> 后面在removeChild时又使用了as断言，为什么呢？item.firstChild不是已经自动识别为ChildNode类型了吗？因为TS会认为，我们可能不能获取到类名为paper的元素，所以item.firstChild的类型就被推断为ChildNode | null，我们有时候比TS更懂我们定义的元素，知道页面一定存在paper 元素，所以可以直接将item.firstChild断言成ChildNode类型。\n\n### 标签属性类型\n\n> 每个HTML标签都有自己的属性，比如Input框就有value、width、placeholder、max-length等属性，下面是Input框的属性类型定义：\n\n```tsx\n\ninterface InputHTMLAttributes<T> extends HTMLAttributes<T> {\n  accept?: string | undefined;\n  alt?: string | undefined;\n  autoComplete?: string | undefined;\n  autoFocus?: boolean | undefined;\n  capture?: boolean | string | undefined;\n  checked?: boolean | undefined;\n  crossOrigin?: string | undefined;\n  disabled?: boolean | undefined;\n  enterKeyHint?: 'enter' | 'done' | 'go' | 'next' | 'previous' | 'search' | 'send' | undefined;\n  form?: string | undefined;\n  formAction?: string | undefined;\n  formEncType?: string | undefined;\n  formMethod?: string | undefined;\n  formNoValidate?: boolean | undefined;\n  formTarget?: string | undefined;\n  height?: number | string | undefined;\n  list?: string | undefined;\n  max?: number | string | undefined;\n  maxLength?: number | undefined;\n  min?: number | string | undefined;\n  minLength?: number | undefined;\n  multiple?: boolean | undefined;\n  name?: string | undefined;\n  pattern?: string | undefined;\n  placeholder?: string | undefined;\n  readOnly?: boolean | undefined;\n  required?: boolean | undefined;\n  size?: number | undefined;\n  src?: string | undefined;\n  step?: number | string | undefined;\n  type?: string | undefined;\n  value?: string | ReadonlyArray<string> | number | undefined;\n  width?: number | string | undefined;\n  onChange?: ChangeEventHandler<T> | undefined;\n}\n```\n\n如果我们需要直接操作DOM，就可能会用到元素属性类型，常见的元素属性类型如下：\n\n- HTML属性类型：`HTMLAttributes`\n- 按钮属性类型：`ButtonHTMLAttributes`\n- 表单属性类型：`FormHTMLAttributes`\n- 图片属性类型：`ImgHTMLAttributes`\n- 输入框属性类型：`InputHTMLAttributes`\n- 链接属性类型：`LinkHTMLAttributes`\n- meta属性类型：`MetaHTMLAttributes`\n- 选择框属性类型：`SelectHTMLAttributes`\n- 表格属性类型：`TableHTMLAttributes`\n- 输入区属性类型：`TextareaHTMLAttributes`\n- 视频属性类型：`VideoHTMLAttributes`\n- SVG属性类型：`SVGAttributes`\n- WebView属性类型：`WebViewHTMLAttributes`\n\n一般情况下，我们是很少需要在项目中显式的去定义标签属性的类型。如果子级去封装组件库的话，这些属性就能发挥它们的作用了。来看例子（来源于网络，仅供学习）：\n\n```tsx\nimport React from 'react';\nimport classNames from 'classnames'\n\nexport enum ButtonSize {\n    Large = 'lg',\n    Small = 'sm'\n}\n\nexport enum ButtonType {\n    Primary = 'primary',\n    Default = 'default',\n    Danger = 'danger',\n    Link = 'link'\n}\n\ninterface BaseButtonProps {\n    className?: string;\n    disabled?: boolean;\n    size?: ButtonSize;\n    btnType?: ButtonType;\n    children: React.ReactNode;\n    href?: string;\n}\n\ntype NativeButtonProps = BaseButtonProps & React.ButtonHTMLAttributes<HTMLButtonElement> // 使用 交叉类型（&） 获得我们自己定义的属性和原生 button 的属性\ntype AnchorButtonProps = BaseButtonProps & React.AnchorHTMLAttributes<HTMLAnchorElement> // 使用 交叉类型（&） 获得我们自己定义的属性和原生 a标签 的属性\n\nexport type ButtonProps = Partial<NativeButtonProps & AnchorButtonProps> //使用 Partial<> 使两种属性可选\n\nconst Button: React.FC<ButtonProps> = (props) => {\n    const { disabled, className, size, btnType, children, href, ...restProps } = props;\n\n    const classes = classNames('btn', className, {\n        [`btn-${btnType}`]: btnType,\n        [`btn-${size}`]: size,\n        'disabled': (btnType === ButtonType.Link) && disabled  // 只有 a 标签才有 disabled 类名，button没有\n    })\n\n    if(btnType === ButtonType.Link && href) {\n        return (\n            <a \n             className={classes}\n             href={href}\n             {...restProps}\n            >\n                {children}\n            </a>\n        )\n    } else {\n        return (\n            <button \n             className={classes}\n             disabled={disabled} // button元素默认有disabled属性，所以即便没给他设置样式也会和普通button有一定区别\n             {...restProps}\n            >\n              {children}\n            </button>\n        )\n    }\n}\n\nButton.defaultProps = {\n    disabled: false,\n    btnType: ButtonType.Default\n}\n\nexport default Button;\n```\n\n这段代码就是用来封装一个buttom按钮，在button的基础上添加了一些自定义属性，比如上面将button的类型使用交叉类型（&）获得自定义属性和原生 button 属性 ：\n\n```tsx\ntype NativeButtonProps = BaseButtonProps & React.ButtonHTMLAttributes<HTMLButtonElement>\n```\n\n可以看到，标签属性类型在封装组件库时还是很有用的，更多用途可以自己探索~\n\n## 工具泛型\n\n在项目中使用一些工具泛型可以提高我们的开发效率，少写很多类型定义。下面来看看有哪些常见的工具泛型，以及其使用方式。\n\n### Partial\n\nPartial 作用是将传入的属性变为可选项。适用于对类型结构不明确的情况。它使用了两个关键字：keyof和in，先来看看他们都是什么含义。keyof 可以用来取得接口的所有 key 值：\n\n```tsx\n\ninterface IPerson {\n  name: string;\n  age: number;\n  height: number;\n}\ntype T = keyof IPerson\n// T 类型为： \"name\" | \"age\" | \"number\"\n\n```\n\nin关键字可以遍历枚举类型,：\n\n```tsx\ntype Person = \"name\" | \"age\" | \"number\"\ntype Obj =  {\n  [p in Keys]: any\n}\n// Obj类型为： { name: any, age: any, number: any }\n```\n\nkeyof 可以产生联合类型, in 可以遍历枚举类型, 所以经常一起使用, 下面是Partial工具泛型的定义：\n\n```tsx\n/**\n- Make all properties in T optional\n- 将T中的所有属性设置为可选\n */\ntype Partial<T> = {\n    [P in keyof T]?: T[P];\n};\n```\n\n这里，keyof T 获取 T 所有属性名, 然后使用 in 进行遍历, 将值赋给 P, 最后 T[P] 取得相应属性的值。中间的?就用来将属性设置为可选。\n\n使用示例如下：\n\n```tsx\n\ninterface IPerson {\n  name: string;\n  age: number;\n  height: number;\n}\n\nconst person: Partial<IPerson> = {\n  name: \"zhangsan\";\n}\n```\n\n### Required\n\n> Required 的作用是将传入的属性变为必选项，和上面的工具泛型恰好相反，其声明如下：\n\n```tsx\n\n/**\n- Make all properties in T required\n- 将T中的所有属性设置为必选\n */\ntype Required<T> = {\n    [P in keyof T]-?: T[P];\n};\n```\n\n可以看到，这里使用-?将属性设置为必选，可以理解为减去问号。适用形式和上面的Partial差不多：\n\n```tsx\n\ninterface IPerson {\n  name?: string;\n  age?: number;\n  height?: number;\n}\n\nconst person: Required<IPerson> = {\n  name: \"zhangsan\";\n  age: 18;\n  height: 180;\n}\n```\n\n### Readonly\n\n> 将T类型的所有属性设置为只读（readonly），构造出来类型的属性不能被再次赋值。Readonly的声明形式如下：\n\n```tsx\n\n/**\n- Make all properties in T readonly\n */\ntype Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n};\n\n使用示例如下：\n\ninterface IPerson {\n  name: string;\n  age: number;\n}\n\nconst person: Readonly<IPerson> = {\n  name: \"zhangsan\",\n  age: 18\n}\n\nperson.age = 20;  //  Error: cannot reassign a readonly property\n```\n\n可以看到，通过 Readonly 将IPerson的属性转化成了只读，不能再进行赋值操作。\n\n### Pick<T, K extends keyof T>\n\n> 从T类型中挑选部分属性K来构造新的类型。它的声明形式如下：\n\n```tsx\n\n/**\n\n- From T, pick a set of properties whose keys are in the union K\n */\ntype Pick<T, K extends keyof T> = {\n    [P in K]: T[P];\n};\n\n使用示例如下：\n\ninterface IPerson {\n  name: string;\n  age: number;\n  height: number;\n}\n\nconst person: Pick<IPerson, \"name\" | \"age\"> = {\n  name: \"zhangsan\",\n  age: 18\n}\n```\n\n### Record<K extends keyof any, T>\n\n> Record 用来构造一个类型，其属性名的类型为K，属性值的类型为T。这个工具泛型可用来将某个类型的属性映射到另一个类型上，下面是其声明形式：\n\n```tsx\n\n/**\n\n- Construct a type with a set of properties K of type T\n */\ntype Record<K extends keyof any, T> = {\n    [P in K]: T;\n};\n\n```\n\n使用示例如下：\n\n```tsx\n\ninterface IPageinfo {\n    title: string;\n}\n\ntype IPage = 'home' | 'about' | 'contact';\n\nconst page: Record<IPage, IPageinfo> = {\n    about: {title: 'about'},\n    contact: {title: 'contact'},\n    home: {title: 'home'},\n}\n\n```\n\n### Exclude<T, U>\n\nExclude 就是从一个联合类型中排除掉属于另一个联合类型的子集，下面是其声明的形式：\n\n```tsx\n\n/**\n\n- Exclude from T those types that are assignable to U\n */\ntype Exclude<T, U> = T extends U ? never : T;\n\n使用示例如下：\n\ninterface IPerson {\n  name: string;\n  age: number;\n  height: number;\n}\n\nconst person: Exclude<IPerson, \"age\" | \"sex\"> = {\n  name: \"zhangsan\";\n  height: 180;\n}\n```\n\n### Omit<T, K extends keyof any>\n\n上面的Pick 和 Exclude 都是最基础基础的工具泛型，很多时候用 Pick 或者 Exclude 还不如直接写类型更直接。而 Omit 就基于这两个来做的一个更抽象的封装，它允许从一个对象中剔除若干个属性，剩下的就是需要的新类型。下面是它的声明形式：\n\n```tsx\n\n/**\n\n- Construct a type with the properties of T except for those in type K.\n */\ntype Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;\n\n使用示例如下：\n\ninterface IPerson {\n  name: string;\n  age: number;\n  height: number;\n}\n\nconst person: Omit<IPerson, \"age\" | \"height\"> = {\n  name: \"zhangsan\";\n}\n```\n\n### ReturnType\n\nReturnType会返回函数返回值的类型，其声明形式如下：\n\n```tsx\n\n/**\n\n- Obtain the return type of a function type\n */\ntype ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;\n```\n\n使用示例如下：\n\n```tsx\nfunction foo(type): boolean {\n  return type === 0\n}\n\ntype FooType = ReturnType<typeof foo>\n```\n\n> 使用 typeof 是为了获取 foo 的函数签名，等价于 (type: any) => boolean。\n\n## Axios 封装\n\n> 基于 Promise 的 HTTP 库，可以在浏览器和 node.js 中使用。Axios 具备以下特性：\n\n- 从浏览器中创建 XMLHttpRequests\n- 从 node.js 创建 HTTP 请求\n- 支持 Promise API\n- 拦截请求和响应\n- 转换请求数据和响应数据\n- 取消请求\n- 自动转换 JSON 数据\n- 客户端支持防御 XSRF\n\nAxios的基本使用就不再多介绍了。为了更好地调用，做一些全局的拦截，通常会对Axios进行封装，下面就使用TypeScript对Axios进行简单封装，使其同时能够有很好的类型支持。Axios是自带声明文件的，所以我们无需额外的操作。​\n\n下面来看基本的封装：\n\n```tsx\nimport axios, { AxiosInstance, AxiosRequestConfig, AxiosPromise,AxiosResponse } from 'axios'; // 引入axios和定义在node_modules/axios/index.ts文件里的类型声明\n\n // 定义接口请求类，用于创建axios请求实例\nclass HttpRequest {\n  // 接收接口请求的基本路径\n  constructor(public baseUrl: string) {\n    this.baseUrl = baseUrl;\n  }\n  \n  // 调用接口时调用实例的这个方法，返回AxiosPromise\n  public request(options: AxiosRequestConfig): AxiosPromise {\n    // 创建axios实例，它是函数，同时这个函数包含多个属性\n    const instance: AxiosInstance = axios.create()\n    // 合并基础路径和每个接口单独传入的配置，比如url、参数等\n    options = this.mergeConfig(options)\n    // 调用interceptors方法使拦截器生效\n    this.interceptors(instance, options.url)\n    // 返回AxiosPromise\n    return instance(options)\n  }\n  \n  // 用于添加全局请求和响应拦截\n  private interceptors(instance: AxiosInstance, url?: string) {\n    // 请求和响应拦截\n  }\n  \n  // 用于合并基础路径配置和接口单独配置\n  private mergeConfig(options: AxiosRequestConfig): AxiosRequestConfig {\n    return Object.assign({ baseURL: this.baseUrl }, options);\n  }\n}\nexport default HttpRequest;\n```\n\n通常baseUrl在开发环境的和生产环境的路径是不一样的，所以可以根据当前是开发环境还是生产环境做判断，应用不同的基础路径。这里要写在一个配置文件里：\n\n```tsx\nexport default {\n    api: {\n        devApiBaseUrl: '/test/api/xxx',\n        proApiBaseUrl: '/api/xxx',\n    },\n};\n```\n\n在上面的文件中引入这个配置：\n\n```tsx\n\nimport { api: { devApiBaseUrl, proApiBaseUrl } } from '@/config';\nconst apiBaseUrl = env.NODE_ENV === 'production' ? proApiBaseUrl : devApiBaseUrl;\n\n之后就可以将apiBaseUrl作为默认值传入HttpRequest的参数：\n\nclass HttpRequest {\n  constructor(public baseUrl: string = apiBaseUrl) {\n    this.baseUrl = baseUrl;\n  }\n\n接下来可以完善一下拦截器类，在类中interceptors方法内添加请求拦截器和响应拦截器，实现对所有接口请求的统一处理：\n\nprivate interceptors(instance: AxiosInstance, url?: string) {\n   // 请求拦截\n    instance.interceptors.request.use((config: AxiosRequestConfig) => {\n      // 接口请求的所有配置，可以在axios.defaults修改配置\n      return config\n    },\n    (error) => {\n      return Promise.reject(error)\n    })\n\n   // 响应拦截\n    instance.interceptors.response.use((res: AxiosResponse) => {\n      const { data } = res\n      const { code, msg } = data\n      if (code !== 0) {\n        console.error(msg)\n      }\n      return res\n    },\n    (error) => {\n      return Promise.reject(error)\n    })\n  }\n```\n\n到这里封装的就差不多了，一般服务端会将状态码、提示信息和数据封装在一起，然后作为数据返回，所以所有请求返回的数据格式都是一样的，所以就可以定义一个接口来指定返回的数据结构，可以定义一个接口：\n\n```ts\n\nexport interface ResponseData {\n  code: number\n  data?: any\n  msg: string\n}\n```\n\n接下来看看使用TypeScript封装的Axios该如何使用。可以先定义一个请求实例：\n\n```tsx\nimport HttpRequest from '@/utils/axios'\nexport * from '@/utils/axios'\nexport default new HttpRequest()\n```\n\n这里把请求类导入进来，默认导出这个类的实例。之后创建一个登陆接口请求方法：\n\n```tsx\nimport axios, { ResponseData } from './index'\nimport { AxiosPromise } from 'axios'\n\ninterface ILogin {\n  user: string;\n  password: number | string\n}\n\nexport const loginReq = (data: ILogin): AxiosPromise<ResponseData> => {\n  return axios.request({\n    url: '/api/user/login',\n    data,\n    method: 'POST'\n  })\n}\n```\n\n这里封装登录请求方法loginReq，他的参数必须是我们定义的ILogin接口的类型。这个方法返回一个类型为AxiosPromise的Promise，AxiosPromise是axios声明文件内置的类型，可以传入一个泛型变量参数，用于指定返回的结果中data字段的类型。​\n\n接下来可以调用一下这个登录的接口：\n\n```tsx\nimport { loginReq } from '@/api/user'\nconst Home: FC = () => {\n  const login = (params) => {\n   loginReq(params).then((res) => {\n     console.log(res.data.code)\n   })\n  }  \n}\n```\n\n通过这种方式，当我们调用loginReq接口时，就会提示我们，参数的类型是ILogin，需要传入几个参数。这样编写代码的体验就会好很多。\n\n## 其他\n\n### import React\n\n在React项目中使用TypeScript时，普通组件文件后缀为.tsx，公共方法文件后缀为.ts。在. tsx 文件中导入 React 的方式如下：\n\n```tsx\nimport * as React from 'react'\nimport * as ReactDOM from 'react-dom'\n```\n\n这是一种面向未来的导入方式，如果想在项目中使用以下导入方式：\n\n```tsx\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\n```\n\n就需要在tsconfig.json配置文件中进行如下配置：\n\n```tsx\n\n\"compilerOptions\": {\n    // 允许默认从没有默认导出的模块导入。\n    \"allowSyntheticDefaultImports\": true,\n}\n\n```\n\n### Types or Interfaces？\n\n> 在定义公共 API 时(比如编辑一个库）使用 interface，这样可以方便使用者继承接口，这样允许使用最通过声明合并来扩展它们；\n> 在定义组件属性（Props）和状态（State）时，建议使用 type，因为 type 的约束性更强。\n> interface 和 type 在 ts 中是两个不同的概念，但在 React 大部分使用的 case 中，interface 和 type 可以达到相同的功能效果，type 和 interface 最大的区别是：type 类型不能二次编辑，而 interface 可以随时扩展：\n\n```ts\n\ninterface Animal {\n  name: string\n}\n\n// 可以继续在原属性基础上，添加新属性：color\ninterface Animal {\n  color: string\n}\n\ntype Animal = {\n  name: string\n}\n// type类型不支持属性扩展\n// Error: Duplicate identifier 'Animal'\ntype Animal = {\n  color: string\n}\n\n```\n\n> type对于联合类型是很有用的，比如：type Type = TypeA | TypeB。而interface更适合声明字典类行，然后定义或者扩展它。\n\n### 懒加载类型\n\n> 如果我们想在React router中使用懒加载，React也为我们提供了懒加载方法的类型，来看下面的例子：\n\n```tsx\n\nexport interface RouteType {\n    pathname: string;\n    component: LazyExoticComponent<any>;\n    exact: boolean;\n    title?: string;\n    icon?: string;\n    children?: RouteType[];\n}\nexport const AppRoutes: RouteType[] = [\n    {\n        pathname: '/login',\n        component: lazy(() => import('../views/Login/Login')),\n        exact: true\n    },\n    {\n        pathname: '/404',\n        component: lazy(() => import('../views/404/404')),\n        exact: true,\n    },\n    {\n        pathname: '/',\n        exact: false,\n        component: lazy(() => import('../views/Admin/Admin'))\n    }\n]\n\n```\n\n下面是懒加载类型和lazy方法在声明文件中的定义：\n\n```tsx\ntype LazyExoticComponent<T extends ComponentType<any>> = ExoticComponent<ComponentPropsWithRef<T>> & {\n  readonly _result: T;\n};\n\nfunction lazy<T extends ComponentType<any>>(\nfactory: () => Promise<{ default: T }>\n): LazyExoticComponent<T>;\n```\n\n### 类型断言\n\n类型断言（Type Assertion）可以用来手动指定一个值的类型。在React项目中，断言还是很有用的，。有时候推断出来的类型并不是真正的类型，很多时候我们可能会比TS更懂我们的代码，所以可以使用断言（使用as关键字）来定义一个值得类型。​\n\n来看下面的例子：\n\n```tsx\n\nconst getLength = (target: string | number): number => {\n  if (target.length) { // error 类型\"string | number\"上不存在属性\"length\"\n    return target.length; // error  类型\"number\"上不存在属性\"length\"\n  } else {\n    return target.toString().length;\n  }\n};\n```\n\n当TypeScript不确定一个联合类型的变量到底是哪个类型时，就只能访问此联合类型的所有类型里共有的属性或方法，所以现在加了对参数target和返回值的类型定义之后就会报错。这时就可以使用断言，将target的类型断言成string类型：\n\n```tsx\n\nconst getStrLength = (target: string | number): number => {\n  if ((target as string).length) {\n    return (target as string).length;\n  } else {\n    return target.toString().length;\n  }\n};\n\n```\n\n需要注意，类型断言并不是类型转换，断言成一个联合类型中不存在的类型是不允许的。​\n\n再来看一个例子，在调用一个方法时传入参数：\n![](/__assets__/img/2022-02-09-11-20-44.png)\n 这里就提示我们这个参数可能是undefined，而通过业务知道这个值是一定存在的，所以就可以将它断言成数字：data?.subjectId as number​\n\n除此之外，上面所说的标签类型、组件类型、时间类型都可以使用断言来指定给一些数据，还是要根据实际的业务场景来使用。​\n\n感悟：使用类型断言真的能解决项目中的很多报错~\n\n### 枚举类型\n\n枚举类型在项目中的作用也是不可忽视的，使用枚举类型可以让代码的扩展性更好，当我想更改某属性值时，无需去全局更改这个属性，只要更改枚举中的值即可。通常情况下，最好新建一个文件专门来定义枚举值，便于引用\n","children":[]}]},{"name":"UmiJS","path":"../guanruihua.github.io/React","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/React/UmiJS","data":"# UmiJS\n\n> [介绍 | UmiJS](https://v2.umijs.org/zh/guide/#特性)\n\n","children":[]}]},{"name":"warning.md","path":"../guanruihua.github.io/React","data":"# [`warning`]()\r\n\r\n## Warning: A component is `contentEditable` and contains `children` managed by React\r\n\r\n> 当在 react jsx中，给标签设置可编辑的属性contentEditable，页面会弹出警告\r\n\r\n`A component is contentEditable and contains children managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.`\r\n\r\n```jsx\r\n<div \r\n className=\"num\" \r\n suppressContentEditableWarning \r\n contentEditable=\"true\" \r\n orignalnum={item.userNum}>\r\n {item.userNum}\r\n</div>\r\n```\r\n","children":[]},{"name":"_sidebar.md","path":"../guanruihua.github.io/React","data":"* antd\n  * v2\n    * [select](antd/v2/select.md)\n* basis\n  * [createElement](basis/createElement.md)\n  * [react-basis](basis/react-basis.md)\n* [begin](begin.md)\n* hook\n  * [context](hook/context/index.md)\n    * [home](hook/context/index.md)\n  * [hook](hook/hook.md)\n  * [Umi-hooks](hook/Umi-hooks.md)\n* [package](package.md)\n* [question](question/index.md)\n  * [home](question/index.md)\n* [react-demo](react-demo.md)\n* [react-v18](react-v18.md)\n* router\n  * [react_router](router/react_router.md)\n  * [v6](router/v6.md)\n* SSR\n  * [next](SSR/next.md)\n* [type](type/index.md)\n  * [home](type/index.md)\n* typescript\n  * [react使用ts](typescript/react使用ts.md)\n* [UmiJS](UmiJS/index.md)\n  * [home](UmiJS/index.md)\n* [使用css_var](使用css_var.md)\n* 内置API\n  * [React.children.map()](内置API/React.children.map().md)\n* [内置ts类型](内置ts类型/index.md)\n  * [home](内置ts类型/index.md)\n* [原理实现](原理实现/index.md)\n  * [home](原理实现/index.md)\n* [懒加载](懒加载.md)\n* 状态管理\n  * dva\n    * [api](状态管理/dva/api.md)\n    * [dva-basic](状态管理/dva/dva-basic.md)\n    * dva-expand\n      * [dva-tsx](状态管理/dva/dva-expand/dva-tsx.md)\n      * [优化](状态管理/dva/dva-expand/优化.md)\n    * [extend](状态管理/dva/extend.md)\n    * [快速上手](状态管理/dva/快速上手.md)\n  * [mobx](状态管理/mobx.md)\n  * [redux](状态管理/redux/index.md)\n    * [home](状态管理/redux/index.md)\n    * [React_Redux_React-redux](状态管理/redux/React_Redux_React-redux.md)\n    * [redux-toolkit](状态管理/redux/redux-toolkit.md)\n","children":[]},{"name":"使用css_var.md","path":"../guanruihua.github.io/React","data":"# React 使用 css var\n\n### less 使用css `var()`\n\n```css\n// 变量申明和计算\n@pre-primary-color: #f00;\n\nbody {\n  --pirmary-color: tint(@pre-primary-color, 20%);\n}\n\n@primary: var(--pirmary-color);\n\n// 使用\ndiv {\n  color: @primary;\n}\n```\n","children":[]},{"name":"内置API","path":"../guanruihua.github.io/React","data":"","children":[{"name":"React.children.map().md","path":"../guanruihua.github.io/React/内置API","data":"# React.children.map()\n\n> 获取子组件进行拷贝子组件添加新属性以便生成新组件的操\n\n```tsx\nclass Child extends Component {\n    componentDidMount() {\n        console.log(\n            React.Children.map(this.props.children, item => {\n                return [item, [item]];\n            })\n        );\n    }\n\n    render() {\n        return (\n            <div>\n                {React.Children.map(this.props.children, item => [\n                    item,\n                    [item]\n                ])}\n            </div>\n        );\n    }\n}\n\nclass ChildrenMap extends Component {\n    constructor(props) {\n        super(props);\n    }\n\n    render() {\n        return (\n            <Child>\n                <div>1</div>\n                <div>2</div>\n            </Child>\n        );\n    }\n}\n\nexport default ChildrenMap\n```\n","children":[]}]},{"name":"内置ts类型","path":"../guanruihua.github.io/React","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/React/内置ts类型","data":"# React 内置类型\n\n## React.ReactNode和React.Element\n\n## ReactNode | undefined\n\n```tsx\ntype ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined;\n```\n\n> `type ReactFragment = {} | ReactNodeArray;`:就是<>xxx</>或者`<React.Fragament>xxx<React.Fragament/>`\n\n```tsx\ninterface ReactPortal extends ReactElement {\n    key: Key | null;\n    children: ReactNode;\n}\n```\n\n> 就是ReactDOM.createPortal(child, container)这个API的返回值\n\n```ts\nexport function createPortal(children: ReactNode, container: Element, key?: null | string): ReactPortal;\ntype ReactText = string | number;\ntype ReactChild = ReactElement | ReactText;\n```\n\n> ReactNode是一个联合类型，囊括了ReactElement\n\n```tsx\ninterface ReactElement<P = any, T extends string | JSXElementConstructor<any> = string | JSXElementConstructor<any>> {\n    type: T;\n    props: P;\n    key: Key | null;\n}\n```\n\n> 写上***(child as ReactElement).props***就不会报错\n\n```tsx\nfunction createElement<P extends {}>(\n    type: FunctionComponent<P> | ComponentClass<P> | string,\n    props?: Attributes & P | null,\n    ...children: ReactNode[]): ReactElement<P>;\n```\n\n> ReactElement: createElement的返回值\n\n```tsx\n// DOM Elements\n// TODO: generalize this to everything in `keyof ReactHTML`, not just \"input\"\nfunction createElement(\n    type: \"input\",\n    props?: InputHTMLAttributes<HTMLInputElement> & ClassAttributes<HTMLInputElement> | null,\n    ...children: ReactNode[]): DetailedReactHTMLElement<InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>;\nfunction createElement<P extends HTMLAttributes<T>, T extends HTMLElement>(\n    type: keyof ReactHTML,\n    props?: ClassAttributes<T> & P | null,\n    ...children: ReactNode[]): DetailedReactHTMLElement<P, T>;\nfunction createElement<P extends SVGAttributes<T>, T extends SVGElement>(\n    type: keyof ReactSVG,\n    props?: ClassAttributes<T> & P | null,\n    ...children: ReactNode[]): ReactSVGElement;\nfunction createElement<P extends DOMAttributes<T>, T extends Element>(\n    type: string,\n    props?: ClassAttributes<T> & P | null,\n    ...children: ReactNode[]): DOMElement<P, T>;\n\n// Custom components\n\nfunction createElement<P extends {}>(\n    type: FunctionComponent<P>,\n    props?: Attributes & P | null,\n    ...children: ReactNode[]): FunctionComponentElement<P>;\nfunction createElement<P extends {}>(\n    type: ClassType<P, ClassicComponent<P, ComponentState>, ClassicComponentClass<P>>,\n    props?: ClassAttributes<ClassicComponent<P, ComponentState>> & P | null,\n    ...children: ReactNode[]): CElement<P, ClassicComponent<P, ComponentState>>;\nfunction createElement<P extends {}, T extends Component<P, ComponentState>, C extends ComponentClass<P>>(\n    type: ClassType<P, T, C>,\n    props?: ClassAttributes<T> & P | null,\n    ...children: ReactNode[]): CElement<P, T>;\nfunction createElement<P extends {}>(\n    type: FunctionComponent<P> | ComponentClass<P> | string,\n    props?: Attributes & P | null,\n    ...children: ReactNode[]): ReactElement<P>;\n```\n\n> - `DOMElement<P, T>，FunctionComponentElement啊，CElement<P, ClassicComponent<P, ComponentState>>`, 都是 extends ReactElement,  所以得出`ReactElement`是由`React.createElement()`这个API创建出来的类型，根本上是一个Js对象，如上图所示，在Jsx里面以自定义组件的形式呈现，比如`<MyComponent />`，这就是一个ReactElement，而`<div />`，也是一个`ReactElement`\n> - 被React渲染到浏览器上的东西，可以理解为VDOM上的每个节点，都是是ReactNode\n\n```tsx\n\nconst Parent = () => {\n  return (\n   <>\n      <div>\n        <Child />\n      <div/>\n    </>\n  )\n}\n\nconst Child = () => {\n  return (\n   <>\n      <div>\n       我是孩子\n      <div/>\n    </>\n  )\n}\n\nReactDOM.render(\n    <Parent />,\n    document.getElementById('root')\n)\n```\n\n> React.FC的返回值是ReactElement\n\n```ts\ninterface FunctionComponent<P = {}> {\n    (props: PropsWithChildren<P>, context?: any): ReactElement<any, any> | null;\n    propTypes?: WeakValidationMap<P> | undefined;\n    contextTypes?: ValidationMap<any> | undefined;\n    defaultProps?: Partial<P> | undefined;\n    displayName?: string | undefined;\n}\n```\n\n> 返回的类型是明确的ReactElement, 看之前createElement源码部分，有对自定义组件的说明。(当然其实也可以理解为返回ReactNode,因为Element是Node的子集，但还是根据源码准确点好, 因为可以注意类组件的render方法和函数声明方式写的组件，他们渲染的类型都是JSX.Element，也就是说 JSX.Element == ReactElement)\n\n到这，虽然写的有点啰嗦，但我们要知其然并知其所以然嘛。\n\n## 事件处理\n\n> 事件处理, event事件对象类型\n\n```tsx\n\nconst onChange = (e) {\n  console.log(e.target.value)\n}\n```\n\n> 受控表单一般都会这么写是吧，但如果你不给e限定类型他就会报错，说e这个类型没有target嘛，这个好解决，cmd点进去看这些合成事件就能看到，大部分啥`ChangeEvent,MouseEvent`\n\n- 剪切板事件对象`:ClipboardEvent<T = Element>`\n\n- 拖拽事件对象:`DragEvent<T = Element>`\n\n- 焦点事件对象:`FocusEvent<T = Element>`\n\n- 表单事件对象:`FormEvent<T = Element>`\n\n- Change事件对象:`ChangeEvent<T = Element>`\n\n- 键盘事件对象:`KeyboardEvent<T = Element>`\n\n- 鼠标事件对象:`MouseEvent<T = Element, E = NativeMouseEvent>`\n\n- 触摸事件对象:`TouchEvent<T = Element>`\n\n- 滚轮事件对象:`WheelEvent<T = Element>`\n\n- 动画事件对象:`AnimationEvent<T = Element>`\n\n- 过渡事件对象:`TransitionEvent<T = Element>`\n\n就比如说我之前写受控表单的时候就是这么写的\n![](/__assets__/img/2022-02-12-19-15-22.png)\n> 处理表单嘛，所以泛型给的就是HTMLInputElement\n\n这里注意到，onChange这个合成事件的类型是啥？ 老长一串，哎，这也直接看简单的声明吧\n\n```tsx\ntype EventHandler<E extends SyntheticEvent<any>> = { \n    bivarianceHack(event: E): void \n}[\"bivarianceHack\"];\n\ntype ReactEventHandler<T = Element> = EventHandler<SyntheticEvent<T>>;\n// 剪切板事件处理函数\ntype ClipboardEventHandler<T = Element> = EventHandler<ClipboardEvent<T>>;\n// 复合事件处理函数\ntype CompositionEventHandler<T = Element> = EventHandler<CompositionEvent<T>>;\n// 拖拽事件处理函数\ntype DragEventHandler<T = Element> = EventHandler<DragEvent<T>>;\n// 焦点事件处理函数\ntype FocusEventHandler<T = Element> = EventHandler<FocusEvent<T>>;\n// 表单事件处理函数\ntype FormEventHandler<T = Element> = EventHandler<FormEvent<T>>;\n// Change事件处理函数\ntype ChangeEventHandler<T = Element> = EventHandler<ChangeEvent<T>>;\n// 键盘事件处理函数\ntype KeyboardEventHandler<T = Element> = EventHandler<KeyboardEvent<T>>;\n// 鼠标事件处理函数\ntype MouseEventHandler<T = Element> = EventHandler<MouseEvent<T>>;\n// 触屏事件处理函数\ntype TouchEventHandler<T = Element> = EventHandler<TouchEvent<T>>;\n// 指针事件处理函数\ntype PointerEventHandler<T = Element> = EventHandler<PointerEvent<T>>;\n// 界面事件处理函数\ntype UIEventHandler<T = Element> = EventHandler<UIEvent<T>>;\n// 滚轮事件处理函数\ntype WheelEventHandler<T = Element> = EventHandler<WheelEvent<T>>;\n// 动画事件处理函数\ntype AnimationEventHandler<T = Element> = EventHandler<AnimationEvent<T>>;\n// 过渡事件处理函数\ntype TransitionEventHandler<T = Element> = EventHandler<TransitionEvent<T>>;\n```\n\n> 编译器一般会有提示，vscode是有的，就比如我们写onChange类型的时候写个Change,后面的EventHandler应该会自动弹出来，实在不行也就直接cmd点进去看源码算了。\n\n## HTML标签类型\n\n> 所有的HTML标签类型都定义在了 node_moudles/@types/react/global.d.ts\n\n### 常见的大概有\n\n- `a`: `HTMLAnchorElement`\n- `body`: `HTMLBodyElement`\n- `br`: `HTMLBRElement`\n- `button`: `HTMLButtonElement`\n- `div`: `HTMLDivElement`\n- `h1`: `HTMLHeadingElement`\n- `h2`: `HTMLHeadingElement`\n- `h3`: `HTMLHeadingElement`\n- `html`: `HTMLHtmlElement`\n- `img`: `HTMLImageElement`\n- `input`: `HTMLInputElement`\n- `ul`: `HTMLUListElement`\n- `li`: `HTMLLIElement`\n- `link`: `HTMLLinkElement`\n- `p`: `HTMLParagraphElement`\n- `span`: `HTMLSpanElement`\n- `style`: `HTMLStyleElement`\n- `table`: `HTMLTableElement`\n- `tbody`: `HTMLTableSectionElement`\n- `video`: `HTMLVideoElement`\n- `audio`: `HTMLAudioElement`\n- `meta`: `HTMLMetaElement`\n- `form`: `HTMLFormElement`\n\n> 然后每个标签都还有自己的属性类型，不过用的不多，一般在自己封装原生组件的库的时候会用到(比如antd的Radio组件)，简单了解下\n\n- HTML属性类型:`HTMLAttributes`\n- 按钮属性类型:`ButtonHTMLAttributes`\n- 表单属性类型:`FormHTMLAttributes`\n- 图片属性类型:`ImgHTMLAttributes`\n- 输入框属性类型:`InputHTMLAttributes`\n- 链接属性类型:`LinkHTMLAttributes`\n- meta属性类型:`MetaHTMLAttributes`\n- 选择框属性类型:`SelectHTMLAttributes`\n- 表格属性类型:`TableHTMLAttributes`\n- 输入区属性类型:`TextareaHTMLAttributes`\n- 视频属性类型:`VideoHTMLAttributes`\n- SVG属性类型:`SVGAttributes`\n- WebView属性类型:`WebViewHTMLAttributes`\n","children":[]}]},{"name":"原理实现","path":"../guanruihua.github.io/React","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/React/原理实现","data":"# react 实现原理\r\n","children":[]}]},{"name":"懒加载.md","path":"../guanruihua.github.io/React","data":"# 懒加载\n\n> <https://www.cnblogs.com/forcheng/p/13132582.html>\n\n1.代码分割\n\n（1）为什么要进行代码分割？\n\n现在前端项目基本都采用打包技术，比如 Webpack，JS逻辑代码打包后会产生一个 bundle.js 文件，而随着我们引用的第三方库越来越多或业务逻辑代码越来越复杂，相应打包好的 bundle.js 文件体积就会越来越大，因为需要先请求加载资源之后，才会渲染页面，这就会严重影响到页面的首屏加载。\n\n而为了解决这样的问题，避免大体积的代码包，我们则可以通过技术手段对代码包进行分割，能够创建多个包并在运行时动态地加载。现在像 Webpack、 Browserify等打包器都支持代码分割技术。\n\n（2）什么时候应该考虑进行代码分割？\n\n这里举一个平时开发中可能会遇到的场景，比如某个体积相对比较大的第三方库或插件（比如JS版的PDF预览库）只在单页应用（SPA）的某一个不是首页的页面使用了，这种情况就可以考虑代码分割，增加首屏的加载速度。\n\n2.React的懒加载\n\n示例代码：\n\n```jsx\nimport React, { Suspense } from 'react';\n\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\n\nfunction MyComponent() {\n  return (\n    <div>\n      <Suspense fallback={<div>Loading...</div>}>\n        <OtherComponent />\n      </Suspense>\n    </div>\n  );\n}\n```\n\n如上代码中，通过 import()、React.lazy 和 Suspense 共同一起实现了 React 的懒加载，也就是我们常说了运行时动态加载，即 OtherComponent 组件文件被拆分打包为一个新的包（bundle）文件，并且只会在 OtherComponent 组件渲染时，才会被下载到本地。\n\n那么上述中的代码拆分以及动态加载究竟是如何实现的呢？让我们来一起探究其原理是怎样的。\n\nimport() 原理\n\nimport() 函数是由TS39提出的一种动态加载模块的规范实现，其返回是一个 promise。在浏览器宿主环境中一个import()的参考实现如下：\n\n```jsx\nfunction import(url) {\n  return new Promise((resolve, reject) => {\n    const script = document.createElement(\"script\");\n    const tempGlobal = \"__tempModuleLoadingVariable\" + Math.random().toString(32).substring(2);\n    script.type = \"module\";\n    script.textContent = `import * as m from \"${url}\"; window.${tempGlobal} = m;`;\n\n    script.onload = () => {\n      resolve(window[tempGlobal]);\n      delete window[tempGlobal];\n      script.remove();\n    };\n\n    script.onerror = () => {\n      reject(new Error(\"Failed to load module script with URL \" + url));\n      delete window[tempGlobal];\n      script.remove();\n    };\n\n    document.documentElement.appendChild(script);\n  });\n}\n```\n\n当 Webpack 解析到该import()语法时，会自动进行代码分割。\n\nReact.lazy 原理\n\n以下 React 源码基于 16.8.0 版本\n\nReact.lazy 的源码实现如下：\n\n```tsx\n\nexport function lazy<T, R>(ctor: () => Thenable<T, R>): LazyComponent<T> {\n  let lazyType = {\n    $$typeof: REACT_LAZY_TYPE,\n    _ctor: ctor,\n    // React uses these fields to store the result.\n    _status: -1,\n    _result: null,\n  };\n\n  return lazyType;\n}\n```\n\n可以看到其返回了一个 LazyComponent 对象。\n\n而对于 LazyComponent 对象的解析：\n\n```tsx\n\n...\ncase LazyComponent: {\n  const elementType = workInProgress.elementType;\n  return mountLazyComponent(\n    current,\n    workInProgress,\n    elementType,\n    updateExpirationTime,\n    renderExpirationTime,\n  );\n}\n...\nfunction mountLazyComponent(\n  _current,\n  workInProgress,\n  elementType,\n  updateExpirationTime,\n  renderExpirationTime,\n) {\n  ...\n  let Component = readLazyComponentType(elementType);\n  ...\n}\n// Pending = 0, Resolved = 1, Rejected = 2\nexport function readLazyComponentType<T>(lazyComponent: LazyComponent<T>): T {\n  const status = lazyComponent._status;\n  const result = lazyComponent._result;\n  switch (status) {\n    case Resolved: {\n      const Component: T = result;\n      return Component;\n    }\n    case Rejected: {\n      const error: mixed = result;\n      throw error;\n    }\n    case Pending: {\n      const thenable: Thenable<T, mixed> = result;\n      throw thenable;\n    }\n    default: { // lazyComponent 首次被渲染\n      lazyComponent._status = Pending;\n      const ctor = lazyComponent._ctor;\n      const thenable = ctor();\n      thenable.then(\n        moduleObject => {\n          if (lazyComponent._status === Pending) {\n            const defaultExport = moduleObject.default;\n            lazyComponent._status = Resolved;\n            lazyComponent._result = defaultExport;\n          }\n        },\n        error => {\n          if (lazyComponent._status === Pending) {\n            lazyComponent._status = Rejected;\n            lazyComponent._result = error;\n          }\n        },\n      );\n      // Handle synchronous thenables.\n      switch (lazyComponent._status) {\n        case Resolved:\n          return lazyComponent._result;\n        case Rejected:\n          throw lazyComponent._result;\n      }\n      lazyComponent._result = thenable;\n      throw thenable;\n    }\n  }\n}\n```\n\n注：如果 readLazyComponentType 函数多次处理同一个 lazyComponent，则可能进入Pending、Rejected等 case 中。\n\n从上述代码中可以看出，对于最初 React.lazy() 所返回的 LazyComponent 对象，其 _status 默认是 -1，所以首次渲染时，会进入 readLazyComponentType 函数中的 default 的逻辑，这里才会真正异步执行 import(url)操作，由于并未等待，随后会检查模块是否 Resolved，如果已经Resolved了（已经加载完毕）则直接返回moduleObject.default（动态加载的模块的默认导出），否则将通过 throw 将 thenable 抛出到上层。\n\n为什么要 throw 它？这就要涉及到 Suspense 的工作原理，我们接着往下分析。\n\nSuspense 原理\n\n由于 React 捕获异常并处理的代码逻辑比较多，这里就不贴源码，感兴趣可以去看 throwException 中的逻辑，其中就包含了如何处理捕获的异常。简单描述一下处理过程，React 捕获到异常之后，会判断异常是不是一个 thenable，如果是则会找到 SuspenseComponent ，如果 thenable 处于 pending 状态，则会将其 children 都渲染成 fallback 的值，一旦 thenable 被 resolve 则 SuspenseComponent 的子组件会重新渲染一次。\n\n为了便于理解，我们也可以用 componentDidCatch 实现一个自己的 Suspense 组件，如下：\n\n```tsx\nclass Suspense extends React.Component {\n  state = {\n    promise: null\n  }\n\n  componentDidCatch(err) {\n    // 判断 err 是否是 thenable\n    if (err !== null && typeof err === 'object' && typeof err.then === 'function') {\n      this.setState({ promise: err }, () => {\n        err.then(() => {\n          this.setState({\n            promise: null\n          })\n        })\n      })\n    }\n  }\n\n  render() {\n    const { fallback, children } = this.props\n    const { promise } = this.state\n    return <>{ promise ? fallback : children }</>\n  }\n}\n```\n\n小结\n\n至此，我们分析完了 React 的懒加载原理。简单来说，React利用 React.lazy与import()实现了渲染时的动态加载 ，并利用Suspense来处理异步加载资源时页面应该如何显示的问题。\n","children":[]},{"name":"状态管理","path":"../guanruihua.github.io/React","data":"","children":[{"name":"dva","path":"../guanruihua.github.io/React/状态管理","data":"","children":[{"name":"api.md","path":"../guanruihua.github.io/React/状态管理/dva","data":"# dva_api\n\n## [#](https://dvajs.com/api/#输出文件)输出文件\n\n### [#](https://dvajs.com/api/#dva)dva\n\n默认输出文件。\n\n### [#](https://dvajs.com/api/#dva-router)dva/router\n\n默认输出 [react-router](https://github.com/ReactTraining/react-router) 接口， [react-router-redux](https://github.com/reactjs/react-router-redux) 的接口通过属性 routerRedux 输出。\n\n比如：\n\n```js\nimport { Router, Route, routerRedux } from 'dva/router';\n```\n\n### [#](https://dvajs.com/api/#dva-fetch)dva/fetch\n\n异步请求库，输出 [isomorphic-fetch](https://github.com/matthew-andrews/isomorphic-fetch) 的接口。不和 dva 强绑定，可以选择任意的请求库。\n\n### [#](https://dvajs.com/api/#dva-saga)dva/saga\n\n输出 [redux-saga](https://github.com/yelouafi/redux-saga) 的接口，主要用于用例的编写。（用例中需要用到 effects）\n\n### [#](https://dvajs.com/api/#dva-dynamic)dva/dynamic\n\n解决组件动态加载问题的 util 方法。\n\n比如：\n\n```js\nimport dynamic from 'dva/dynamic';\n\nconst UserPageComponent = dynamic({\n  app,\n  models: () => [\n    import('./models/users'),\n  ],\n  component: () => import('./routes/UserPage'),\n});\n```\n\n`opts` 包含：\n\n- app: dva 实例，加载 models 时需要\n- models: 返回 Promise 数组的函数，Promise 返回 dva model\n- component：返回 Promise 的函数，Promise 返回 React Component\n\n## [#](https://dvajs.com/api/#dva-api)dva API\n\n### [#](https://dvajs.com/api/#app-dva-opts)`app = dva(opts)`\n\n创建应用，返回 dva 实例。(注：dva 支持多实例)\n\n`opts` 包含：\n\n- `history`：指定给路由用的 history，默认是 `hashHistory`\n- `initialState`：指定初始数据，优先级高于 model 中的 state，默认是 `{}`\n\n如果要配置 history 为 `browserHistory`，可以这样：\n\n```js\nimport createHistory from 'history/createBrowserHistory';\nconst app = dva({\n  history: createHistory(),\n});\n```\n\n另外，出于易用性的考虑，`opts` 里也可以配所有的 [hooks](https://dvajs.com/api/#appusehooks) ，下面包含全部的可配属性：\n\n```js\nconst app = dva({\n  history,\n  initialState,\n  onError,\n  onAction,\n  onStateChange,\n  onReducer,\n  onEffect,\n  onHmr,\n  extraReducers,\n  extraEnhancers,\n});\n```\n\n### [#](https://dvajs.com/api/#app-use-hooks)`app.use(hooks)`\n\n配置 hooks 或者注册插件。（插件最终返回的是 hooks ）\n\n比如注册 [dva-loading](https://github.com/dvajs/dva-loading) 插件的例子：\n\n```js\nimport createLoading from 'dva-loading';\n...\napp.use(createLoading(opts));\n```\n\n`hooks` 包含：\n\n#### [#](https://dvajs.com/api/#onerror-err-dispatch)`onError((err, dispatch) => {})`\n\n`effect` 执行错误或 `subscription` 通过 `done` 主动抛错时触发，可用于管理全局出错状态。\n\n注意：`subscription` 并没有加 `try...catch`，所以有错误时需通过第二个参数 `done` 主动抛错。例子：\n\n```js\napp.model({\n  subscriptions: {\n    setup({ dispatch }, done) {\n      done(e);\n    },\n  },\n});\n```\n\n如果我们用 antd，那么最简单的全局错误处理通常会这么做：\n\n```js\nimport { message } from 'antd';\nconst app = dva({\n  onError(e) {\n    message.error(e.message, /* duration */3);\n  },\n});\n```\n\n#### [#](https://dvajs.com/api/#onaction-fn-fn)`onAction(fn | fn[])`\n\n在 action 被 dispatch 时触发，用于注册 redux 中间件。支持函数或函数数组格式。\n\n例如我们要通过 [redux-logger](https://github.com/evgenyrodionov/redux-logger) 打印日志：\n\n```js\nimport createLogger from 'redux-logger';\nconst app = dva({\n  onAction: createLogger(opts),\n});\n```\n\n#### [#](https://dvajs.com/api/#onstatechange-fn)`onStateChange(fn)`\n\n`state` 改变时触发，可用于同步 `state` 到 localStorage，服务器端等。\n\n#### [#](https://dvajs.com/api/#onreducer-fn)`onReducer(fn)`\n\n封装 reducer 执行。比如借助 [redux-undo](https://github.com/omnidan/redux-undo) 实现 redo/undo ：\n\n```js\nimport undoable from 'redux-undo';\nconst app = dva({\n  onReducer: reducer => {\n    return (state, action) => {\n      const undoOpts = {};\n      const newState = undoable(reducer, undoOpts)(state, action);\n      // 由于 dva 同步了 routing 数据，所以需要把这部分还原\n      return { ...newState, routing: newState.present.routing };\n    },\n  },\n});\n```\n\n#### [#](https://dvajs.com/api/#oneffect-fn)`onEffect(fn)`\n\n封装 effect 执行。比如 [dva-loading](https://github.com/dvajs/dva-loading) 基于此实现了自动处理 loading 状态。\n\n#### [#](https://dvajs.com/api/#onhmr-fn)`onHmr(fn)`\n\n热替换相关，目前用于 [babel-plugin-dva-hmr](https://github.com/dvajs/babel-plugin-dva-hmr) 。\n\n#### [#](https://dvajs.com/api/#extrareducers)`extraReducers`\n\n指定额外的 reducer，比如 [redux-form](https://github.com/erikras/redux-form) 需要指定额外的 `form` reducer：\n\n```js\nimport { reducer as formReducer } from 'redux-form'\nconst app = dva({\n  extraReducers: {\n    form: formReducer,\n  },\n});\n```\n\n#### [#](https://dvajs.com/api/#extraenhancers)`extraEnhancers`\n\n指定额外的 [StoreEnhancer](https://github.com/reactjs/redux/blob/master/docs/Glossary.md#store-enhancer) ，比如结合 [redux-persist](https://github.com/rt2zz/redux-persist) 的使用：\n\n```js\nimport { persistStore, autoRehydrate } from 'redux-persist';\nconst app = dva({\n  extraEnhancers: [autoRehydrate()],\n});\npersistStore(app._store);\n```\n\n### [#](https://dvajs.com/api/#app-model-model)`app.model(model)`\n\n注册 model，详见 [#Model](https://dvajs.com/api/#model) 部分。\n\n### [#](https://dvajs.com/api/#app-unmodel-namespace)`app.unmodel(namespace)`\n\n取消 model 注册，清理 reducers, effects 和 subscriptions。subscription 如果没有返回 unlisten 函数，使用 `app.unmodel` 会给予警告⚠️。\n\n### [#](https://dvajs.com/api/#app-replacemodel-model)`app.replaceModel(model)`\n\n> 只在app.start()之后可用\n\n替换model为新model，清理旧model的reducers, effects 和 subscriptions，但会保留旧的state状态，对于HMR非常有用。subscription 如果没有返回 unlisten 函数，使用 `app.unmodel` 会给予警告⚠️。\n\n如果原来不存在相同namespace的model，那么执行`app.model`操作\n\n### [#](https://dvajs.com/api/#app-router-history-app-routerconfig)`app.router(({ history, app }) => RouterConfig)`\n\n注册路由表。\n\n通常是这样的：\n\n```js\nimport { Router, Route } from 'dva/router';\napp.router(({ history }) => {\n  return (\n    <Router history={history}>\n      <Route path=\"/\" component={App} />\n    </Router>\n  );\n});\n```\n\n推荐把路由信息抽成一个单独的文件，这样结合 [babel-plugin-dva-hmr](https://github.com/dvajs/babel-plugin-dva-hmr) 可实现路由和组件的热加载，比如：\n\n```js\napp.router(require('./router'));\n```\n\n而有些场景可能不使用路由，比如多页应用，所以也可以传入返回 JSX 元素的函数。比如：\n\n```js\napp.router(() => <App />);\n```\n\n### [#](https://dvajs.com/api/#app-start-selector)`app.start(selector?)`\n\n启动应用。`selector` 可选，如果没有 `selector` 参数，会返回一个返回 JSX 元素的函数。\n\n```js\napp.start('#root');\n```\n\n那么什么时候不加 `selector`？常见场景有测试、node 端、react-native 和 i18n 国际化支持。\n\n比如通过 react-intl 支持国际化的例子：\n\n```js\nimport { IntlProvider } from 'react-intl';\n...\nconst App = app.start();\nReactDOM.render(<IntlProvider><App /></IntlProvider>, htmlElement);\n```\n\n## [#](https://dvajs.com/api/#model)Model\n\nmodel 是 dva 中最重要的概念。以下是典型的例子：\n\n```js\napp.model({\n  namespace: 'todo',\n  state: [],\n  reducers: {\n    add(state, { payload: todo }) {\n      // 保存数据到 state\n      return [...state, todo];\n    },\n  },\n  effects: {\n    *save({ payload: todo }, { put, call }) {\n      // 调用 saveTodoToServer，成功后触发 `add` action 保存到 state\n      yield call(saveTodoToServer, todo);\n      yield put({ type: 'add', payload: todo });\n    },\n  },\n  subscriptions: {\n    setup({ history, dispatch }) {\n      // 监听 history 变化，当进入 `/` 时触发 `load` action\n      return history.listen(({ pathname }) => {\n        if (pathname === '/') {\n          dispatch({ type: 'load' });\n        }\n      });\n    },\n  },\n});\n```\n\nmodel 包含 5 个属性：\n\n### [#](https://dvajs.com/api/#namespace)namespace\n\nmodel 的命名空间，同时也是他在全局 state 上的属性，只能用字符串，不支持通过 `.` 的方式创建多层命名空间。\n\n### [#](https://dvajs.com/api/#state)state\n\n初始值，优先级低于传给 `dva()` 的 `opts.initialState`。\n\n比如：\n\n```js\nconst app = dva({\n  initialState: { count: 1 },\n});\napp.model({\n  namespace: 'count',\n  state: 0,\n});\n```\n\n此时，在 `app.start()` 后 state.count 为 1 。\n\n### [#](https://dvajs.com/api/#reducers)reducers\n\n以 key/value 格式定义 reducer。用于处理同步操作，唯一可以修改 `state` 的地方。由 `action` 触发。\n\n格式为 `(state, action) => newState` 或 `[(state, action) => newState, enhancer]`。\n\n详见： <https://github.com/dvajs/dva/blob/master/packages/dva-core/test/reducers.test.js>\n\n### [#](https://dvajs.com/api/#effects)effects\n\n以 key/value 格式定义 effect。用于处理异步操作和业务逻辑，不直接修改 `state`。由 `action` 触发，可以触发 `action`，可以和服务器交互，可以获取全局 `state` 的数据等等。\n\n格式为 `*(action, effects) => void` 或 `[*(action, effects) => void, { type }]`。\n\ntype 类型有：\n\n- `takeEvery`\n- `takeLatest`\n- `throttle`\n- `watcher`\n\n详见：<https://github.com/dvajs/dva/blob/master/packages/dva-core/test/effects.test.js>\n\n### [#](https://dvajs.com/api/#subscriptions)subscriptions\n\n以 key/value 格式定义 subscription。subscription 是订阅，用于订阅一个数据源，然后根据需要 dispatch 相应的 action。在 `app.start()` 时被执行，数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等。\n\n格式为 `({ dispatch, history }, done) => unlistenFunction`。\n\n注意：如果要使用 `app.unmodel()`，subscription 必须返回 unlisten 方法，用于取消数据订阅。\n","children":[]},{"name":"dva-basic.md","path":"../guanruihua.github.io/React/状态管理/dva","data":"# dva-basic\n\n> 基于redux和redux-saga的数据流方案, 简化开发, dav还额外内置react-router和fetch\n\n## dynamic(opts)\n\n> opts\n>\n> - app:dva实例, 加载models时需要\n> - models: 返回Promise数组的函数, Promise返回dva model\n> - component: 返回Promise的函数, Promise返回React Component\n\n```react\n// 路由文件\nimport { Router, Route } from 'dva/router';\nimport IndexPage from './routes/IndexPage'\nimport TodoList from './routes/TodoList'\n\nfunction RouterConfig({ history }) {\n  return (\n    <Router history={history}>\n        <Route path=\"/\" component={IndexPage} />\n        <Route path='/todoList' components={TodoList}/>\n    </Router>\n  )\n}\nexport default RouterConfig\n```\n\n改成\n\n```react\nimport { Router, Switch, Route } from 'dva/router'\nimport dynamic from 'dva/dynamic'\n\nfunction RouterConfig({ history, app }) {\n  const IndexPage = dynamic({\n    app,\n    component: () => import('./routes/IndexPage'),\n  })\n\n  const Users = dynamic({\n    app,\n    models: () => [import('./models/users')],\n    component: () => import('./routes/Users'),\n  })\n\n  return (\n    <Router history={history}>\n      <Switch>\n        <Route exact path=\"/\" component={IndexPage} />\n        <Route exact path=\"/users\" component={Users} />\n      </Switch>\n    </Router>\n  )\n}\n\nexport default RouterConfig\n```\n\n## mock\n\n> 模拟数据, 模拟接口api的请求方式\n\n### 在dva中的使用 1\n\n在mock文件夹下创建\n\n```js\n// product.js\nmodule.exports = {\n  \"GET /api/product\":{ \"name\" : \"高粱\" }\n}\n\n// user.js\nmodule.exports = {\n  \"POST /api/login\": (req, res) => {\n    res.send({\n       msg: \"登录成功\" \n      })\n   }\n}\n```\n\n设置.roadhogrc.mock.js\n\n```js\n// 1: 一个一个引入\nexport default {\n  ...require(\"./mock/product\"),\n  ...require(\"./mock/product\") ,\n  ....\n}\n\n// 2. 通过fs和path来引入mock文件夹下全部文件引入\nconst mock = {}\nfs.readdirSync(path.join(__dirname + '/mock' )).forEach(function(file){\n  if ( file.match(/\\.js$/)) {\n    Object.assign(mock, require('./mock/' + file ))\n  }\n})\nexport default mock\n```\n\n在service中定义请求方式\n\n```jsx\nimport request from '../utils/request';\nexport function getProduct(){\n  return request(\"/api/product\")\n}\n```\n\n在组件中使用\n\n```jsx\nimport * as api from '../services/example';\n\ncomonentDidMout() {\n  api.getProduct().then(res => console.log(res) )\n}\n```\n\n### 在dva中的使用 2\n\n1. 在根目录的mock目录下新建一个文件’mockData.js’,写入下面代码\n\n```javascript\nmodule.exports = {\n  'GET /api/mockData': (request, response) => {\n    console.log(request);\n    response.send({\n      msg: '登陆成功'\n    })\n  }\n}\n```\n\n2. 在根目录下的`.roadhogrc.mock.js`文件中进行注册\n\n```javascript\nexport default {\n  ...require(\"./mock/testMock\")\n};\n```\n\n3. 在根目录下的src下的service目录下写一个请求方法\n\n```javascript\n// 注册mock接口\nexport function mockData() {\n    return request('/api/mockData');\n}\n1234\n```\n\n4. 在页面中引入请求方法之后就能进行调用\n\n```javascript\nimport * as apis from '../service/example'\napis.mockData()\n.then((res) => {\n  console.log(res);\n})\n12345\n```\n\n### 在umi中的使用\n\n和dva中基本相同,只是不需要第二步\n\n### 使用自己封装的请求方法进行调用(即不使用service)\n\n不需要第3步,将第四步代码替换为\n\n```javascript\nfetch('/api/mockData')\n.then(res => res.json())\n.then(data => console.log(data))\n.catch(err => ({ err }));\n1234\n```\n\n### 续篇(response和request参数的说明)\n\n```javascript\nRequest\n    req.baseUrl 基础路由地址\n    req.body post发送的数据解析出来的对象\n    req.cookies 客户端发送的cookies数据\n    req.hostname 主机地址 去掉端口号\n    req.ip 查看客户端的ip地址\n    req.ips 代理的IP地址\n    req.originalUrl 对req.url的一个备份\n    req.params 在使用/:id/:name 匹配params\n    req.path 包含请求URL的路径部分\n    req.protocol http 或https协议\n    req.query 查询字符串解析出来的对象 username=zhangsan&password=123 { username:zhangsan }\n    req.route 当前匹配的路由 正则表达式\n    req.params 获取路由匹配的参数\n    req.get 获取请求header里的参数\n    req.is 判断请求的是什么类型的文件\n    req.param(key名称) 用来获取某一个路由匹配的参数\n \n \nResponse\n    res.headersSent 查看http响应是否响应了http头\n    res.append(名称,value) 追加http响应头\n    res.attachment(文件路径) 响应文件请求 \n    res.cookie() 设置cookie\n    \n    res.setHeader('Content-Type','text/html;charset=utf8')\n    res.append('Content-Type','text/html;charset=utf8')\n    res.append('hehe','1008')\n    res.append('haha','1008')\n    res.attachment('./xx.zip') //Content-Disposition: attachment; filename=\"xx.zip\"\n    res.clearCookie(cookiename) 删除cookie\n    res.cookie('zhangsan','lisi') 设置cookie\n    res.cookie('zhangsan1','lisi2',{\n        maxAge:900000,\n        httpOnly:true,\n        path: '/admin', \n        secure: true,\n        signed:true\n    })\n    res.clearCookie('zhangsan')\n \n    res.download(文件的path路径) 跟attachment类似 用来处理文件下载的 参数是文件地址\n    res.end http模块自带的\n    res.format()协商请求文件类型 format匹配协商的文件类型\n    res.format({\n        'text/plain': function(){\n            res.send('hey');\n        },\n        \n        'text/html': function(){\n            res.send('<p>hey</p>');\n        },\n        \n        'application/json': function(){\n            res.send({ message: 'hey' });\n        },\n        \n        'default': function() {\n            // log the request and respond with 406\n            res.status(406).send('Not Acceptable');\n        }\n    });\n \n    res.get('key') 获取响应header数据\n    res.json() 返回json数据 会自动设置响应header Content-type 为json格式 application/json\n \n    res.json({\n        xx:100\n    })\n \n    res.json({\n        xx:100\n    })\n \n    jsonp 利用的就是浏览器加载其他服务器的文件不会存在跨域问题\n    ajax请求就会有跨域问题\n \n    res.setHeader('Content-Type','text/javascript;charsert=utf8')\n    res.end(`typeof ${req.query.callback} == 'function' ? ${req.query.callback}({aa:100}):null`)\n \n    res.jsonp({aaa:100})\n \n \n    重定向 把访问的地址跳转到另一个地址上\n    res.redirect(301,'/api/aes')\n \n    express jade\n    res.render('index',{title:\"hehe\",test:\"23\"})\n    res.send('') 发送数据 可以是任意类型的数据\n    res.sendFile() 发送文件的 \n    res.sendStatus(200) 设置发送时的状态码\n    res.set('Content-Type', 'text/plain') //设置响应header\n    res.status(200) // 设置状态码\n    res.type('') // 直接设置响应的文件类型\n \n    res.type('pdf')\n \n    res.send({aa:100})\n    res.end('ok')\n    res.end({aa:100})\n \n    res.end('你好')\n \n \n    res.end(req.get('Accept-Language'))\n    res.json({\n        is:req.is('text/html')\n    })\n \n    res.json({\n        type:req.baseUrl,\n        hostname:req.hostname,\n        // ip:req.ip,\n        // ips:req.ips,\n        // route:req.route,\n        ct:req.get('Accept'),\n        cs:'22'\n    })\n```\n\n## model对象\n\n> 5个重要的属性: namespace, state, reducers, effects, subscriptions\n\n#### namespace\n>\n> - namespace : model 的命名空间，同时也是他在全局 state 上的属性，只能用字符串，不支持通过`.`的方式创建多层命名空间\n>\n\n#### state\n>\n> - state : reducer的初始值, 优先级低于传输给dva()的``opts.initialState`\n>\n>   - ```tsx\n>     const app = dva({\n>       // 初始化state\n>       initialState: { count: 1 },\n>     });\n>     app.model({\n>       namespace: 'count',\n>       // 初始化state\n>       state: 0,\n>     })\n>     \n>     // 在app.start()后state.count为1\n>     ```\n>\n\n#### reducers\n\n> - reducers : 以key/ value格式定义reducer, 用于处理同步操作, **唯一可以修改state的地方**\n>\n> - reducres中的  return 可以覆盖state原有的数据\n>\n> - 不能实现异步操作\n>\n>   - 格式: `(state, action) => newState` 或 `[(state, action) => newState, enhancer]`\n>\n>   - ```jsx\n>     namespace: 'todo',\n>       state: {\n>         list: []\n>       },\n>       // reducers 写法\n>       reducers: {\n>         save(state, { payload: { list } }) {\n>           return { ...state, list }\n>         }\n>       }\n>     ```\n\n#### effects\n\n> - 以`key/value` 格式定义effect, 用于处理异步操作的业务逻辑,  \n>\n> - 可以实现异步操作,\n>\n> - **不直接修改state**,可以通过put来触发reducers来修改modul中的state\n>\n> - 由action触发, 可以触发action, 可以和服务器交互, 可以获取全局state的数据等\n>\n> - 格式:  `*(action, effects) => void` 或 `[*(action, effects) => void, { type }]`\n>   - type类型:\n>     - takeEvery\n>     - takeLatest\n>     - throttle\n>     - watcher\n>   - effects\n>     - put : 用于触发 action , 常常用于通过触发reducer的方法来修改state\n>       - `yield put({ type: 'todos/add', payload: 'Learn Dva'})`\n>     - call : 用于调用异步逻辑, 支持Promise\n>       - `const result = yield call(fetch, '/todos')`\n>       - 第一个参数: 调用的函数\n>       - 第二个参数: 你要传输的参数\n>     - select : 用于从state里获取数据\n>       - `const todos = yield select(state => state.todos)`\n>\n> - 错误处理\n>\n>   - 全局错误处理\n>\n>     - effects和subscriptions的抛错全部会走onError hook，所以可以在onError里统一处理错误\n>\n>       ```jsx\n>       const app = dva({\n>        onError(e, dispatch) {\n>         console.log(e.message);\n>        },\n>       });\n>       \n>       ```\n>\n>\n>\n>   - 本地错误处理\n>\n>     - 对某些effects的错误进行特殊处理，需要在effect内部加try catch。\n>\n>       ```jsx\n>       app.model({\n>        effects: {\n>         *addRemote() {\n>          try {\n>           // Your Code Here\n>          } catch(e) {\n>           console.log(e.message);\n>          }\n>         },\n>        },\n>       });\n>       // try{}catch{}finally{}\n>       ```\n>\n>\n\n```jsx\n// effects 写法\neffects: {\n    *addTodo({ payload: value }, { call, put, select }) {\n      // 模拟网络请求\n      const data = yield call(todoService.query, value)\n      console.log(data)\n      let tempList = yield select(state => state.todo.list)\n      let list = []\n      list = list.concat(tempList)\n      const tempObj = {}\n      tempObj.title = value\n      tempObj.id = list.length\n      tempObj.finished = false\n      list.push(tempObj)\n      yield put({ type: 'save', payload: { list }})\n    },\n    *toggle({ payload: index }, { call, put, select }) {\n      // 模拟网络请求\n      const data = yield call(todoService.query, index)\n      let tempList = yield select(state => state.todo.list)\n      let list = []\n      list = list.concat(tempList)\n      let obj = list[index]\n      obj.finished = !obj.finished\n      yield put({ type: 'save', payload: { list } })\n    },\n    *delete({ payload: index }, { call, put, select }) {\n      const data = yield call(todoService.query, index)\n      let tempList = yield select(state => state.todo.list)\n      let list = []\n      list = list.concat(tempList)\n      list.splice(index, 1)\n      yield put({ type: 'save', payload: { list } })\n    },\n    *modify({ payload: { value, index } }, { call, put, select }) {\n      const data = yield call(todoService.query, value)\n      let tempList = yield select(state => state.todo.list)\n      let list = []\n      list = list.concat(tempList)\n      let obj = list[index]\n      obj.title = value\n      yield put({ type: 'save', payload: { list } })\n    }\n  }\n\n// 组件中调用\nthis.props.dispatch({\n type: '[namespaceName]/[effectsfuntionName]',\n  payload: '[要传输的数据]'\n})\n```\n\n#### subscriptions\n\n> - 主要在model中实现事件监听, 可以监听路由变化, 鼠标, 键盘, 服务器, 状态变化等\n> - 以key/vallue格式定义subscriptions, subscriptions是订阅, 用于订阅一个数据源, 然后需要dispatch相应的action\n> - 在app.start()被执行时, 数据源可以是当前时候, 服务器的websocket连接, keyboard输入, geolocation变化, history路由变化等\n> - 格式`({ dispatch, history } , done ) => unlistenFunction`\n> - 取消数据订阅: 使用app.unmode(), subscription必须返回unlisten方法\n\n```jsx\n// subscriptions 写法\nsubscriptions: {\n    setup({ dispatch, history }) {\n      // 监听路由的变化，请求页面数据\n      return history.listen(({ pathname, search }) => {\n        const query = queryString.parse(search)\n        let list = []\n        if (pathname === 'todoList') {\n          dispatch({ type: 'save', payload: { list } })\n        }\n      })\n    }\n  }\n```\n\n路由监听\n\n```jsx\n subscriptions: {\n   setup ({dispatch, history}) {\n     history.listen(( pathname ) => {\n       console.log(pathname)\n     })\n   }\n },\n```\n\n点击事件\n\n```js\n subscriptions: {\n     onClick ({dispatch}) {\n        document.addEventListener('click',() => {   //这里表示当鼠标点击时就会触发里面的dispatch命令，这里的save就是reducers中的方法名\n          dispatch (type:\"save\")\n        })\n     }),\n },\n\n```\n\n#### connect\n\n> 将路由的state传输给当前组件\n\n```js\nimport { connect } from 'dva';\nclass IndexPage extends React.Component{\n  render(){\n    console.log(this.props)// 可以拿到state.product里面的数据\n    return( \n     ...  \n    )\n  }\n}\n\nconst mapStateProps = (state) => {\n  return {\n    productList:state.product\n  }\n}\n// 将state.product的数据传输给IndexPage组件\nexport default connect(mapStateProps)(IndexPage);\n```\n\n## router\n\n### withRouter\n\n> 这样子就不用父组件传输过来history对象, `this.props.history`也不会为空了\n\n```js\nimport { withRouter } from \"dva/router\";\n\nclass Product extends React.Component{\n  ... \n    this.props.history.push(\"/\");// 实现跳转到主页'/'\n    ...\n}\nexport default withRouter(Product);   \n```\n\n### routerRedux\n\n```js\nimport { routerRedux } from 'dva/router';\nclass Product extends React.Component{\n  ... \n    this.props.history.dispatch(routerRedux.push(\"/\"));// 实现跳转到主页'/'\n    ...\n}\nexport default Product; \n\n```\n\n## 使用dva框架和直接使用redux写法的区别\n\n#### 用 redux\n\n##### *actions.js 文件*\n\n```tsx\nexport const REQUEST_TODO = 'REQUEST_TODO';\nexport const RESPONSE_TODO = 'RESPONSE_TODO';\nconst request = count => ({type: REQUEST_TODO, payload: {loading: true, count}});\nconst response = count => ({type: RESPONSE_TODO, payload: {loading: false, count}});\nexport const fetch = count => {\n  return (dispatch) => {\n    dispatch(request(count));\n    return new Promise(resolve => {\n      setTimeout(() => {\n        resolve(count + 1);\n      }, 1000)\n    }).then(data => {\n      dispatch(response(data))\n    })\n  }\n}\n```\n\n##### *reducer.js 文件*\n\n```dart\nimport { REQUEST_TODO, RESPONSE_TODO } from './actions';\n\nexport default (state = {\n  loading: false,\n  count: 0\n}, action) => {\n  switch (action.type) {\n    case REQUEST_TODO:\n      return {...state, ...action.payload};\n    case RESPONSE_TODO:\n      return {...state, ...action.payload};\n    default:\n      return state;\n  }\n}\n```\n\n##### *app.js 文件*\n\n```jsx\nimport React from 'react';\nimport { bindActionCreators } from 'redux';\nimport { connect } from 'react-redux';\n\nimport * as actions from './actions';\n\nconst App = ({fetch, count, loading}) => {\n  return (\n    <div>\n      {loading ? <div>loading...</div> : <div>{count}</div>}\n      <button onClick={() => fetch(count)}>add</button>\n    </div>\n  )\n}\n\nfunction mapStateToProps(state) {\n  return state;\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return bindActionCreators(actions, dispatch)\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App)\n```\n\n##### *index.js 文件*\n\n```jsx\nimport { render } from 'react-dom';\nimport { createStore, applyMiddleware } from 'redux';\nimport { Provider } from 'react-redux'\nimport thunkMiddleware from 'redux-thunk';\n\nimport reducer from './app/reducer';\nimport App from './app/app';\n\nconst store = createStore(reducer, applyMiddleware(thunkMiddleware));\n\nrender(\n  <Provider store={store}>\n    <App/>\n  </Provider>\n  ,\n  document.getElementById('app')\n)\n```\n\n#### 使用dva\n\n##### *model.js 文件*\n\n```tsx\nexport default {\n  namespace: 'demo',\n  state: {\n    loading: false,\n    count: 0\n  },\n  reducers: {\n    request(state, payload) {\n      return {...state, ...payload};\n    },\n    response(state, payload) {\n      return {...state, ...payload};\n    }\n  },\n  effects: {\n    *'fetch'(action, {put, call}) {\n      yield put({type: 'request', loading: true});\n\n      let count = yield call((count) => {\n        return new Promise(resolve => {\n          setTimeout(() => {\n            resolve(count + 1);\n          }, 1000);\n        });\n      }, action.count);\n\n      yield put({\n        type: 'response',\n        loading: false,\n        count\n      });\n    }\n  }\n}\n```\n\n##### *app.js 文件*\n\n```jsx\nimport React from 'react'\nimport { connect } from 'dva';\n\nconst App = ({fetch, count, loading}) => {\n  return (\n    <div>\n      {loading ? <div>loading...</div> : <div>{count}</div>}\n      <button onClick={() => fetch(count)}>add</button>\n    </div>\n  )\n}\n\nfunction mapStateToProps(state) {\n  return state.demo;\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return {\n    fetch(count){\n      dispatch({type: 'demo/fetch', count});\n    }\n  }\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App)\n```\n\n##### *index.js 文件*\n\n```jsx\nimport dva from 'dva';\nimport model from './model';\nimport App from './app';\nconst app = dva();\napp.use({});\napp.model(model);\napp.router(() => <App />);\napp.start();\n```\n\n我们通过上面两种不同方式来实现一个异步的计数器的代码结构发现：\n\n1. **使用 redux 需要拆分出`action`模块和`reducer`模块**\n2. **dva将`action`和`reducer`封装到`model`中，异步流程采用Generator处理**\n","children":[]},{"name":"dva-expand","path":"../guanruihua.github.io/React/状态管理/dva","data":"","children":[{"name":"dva-tsx.md","path":"../guanruihua.github.io/React/状态管理/dva/dva-expand","data":"# dva-typescript\n\n> [相关资料](https://github.com/typescript-cheatsheets/react)\n>\n> [相关资料](https://github.com/zhongsp/TypeScript)\n\n## 环境搭建\n\n全局安装\n\n```shell\nnpm i typescript -g\n```\n\n项目内部安装\n\n```shell\nnpm i link typescript\nnpm i --save-dev ts-loader source-map-loader\nnpm i --save-dev @types/react @types/react-dom\n```\n\n根目录下添加tsconfig.json文件\n\n```json\n{\n  \"compilerOptions\": {\n    \"strictNullChecks\": true,\n    \"moduleResolution\": \"node\",\n    \"allowSyntheticDefaultImports\": true,\n    \"experimentalDecorators\": true,\n    \"jsx\": \"preserve\",\n    \"noUnusedParameters\": true,\n    \"noUnusedLocals\": true,\n    \"target\": \"es6\",\n    \"lib\": [\n      \"dom\",\n      \"es7\"\n    ]\n  },\n  \"exclude\": [\n    \"node_modules\",\n    \"lib\",\n    \"es\"\n  ]\n}\n\n```\n\ndemo\n\n```tsx\nimport * as React from 'react'\nimport { render } from 'react-dom'\n\ninterface IAppProps {}\ninterface IAppState {}\n\nclass App extends React.Component<IAppProps, IAppState> {\n  public render(): JSX.Element {\n    return (\n      <div>\n        这是typescript了哦~\n      </div>\n    )\n  }\n}\n\nexport default App;\n```\n\n> 然后直接在路由页面吧该组件展示出去\n","children":[]},{"name":"优化.md","path":"../guanruihua.github.io/React/状态管理/dva/dva-expand","data":"# dva优化\n\n## 引入dva后一直存在一个warning：Please use `require(\"history\").createHashHistory` instead of\n\n> 修改node_modules/dva/lib/index.js\n\n```js\n// var _createHashHistory = _interopRequireDefault(require(\"history/createHashHistory\")); // 把这个改成下面的\nvar _createHashHistory = _interopRequireDefault(require(\"history\").createHashHistory);\n```\n\n## 简写多个models的引入\n\n```react\n\n// app.model(require('./models/example').default);\n// app.model(require('./models/a').default);\n// app.model(require('./models/b').default);\n// app.model(require('./models/c').default);\n// app.model(require('./models/d').default);\n// app.model(require('./models/e').default);\n// app.model(require('./models/f').default);\n\n```\n\n在models文件夹下建立一个, index.js\n\n```js\nconst context = require.context(\"./\", false, /\\.js$/).keys().filter(item => item!==\"./index.js\"); \nconst newContext = context.map(it => it.slice(2))\nexport default newContext\n```\n\n然后在index.js下\n\n改成\n\n```react\n// 3. Model\n// app.model(require('./models/example').default);\n// app.model(require('./models/products').default);\n// 添加这个和models/index, 可以实现添加多个model的简写\nrequire('./models').default.forEach(key => app.model(require(`./models/${key}`).default))\n```\n","children":[]}]},{"name":"extend.md","path":"../guanruihua.github.io/React/状态管理/dva","data":"# dva-extend\n\n## dva+antd\n\n> `npm install antd babel-plugin-import --save`\n\n`.webpackrc`添加配置\n\n```json\n{\n+  \"extraBabelPlugins\": [\n+    [\"import\", { \"libraryName\": \"antd\", \"libraryDirectory\": \"es\", \"style\": \"css\" }]\n+  ]\n}\n```\n\n## 使用less\n\n`.webpackrc`添加配置\n\n```js\ndisableCSSModules: true,\n  \n//1.\n{\n  disableCSSModules: true,\n}\n\n// 2.\n{\n+  \"extraBabelPlugins\": [\n+    [\"import\", { \"libraryName\": \"antd\", \"libraryDirectory\": \"es\", \"style\": \"css\", \"disableCSSModules\": true,}]\n+  ]\n}\n```\n","children":[]},{"name":"快速上手.md","path":"../guanruihua.github.io/React/状态管理/dva","data":"# dva快速上手\n\n## [#](https://dvajs.com/guide/getting-started.html#安装-dva-cli)安装 dva-cli\n\n通过 npm 安装 dva-cli 并确保版本是 `0.9.1` 或以上。\n\n```bash\n$ npm install dva-cli -g\n$ dva -v\ndva-cli version 0.9.1\n```\n\n## [#](https://dvajs.com/guide/getting-started.html#创建新应用)创建新应用\n\n安装完 dva-cli 之后，就可以在命令行里访问到 `dva` 命令（[不能访问？](http://stackoverflow.com/questions/15054388/global-node-modules-not-installing-correctly-command-not-found)）。现在，你可以通过 `dva new` 创建新应用。\n\n```bash\ndva new dva-quickstart\n```\n\n这会创建 `dva-quickstart` 目录，包含项目初始化目录和文件，并提供开发服务器、构建脚本、数据 mock 服务、代理服务器等功能。\n\n然后我们 `cd` 进入 `dva-quickstart` 目录，并启动开发服务器：\n\n```bash\ncd dva-quickstart\nnpm start\n```\n\n几秒钟后，你会看到以下输出：\n\n```bash\nCompiled successfully!\n\nThe app is running at:\n\n  http://localhost:8000/\n\nNote that the development build is not optimized.\nTo create a production build, use npm run build.\n```\n\n在浏览器里打开 <http://localhost:8000> ，你会看到 dva 的欢迎界面。\n\n## [#](https://dvajs.com/guide/getting-started.html#使用-antd)使用 antd\n\n通过 npm 安装 `antd` 和 `babel-plugin-import` 。`babel-plugin-import` 是用来按需加载 antd 的脚本和样式的，详见 [repo](https://github.com/ant-design/babel-plugin-import) 。\n\n```bash\nnpm install antd babel-plugin-import --save\n```\n\n编辑 `.webpackrc`，使 `babel-plugin-import` 插件生效。\n\n```diff\n{\n+  \"extraBabelPlugins\": [\n+    [\"import\", { \"libraryName\": \"antd\", \"libraryDirectory\": \"es\", \"style\": \"css\" }]\n+  ]\n}\n```\n\n> 注：dva-cli 基于 roadhog 实现 build 和 dev，更多 `.webpackrc` 的配置详见 [roadhog#配置](https://github.com/sorrycc/roadhog#配置)\n\n## [#](https://dvajs.com/guide/getting-started.html#定义路由)定义路由\n\n我们要写个应用来先显示产品列表。首先第一步是创建路由，路由可以想象成是组成应用的不同页面。\n\n新建 route component `routes/Products.js`，内容如下：\n\n```javascript\nimport React from 'react';\n\nconst Products = (props) => (\n  <h2>List of Products</h2>\n);\n\nexport default Products;\n```\n\n添加路由信息到路由表，编辑 `router.js` :\n\n```diff\n+ import Products from './routes/Products';\n...\n+ <Route path=\"/products\" exact component={Products} />\n```\n\n然后在浏览器里打开 <http://localhost:8000/#/products> ，你应该能看到前面定义的 `<h2>` 标签。\n\n## [#](https://dvajs.com/guide/getting-started.html#编写-ui-component)编写 UI Component\n\n随着应用的发展，你会需要在多个页面分享 UI 元素 (或在一个页面使用多次)，在 dva 里你可以把这部分抽成 component 。\n\n我们来编写一个 `ProductList` component，这样就能在不同的地方显示产品列表了。\n\n新建 `components/ProductList.js` 文件：\n\n```javascript\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { Table, Popconfirm, Button } from 'antd';\n\nconst ProductList = ({ onDelete, products }) => {\n  const columns = [{\n    title: 'Name',\n    dataIndex: 'name',\n  }, {\n    title: 'Actions',\n    render: (text, record) => {\n      return (\n        <Popconfirm title=\"Delete?\" onConfirm={() => onDelete(record.id)}>\n          <Button>Delete</Button>\n        </Popconfirm>\n      );\n    },\n  }];\n  return (\n    <Table\n      dataSource={products}\n      columns={columns}\n    />\n  );\n};\n\nProductList.propTypes = {\n  onDelete: PropTypes.func.isRequired,\n  products: PropTypes.array.isRequired,\n};\n\nexport default ProductList;\n```\n\n## [#](https://dvajs.com/guide/getting-started.html#定义-model)定义 Model\n\n完成 UI 后，现在开始处理数据和逻辑。\n\ndva 通过 model 的概念把一个领域的模型管理起来，包含同步更新 state 的 reducers，处理异步逻辑的 effects，订阅数据源的 subscriptions 。\n\n新建 model `models/products.js` ：\n\n```javascript\nexport default {\n  namespace: 'products',\n  state: [],\n  reducers: {\n    'delete'(state, { payload: id }) {\n      return state.filter(item => item.id !== id);\n    },\n  },\n};\n```\n\n这个 model 里：\n\n- `namespace` 表示在全局 state 上的 key\n- `state` 是初始值，在这里是空数组\n- `reducers` 等同于 redux 里的 reducer，接收 action，同步更新 state\n\n然后别忘记在 `index.js` 里载入他：\n\n```diff\n// 3. Model\n+ app.model(require('./models/products').default);\n```\n\n## [#](https://dvajs.com/guide/getting-started.html#connect-起来)connect 起来\n\n到这里，我们已经单独完成了 model 和 component，那么他们如何串联起来呢?\n\ndva 提供了 connect 方法。如果你熟悉 redux，这个 connect 就是 react-redux 的 connect 。\n\n编辑 `routes/Products.js`，替换为以下内容：\n\n```javascript\nimport React from 'react';\nimport { connect } from 'dva';\nimport ProductList from '../components/ProductList';\n\nconst Products = ({ dispatch, products }) => {\n  function handleDelete(id) {\n    dispatch({\n      type: 'products/delete',\n      payload: id,\n    });\n  }\n  return (\n    <div>\n      <h2>List of Products</h2>\n      <ProductList onDelete={handleDelete} products={products} />\n    </div>\n  );\n};\n\n// export default Products;\nexport default connect(({ products }) => ({\n  products,\n}))(Products);\n```\n\n最后，我们还需要一些初始数据让这个应用 run 起来。编辑 `index.js`：\n\n```diff\n- const app = dva();\n+ const app = dva({\n+   initialState: {\n+     products: [\n+       { name: 'dva', id: 1 },\n+       { name: 'antd', id: 2 },\n+     ],\n+   },\n+ });\n```\n\n刷新浏览器，应该能看到以下效果：\n\n<img src=\"https://zos.alipayobjects.com/rmsportal/GQJeDDeUCSTRMMg.gif\" alt=\"img\" style=\"zoom:80%;\" />\n\n## [#](https://dvajs.com/guide/getting-started.html#构建应用)构建应用\n\n完成开发并且在开发环境验证之后，就需要部署给我们的用户了。先执行下面的命令：\n\n```bash\nnpm run build\n```\n\n几秒后，输出应该如下：\n\n```bash\n> @ build /private/tmp/myapp\n> roadhog build\n\nCreating an optimized production build...\nCompiled successfully.\n\nFile sizes after gzip:\n\n  82.98 KB  dist/index.js\n  270 B     dist/index.css\n```\n\n`build` 命令会打包所有的资源，包含 JavaScript, CSS, web fonts, images, html 等。然后你可以在 `dist/` 目录下找到这些文件。\n","children":[]}]},{"name":"mobx.md","path":"../guanruihua.github.io/React/状态管理","data":"# Mobx\n\n\n\n## this找不到问题\n\n```tsx\n 添加\t\n constructor() {\n\t\tmakeObservable(this);\n\t}\n```\n\n\n\n## 继承使用\n\n### 父类\n\n```tsx\nclass father{\n   constructor() {\n\t\tmakeObservable(this);\n\t}\n  @action.bound\n  fn(){}\n}\n\n```\n\n\n\n### 子类\n\n```tsx\nclass son extends father{\n   constructor() {\n     super();\n\t\tmakeObservable(this);\n\t}\n  @override\n\tfn(){\n\t\t// 这里就可以重写方法\n  }  \n}\n```\n\n","children":[]},{"name":"redux","path":"../guanruihua.github.io/React/状态管理","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/React/状态管理/redux","data":"# Redux\n\n>  [React Redux ](https://react-redux.js.org/tutorials/quick-start)\n>\n>  [React redux-saga使用详解](https://blog.csdn.net/ZYC88888/article/details/82730879)\n\n","children":[]},{"name":"React_Redux_React-redux.md","path":"../guanruihua.github.io/React/状态管理/redux","data":"# React, Redux, React-Redux\n\n> React : 负责组件的UI界面渲染\n>\n> Redux : 数据处理中心\n>\n> React-Redux : 连接组件和数据中心, 就是和react和redux联系起来\n\n## react生命周期\n\n1. `getDefaultProps()`\n\n设置默认的props，es6中用 `static dufaultProps={}` 设置组件的默认属性。在整个生命周期只执行一次。\n\n2. `getInitialState()`\n\n在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props。\n\n3. `componentWillMount()`\n\n    ajax数据的拉取操作，定时器的启动。\n\n组件初始化时调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。\n\n4. `render()`\n\nReact最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。\n\n5. `componentDidMount()`    动画的启动，输入框自动聚焦\n\n组件渲染之后调用，可以通过this.getDOMNode()获取和操作dom节点，只调用一次。\n\n二、在更新时也会触发5个钩子函数：\n\n2. `componentWillReceivePorps(nextProps)`\n\n组件初始化时不调用，组件接受新的props时调用。不管父组件传递给子组件的props有没有改变，都会触发。\n\n3. `shouldComponentUpdate(nextProps, nextState)`\n\nReact性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。不过调用this.forceUpdate会跳过此步骤。\n\n4. `componentWillUpdate(nextProps, nextState)`\n\n组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state\n\n5. `render()`\n\n不多说\n\n6. `componentDidUpdate()`\n\n组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。\n\n三、卸载钩子函数\n\n7. `componentWillUnmount()`   定时器的清除\n\n组件将要卸载时调用，一些事件监听和定时器需要在此时清除。\n\n<img src=\"https://images.gitee.com/uploads/images/2020/1118/114419_53fa0c37_7984151.png\" style=\"zoom:67%;\" />\n\n## Redux\n\n> 1. 唯一数据源\n> 2. 状态只读\n> 3. 数据改变指定通过纯函数(reducer)完成\n\n### 核心api\n\n> store, reducer, action\n\n#### store\n\n![](https://images.gitee.com/uploads/images/2020/1118/114823_9f073716_7984151.png)\n\n> getState():  存储的数据, 状态树\n>\n> dispatch(action): 分发action, 并返回action, 这是唯一能改变store中数据的方式\n>\n> subscrible(listener) : 注册一个监听者, store发生变化时候被调用\n\n#### reducer\n\n<img src=\"https://images.gitee.com/uploads/images/2020/1118/115210_465f7e83_7984151.png\" style=\"zoom:67%;\" />\n","children":[]},{"name":"redux-toolkit.md","path":"../guanruihua.github.io/React/状态管理/redux","data":"# Redux Toolkit\n\n> 简化 `redux` 的使用\n\n## Api\n\n> - `configureStore() `\n>   提供简化的配置选项和良好的默认值。它可以自动组合众多的reducers，添加用户提供的任何Redux中间件，默认情况下包括Redux -thunk(处理异步Action的中间件)，并支持使用Redux DevTools扩展。\n> - `createReducer() `\n>   创建reducer的action映射表而不必编写switch语句。自动使用immer库让你用正常的代码编写更简单的不可变更新，比如state.todos[3].completed = true。\n> - `createAction() `\n>   为给定的操作类型字符串生成action creator函数\n> - `createSlice() `\n>   根据传递的参数自动生成相应的actionCreator和reducer函数\n> - `createAsyncThunk() `\n>   接受action字符串和返回Promise的函数，并生成分派的thunk函数\n> - `createEntityAdapter `\n>   生成可重用的reducers和selectors来管理store中的数据, 执行CRUD操作\n> - `createSelector() `\n>   来自reselect库，被重新导出，用于state缓存，防止不必要的计算\n\n## 安装使用\n\n> `npx create-react-app my-app --template redux`\n\n### 配置组件和redux的热重载\n\n```js\nimport { configureStore } from '@reduxjs/toolkit'\n\nimport rootReducer from './rootReducer'\n\nconst store = configureStore({\n  reducer: rootReducer\n})\n\nif (process.env.NODE_ENV === 'development' && module.hot) {\n  module.hot.accept('./rootReducer', () => {\n    const newRootReducer = require('./rootReducer').default\n    store.replaceReducer(newRootReducer)\n  })\n}\n\nexport type AppDispatch = typeof store.dispatch\n\nexport default store\n```\n\n\n\n### 组件树热重载\n\n```js\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport { Provider } from 'react-redux'\n\nimport store from './app/store'\n\nimport './index.css'\n\n// 这里把树根节点的渲染逻辑提取到render函数中以在webpack检测到文件改变之后进行热更新\nconst render = () => {\n  const App = require('./app/App').default\n\n  ReactDOM.render(\n    <Provider store={store}>\n      <App />\n    </Provider>,\n    document.getElementById('root')\n  )\n}\n\nrender()\n\nif (process.env.NODE_ENV === 'development' && module.hot) {\n  module.hot.accept('./app/App', render)\n}\n```\n\n\n\n### 使用`useSelector() `和`useDispatch() ` Hook来替代`connect() `\n\n> - 传统的react应用在与redux进行连接时候是通过react-redux库的connect函数来传入mapState和mapDispatch函数来将redux中的state和action存储到组件的props中。\n> - react-redux新版已经支持useSelector, useDispatch Hook， 我们可以使用它们替代connect的写法。通过它们我们可以在纯函数组件中获取到store中的值并做到监测变化\n\n```js\nimport React, { useState } from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport {\n  decrement,\n  increment,\n  incrementByAmount,\n  incrementAsync,\n  selectCount,\n} from \"./counterSlice\";\nimport styles from \"./Counter.module.css\";\n\nexport default function Counter() {\n  const count = useSelector(selectCount);\n  const dispatch = useDispatch();\n  const [incrementAmount, setIncrementAmount] = useState(\"2\");\n\n  return (\n    <div>\n      <div className={styles.row}>\n        <button\n          className={styles.button}\n          aria-label=\"Increment value\"\n          onClick={() => dispatch(increment())}\n        >\n          +\n        </button>\n        <span className={styles.value}>{count}</span>\n        <button\n          className={styles.button}\n          aria-label=\"Decrement value\"\n          onClick={() => dispatch(decrement())}\n        >\n          -\n        </button>\n      </div>\n      <div className={styles.row}>\n        <input\n          className={styles.textbox}\n          aria-label=\"Set increment amount\"\n          value={incrementAmount}\n          onChange={(e) => setIncrementAmount(e.target.value)}\n        />\n        <button\n          className={styles.button}\n          onClick={() =>\n            dispatch(incrementByAmount(Number(incrementAmount) || 0))\n          }\n        >\n          Add Amount\n        </button>\n        <button\n          className={styles.asyncButton}\n          onClick={() => dispatch(incrementAsync(Number(incrementAmount) || 0))}\n        >\n          Add Async\n        </button>\n      </div>\n    </div>\n  );\n}\n```\n\n### 使用useEffect Hook来执行异步逻辑\n\n\n\n```js\nexport const IssuesListPage = ({\n  org,\n  repo,\n  page = 1,\n  setJumpToPage,\n  showIssueComments\n}: ILProps) => {\n  const [issuesResult, setIssues] = useState<IssuesResult>({\n    pageLinks: null,\n    pageCount: 1,\n    issues: []\n  })\n  const [numIssues, setNumIssues] = useState<number>(-1)\n  const [isLoading, setIsLoading] = useState<boolean>(false)\n  const [issuesError, setIssuesError] = useState<Error | null>(null)\n\n  const { issues, pageCount } = issuesResult\n\n  useEffect(() => {\n    async function fetchEverything() {\n      async function fetchIssues() {\n        const issuesResult = await getIssues(org, repo, page)\n        setIssues(issuesResult)\n      }  \nasync function fetchIssueCount() {\n    const repoDetails = await getRepoDetails(org, repo)\n    setNumIssues(repoDetails.open_issues_count)\n  }\n\n  try {\n    await Promise.all([fetchIssues(), fetchIssueCount()])\n    setIssuesError(null)\n  } catch (err) {\n    console.error(err)\n    setIssuesError(err)\n  } finally {\n    setIsLoading(false)\n  }\n}\n\nsetIsLoading(true)\n\nfetchEverything()\n  }, [org, repo, page])\n\n  // omit rendering\n}\n```\n\n\n### createAsyncThunk的使用\n\n> 参数\n> \t\trtk提供的生成thunk action creator的工具函数\n> 参数:\n>\n> 1. type: actionType字符串(如users/requestStatus)， rtk会会基于此生成以下三个action creator\t\n>\n>    `fulfilled: 'users/requestStatus/fulfilled' `\n>\n>    `rejected: 'users/requestStatus/rejected' `\t\t\n>\n>    `pending: 'users/requestStatus/pending`\t\n>\n> - payloadCreator\n>   一个回调函数，它应该返回一个包含一些异步逻辑结果的promise\n>   payloadCreator的参数有两个:\n>\n>   - arg\n>     dispatch thunk action creator 时候参入的参数值，如ids等需要参与AJAX的值\n>\n>   - thunkAPI对象\n>     一个对象，包含通常传递给Redux thunk函数的所有参数，以及其他选项\n>     - dispatch store的dispatch函数\n>     - getState store的getState函数\n>     - extra 调用configureStore配置store时候传递给thunk middleware的额外参数\n>     - requestId当次请求的唯一表示串\n>     - signal取消标志， 如果应用有其他地方标记这个请求应该取消则为true\n>     - rejectWithValue工具函数, 用于返回一个可以自定义payload被reject的Promise\n>\n>     \n>\n> - options对象\n>\n>   - condition: 一个回调，如果需要，可用于跳过payload creator函数逻辑执行\n>   - dispatchConditionRejection： 如果condition()返回false，则默认行为是根本不分派任何动作。如果您仍然希望在thunk被取消时发送一个“rejected”操作，将此标志设置为true。\n\n\n\n\n\n\n\n### createAsyncThunk函数的返回值\n\n返回一个标准的Redux thunk action creator。thunk动作创建器函数将为pending, fulfilled, rejected情况提供普通action creator，并将其作为嵌套字段附加。\n如上面的fetchUserById例子:\n通过调用createAsyncThunk会生成四对action, action creator\n\nfetchUserById.pending，一个action creator，它分派一个’users/fetchByIdStatus/pending’操作\nfetchUserById.fulfilled 一个分派’users/fetchByIdStatus/ fulfilled’动作的action creator\nfetchUserById.rejected: 一个分派’users/fetchByIdStatus/rejected’动作的action creator\n要在reducer中处理这些action，请使用对象键表示法或“构建器回调”表示法引用createReducer或createSlice中的action creator。\n\n```js\nconst reducer1 = createReducer(initialState, {\n  [fetchUserById.fulfilled]: (state, action) => {}\n})\n\nconst reducer2 = createReducer(initialState, builder => {\n  builder.addCase(fetchUserById.fulfilled, (state, action) => {})\n})\n\nconst reducer3 = createSlice({\n  name: 'users',\n  initialState,\n  reducers: {},\n  extraReducers: {\n    [fetchUserById.fulfilled]: (state, action) => {}\n  }\n})\n\nconst reducer4 = createSlice({\n  name: 'users',\n  initialState,\n  reducers: {},\n  extraReducers: builder => {\n    builder.addCase(fetchUserById.fulfilled, (state, action) => {})\n  }\n})\n```\n\n\n\n### 处理thunk的返回结果\n\n调用thunks时可能返回一个值。一个常见的用例是:从thunk返回一个promise，从组件中分派thunk，然后等待promise被解析，然后再做额外的工作:\n\n```js\nconst onClick = () => {\n  dispatch(fetchUserById(userId)).then(() => {\n    // do additional work\n  })\n}\n```\n\n\n由createAsyncThunk生成的thunks将总是返回一个已解析的承诺，其中包含已实现的操作对象或被拒绝的操作对象，视情况而定。\n\n调用逻辑可能希望将这些操作视为最初的promise内容。redux toolkit导出一个unwrapResult函数，该函数可用于从操作中提取负载或错误，并适当地返回或抛出结果\n\n```js\nimport { unwrapResult } from '@reduxjs/toolkit'\n\n// in the component\nconst onClick = () => {\n  dispatch(fetchUserById(userId))\n    .then(unwrapResult)\n    .then(originalPromiseResult => {})\n    .catch(serializedError => {})\n}\n```\n\n\n如果您需要定制被reject操作的内容，您应该自己捕获任何错误，然后使用thunkAPI返回的rejectWithValue。执行return rejectWithValue(errorPayload)将导致被reject的操作将该值作为action.payload使用\n\n```js\nconst updateUser = createAsyncThunk(\n  'users/update',\n  async (userData, { rejectWithValue }) => {\n    const { id, ...fields } = userData\n    try {\n      const response = await userAPI.updateById(id, fields)\n      return response.data.user\n    } catch (err) {\n      // Use `err.response.data` as `action.payload` for a `rejected` action,\n      // by explicitly returning it using the `rejectWithValue()` utility\n      return rejectWithValue(err.response.data)\n    }\n  }\n)\n```\n\n\n\n### 请求的取消\n\n#### 请求前取消\n\n如果您需要在调用负载创建器之前取消一个thunk，您可以在负载创建器之后提供一个条件回调选项。回调函数将接收thunk参数和一个带有{getState, extra}的对象作为参数，并使用它们来决定是否继续。如果执行应该被取消，条件回调函数应该返回false\n\n```js\nconst fetchUserById = createAsyncThunk(\n  'users/fetchByIdStatus',\n  async (userId, thunkAPI) => {\n    const response = await userAPI.fetchById(userId)\n    return response.data\n  },\n  {\n    condition: (userId, { getState, extra }) => {\n      const { users } = getState()\n      const fetchStatus = users.requests[userId]\n      if (fetchStatus === 'fulfilled' || fetchStatus === 'loading') {\n        // Already fetched or in progress, don't need to re-fetch\n        return false\n      }\n    }\n  }\n)\n```\n\n#### 请求时取消\n\n如果你想在它完成之前取消运行的thunk，你可以使用dispatch返回的promise的abort方法\n\n```js\nimport { fetchUserById } from './slice'\nimport { useAppDispatch } from './store'\nimport React from 'react'\n\nfunction MyComponent(props) {\n  const dispatch = useAppDispatch()\n  React.useEffect(() => {\n    // Dispatching the thunk returns a promise\n    const promise = dispatch(fetchUserById(props.userId))\n    return () => {\n      // `createAsyncThunk` attaches an `abort()` method to the promise\n      promise.abort()\n    }\n  }, [props.userId])\n}\n```\n\n\n使用thunkAPI.signal取消网络请求\n现代浏览器的fetch api已经提供了对中止信号的支持\n\n```js\nimport { createAsyncThunk } from '@reduxjs/toolkit'\n\nconst fetchUserById = createAsyncThunk(\n  'users/fetchById',\n  async (userId, thunkAPI) => {\n    const response = await fetch(`https://reqres.in/api/users/${userId}`, {\n      signal: thunkAPI.signal,\n    })\n    return await response.json()\n  }\n)\n```\n\n#### 检查取消状态\n\n你可以用这个中止属性定期检查thunk是否已中止，并在这种情况下停止代价高昂的长时间运行的工作\n\n\n\n```js\nimport { createAsyncThunk } from '@reduxjs/toolkit'\n\nconst readStream = createAsyncThunk(\n  'readStream',\n  async (stream, { signal }) => {\n    const reader = stream.getReader()\nlet done = false\nlet result = ''\n\nwhile (!done) {\n  if (signal.aborted) {\n    throw new Error('stop the work, this has been aborted!')\n  }\n  const read = await reader.read()\n  result += read.value\n  done = read.done\n  }\n  return result\n  }\n)\n```\n\n\n你也可以调用signal.addEventListener(‘abort’， callback)在调用promise.abort()时通知thunk内部的逻辑。例如，这可以与axios CancelToken一起使用\n\n```js\nimport { createAsyncThunk } from '@reduxjs/toolkit'\nimport axios from 'axios'\n\nconst fetchUserById = createAsyncThunk(\n  'users/fetchById',\n  async (userId, { signal }) => {\n    const source = axios.CancelToken.source()\n    signal.addEventListener('abort', () => {\n      source.cancel()\n    })\n    const response = await axios.get(`https://reqres.in/api/users/${userId}`, {\n      cancelToken: source.token,\n    })\n    return response.data\n  }\n)\n```\n\n\n\n### createEntityAdapter\n\n生成一组预构建的reducer和selector的函数，用于对包含特定类型数据对象实例的规范化状态结构执行CRUD操作。这些reducer函数可以作为case reducer传递给createReducer和createSlice。它们也可以作为createReducer和createSlice内部的“突变”助手函数\n实例\n\n```js\nimport {\n  createEntityAdapter,\n  createSlice,\n  configureStore\n} from '@reduxjs/toolkit'\n\n// Since we don't provide `selectId`, it defaults to assuming `entity.id` is the right field\nconst booksAdapter = createEntityAdapter({\n  // Keep the \"all IDs\" array sorted based on book titles\n  sortComparer: (a, b) => a.title.localeCompare(b.title)\n})\n\nconst booksSlice = createSlice({\n  name: 'books',\n  initialState: booksAdapter.getInitialState({\n    loading: 'idle'\n  }),\n  reducers: {\n    // Can pass adapter functions directly as case reducers.  Because we're passing this\n    // as a value, `createSlice` will auto-generate the `bookAdded` action type / creator\n    bookAdded: booksAdapter.addOne,\n    booksLoading(state, action) {\n      if (state.loading === 'idle') {\n        state.loading = 'pending'\n      }\n    },\n    booksReceived(state, action) {\n      if (state.loading === 'pending') {\n        // Or, call them as \"mutating\" helpers in a case reducer\n        booksAdapter.setAll(state, action.payload)\n        state.loading = 'idle'\n      }\n    },\n    bookUpdated: booksAdapter.updateOne\n  }\n})\n\nconst {\n  bookAdded,\n  booksLoading,\n  booksReceived,\n  bookUpdated\n} = booksSlice.actions\n\nconst store = configureStore({\n  reducer: {\n    books: booksSlice.reducer\n  }\n})\n\n// Check the initial state:\nconsole.log(store.getState().books)\n// {ids: [], entities: {}, loading: 'idle' }\n\nconst booksSelectors = booksAdapter.getSelectors(state => state.books)\n\nstore.dispatch(bookAdded({ id: 'a', title: 'First' }))\nconsole.log(store.getState().books)\n// {ids: [\"a\"], entities: {a: {id: \"a\", title: \"First\"}}, loading: 'idle' }\n\nstore.dispatch(bookUpdated({ id: 'a', changes: { title: 'First (altered)' } }))\nstore.dispatch(booksLoading())\nconsole.log(store.getState().books)\n// {ids: [\"a\"], entities: {a: {id: \"a\", title: \"First (altered)\"}}, loading: 'pending' }\n\nstore.dispatch(\n  booksReceived([\n    { id: 'b', title: 'Book 3' },\n    { id: 'c', title: 'Book 2' }\n  ])\n)\n\nconsole.log(booksSelectors.selectIds(store.getState()))\n// \"a\" was removed due to the `setAll()` call\n// Since they're sorted by title, \"Book 2\" comes before \"Book 3\"\n// [\"c\", \"b\"]\n\nconsole.log(booksSelectors.selectAll(store.getState()))\n// All book entries in sorted order\n// [{id: \"c\", title: \"Book 2\"}, {id: \"b\", title: \"Book 3\"}]\n```\n\n","children":[]}]}]}]},{"name":"README.md","path":"../guanruihua.github.io","data":"# [ruihuag](https://guanruihua.github.io/#/)\r\n\r\n## plan\r\n\r\n- `browser-helper-js` 包 准备中\r\n- `file-system-hoc` 包 准备中\r\n- 开源项目 测试覆盖率\r\n","children":[]},{"name":"Tool","path":"../guanruihua.github.io","data":"","children":[{"name":"autohotkey","path":"../guanruihua.github.io/Tool","data":"","children":[{"name":"autohotkey-config.md","path":"../guanruihua.github.io/Tool/autohotkey","data":"# autohotkey\n\n```\n#NoEnv  ; Recommended for performance and compatibility with future AutoHotkey releases.\n; #Warn  ; Enable warnings to assist with detecting common errors.\nSendMode Input  ; Recommended for new scripts due to its superior speed and reliability.\nSetWorkingDir %A_ScriptDir%  ; Ensures a consistent starting directory.\n\n#w::    ;;这里的 #->表示window键  w->表示字母w键                   \nWinMinimize,A    ;;最小化当前窗口      \nreturn     \n\n!h:: Send {Left} \nreturn\n!l:: Send {Right}\nreturn\n!j:: Send {Down}\nreturn\n!k:: Send {Up}\nreturn \n\n; 上下左右滚轮\n!u:: Send {WheelDown}\nreturn \n!i:: Send {WheelUp}\nreturn \n!y:: Send {Wheelleft}\nreturn \n!o:: Send {WheelRight}\nreturn \n\n; 鼠标左击\n!-::  \nSendEvent {Blind}{LButton down}\nKeyWait RCtrl  \nSendEvent {Blind}{LButton up}\nreturn\n\n; 鼠标右击\n!=::  \nSendEvent {Blind}{RButton down}\nKeyWait AppsKey  \nSendEvent {Blind}{RButton up}\nreturn\n\n\n; 删除 / 退格\n!b:: Send {BackSpace}\nreturn \n!m:: Send {NumpadAdd} \nreturn \n!n:: Send {NumpadSub}\nreturn\n!,:: Send {=}\nreturn\n\n; 其他快捷键\n;!space:: {+}\n;return\n\n; 自用的按键映射\n$CapsLock::\nKeyWait, CapsLock\nIf (A_PriorKey=\"CapsLock\")\nSetCapsLockState, % GetKeyState(\"CapsLock\",\"T\") ? \"Off\":\"On\"\nReturn\n#If, GetKeyState(\"CapsLock\", \"P\")\nk::Up\nj::Down\nh::Left\nl::Right\n1::Send #{1}\n2::Send #{2}\n3::Send #{3}\n4::Send #{4}\n5::Send #{5}\n6::Send #{6}\n7::Send #{7}\n8::Send #{8}\n9::Send #{9}\n^k::Send +{Up}\n^j::Send +{Down}\n^h::Send +{Left}\n^l::Send +{Right}\nw::Send ^{Left}\ne::Send ^{Right}\nu::Send ^{z}\ng::Send {Enter} \nz::Send ^{z}\nc::Send ^{c}\nv::Send ^{v}\ns::Send ^{s}\nx::Send ^{x}\n#w::Send ^{w}\nEnter::Send {Esc}\nq::Send {Esc}\nSpace::Send {=}\n,::Home\n.::End\nr::Send ^{/}\nb::Send {BackSpace}\nd::Send {Delete}\nn::Send ^{Backspace}\nm::Send ^{Delete}\n```\n","children":[]},{"name":"index.md","path":"../guanruihua.github.io/Tool/autohotkey","data":"# AutoHotkey\n\n> [用于热键和宏的按键和鼠标/操纵杆按钮的列表 (sourceforge.net)](http://ahkcn.sourceforge.net/docs/KeyList.htm)\n\n## 自启动设\n\n>添加到 `C:\\Users\\用户名\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup`\n","children":[]}]},{"name":"bat","path":"../guanruihua.github.io/Tool","data":"","children":[{"name":"bat.md","path":"../guanruihua.github.io/Tool/bat","data":"# Batch\n\n> - 几乎任何windows 都可以直接运行\n> - 大小写不敏感\n> - 行前空格不敏感\n> - 编码格式采用`GB2312`正常( ANSI )\n","children":[]},{"name":"bat_script.md","path":"../guanruihua.github.io/Tool/bat","data":"# bat\n\n## 脚本\n\n> 例子, 这是一个git 提交的模板\n\n```shell\n@echo off\nset /p commit=commit:\ntitle auto commit\n\nrem 调用git命令，如果没有找到git命令，说明环境变量未配置\nrem 将git改成git安装目录下的git.exe也可以实现\n\ngit add .\ngit commit -m %commit%\ngit push\n\npause\n```\n\n## 执行\n\n> 1. `CMD`: 文件名.bat\n>\n> 2. `powershell`: ./文件名.bat\n> 3. 直接点击运行\n","children":[]}]},{"name":"eclipse","path":"../guanruihua.github.io/Tool","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Tool/eclipse","data":"# Eclipse\n\n>\n\n## 插件\n\n> Help -> Eclipse Marketplace.\n>\n> 1. vim\n> 2. Spring Tools\n","children":[]}]},{"name":"git","path":"../guanruihua.github.io/Tool","data":"","children":[{"name":"gitee.md","path":"../guanruihua.github.io/Tool/git","data":"# 码云的使用\n\n### 提交没有显示贡献问题\n\n> 问题1:提交后贡献度不显示\n>\n> 原因1:本地git和码云帐号邮箱不一致\n>\n> 解决1:将本地帐号调整一下\n>\n> 查看当前git用户名： git config user.name\n>\n> 查看当前git邮箱： git config user.email\n>\n> 切换git用户名: git config --global user.name \"YOURUSERNAME\"\n>\n> 切换git邮箱： git config --global user.email \"YOUREMAIL\"\n\n## clone代码\n\n`git clone git@gitee.com:guanruihua/grh_note.git`\n\n## 上传文件\n\n```git\ngit add .(上传全部文件)\ngit commit -m \"备注\"(上传到缓冲区)\ngit push origin master(上传到云端)\n```\n\n## 删除文件\n\n```\nrm '文件名'(删除文件)\ngit add '文件名'(将删除文件的状态添加到暂存区)\ngit commit -m 'delete 文件名'(将改文将状态上传到缓冲区)\ngit push (上传到云端)\n```\n\n## 删除文件夹\n\n```git\nls (查看本地分支的文件)\ngit rm raindow -r -f (删除raindow文件夹及其所有文件)\ngit commit -m \"delete raindow\" (同步删除操作)\ngit push origin master (提交分支)\n```\n\n密钥对创建成功。\n\n指纹：F0A136C885F5A7438B624048CB2352B6BB958F9A\n\n## 删除分支\n\n```git\ngit branch -a (查看所有分支)\ngit push origin --delete HEAD (删除HEAD分支)\n```\n","children":[]},{"name":"github.md","path":"../guanruihua.github.io/Tool/git","data":"# github\n\n## 速度太慢\n\n## github图片加载问题\n\n> 在原本的``url`地址上加`cnpmjs.org`\n>\n> 例如:`github.com/...`=>`github.com.cnpmjs.org/...`\n\n添加到hosts文件( `C:\\Windows\\System32\\drivers\\etc` ) 中\n\n> - 但是还是会有丢包的情况出现\n> - 若文件无法修改记得把文件只读的选项去掉\n\n```tiki wiki\n# GitHub Start \n\n192.30.253.112    Build software better, together \n192.30.253.119    gist.github.com\n151.101.184.133    assets-cdn.github.com\n151.101.184.133    raw.githubusercontent.com\n151.101.184.133    gist.githubusercontent.com\n151.101.184.133    cloud.githubusercontent.com\n151.101.184.133    camo.githubusercontent.com\n151.101.184.133    avatars0.githubusercontent.com\n151.101.184.133    avatars1.githubusercontent.com\n151.101.184.133    avatars2.githubusercontent.com\n151.101.184.133    avatars3.githubusercontent.com\n151.101.184.133    avatars4.githubusercontent.com\n151.101.184.133    avatars5.githubusercontent.com\n151.101.184.133    avatars6.githubusercontent.com\n151.101.184.133    avatars7.githubusercontent.com\n151.101.184.133    avatars8.githubusercontent.com\n\n # GitHub End\n```\n\n然后还是发现有的图片无法显示就可以通过以下来解决\n\n> 1. 在无法查看图片的页面按下``F12`\n> 2. 找到该图片的链接 例如:`https://avatars2.githubusercontent.com/u/15832957?s=60&v=4`\n> 3. 打开<https://www.ipaddress.com/>\n> 4. 输入`avatars2.githubusercontent.com`进去就可以看到域名的信息和IP地址\n> 5. 然后添加进``hosts文件``去\n\n```git\nip地址    avatars2.githubusercontent.com 的格式\n```\n\n```git\necho \"# File\" >> README.md\ngit init\ngit add README.md\ngit commit -m \"first commit\"\ngit branch -M main\ngit remote add origin git@github.com:guanruihua/File.git\ngit push -u origin main\n\n\n\ngit remote add origin git@github.com:guanruihua/File.git\ngit branch -M main\ngit push -u origin main\n```\n\n## 无法访问github\n\n> 绕过DNS, 直接使用本地DNS记录进行直接跳转\n\n## 1.通过命令提示符ping到GitHub的IP\n\n打开命令符：win+R，输入cmd，回车即可调出命令符\n\nping：在命令行中输入ping [http://github.com](https://link.zhihu.com/?target=http%3A//github.com)，记录红框中的IP\n\n![img](https://pic3.zhimg.com/80/v2-305df8d0e362b9b04904f0817917f94e_1440w.jpg)\n\n## 2.DNS查询\n\n在浏览器中打开DNS查询网站：[http://tool.chinaz.com/dns?type=1&host=github.com&ip=](https://link.zhihu.com/?target=http%3A//tool.chinaz.com/dns%3Ftype%3D1%26host%3Dgithub.com%26ip%3D)\n\n选一个TTL值小的IP记录下来\n\n![img](https://pic3.zhimg.com/80/v2-3878daee945c457c5a0ce75d8d279f3a_1440w.jpg)\n\n## 3.修改HOST\n\n通常在修改系统host的时候，为编辑器授权管理员权限是一件比较麻烦的事情，这里给大家介绍一种非常简单的方式。详情见文章：[用创建桌面快捷方式的方法快速修改HOST](https://link.zhihu.com/?target=https%3A//pzyer.com/tips/%E7%94%A8%E5%88%9B%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95%E5%BF%AB%E9%80%9F%E4%BF%AE%E6%94%B9HOST.html)\n\n操作完成后，这里我们将前面查到的两个IP都写进HOST记录\n\n![img](https://pic1.zhimg.com/80/v2-bb2b0fd6de49540d951e917c3d6e24a0_720w.jpg)\n\n## 4.刷新本地DNS缓存\n\n打开命令提示符，输入：ipconfig /flushdns\n\n返回显示：\nWindows IP 配置\n已成功刷新 DNS 解析缓存。\n\n## 5.成功优化\n\n这个时候我们再次访问就会发现加载速度快多了，或者之前不能访问，现在能访问了\n","children":[]},{"name":"type.md","path":"../guanruihua.github.io/Tool/git","data":"# Commit Type\r\n\r\n## type用于说明 commit 的类别，只允许使用下面8个标识\r\n\r\n```shell\r\nbr: 此项特别针对bug号，用于向测试反馈bug列表的bug修改情况\r\nfeat：新功能（feature）\r\nfix：修补bug\r\ndocs：文档（documentation）\r\nstyle： 格式（不影响代码运行的变动）\r\nopt: 优化\r\nrefactor：重构（即不是新增功能，也不是修改bug的代码变动）\r\ntest：增加测试\r\nchore：构建过程或辅助工具的变动\r\nrevert: feat(pencil): add 'graphiteWidth' option (撤销之前的commit)\r\n```\r\n","children":[]},{"name":"命令","path":"../guanruihua.github.io/Tool/git","data":"","children":[{"name":"git.md","path":"../guanruihua.github.io/Tool/git/命令","data":"# git\n\n## 前言\n\n> 工具:  [TortoiseGit](https://gitee.com/enterprises?utm_source=baidu&utm_medium=sem&utm_term=110206&utm_campaign=enterprise&bd_vid=8015310045877046198)\n>\n> 工作流程: 工作目录 -> 暂存区 -> GIT仓库\n\n![image](https://img-blog.csdnimg.cn/img_convert/b7c2d1149f813df1097f1888eb04e94f.png)\n\n## git常用指令\n\n【git init 】：为当前项目创建一个本地仓库（即需要事先有一个创建好的项目）\n【git clone [url]】：克隆一个仓库\n【git status 】：查看git的状态\n【git add ./】：添加当前目录下的所有到“Stage”中\n【git commit】：提交“Stage”中的内容到本地仓库中\n【git pull origin master】：拉去远程仓库“origin”相应的分支到本地仓库中的master中，在push之前常常需要先pull一下最新的仓库\n【git pull origin master --allow-unrelated-histories】：如果本地与远程是两个独立的仓库，则在pull时需要指定其“允许无关的日志合并”，否则会保存\n【git push origin master】：将本地仓库中的内容提交到远程仓库中（origin为远程分支的名字，master为当前分支的名字，应注意的是，该命令是不完全完整的，在实际使用中，如果是第一个提交到远程，应该使用的命令为【git push -u origin master】，如果不是第一次，则直接使用【git push】即可）\n【git remote add origin [url]】：添加一个远程仓库连接，并为其命名为\"origin\"，当然也可以自定义其它的名字，但一般都命名为origin\n【git remote rm origin】：删除一个名为\"origin\"的远程仓库连接\n【git remote set-url origin [url]】：修改\"origin\"的url（结合上面一个命令可以发现，想要修改远程仓库连接有两种方法：一种是先删除再添加，一种是直接修改）\n\n```shell\ngit status // 查看代码状态\ngit checkout [ 分支名称 ] // 查看分支的状态\ngit add . // 添加修改\ngit commit -m \"[描述]\" //添加到本地换成\ngit push \ngit push -u origin master\ngit config user.name \"[username]\" // 配置用户名\ngit config user.email \"[eamil]\" // 配置邮箱\ngit config user.name // 查看用户名\ngit config user.email // 查看用户邮箱\n```\n\n```shell\ngit init\ngit add .\ngit commit -m 'message'\ngit remote add origin 远程库地址\ngit push -u origin main | master\n```\n\n```shell\necho \"# note\" >> README.md\ngit init\ngit add README.md\ngit commit -m \"first commit\"\ngit branch -M main\ngit remote add origin git@github.com:guanruihua/note.git\ngit push -u origin main\n                \n```\n\n```shell\ngit remote add origin git@github.com:guanruihua/note.git\ngit branch -M main\ngit push -u origin main\n```\n\n## 建立远程仓库连接\n\n```shell\n# 和远程仓库建立连接\ngit remote add origin https://github.com/Jacob-xyb/Projiect  \ngit remote remove origin https://github.com/Jacob-xyb/Projiect # 删除远程仓库\n```\n\n## 提交\n\n### 普通提交\n\n```shell\ngit commit -m \"commit\"\ngit push -u origin main | master\n```\n\n```shell\ngit add .\ngit commit -m \"描述\"\ngit push origin // 提交到已经切换到分支\n```\n\n### 强制提交\n\n```shell\n报错内容：\nTo github.com:***/***\n! [rejected] master -> master (non-fast-forward)\nerror: failed to push some refs to ‘git@github.com:***/***’\nhint: Updates were rejected because the tip of your current branch is behind\nhint: its remote counterpart. Integrate the remote changes (e.g.\nhint: ‘git pull …’) before pushing again.\nhint: See the ‘Note about fast-forwards’ in ‘git push --help’ for details.\n```\n\n```shell\ngit push origin master -f\n```\n\n### 提交到其他分支\n\n> 首先要建立本地的分支，并切换到该分支上（本地建立完分支，默认是在master分支上）\n\n```shell\ngit branch hello_git_branch // 创建分支\ngit checkout hello_git_branch // 检查该分支\ngit push origin hello_git_branch // push到远程仓库上面\n```\n\n## git 查看仓库信息\n\n```shell\ngit log    # 查看日志信息\ngit reflog    # 查看一行日志\ngit remote -v  # 查看当前项目的远程git地址\ncat .git/HEAD  # 查看当前HEAD\n```\n\n查看系统config\n\n```\ngit config --system --list\n```\n\n查看当前用户（global）配置\n\n```\ngit config --global --list\n```\n\n查看当前仓库配置信息\n\n```\ngit config --local --list\n```\n\n## git 更新代码到本地\n\n### 正规流程\n\n```shell\ngit status（查看本地分支文件信息，确保更新时不产生冲突）\ngit checkout – [file name] （若文件有修改，可以还原到最初状态; 若文件需要更新到服务器上，应该先merge到服务器，再更新到本地）\ngit branch（查看当前分支情况）\ngit checkout remote branch (若分支为本地分支，则需切换到服务器的远程分支)\ngit pull\n```\n\n### 快速流程\n\n```shell\ngit pull (一句命令搞定)\ngit branch 看看分支\ngit checkout aaa 切换分支aaa\ngit branck aaa 创建aaa分支\ngit chechout -b aaa 本地创建 aaa分支，同时切换到aaa分支。只有提交的时候才会在服务端上创建一个分支\n```\n\n## git 撤销\n\n用暂存区中的文件覆盖工作目录中的文件：\n`git checkout 文件名字`\n\n从暂存区中删除文件：\n`git rm --cached 文件`\n\n将 git 仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录：\n\n```shell\ngit reset --hard commitID  # 恢复到指定ID版本\ngit reset --hard HEAD^  # 回退上一个版本\ngit reset --hard HEAD~1  # 回退上一个版本 // ～n 就是回退n个版本\n```\n\n注意：如果将版本指针前置的话，指针后面的日志就会消失。\n删除 远程仓库 中的文件\n`git rm -r --cached 文件`\n\n修改提交的commit注释\n`git commit --amend`\n\n> 参数讲解\n> `--mixed`\n> 不删除工作空间改动代码，撤销commit，并且撤销git add . 操作\n>\n> 这个为默认参数，git reset --mixed HEAD^ 和 git reset HEAD^ 效果是一样的。\n>\n> `--soft`\n> 不删除工作空间改动代码，撤销commit，不撤销 git add .\n>\n> `--hard`\n> 删除工作空间改动代码，撤销 commit，撤销 git add .\n>\n> 注意完成这个操作后，就恢复到了上一次的commit状态。\n\n## 版本回退\n\n```shell\ngit add . // 提交到暂存去\ngit commit -m \"描述\" // 提交到本地分支\ngit push -u origin master // 提交到远程服务器(第一个版本)\n\n...\ngit push origin master // 修改项目后提交 ( 第二个版本 )\n\ngit add .\ngit commit -m \"描述\"\ngit push origin master // 修改项目后提交 ( 第三个版本 )\n\ngit log // 查看历史提交记录\ngit log --pretty =online // 查看历史提交记录[减少多余信息]\ngit reset --hard HEAD^ // 回到上一个版本\ngit reset --hard HEAD~100 // 回退到100个版本前\n\ngit reflog // 查看已经回退过的版本记录\n```\n\n## git 分支\n\n分支细分\n主分支（master）：第一次向 git 仓库中提交更新记录时自动产生的一个分支。\n开发分支（develop）：作为开发的分支，基于 master 分支创建。\n功能分支（feature）：作为开发具体功能的分支，基于开发分支创建。\n查看本地和远程分支\n\n### 查看本地分支（*为当前分支）\n\ngit branch == git branch --list == git branch -l\n\n### 查看本地和远程分支\n\ngit branch --all == git branch -a\n\n### 查看远程所有分支\n\ngit branch --remote == git branch -r\n\n### 切换分支\n\ngit checkout 分支名称\n\n### 分支重命名\n\ngit branch -m [oldName] [newName]\n\n切换分支之前要保持当前暂存区完全干净，不然会出现错误。\n\n这是由于 git 的暂存区是所有分支共享的，因此，只要未提交(commit)的内容都会在所有分支上呈现。有时，我们还未完成当前分支的功能开发，但是又亟需在另一个分支上修改内容(如：修复一个 BUG)。\n\n一种方式是通过“git commit”(提交)，解决这个问题。但在正常使用中，我们应该在完成某个功能的开发后才提交一个版本，而不是频繁的提交。\n\n这时，我们可以使用“git stash”(储藏)来解决这个问题。\n\n### 创建分支\n\ngit branch 分支名称   # 创建分支（基于所在分支创建）\ngit checkout -b branchName commitId # 根据指定版本号创建分支\n\n#### 合并和删除分支\n\n##### 合并\n\ngit merge 来源分支   # 合并分支（将来源分支合并到当前分支）\n\n##### 删除\n\ngit branch -d 分支名称  # 删除本地分支（如果删除的分支没有被合并是不能删除的）\ngit branch -D 分支名称  # 强制删除本地分支\ngit push origin -d 分支名称 # 删除远程分支[Git > v1.7.0](推荐)\ngit push origin :分支名称 # 删除远程分支(\":\"代表删除)\n\n##### 暂时保存更改\n\n在 git 中，可以暂时提取分支上所有的改动并存储，让开发人员得到一个干净的工作副本，临时转向其他工作。\n\n使用场景：分支临时切\n\ngit stash  # 临时保存\ngit stash pop # 恢复保存\n\n##### 分支管理\n\n### 将本地develop分支强制（-f）推送到远程master\n\ngit push origin develop:master -f\n\n### 重置的方法\n\ngit checkout master  # 切换到旧分支\ngit reset --hard develop  # 将本地的旧分支master重置成develop\ngit push origin master --force # 强制推送\n\n### 删除远程分支\n\n`git push origin --delete develop # 删除远程仓库`\n`git push origin:develop   # 推送至服务器才行`\n\n## 一台电脑同时使用gitee和github\n\n### 创建ssh key\n\n```shell\n# 进入用户目录下的 .ssh 文件夹下，路径会因你使用的操作系统不同而略有差异\n# 没有这个文件夹也无所谓，直接运行下一句命令也可以\ncd ~/.ssh\n\n# 生成 key，将邮件地址替换为你 Gitee 或者 Github 使用的邮件地址\nssh-keygen -t rsa -C \"xxx@xxx.com\"\n\n# gitee\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/c/Users/your_user_name/.ssh/id_rsa): id_rsa_gitee\nEnter passphrase (empty for no passphrase)://这里直接回车\nEnter same passphrase again://这里直接回车\n# github\n重复上过程,吧id_rsa_gitee 改成 id_rsa_github\n```\n\n### 在gitee和github添加public key\n\n```shell\ncd ~/.ssh\ncat id_rsa_gitee.pub\n//这里 gitee 的public key\ncat id_rsa_github.pub\n//这里 github 的public key\n```\n\n然后再分别添加到github 和 gitee 的 SSH\n\n### 创建配置文件\n\n在.ssh文件夹创建config文件, 添加内容 区分 两个 ssh key\n\n```shell\n# gitee\nHost gitee.com\nHostName gitee.com\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/id_rsa_gitee\n\n# github\nHost github.com\nHostName github.com\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/id_rsa_github\n```\n\n### 测试连接是否正常\n\n```shell\nssh -T git@github.com\n\nHi guanruihua! You've successfully authenticated, but GitHub does not provide shell access.\n\n\nssh -T git@gitee.com\n\nHi grh-gitee! You've successfully authenticated, but GITEE.COM does not provide shell access.\n```\n","children":[]},{"name":"index.md","path":"../guanruihua.github.io/Tool/git/命令","data":"# 命令\r\n","children":[]},{"name":"分支.md","path":"../guanruihua.github.io/Tool/git/命令","data":"# 分支\r\n\r\n## 查看分支\r\n\r\n```shell\r\ngit branch\r\n```\r\n\r\n## 新建分支\r\n\r\n- 在dev分支新建1个master分支不存在的文件\r\n- `-b`: 创建并切换\r\n\r\n```shell\r\n# 创建dev分支\r\ngit checkout -b dev\r\n# 等同于\r\ngit branch dev\r\ngit checkout dev\r\n```\r\n\r\n## 合并\r\n\r\n- 合并分支\r\n\r\n```shell\r\n# 切换到master分支\r\ngit checkout master\r\n# 将dev分支合并到主分支master上\r\ngit merge dev\r\n```\r\n\r\n## 删除分支\r\n\r\n```shell\r\n# 删除dev分支\r\ngit branch -d dev\r\n```\r\n","children":[]},{"name":"切换远程地址.md","path":"../guanruihua.github.io/Tool/git/命令","data":"# 切换远程地址\r\n\r\n## 修改远程仓库地址\r\n\r\n【git remote set-url origin URL】 更换远程仓库地址，URL为新地址。\r\n\r\n## 先删除远程仓库地址，然后再添加\r\n\r\n【git remote rm origin】 删除现有远程仓库\r\n【git remote add origin url】添加新远程仓库\r\n","children":[]},{"name":"基于主线分支创建新娘分支.md","path":"../guanruihua.github.io/Tool/git/命令","data":"# [`基于主线分支创建新娘分支`]()\r\n\r\n主线分支：main\r\n\r\n基于主线分支创建的分支：feature\r\n\r\n① 切换到主线分支：\r\n\r\ngit checkout main\r\n\r\n② 拉取主线分支最新的代码：\r\n\r\ngit pull --rebase\r\n\r\n③ 创建新分支并切换到该分支：\r\n\r\ngit checkout -b feature\r\n\r\n④ 推送新分支到远程仓库：\r\n\r\ngit push origin feature -f\r\n\r\n⑤ 关联远程仓库\r\n\r\ngit branch --set-upstream-to=origin/feature\r\n\r\n⑥ 尝试拉取验证：\r\n\r\ngit pull --rebase\r\n","children":[]},{"name":"指定版本创建分支.md","path":"../guanruihua.github.io/Tool/git/命令","data":"# [`指定版本创建分支`]()\r\n\r\n1. 显示日志`git log`\r\n2. 在指定版本创建分支 `git branch <分支名> <SHA>`\r\n3. 切换分支 `git checkout <分支名>`\r\n4. 推送分支 `git push --set-upstream origin <分支名>`\r\n","children":[]},{"name":"推送代码时打tag.md","path":"../guanruihua.github.io/Tool/git/命令","data":"# 推送时打tag\r\n\r\n```shell\r\ngit add . \r\ngit commit -m \"更改注释\"\r\ngit tag v1.0.5\r\n# 或 git tag -a v1.0.5 -m 'my version 1.0.5'\r\n# 查看 tag\r\ngit tag\r\n# v1.0.5 tag 名\r\ngit push origin v1.0.5\r\ngit pull\r\ngit push\r\n```\r\n","children":[]},{"name":"撤销commit.md","path":"../guanruihua.github.io/Tool/git/命令","data":"# [`撤销commit`]()\r\n\r\n- 修改了本地的代码，然后使用：\r\n\r\n```shell\r\ngit add file\r\ngit commit -m '修改原因'\r\n```\r\n\r\n执行commit后，还没执行push时，想要撤销这次的commit\r\n\r\n解决方案：\r\n使用命令：\r\n\r\n`git reset --soft HEAD^`\r\n\r\n这样就成功撤销了commit，如果想要连着add也撤销的话，–soft改为–hard（删除工作空间的改动代码）。\r\n\r\n命令详解：\r\n\r\nHEAD^ 表示上一个版本，即上一次的commit，也可以写成HEAD~1\r\n如果进行两次的commit，想要都撤回，可以使用HEAD~2\r\n\r\n–soft\r\n不删除工作空间的改动代码 ，撤销commit，不撤销git add file\r\n\r\n–hard\r\n删除工作空间的改动代码，撤销commit且撤销add\r\n\r\n# commit注释写错了，先要改一下注释，有其他方法也能实现\r\n\r\n`git commit --amend`\r\n\r\n这时候会进入vim编辑器，修改完成你要的注释后保存即可。\r\n","children":[]}]},{"name":"拉取某个文件.md","path":"../guanruihua.github.io/Tool/git","data":"# 拉取某个文件\r\n\r\n- Git 单独pull某个文件\r\n- 命令：从主分支上拉去某个文件\r\n `git checkout master -- filepath`\r\n\r\n- 例子：\r\n `git checkout master -- src/main/resources/mybatis/mappers/CategoryMapper.xml`\r\n\r\n- 注意在 “--” 之后有一个空格，获取文件地址可以直接右键“copy path”选择相应的路径就可以了\r\n","children":[]},{"name":"提交pr.md","path":"../guanruihua.github.io/Tool/git","data":"# 提交pr(pull request)\r\n\r\n## 复制仓库\r\n\r\n> 点击`fork`, 就会在自己github上创建此仓库\r\n\r\n## 克隆仓库\r\n\r\n> clone 代码, 或者用命令克隆仓库到本地\r\n\r\n## 创建分支\r\n\r\n```bash\r\ngit checkout -b [branch Name]\r\n```\r\n\r\n## 推送到远程库\r\n\r\n```bash\r\ngit add .\r\ngit commit -m \"[desc]\"\r\ngit push origin [branch Name]\r\n```\r\n\r\n## 创建拉取请求\r\n\r\n> github 仓库点击 `Compare & pull request` 按钮\r\n\r\n## 同步复刻`master`分支\r\n\r\n```bash\r\ngit checkout master\r\n# 给原始仓库添加upstream仓库\r\ngit remote add upstream [HTTPS]\r\n```\r\n\r\n## 获取原始仓库的变更\r\n\r\n> 从原始仓库获取变更，所有提交到原始仓库的变更将会保存在本地的`upstream/master`分支中\r\n\r\n```bash\r\ngit fetch upstream\r\n```\r\n\r\n## 合并变更\r\n\r\n```bash\r\ngit merge upstream/master\r\n```\r\n\r\n## 把变更推送到github\r\n\r\n```bash\r\ngit push origin master\r\n```\r\n\r\n## 删除无用分支\r\n\r\n```bash\r\ngit branch -d [Branch Name]\r\n# 删除github 无用分支\r\ngit push origin --delete [Branch Name]\r\n```\r\n","children":[]},{"name":"配置","path":"../guanruihua.github.io/Tool/git","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Tool/git/配置","data":"","children":[]}]},{"name":"钩子","path":"../guanruihua.github.io/Tool/git","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Tool/git/钩子","data":"# Git钩子\r\n\r\n### 钩子\r\n\r\n> 钩子的全部放在`.git/hooks`下面，在新建一个项目仓库的时候，Git已经在这个文件夹下给我们生成了很多个`.sample`后缀的钩子，这些钩子只要把`.sample`去掉就可以运行了，我们可以在这些`sample`上面修改完成我们自己的钩子\r\n\r\n### 客户端钩子\r\n\r\n> 官网链接[钩子](https://git-scm.com/book/zh/v2/自定义-Git-Git-钩子#_git_hooks)\r\n\r\n客户端钩子很好理解，你`commit`之后想做其他事，比如说编译一下程序啥的，这里我就不多讲，主要由下面几个钩子组成\r\n\r\n- pre-commit 提交之前\r\n- post-commit 提交之后\r\n- pre-rebase 变基之前\r\n- post-rewrite 替换提交记录之后\r\n- pre-push 推之前\r\n\r\n### 服务端钩子\r\n\r\n服务端钩子就是你`push`之后的事情服务器要运行的脚步，有用推的步骤只有一个，所以钩子只有四个\r\n\r\n- pre-receive 接受之前\r\n- update 更新之前\r\n- post-update 更新之后\r\n- post-receive 接受之后\r\n\r\n服务器接收到客户端请求时，`pre-receive`先进行调用，如果返回值为非0就会拒绝推送，所以我们写钩子的时候一定要记住最后要返回0才能正常接收更新，`update`主要处理多分支推送，有的时候你一次更新，推三四个分支到服务器，`pre-receive`只会调用一次，`update`会对每个的分支调用一次，后面两个都很容易理解\r\n\r\n一般我们就是要在服务端更新代码之后运行脚步，所以我们要修改的就是`post-update`或者`post-receive`\r\n\r\nbash脚步大家都会写，但是大家可能会很陌生什么是Git服务端，接下来我们就来介绍一下Git服务端是什么\r\n\r\n### Git 服务端\r\n\r\n大家一般使用Git都是使用的客户端，但是Git这个工具的确很强，它不但可以当做客户端，也可以当做服务端，为了让大家更好的理解Git服务端，我们先来拿本地文件做”服务器“\r\n\r\n首先我们先新建一个文件夹为`server`，在新建一个文件夹为`local`，假设文件夹都在`/root`文件夹下\r\n\r\n我们执行下面的命令生成服务器\r\n\r\n```\r\ncd /root/server\r\ngit init --bare\r\n\r\n```\r\n\r\n只需要在`init`后面添加一个`--bare`选项告诉Git，Git就会帮我们生成一个空的“服务端”，我们可以查看一下文件，我们发现Git 给我们生成下面几个文件夹，其中就有我们的hooks\r\n\r\n```\r\nbranches  config  description  HEAD  hooks  info  objects  refs\r\n\r\n```\r\n\r\n但是服务端和客户端生成的位置不一样，客户端是给我们生成一个`.git`文件夹，里面放了这些文件夹，然而服务端直接将这些文件夹放在主目录了\r\n\r\n行我们已经生成了服务端的，接下来我们生成客户端的钩子\r\n\r\n```\r\ncd /root/local\r\ngit init\r\n\r\n```\r\n\r\n很简单，同我们往常操作一样，我们这时候添加一个`README.md` 然后`commit`一下准备开始往服务端推代码了\r\n\r\n在 linux 下直接执行下面命令就行\r\n\r\necho “local update” >> README.md\r\ngit add README.md\r\ngit commit -m “Add ReadME”\r\n\r\n接下来我们就要向”服务器“提交代码了，我们先添加本地文件作为远程服务器\r\n\r\n```\r\ngit remote add origin file:////root/server\r\n\r\n```\r\n\r\n然后直接推代码\r\n\r\n```\r\ngit push origin master\r\n\r\n```\r\n\r\n这样我们就向我们文件提交了代码，这时候我们回到我们”服务器“\r\n\r\n```\r\ncd /root/server\r\nls\r\nbranches  config  description  HEAD  hooks  info  objects  refs\r\n\r\n```\r\n\r\n我们惊奇的发现服务器并没有我们新建的`README.md`文件，原来Git服务端并不像SVN一样只保留一份代码大家共同修改，**Git服务端只是记录文件变化和分支变化**\r\n\r\n这里插一句我为什么会去了解Git钩子，由于一开始实现服务器自动更新我的FastProxyScan项目代码，但是我又不想使用`Github`钩子（push后发送http请求），太麻烦了，后来我一想干脆直接推到我的服务器上，但是推到服务器上的代码只是记录了分支和提交信息，不包含源文件，所以我只好在在服务器上部署这个项目，并添加一个服务器钩子，当服务器更新完成后，再用钩子把服务器上的项目代码更新\r\n\r\n### 如何写服务器钩子\r\n\r\n通过上面对本地文件新建仓库，我们知道Git“服务端”新建很简单，我们一般接触比较多的是Github服务端，但是Git非常强大，他可以支持多种协议来连接“服务端”，比如说我们上面用到的本地文件（`file`协议），假如你用`ssh`连接远程服务器，你也可以使用类似`git remote add origin ssh://username@ip/file/path`添加ssh远程仓库\r\n\r\ngit 支持的协议有ssh、http、https、file、git等协议，你只要确保你能连接上远程服务器就行，接下来我们谈谈如何写服务器钩子\r\n\r\n在使用`git init --bare`新建了一个Git服务端之后，在服务端文件下面有一个`hooks`文件夹，我们要做的就是把脚本放到`hooks`文件夹里面（当然你要确保它有执行权限），如果你更擅长写`Python`，`Ruby`那些脚步也可以，不过要确保前缀后后缀正确。\r\n\r\n这里要提到很重要的一点，由于在执行钩子的时候，环境变量`GIT_DIR`被设置为服务端当前目录，如果你像我一样想更新在另外一个文件夹下面的项目代码，你必须使用`uset GIT_DIR`清除变量名，否则只会更新服务端，而不会更新你的项目代码\r\n\r\n这里我提供一个模板\r\n\r\n文件名为 `post-update`或者`post-receive`\r\n\r\n```\r\n#!/bin/sh\r\ncd /project/path/ || exit\r\nunset GIT_DIR\r\ngit pull origin master\r\n\r\nexec git-update-server-info\r\n\r\n```\r\n\r\n你只需修改项目文件路径和仓库名即可\r\n","children":[]}]},{"name":"错误","path":"../guanruihua.github.io/Tool/git","data":"","children":[{"name":"index.md","path":"../guanruihua.github.io/Tool/git/错误","data":"# git error\r\n\r\n## git page `Error: The process '/usr/bin/git' failed with exit code 128`\r\n\r\n> 我处理方法, 添加补充README.md 后就正常了\r\n\r\n## git push origin HEAD:＜name-of-remote-branch＞\r\n\r\n```shell\r\ngit push origin HEAD:develop\r\n```\r\n\r\n> develop: 分支名\r\n\r\n## 解决 error: Your local changes to the following files would be overwritten by merge：XXXX\r\n\r\n### 保留本地最新修改，并拉取仓库中忘记 pull 的代码到本地\r\n\r\n```shell\r\ngit stash  \r\ngit pull origin master  \r\ngit stash pop  \r\n```\r\n\r\n### 放弃本地代码，新修改的都不要了，退回上一版本，再拉取代码到本地\r\n\r\n```shell\r\ngit reset --hard  \r\ngit pull origin master  \r\n```\r\n\r\n### 对于本地的项目中修改不做任何理会，就需要用到 Git pull 的强制覆盖\r\n\r\n```shell\r\n git fetch --all\r\n git reset --hard origin/master \r\n git pull\r\n```\r\n","children":[]},{"name":"timeout.md","path":"../guanruihua.github.io/Tool/git/错误","data":"# Timeout\r\n\r\n## git上传代码报错ssh: connect to host github.com port 22: Connection timed out解决办法\r\n\r\n当在远程库上设置了SSH 之后还是报错连接超时，问题如下\r\n\r\n```bash\r\n$ git push origin master\r\nssh: connect to host github.com port 22: Connection timed out\r\nfatal: Could not read from remote repository.\r\n\r\nPlease make sure you have the correct access rights\r\nand the repository exists.\r\n```\r\n\r\n这个时候需要检查一下SSH是否能够连接成功，输入以下命令\r\n\r\n```bash\r\nssh -T git@github.com\r\n```\r\n\r\n稍等片刻如果继续报错，如下：\r\n\r\n```bash\r\nssh: connect to host github.com port 22: Connection timed out\r\n```\r\n\r\n则，可以使用一下解决办法\r\n\r\n打开存放ssh的目录\r\n\r\n```bash\r\ncd ~/.ssh\r\n\r\nls\r\n```\r\n\r\n查看是否存在 `id_rsa_github.pub` ,`id_rsa_github`, `known_hosts` 三个文件，如果没有移步解决办法：\r\n\r\n如果存在，则新建config文件输入下面内容\r\n\r\n```bash\r\nHost github.com\r\nUser YourEmail@163.com\r\nHostname ssh.github.com\r\nPreferredAuthentications publickey\r\nIdentityFile ~/.ssh/id_rsa\r\nPort 443\r\n```\r\n\r\n其中User后面为GitHub的账号名称\r\n\r\n创建方法：\r\n\r\n`vim config`\r\n\r\n然后编辑，最后:wq退出\r\n\r\n保存之后再次执行`\"ssh -T git@github.com\"`时，会出现如下提示，回车\"yes\"即可\r\n","children":[]}]}]},{"name":"idea.md","path":"../guanruihua.github.io/Tool","data":"# idea\n\n## 快捷键\n\n| 快捷键           | 输出                                            |\n| ---------------- | ----------------------------------------------- |\n| psvm             | main  S函数                                     |\n| fori             | for循环                                         |\n| sout             | `System.out.println('')`                        |\n| **Ctrl+P**       | **显示方法参数**                                |\n| **Ctrl+W**       | **选择代码块，连续按会增加选择外层的代码块**    |\n| **Ctrl+Shift+W** | **与“Ctrl+W”相反，减少选择代码块**              |\n| **Ctrl+Alt+L**   | **格式化代码**                                  |\n| **Ctrl+Alt+I**   | **自动优化代码缩进**                            |\n| **Ctrl+[ \\| ]**  | **光标移动到代码块的起始 \\| 结束 位置**         |\n| `Ctrl+alt+T`     | 选中的代码会被包含进要执行try…catch或其他语句中 |\n| `ctrl+shift+u`   | 大小写转换                                      |\n\n## idea-vim\n\n### 安裝ideaVim插件\n\n> setting/plugins : 在idea中直接搜索插件 `ideaVim` 并安装\n\n#### 配置vim\n\n在 `/home/`目录下创建 `.ideavimrc`文件，如在 windows 系统中，则在 `C:\\Users\\xxxx\\`下建\n\n在 `.ideavimrc` 中:\n\n```shell\n\" Vim 的默认寄存器和系统剪贴板共享\nset clipboard+=unnamed\n\n\" leader: ,  快捷键前缀\nlet mapleader = \",\"\n\n\" 基础键位映射\n\" esc 使用jk\n\"inoremap jk <esc>\n\n\" 映射idea常用快捷键\n\" 重命名\nnnoremap <leader>r :action RenameElement<CR>\n\" 格式化当前文件\nnnoremap <leader>f :action ReformatCode<CR><esc>\n\" quick java doc\nnnoremap <leader>q :action QuickJavaDoc<CR>\n\n\" 映射到idea快捷键\n\" 弹出输入框，可以跳到指定类\nnnoremap <Space>gc :action GotoClass<CR>\n\" 弹出输入框，跳转到指定操作\nnnoremap <Space>ga :action GotoAction<CR>\n\n\" 跳转到实现\nnnoremap <Space>gi :action GotoImplementation<CR>\n\" 跳转到指定的文件\nnnoremap <Space>gf :action GotoFile<CR>\n\" 跳转到方法的声明\nnnoremap <Space>gs :action GotoSuperMethod<CR>\n\" 跳转到测试\n\" nnoremap <Space>gt :action GotoTest<CR>\n\" 跳转到变量的声明\nnnoremap <Space>gS :action GotoSymbol<CR>\n\n\" 查找使用\nnnoremap <Space>fu :action FindUsages<CR>\n\" 显示使用\nnnoremap <Space>su :action ShowUsages<CR>\n\n\" 前进，相当似于eclipse中的alt+方向右键\n\" nnoremap gf :action Forward<CR>\n\" 后退，相当于eclipse中的alt+方向左键\n\" nnoremap gb :action Back<CR>\n\n\" 插件模拟\n\" surround\nset surround\n\" multiple-cursors\nset multiple-cursors\n\" easyMotion 模拟，额外依赖插件：AceJump,IdeaVim-EasyMotion\nset easymotion\n\" 注释插件模拟\nset commentary\n```\n\n| 快捷键   | 中文                                                                            |\n| -------- | ------------------------------------------------------------------------------- |\n| ci\"      | change inside “,找到最近”“的位置，并删除”\"中内容                                |\n| ci(、ci[ | change inside (， change inside [                                               |\n| cit      | cat in tag，可以直接编辑匹配的xml标签中的内容！                                 |\n| yi\"      | yank inside \" ,复制\"\"中的所有内容                                               |\n| ya\"      | yank around \" 复制整个字符串，包括双引号。                                      |\n| ysiw’    | 为光标下的单词包围上单引号,同理 ysiw\"                                           |\n| cs’\"     | 将单引号变成双引号,change surrounding ’ replace “”                              |\n| cs\"(     | 将双引号变成圆括号’                                                             |\n| gUw      | 大写                                                                            |\n| guw      | 小写                                                                            |\n| gc       | 打开或关闭注释. 输入 gcc 打开或关闭某一行代码注释， gc2j 打开或关闭两行代码注释 |\n| gC       | 块代码注释.输入 gCi) 注释 括号()中的代码                                        |\n| gd       | Go to definition, 跳转到定义                                                    |\n| gb       | 找出与光标下相同的下一个单词, 并添加一个光标 ，接下来就可以同时修改             |\n| af       | VISUAL 模式命令, 依据语法分析, 将选择区域向外扩展                               |\n| gh       | 等同于将鼠标移至光标所在单词, 方便查看定义以及报错                              |\n| gt       | 下一个文件                                                                      |\n| gT       | 上一个文件                                                                      |\n","children":[]},{"name":"PC","path":"../guanruihua.github.io/Tool","data":"","children":[{"name":"PC相关技术","path":"../guanruihua.github.io/Tool/PC","data":"","children":[{"name":"host.md","path":"../guanruihua.github.io/Tool/PC/PC相关技术","data":"# 解决部分图片加载问题\n\n```shell\n# GitHub Start\n\n140.82.113.3      github.com\n140.82.114.20     gist.github.com\n\n151.101.184.133    assets-cdn.github.com\n151.101.184.133    raw.githubusercontent.com\n151.101.184.133    gist.githubusercontent.com\n151.101.184.133    cloud.githubusercontent.com\n151.101.184.133    camo.githubusercontent.com\n151.101.184.133    avatars0.githubusercontent.com\n199.232.68.133     avatars0.githubusercontent.com\n199.232.28.133     avatars1.githubusercontent.com\n151.101.184.133    avatars1.githubusercontent.com\n151.101.184.133    avatars2.githubusercontent.com\n199.232.28.133     avatars2.githubusercontent.com\n151.101.184.133    avatars3.githubusercontent.com\n199.232.68.133     avatars3.githubusercontent.com\n151.101.184.133    avatars4.githubusercontent.com\n199.232.68.133     avatars4.githubusercontent.com\n151.101.184.133    avatars5.githubusercontent.com\n199.232.68.133     avatars5.githubusercontent.com\n151.101.184.133    avatars6.githubusercontent.com\n199.232.68.133     avatars6.githubusercontent.com\n151.101.184.133    avatars7.githubusercontent.com\n199.232.68.133     avatars7.githubusercontent.com\n151.101.184.133    avatars8.githubusercontent.com\n199.232.68.133     avatars8.githubusercontent.com\n\n# GitHub End\n```\n","children":[]},{"name":"search-tips.md","path":"../guanruihua.github.io/Tool/PC/PC相关技术","data":"# 搜索技巧\n\n| 说明          |             关键词              |        例子         |          结果          |\n| :------------ | :-----------------------------: | :-----------------: | :--------------------: |\n|               |        关键字用空格隔开         |      文献 国内      |                        |\n| 关键词        |               \"\"                |       \"电传\"        |  不会有“电话传真”之类  |\n| 多个关键词    |                +                |   +电脑+电话+传真   | 内容一点有这三个关键字 |\n| 排除干扰项    |                -                |   锤子 -锤子手机    |    可以排除锤子手机    |\n| 指定域名      |     site:域名+(空格)+关键字     | site:zhihu.com 抠脚 |     全是知乎的抠脚     |\n| 指定文件格式  | filetype:文件格式+(空格)+关键词 | filtetype:pdf 高数  |                        |\n| 指定标题      |          intitle:+标题          |                     |                        |\n| 单关键字      |         intext: 关键字          |                     |                        |\n| 过个关键字    |    allintext:关键字1 关键字2    |                     |                        |\n| 网页url要包含 |          inurl:关键字           |                     |                        |\n","children":[]},{"name":"window.md","path":"../guanruihua.github.io/Tool/PC/PC相关技术","data":"# window\n\n## 计算机\n\n## 卓越性能\n\n- `powercfg -duplicatescheme e9a42b02-d5df-448d-aa00-03f14749eb61`\n\n### 本地组策略编辑器\n\n- 打开: `win + R` => `gpedit.msc` => 确定\n\n- 可以进去管理计算机的一些软件\n\n#### 删除服务\n\n> `sc delete MySQL`[服务名, 如果不知道可以去计算机管理处查看, 复制服务名 ]\n\n### 注册表管理器\n\n> 打开:　`win + R` => `regedit` => 确定\n>\n> 查看软件的注册表\n\n## 输入法\n\n### U/V模式\n\n> `U`模式 : `uyouyouyouyou` =>  叕\n>\n> `V`模式 : `v1024*1024`=> 1048576\n\n### 其他\n\n> `ctrl+shift+b` : 输入法的表情包\n\n## 键盘锁\n\n> `win + r`  输入 `osk`\n\n## 模式\n\n> - 卓越性能代码：\n>   - 打开powershell 输入以下指令, 然后可以去设置中找到打开\n>   - “powercfg -duplicatescheme e9a42b02-d5df-448d-aa00-03f14749eb61”\n>\n> - 上帝模式代码：\n>   - 新建一个文件夹, 将名字命名为以下\n>   - “GodMode.{ED7BA470-8E54-465E-825C-99712043E01C}”\n","children":[]},{"name":"内网穿透.md","path":"../guanruihua.github.io/Tool/PC/PC相关技术","data":"# 内网穿透\n\n>\n> - [(41条消息) 内网穿透-把自己的电脑部署为公网可访问的服务器_飞鸿先森的博客-CSDN博客](https://blog.csdn.net/Feihongxiansen/article/details/94480480)\n>\n> [下载 - cpolar 安全的内网穿透工具](https://www.cpolar.com/download)\n","children":[]},{"name":"端口号占用处理.md","path":"../guanruihua.github.io/Tool/PC/PC相关技术","data":"# 端口号占用处理\n\n```shell\n1.查看该端口被哪些进程占用\n \nnetstat -ano|findstr [端口号]  \n \n2.查看进程信息\n \ntasklist | findstr [pid]  \n \n3.根据进程ID或进程名称杀进程\n \ntaskkill /f /pid [pid]\n \ntaskkill /f /im [进程名]\n```\n","children":[]}]},{"name":"脚本","path":"../guanruihua.github.io/Tool/PC","data":"","children":[]}]},{"name":"ps.md","path":"../guanruihua.github.io/Tool","data":"\n# ps\n\n## ps切圆形图\n\n### 1. 先用椭圆选框工具按钮, 圈号需要的区域\n\n<img src=\"ps.assets/143327_5bfe86c4_7984151.png\" style=\"zoom: 67%;\" />\n\n<img src=\"ps.assets/143422_7406aca5_7984151.png\" style=\"zoom: 33%;\" />\n\n### 2. 然后，左手按住键盘上“**Shift**”和“**Alt**”两个键，右手拖动**鼠标画出一个比较合适的圆形选区**，画好后用鼠标调整圆形选区的位置，使其刚好框住自己想要的圆形部分\n\n当然，也可以按住键盘上的“**shift**”键，拖动出一个正圆，不松开鼠标左键，继续按住“**space**”键，移动鼠标来改变正圆的位置。\n\n（注：*“Shift”键是为了画出正圆，而“Alt”键是为了将鼠标设定为所画圆圈的圆心，“Space”键是用来改变正在绘制图形位置的* )\n\n### 3.按`ctrl+j`:以圆形选取内的图画新建一个图层\n","children":[]},{"name":"README.md","path":"../guanruihua.github.io/Tool","data":"# [ruihuag](https://guanruihua.github.io/#/)\r\n\r\n![](../__assets__/001.jpg)\r\n<!-- ![Metrics](https://metrics.lecoq.io/guanruihua?template=classic&isocalendar=1&languages=1&base=header%2C%20activity%2C%20community%2C%20repositories%2C%20metadata&base.indepth=false&base.hireable=false&base.skip=false&isocalendar=false&isocalendar.duration=half-year&languages=false&languages.limit=8&languages.threshold=0%25&languages.other=false&languages.colors=github&languages.sections=most-used&languages.indepth=false&languages.analysis.timeout=15&languages.categories=markup%2C%20programming&languages.recent.categories=markup%2C%20programming&languages.recent.load=300&languages.recent.days=14&config.timezone=Asia%2FShanghai) -->\r\n","children":[]},{"name":"ssl.md","path":"../guanruihua.github.io/Tool","data":"# [`ssl`]()\r\n\r\n> - [SSL证书生成器](https://zh.rakko.tools/tools/46/)\r\n> - [windows生成ssl证书，实现本地https访问](https://blog.csdn.net/qq243920161/article/details/119963501)\r\n","children":[]},{"name":"svn","path":"../guanruihua.github.io/Tool","data":"","children":[{"name":"svn.md","path":"../guanruihua.github.io/Tool/svn","data":"# svn\n\n## 常用概念\n\n> - repository( 源代码库 )：源代码工体提交的地方\n> - checkout（提取）：没有源代码, 需要从repository check out 一份\n> - commit（提交）： 当你修改了代码, 你需要commit到repository\n> - update（更新）：当你已经checkout一份源码, 可以update一下就可以和repository上的源代码同步, 手上的代码就会有更新\n\n> 如果两个程序员修改用一个文件, svn可以合并这两个程序员的改动\n>\n> 如果修改的是同一行, svn会提交文件conflict冲突, 需要手动确定\n\n## 主要功能\n\n1. 目录版本控制\n2. 真实的版本历史\n3. 自动提交\n4. 纳入版本控管的元数据\n5. 选择不同的网络层\n6. 一致的数据处理方式\n7. 有效的分支branch 与 标签 tag\n8. hackability\n\n## 安装\n\n把bin目录添加到path环境变量中\n\n## 使用\n\n### 冲突合并\n\n![image-20210617232336576](svn.assets/image-20210617232336576.png)\n\n方案一：\n\n1.放弃本地修改的，选择svn Revert的选项撤回本地代码，先更新服务器上的文件，然后在把我们要修改的添加上去，在提交。\n\n方案二：本地冲突合并解决(根据两人修改的东西对比）。\n\n1.打开冲突文件你会看到由小于号、等于号和大于号串组成的三个部分。*切记小于号、等于号和大于号串是冲突标记，并不是冲突的数据。\n\n2.其中小于号和等号之间的内容是你的修改，而等号和大于号之间的修改是其他人的修改，在明确了冲突的原因之后，我们已经知道怎么修改了，两个人的修改都是需要保留的。\n","children":[]}]},{"name":"vim","path":"../guanruihua.github.io/Tool","data":"","children":[{"name":"nvim.md","path":"../guanruihua.github.io/Tool/vim","data":"# nvim\n\n## 缓冲区\n\n> `:ls`\n>\n> 会显示多个存文件\n>\n> :buffer  编号 / 后面的路径名\n\n## 窗口控制\n\n| 描述                          | 快捷键                   | 补充                         |\n| ----------------------------- | ------------------------ | ---------------------------- |\n| 关闭当前窗口                  | `Ctrl  + w  c`           | 关闭最后一改窗口`Ctrl + w q` |\n| 上下 \\| 左右 分割当前文件     | `Ctrl + w s | v`         |                              |\n| 上下 \\| 左右 打开一个新的文件 | `:sp | :vsp filename`    |                              |\n| 光标移动到 上下左右 屏幕      | `Ctrl + w k | j | h | l` |                              |\n| 窗口移动 上下左右 移动窗口    | `Ctrl + w K | J | H | L` |                              |\n\n> 最快的方法：\n> 1改变高度：res +n（增加n行的高度)\n>\n> 2.改变宽度：vertical res +n（增加n列的宽度）\n>\n> [ n : 可以使用+/-来表示添加或减少对应的列数 ]\n\n## Neovim 和 vim-plug 安装\n\n> vim的插件管理器\n>\n> 环境是 windows10\n>\n> 配置文件路径: `C:\\Users\\ruihuag\\AppData\\Local\\nvim`\n\n### 安装包准备\n\n> [nvim](https://github.com/neovim/neovim/releases/tag/nightly): 直接下载nvim-win64.zip\n>\n> [vim-plug](https://github.com/junegunn/vim-plug): 要是无法下载`plug.vim`, 可以选择下载整个vim-plug项目, 里面有个文件就是`plug.vim`\n\n### 开始安装\n\n> - neovim\\bin\\nvim-qt点击打开就可以开始使用\n>\n> - 把`neovim\\bin`添加到环境变量中\n>\n> - 在C:User\\用户名\\Appdata\\Local下创建nvim文件夹\n>\n> - 在nvim文件中创建autoload文件夹 , plugged文件夹 和`init.vim`(配置文件)\n>\n>   - autoload: 放`plug.vim`文件\n>\n>   - plugged: 存放下载下来的vim插件\n>\n>   - init.vim : 配置文件填写下面配置\n>\n>     - ```vim\n>       call plug#begin('~/AppData/Local/nvim/plugged')\n>       Plug 'junegunn/vim-easy-align'\n>       Plug 'scrooloose/nerdtree'\n>       call plug#end()\n>       ```\n>\n> - cmd控制台: 输入`nvim`打开,在命令模式输入`:PlugInstall`安装插件\n\n## vim-plug 使用\n\n> 常用插件： [https://vimawesome.com](https://vimawesome.com/)\n\n## 组件安装和卸载\n\n> 安装\n>\n> - 添加`Plug '插件名'`\n> - 命令模式`:PlugInstall`\n>\n> 卸载\n>\n> - 删除添加的`Plug '插件名'`\n> - 命令行模式`:PlugClean`, 选择y就可以彻底删除插件\n\n## NERDTree 文件树\n\n| 描述     | 操作                                                         |\n| -------- | ------------------------------------------------------------ |\n| 打开目录 | `:NERDTree` | `<F8>`                                         |\n| 目录操作 | `m` : 创建文件 \\| 删除文件 \\| 复制文件 \\| 移动文件 等<br>P       跳到根结点<br/>p       跳到父结点<br/>K       跳到当前目录下同级的第一个结点<br/>J       跳到当前目录下同级的最一个结点 |\n| 窗口移动 | `ctrl + w` ( 两次 ) [ 向右切 ]  <br/>`ctrl + w + h|j|k|l`[ 移动对应方向 ] <br/>`ctrl + h|j|k|l`[ 移动对应方向 ] |\n| 标签页   | `[ 回车 ]` :  新标签页打开<br>   T: 新标签打开, 光标不跳转  <br> `gt` : 向右切<br> `gT`: 向左切 <br>`alt+[number]`: 跳转到对应的标签页 |\n| 分屏打开 | `o`: 打开文件<br> `i`: 水平分屏打开<br/> `s`: 垂直分屏打开<br/>[ 前加`g`: 打开, 但光标不跳转 ] |\n\n> ```shell\n> !       执行当前文件\n> O       递归打开选中 结点下的所有目录\n> x       合拢选中结点的父目录\n> X       递归 合拢选中结点下的所有目录\n> e       Edit the current dif\n> \n> C       将选中目录或选中文件的父目录设为根结点\n> u       将当前根结点的父目录设为根目录，并变成合拢原根结点\n> U       将当前根结点的父目录设为根目录，但保持展开原根结点\n> r       递归刷新选中目录\n> R       递归刷新根结点\n> cd      将 CWD 设为选中目录\n> \n> :tabnew [++opt选项] ［＋cmd］ 文件      建立对指定文件新的tab\n> :tabclose   关闭当前的 tab\n> :tabo   关闭所有其他的 tab\n> :tabs   查看所有打开的 tab\n> :tabp   前一个 tab\n> :tabn   后一个 tab\n> ```\n>\n\n## sandwich 环绕字符编辑\n\n> `t`: html标签 [ `tp`: `<p>` ]\n>\n> `b`:  指代成对的符号 [ 修改的时候 ]\n>\n> `选择区域` : `w`, `3w`, `$`, `W`,`0`,`f\"`[  查找 ]\n>\n> `sa` : 新增\n>\n> `sr`: 修改\n>\n> `sd`: 删除\n\n> - 新增环绕字符: `sa`\n>   - `sa[选择区域][符号 | 标签]`: 给多个词加该符号\n>   - `sa[选择区域][符号 | 标签]`: 给多个词加该符号[ 不包括符号 ]\n>   - 可视化模式下, 选择区域+`sa[符号 | 标签]`\n> - 修改环绕字符: `sr`\n>   - `srb[符号|]`: 将成对符号修改成该符号\n>   - `srbTp`: 修改成`<p>`\n>   - `srtth1`: 修改成`<h1>`\n>   - `srT)`: 将标签修改成`()`\n> - 删除环绕字符: `sd`\n>   - `sdb` : 删除引号或括号\n>   - `sdt`: 删除标签\n\n## vim-colorschemes 颜色主题\n\n> colorschemes的github主页为：<https://github.com/flazz/vim-colorschemes>\n> 在文档中找到`Using`，选择一种主题颜色\n\n命令模式输入其中一个可以切换主题\n\n```\ncolorscheme wombat\n```\n\n```\ncolorscheme molokai\n```\n\n## 多光标 vim-visual-multi\n\n> 基本用法：\n>\n> - 选择带的单词（如在崇高的文本/VS 代码中）Ctrl-N`Ctrl-d`\n>   - 输入多个`Ctrl N` 选择多个单词， 可以通过[]来移动光标选着, 通过Q取消一个光标\n> - 使用Ctrl-Down/Ctrl-Up\n> - 一次选择一个字符Shift-Arrows\n> - 按 /获取下一个/上一次匹配nN\n> - 按/选择下一个/上一个光标[ ]\n> - 按跳过当前并获取下一次匹配q\n> - 按以删除当前光标/选择Q\n>\n> 两种主要模式：\n>\n> - 在*光标模式下*，命令的工作方式与在正常模式下一样\n> - 在*扩展模式下*，命令的工作方式与在可视模式下一样\n> - 按下可切换 [光标] 和 [扩展] 模式Tab\n>\n> 大多数 vim 命令都正常工作（运动、替换字符、更改大小写等）。此外，您还可以：r~\n>\n> - 在游标上运行宏/ex/正常命令\n> - 对齐光标\n> - 转置选择\n> - 使用正则表达式或从可视模式添加模式\n\n## 联想\n\n> `ins-completion`\n\n### 在当前文件获取整行\n\n快捷键：`<C-X><C-L>`\n\n### 文件名\n\n快捷键：`<C-X><C-F>`\n\n### 当前文件中的关键字\n\n快捷键：`<C-X><C-P>`或`<C-X><C-N>`\n\n### `complete`选项所指定的范围中的关键字\n\n快捷键：`<C-N>`或`<C-P>`\n\n### `dictionary`中的关键字\n\n快捷键：`<C-X><C-K>`\n\n假设你有一个`javascript.dict`文件，其内容如下：\n\n```\nPromise\nProxy\nlet\nclass\nextends\n```\n\n设置`:set dictionary+=/path/to/es6.dict`之后就可以用`<C-X><C-K>`来补全这些关键字了。\n","children":[]},{"name":"space-vim.md","path":"../guanruihua.github.io/Tool/vim","data":"# space-vim\n\n> 官网 : <https://spacevim.org/cn/use-vim-as-ide/>\n\n## windows配置\n\n> Windows 下最快捷的安装方法是下载安装脚本 [install.cmd](https://spacevim.org/cn/install.cmd) 并运行。\n>\n> SpaceVim 的默认配置文件为 `~/.SpaceVim.d/init.toml`。下面为一简单的配置示例。 如果需要查阅更多 SpaceVim 配置相关的信息，请阅读 SpaceVim 用户文档。\n\n```toml\n# 这是一个基础的 SpaceVim 配置示例\n\n# 所有的 SpaceVim 选项都列在 [options] 之下\n[options]\n    # 设置 SpaceVim 主题及背景，默认的主题是 gruvbox，如果你需要使用更\n    # 多的主题，你可以载入 colorscheme 模块\n    colorscheme = \"gruvbox\"\n    # 背景可以取值 \"dark\" 或 \"light\"\n    colorscheme_bg = \"dark\"\n    # 启用/禁用终端真色，在目前大多数终端下都是支持真色的，当然也有\n    # 一小部分终端不支持真色，如果你的 SpaceVim 颜色看上去比较怪异\n    # 可以禁用终端真色，将下面的值设为 false\n    enable_guicolors = true\n    # 设置状态栏上分割符号形状，如果字体安装失败，可以将值设为 \"nil\" 以\n    # 禁用分割符号，默认为箭头 \"arrow\"\n    statusline_separator = \"nil\"\n    statusline_iseparator = \"bar\"\n    # 设置顶部标签列表序号类型，有以下五种类型，分别是 0 - 4\n    # 0: 1 ➛ ➊\n    # 1: 1 ➛ ➀\n    # 2: 1 ➛ ⓵\n    # 3: 1 ➛ ¹\n    # 4: 1 ➛ 1\n    buffer_index_type = 4\n    # 显示/隐藏顶部标签栏上的文件类型图标，这一图标需要安装 nerd fonts，\n    # 如果未能成功安装这一字体，可以隐藏图标\n    enable_tabline_filetype_icon = true\n    # 是否在状态栏上显示当前模式，默认情况下，不显示 Normal/Insert 等\n    # 字样，只以颜色区分当前模式\n    enable_statusline_mode = false\n\n# SpaceVim 模块设置，主要包括启用/禁用模块\n\n# 启用 autocomplete 模块，启用模块时，可以列出一些模块选项，并赋值，\n# 关于模块的选项，请阅读各个模块的文档\n[[layers]]\n    name = \"autocomplete\"\n    auto-completion-return-key-behavior = \"complete\"\n    auto-completion-tab-key-behavior = \"cycle\"\n\n# 禁用 shell 模块，禁用模块时，需要加入 enable = false\n[[layers]]\n    name = \"shell\"\n    enable = false\n\n# 添加自定义插件\n[[custom_plugins]]\n    repo = \"lilydjwg/colorizer\"\n    merged = false\n```\n\n## 常用快捷键\n\n> SPC : 空格\n>\n> Leader : \\\n>\n> `:term` : 打开终端\n>\n> `spc f S` : 保存所有文件\n\n| 快捷键           | 描述                                 | 快捷键               | 描述                                         |\n| ---------------- | ------------------------------------ | -------------------- | -------------------------------------------- |\n| `SPC + [number]` | 跳转到各个对应窗口编号的窗口         | `Leader + [number ]` | 通过该快捷键对文件进行标记, 并跳转到对应文件 |\n| `SPC + b f`      | 代码格式化                           | `SPC + Tap`         | 切换到文件目录                               |\n| `g r`           | 跳转到前一个Tab, 用于两个tab来回切换 |\n\n## 窗口常用操作\n\n> 窗口切换:\n>\n> - 小窗口多文件切换 : `\\ [ number ]`\n> - 打开\n>   - 大窗口切换打开: `SPC + [ number ]`\n>   - 分屏打开 : `sg`\n>   - 垂直分屏打开 : `sv`\n> - 关闭一个窗口 `spc w d`\n> - 关闭一个文件 `spc b d`\n>\n> 文件树操作:\n>\n> - 切换文件树: `spc f t`\n>\n> - 打开文件/目录: 移动光标到指定的文件 + 回车\n> - 打开目录:\n>   - 关闭 `h`\n>   - 进入`L`\n\n## 文件树中打开\n\n> 如果只有一个可编辑窗口，则在该窗口中打开选择的文件，否则则需要指定窗口来打开文件\n\n| 快捷键          | 功能描述         |\n| :-------------- | :--------------- |\n| `l` / `<Enter>` | 打开文件         |\n| `sg`            | 分屏打开文件     |\n| `sv`            | 垂直分屏打开文件 |\n\n## 基本操作\n\n| 快捷键            | 功能描述                       |\n| :---------------- | :----------------------------- |\n| `<Up>`            | 向上移动光标，不跳过折行       |\n| `<Down>`          | 向下移动光标，不跳过折行       |\n| `H`               | 移动光标至屏幕顶部             |\n| `L`               | 移动光标至屏幕底部             |\n| `<`               | 向左移动文本                   |\n| `>`               | 向右移动文本                   |\n| `}`               | 向前移动一个段落               |\n| `{`               | 向后移动一个段落               |\n| `Ctrl-f`          | 向下翻页 (`Ctrl-f` / `Ctrl-d`) |\n| `Ctrl-b`          | 向上翻页 (`C-b` / `C-u`)       |\n| `Ctrl-e`          | 向下滚屏 (`3 Ctrl-e/j`)        |\n| `Ctrl-y`          | 向上滚屏 (`3Ctrl-y/k`)         |\n| `Ctrl-Shift-Up`   | 向上移动当前行                 |\n| `Ctrl-Shift-Down` | 向下移动当前行                 |\n\n## 他人笔记\n\n# 自动更新\n\n  [options]\nautomatic_update = true\n\n# 启动主题\n\n  [options]\ncolorscheme = \"molokai\"\n\n  [[layers]]\nname = \"colorscheme\"\n\n# 更新插件\n\n  :SPUpdate\n\n# 查看日志\n\n  :SPDebugInfo!\n\n# 界面元素切换\n\n## SPC t\n\n  SPC t 8 高亮所有超过 80 列的字符\nSPC t f 高亮临界列\nSPC t hh 高亮当前行\nSPC t hi 高亮代码对其线\nSPC t hc 高亮光标所在列\nSPC t hs 启动语法高亮\nSPC t n 显示隐藏行号\nSPC t b 切换背景色\nSPC t c 切换 conceal 模式\nSPC t p 切换 paste 模式\nSPC t t Tab 管理器\n\n  SPC t mb 电池\nSPC t mM 文件类型\nSPC t mt 时间\nSPC t md 日期\nSPC t mT 状态栏\nSPC t mv 版本控制\n\n  SPC t 8 高亮指定列后的所有字符\nSPC t f 高亮指定列字符\nSPC t s 语法检查\nSPC t S 拼写检查\n\n## SPC T\n\n  SPC T ~ 显示/隐藏 Buffer 结尾/行首的~\nSPC T f 显示隐藏边框\nSPC T m 显示隐藏菜单\nSPC T t 显示隐藏工具栏\n\n# 切换 window\n\n  SPC [1-9]\n\n# 切换 tag\n\n  \\ [1-9]\ng r 跳前一个 tag\n\n# 搜索计数\n\n```\n1[layers]\n2    name = \"incsearch\"\n```\n\n# 状态栏分隔符\n\n```\n1[options]\n2statusline_separator = 'arrow'\n```\n\n# 标签管理器\n\n  o 展开/关闭标签目录\nr 重命名标签\nn 新建标签\nN 新建匿名标签\nx 删除标签\nenter 跳转到标签\n\n# 文件树\n\n  F3\nSPC f t\nSPC f T\n\n  N 新建文件\nyy 复制文件路径\nyY 复制文件\np 粘贴\n. 显示隐藏\nsv 分屏\nsg 分屏\np 预览文件\ni 文件修改历史\nv 快速查看\n\n> < 放大缩小\n> g x 使用相关程序执行\n> ' 标记\n> V 清除所有标记\n> Ctrl+r 刷新\n\n# 光标\n\n  jkjh\nH 屏幕顶部\nL 屏幕底部\n\n> 右移动文本\n> < 左移动文本\n> } 后移动段落\n> { 前移动段落\n> ctrl + f/d 向下翻页\n> ctrl + b/u 向上翻页\n> ctrl + e/j 向下滚屏\n> ctrl + y/k 向上滚屏\n> ctrl + c 复制绝对路径\n> ctrl + x 切换窗口文件\n> ctrl + shift + up 向上移动当前行\n> ctrl + shift + down 向下移动当前行\n\n# SPC x a\n\n  SPC x a 各种对其\nSPC x j 各种对其\n\n# SPC x\n\n  SPC x c 统计单词\nSPC x d w 删除空白\nSPC x g t 翻译\nSPC x u 小写\nSPC x U 大写\nSPC x tc 字符前提\nSPC x tC 字符后提\n\n# 文本插入\n\n  SPC i ll list\nSPC i lp paragh\nSPC i ls sentence\nSPC i p1 password\nSPC i p2 password2\nSPC i p3 password3\nSPC i pp easy password\nSPC i pn numerical password\nSPC i U UUID\nSPC n +/- 数字加减\n\n# 注释\n\n  SPC ; 进入注释操作模式\nSPC c h 隐藏/显示注释\nSPC c l 注释/反注释当前行\nSPC c L 注释行\nSPC c u 反注释行\nSPC c p 注释/反注释段落\nSPC c P 注释段落\nSPC c s 使用完美格式注释\nSPC c t 注释/反注释到行\nSPC c T 注释到行\nSPC c y 注释/反注释同时复制(TODO)\nSPC c Y 复制到未命名寄存器后注释\nSPC c $ 从光标位置开始注释当前行\n\n# 语法树\n\n  F2\n\n# WINDOW\n\n  SPC w = window\nSPC w . 启用窗口临时快捷键\nSPC w 在同一标签内进行窗口切换\nSPC w = 对齐分离的窗口\nSPC w c 进入阅读模式，浏览当前窗口 (需要 tools 模块)\nSPC w C 选择某一个窗口，并且进入阅读模式 (需要 tools 模块)\nSPC w d 删除一个窗口\nSPC w D 选择一个窗口并关闭\nSPC w F 新建一个新的标签页\nSPC w h 移至左边窗口\nSPC w H 将窗口向左移动\nSPC w j 移至下方窗口\nSPC w J 将窗口向下移动\nSPC w k 移至上方窗口\nSPC w K 将窗口向上移动\nSPC w l 移至右方窗口\nSPC w L 将窗口向右移动\nSPC w m 最大化/最小化窗口（最大化相当于关闭其它窗口）\nSPC w M 选择窗口进行替换\nSPC w o 按序切换标签页\nSPC w p m 使用弹窗打开消息\nSPC w p p 关闭当前弹窗窗口\nSPC w r 顺序切换窗口\nSPC w R 逆序切换窗口\nSPC w s/- 水平分割窗口\nSPC w S 水平分割窗口，并切换至新窗口\nSPC w u 恢复窗口布局\nSPC w U 撤销恢复窗口布局\nSPC w v// 垂直分离窗口\nSPC w V 垂直分离窗口，并切换至新窗口\nSPC w w 切换至前一窗口\nSPC w W 选择一个窗口\n\n# 缓冲区\n\n  SPC 切换至前一缓冲区，常用于两个缓冲区来回切换\nSPC b . 启用缓冲区临时快捷键\nSPC b b 通过模糊搜索工具进行缓冲区切换，需要启用一个模糊搜索工具模块\nSPC b d 删除当前缓冲区，但保留编辑窗口\nSPC b D 选择一个窗口，并删除其缓冲区\nSPC b c 删除其它已保存的缓冲区\nSPC b C-d 删除其它所有缓冲区\nSPC b e 清除当前缓冲区内容，需要手动确认\nSPC b h 打开欢迎界面， 等同于快捷键 SPC a s\nSPC b n 切换至下一个缓冲区，排除特殊插件的缓冲区\nSPC b m 打开消息缓冲区\nSPC b p 切换至前一个缓冲区，排除特殊插件的缓冲区\nSPC b P 使用系统剪切板内容替换当前缓冲区\nSPC b R 从磁盘重新读取当前缓冲区所对应的文件\nSPC b w 切换只读权限\nSPC b Y 将整个缓冲区复制到系统剪切板\nSPC b N h 在左侧新建一个窗口，并在其中新建空白 buffer\nSPC b N j 在下方新建一个窗口，并在其中新建空白 buffer\nSPC b N k 在上方新建一个窗口，并在其中新建空白 buffer\nSPC b N l 在右侧新建一个窗口，并在其中新建空白 buffer\nSPC b N n 在当前窗口新建一个空白 buffer\n\n# 文件操作\n\n  SPC f / 使用 find 命令查找文件，支持参数提示\nSPC f b 跳至文件书签\nSPC f C d 修改文件编码 unix -> dos\nSPC f C u 修改文件编码 dos -> unix\nSPC f D 删除文件以及 buffer，需要手动确认\nSPC f f 打开文件\nSPC f F 打开光标下的文件\nSPC f o 代开文件树，并定位到当前文件\nSPC f R rename the current file(TODO)\nSPC f s / Ctrl-s 保存文件 (:w)\nSPC f W 使用管理员模式保存\nSPC f S 保存所有文件\nSPC f r 打开文件历史\nSPC f t 切换侧栏文件树\nSPC f T 打开文件树侧栏\nSPC f d Windows 下显示/隐藏磁盘管理器\nSPC f y 复制并显示当前文件的绝对路径\n\n# SPACE VIM\n\n  SPC f v v 复制并显示当前 SpaceVim 的版本\nSPC f v d 打开 SpaceVim 的用户配置文件\n\n# 错误处理\n\n  SPC t s 切换语法检查器\nSPC e c 清除所有错误\nSPC e h describe a syntax checker\nSPC e l 切换显示错误/警告列表\nSPC e n 跳至下一错误\nSPC e p 跳至上一个错误\nSPC e v 验证语法检查器设置\nSPC e . 错误暂态\n\n# quickfix\n\n   q l 打开 quickfix 列表窗口\nq c 清除 quickfix 列表\nq n 跳到 quickfix 列表中下一个位置\nq p 跳到 quickfix 列表中上一个位置\n\n# 跳动到定义代码块\n\n```\n1g d\n```\n\n# 关闭当前 buffer\n\n```\n1Space b d\n```\n","children":[]},{"name":"vim-plug.md","path":"../guanruihua.github.io/Tool/vim","data":"# vim 配置\n\n## init.vim\n\n```\ncall plug#begin('~/AppData/Local/nvim/plugged')\nPlug 'scrooloose/nerdtree' \"文件树\nPlug 'flazz/vim-colorschemes' \" 主题\nPlug 'jiangmiao/auto-pairs' \"成对插入符号\nPlug 'pangloss/vim-javascript' \" 代码高亮与显示缩进\nPlug 'tpope/vim-commentary' \" 备注\nPlug 'mxw/vim-jsx' \"jsx语法包\nPlug 'ap/vim-css-color' \"css颜色显示\n\"Plug 'valloric/youcompleteme' \"代码提示\nPlug 'mattn/emmet-vim' \"HTML补全\nPlug 'posva/vim-vue' \"vue代码高亮\nPlug 'scrooloose/syntastic' \"vue语法检查\nPlug 'mxw/vim-jsx' \"jsx代码高亮\nPlug 'neoclide/coc.nvim', {'branch': 'release'} \" 代码提示\nPlug 'majutsushi/tagbar' \"预览代码结构\nPlug 'machakann/vim-sandwich' \"环绕字符编辑(sandwich)\n\n\"Plug 'marijnh/tern_for_vim' \"代码提示插件2, 和上一个一起使用\n\"Plug 'moll/vim-node' \"node的相关插件\n\"Plug 'liuchengxu/vista.vim' \" \n\"Plug 'tpope/vim-surround' \" 添加、更改和删除标签\ncall plug#end()\n\n\"*********************************************************************************\n\" 代码提示 coc.nvim \nlet g:coc_global_extensions = ['coc-json','coc-css','coc-html']\n\n\"*********************************************************************************\n\"分割窗口\nnnoremap <C-J> <C-W><C-J>\nnnoremap <C-K> <C-W><C-K>\nnnoremap <C-L> <C-W><C-L>\nnnoremap <C-H> <C-W><C-H>\n\n\n\"定义快捷键\nmap <F8> :NERDTreeToggle<CR> \"文件树折叠\nnmap <F9> :TagbarToggle<CR> \"预览代码结构\nnmap <C-Z> <CR> \" 去掉这个快捷键, 会导致我的机器卡死\nnmap lj   ^  \"行首\nnmap lk   $  \"行末\n\n\"文件保存与退出  \nnmap fw     :w!<CR>  \"强制保存\nnmap fq     :q!<CR>  \"强制保存与退出\nnmap fwq    :wq!<CR> \"强制保存与退出\n\n\"代码折叠\nset foldmethod=indent  \"indent 依缩进折叠 ；manual 手动折叠 ； marker 依标志折叠; syntax 依语法折叠; expr 依表达式折叠; diff 折叠未被改动的行\"\nset foldlevel=3\nnnoremap <space> za\nlet g:SimpylFold_docstring_preview=1\nlet NERDTreeMapOpenInTab='<ENTER>' \n\n\" 显示制图符\nset listchars=tab:>-\n\n\"文件树\n\"自动打开\nautocmd vimenter * NERDTree\nautocmd VimEnter * wincmd p\n\"vim设置\n\"*****************************************************************************\n\" VUE & React 的配置\nau BufNewFile,BufRead *.html,*.js,*.vue set tabstop=2\nau BufNewFile,BufRead *.html,*.js,*.vue set softtabstop=2\nau BufNewFile,BufRead *.html,*.js,*.vue set shiftwidth=2\nau BufNewFile,BufRead *.html,*.js,*.vue set expandtab\nau BufNewFile,BufRead *.html,*.js,*.vue set autoindent\nau BufNewFile,BufRead *.html,*.js,*.vue set fileformat=unix\nlet g:syntastic_javascript_checkers = ['eslint'] \"配置eslint检查器\nlet g:jsx_ext_required = 0 \"允许在普通JS文件中使用JSX\n\"*****************************************************************************\ncolorscheme molokai \"主题\n\nset foldenable\nset fdm=manual \"开启代码折叠\n\n\" 添加js提示文件(补全)\nset dictionary+=C:/Users/ruihuag/AppData/Local/nvim/javascript.dict\n\nlet g:ycm_min_num_of_chars_for_completion = 3 \nlet g:ycm_autoclose_preview_window_after_completion=1\nlet g:ycm_complete_in_comments = 1\nlet g:ycm_key_list_select_completion = ['<c-n>', '<Down>']\nlet g:ycm_key_list_previous_completion = ['<c-p>', '<Up>']\n\" 比较喜欢用tab来选择补全...\n\"function! MyTabFunction ()\n\"    let line = getline('.')\n\"    let substr = strpart(line, -1, col('.')+1)\n\"    let substr = matchstr(substr, \"[^ \\t]*$\")\n\"    if strlen(substr) == 0\n\"        return \"\\<tab>\"\n\"    endif\n\"    return pumvisible() ? \"\\<c-n>\" : \"\\<c-x>\\<c-o>\"\n\"endfunction\n\"inoremap <tab> <c-r>=MyTabFunction()<cr>\n\n\n\"****************************************************************************\n\" tap页切换\n\" alt + [number] : 切换tap\n\n:nn <M-1> 1gt\n:nn <M-2> 2gt\n:nn <M-3> 3gt\n:nn <M-4> 4gt\n:nn <M-5> 5gt\n:nn <M-6> 6gt\n:nn <M-7> 7gt\n:nn <M-8> 8gt\n:nn <M-9> 9gt\n:nn <M-0> :tablast<CR>\n\n\"****************************************************************************\n\n\" jsx语法包\nlet g:jsx_ext_required = 1\nlet g:jsx_pragma_required = 1\n\nlet NERDTreeShowHidden=1 \"显示隐藏文件\n\nset tabstop=2\nset softtabstop=4\nset shiftwidth=4\nset expandtab\nset autoindent\nset fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936\nset termencoding=utf-8\nset encoding=utf-8\nset nu\nset relativenumber       \"开启相对行数\nset clipboard=unnamed            \"系统剪贴板\nlet mapleader=';'                \"定义leader\nset backspace=indent,eol,start   \"backspace不能用时设置\nset noswapfile \nset clipboard=unnamed            \"设置系统复制粘贴板\nset hlsearch                     \"搜索关键字高亮\nset incsearch                    \"输入搜索命令立即显示\nset encoding=utf-8\nset wrap                         \"主动换行\nset autoread \nset autowriteall\n\" 让配置变更立即生效  \nautocmd BufWritePost $MYVIMRC source $MYVIMRC  \n\n\"定义高亮\nhighlight BadWhitespace guifg=gray guibg=red ctermfg=gray ctermbg=red\nset nobackup                      \"关闭.swp文件\nset nowritebackup\n\"au InsertLeave *.go, *.sh, *.py write   \"退出插入模式指定类型的文件自动保存\n\"au InsertLeave *.js, *.json write\n\"****************************************************************************\n```\n\n## javascript.dict\n\n```\n# a\n# b\n# c\nconst\nconsole\nclass\n\n# d \n# e\nexport\nextends\n\n# f\nfunction\n\n# g\n# h \n# i \ninfo\n\n# j \n# k \n# l \nlog\nlet\n\n# m\nmodule\n\n# n \nnode\n# o \n# p \nPromise\nProxy\n\n# q\n# r \nReact\nrequire()\n\n# s \n# t\n# u \n# v \nvar\nVue\n\n# w \n# x\n# y \n# z \n```\n","children":[]},{"name":"vim.md","path":"../guanruihua.github.io/Tool/vim","data":"# VIM\n\n> [Vim 常用操作 (juejin.cn)](https://juejin.cn/post/6847902217882746893)\n\n> 编辑器\n>\n> - eclipse vim 插件 Vrapper\n>   - 修改快捷键 windows -> preferences -> generals -> keys\n>   - 输入vrapper 然后就跨域修改vim快捷键了\n>     - ctrl + b\n\n![](https://www.runoob.com/wp-content/uploads/2015/10/vi-vim-cheat-sheet-sch.gif)\n\n## 常用指令\n\n| 指令                                                         | 描述 |\n| ------------------------------------------------------------ | ---- |\n| `[数字] + 指令` => 重复执行次数                              |      |\n| `:.,+n` => 指定当前行往下n行                                 |      |\n| 词单位移动 右移动: `w | e` 左移动: `b`                       |      |\n| 文字最前: `^`  行首: `0[零]`                                |      |\n| 文字最后: `$`  行末: `A`                                     |      |\n| `ctrl-f` 向后翻页 `ctrl-b` 向后翻页                          |      |\n| `zz` 重绘屏幕，把当前行显示在窗口正中                        |      |\n| 撤销 : `u`   , 撤销上一个操作:  `ctrl +r`                   |      |\n| 首行 `gg` , 行末 `G`                                         |      |\n| 全删: `ggdG`                                                 |      |\n| `ggVG` : 全部复制                                            |      |\n| `Ctrl-b` 上一页， `Ctrl-f`下一页                            |      |\n| ( : 跳至上一句开头，  **)** : 跳至下一局开头<br/>**{** : 上一段开头，  **}** : 下一段开头 `[ 都是通过空行区分 ]` |      |\n| **H** 将光标定位到屏幕的顶端 **M**  屏幕的中间 **L**  屏幕的底端 |      |\n| `gv` 重选上一次由可视模式选择的文本范围<br>`vi[符号]`: 通过符号选择 |      |\n\n### 删除\n\n> 行\n>\n> - 从光标删除到行**末** `d$`\n> - 从光标处删除到行**前**`d^`\n> - 删除当行`dd`\n> - 删除多行`*dd`[ * :填行数]\n> - 删除多词 `d*[w/e]`\n> - `ci}` 修改花括号内内容\n> - `dap` 删除一个段落（以空行界定，段落后的空行也会删除）\n>\n> 单词\n>\n> - `dw`  从光标处删除至下一个单词的起始处(不保留单词间的空格)\n>\n> - `de`  从光标处删除至一个单词的末尾(就是会保留单词间的空格)\n\n### 复制&粘贴\n\n> 全部复制`ggVG`\n>\n> 复制\n>\n> - 单行复制`yy`\n> - 多行复制`*yy`[ * : 填行数]\n> - 选择部分复制`v`[进入可视模式]+通过光标移动选择要复制部分+`y`[复制]\n>\n> 粘贴\n>\n> - 粘贴到光标前`P`\n> - 粘贴到光标后`p`\n>\n> 将1-10行插入到第20行之后:`:1,10 co 20`  = > (可以使用相对行数写法 )\n\n## 可视化模式\n\n### 常用\n\n> `gv` 重选上一次由可视模式选择的文本范围\n>\n> `vi[符号]`: 通过符号选择\n\n> `v` : 单字符模式\n>\n> `V`: 行模式\n>\n> `ctrl+v` : 列模式\n\n### 选\n\n> **gv** 重选上一次由可视模式选择的文本范围\n>\n> 包含括号\n>\n> - **ab** 选中括号中的内容\n>\n> - **aB** 选中{}括号中的内容\n>\n> 不包含括号\n>\n> - **ib** 选中括号中的内容\n>\n> - **iB** 选中{}中的内容\n>\n> 通过符号选择\n>\n> - `vi + [符号]`高亮选中花括号中内容( 符号可选: 外逗号、单引号、双引号等也是一样的 )\n> - **vi}**  高亮选中花括号中内容\n> - **va}**  高亮选中花括号及花括号中的内容。\n\n### 操作\n\n> **U** 选中块都转换成大写，**~** 切换块中内容的大小写，\n>\n> **>** 块右移， **<** 块左移，  \n>\n> **y** 复制块，  **d** 删除块，  **r** 替换， **c** 删除并进去插入模式\n>\n> - **I** 和 **A** 进入插入模式，置光标于选块的开始和结尾(小写的不行)\n> - **o** 跳转选中块的末端， **O** 跳至首端\n\n## 备注 commentary\n\n| 描述     | 操作                                                         |\n| -------- | ------------------------------------------------------------ |\n| 备注多行 | visual 模式 选择 要备注的代码 内容 输入`gc`                  |\n| 备注一行 | 直接在需要备注的行输入`gc`                                   |\n| 替换指令 | 全部行首添加`//` :  `:% s/^/\\/\\//g` <br/>在2-50行首添加`//`  :  `:2,50 s/^/\\/\\//g`<br/>2-50行删除`//`: `:2, 50 s/^\\/\\/// |\n\n## 格式化代码\n\n>gg=G    **将全部代码格式化**\n>\n>nG=mG  **将第**n行到第**m**行的代码格式化\n>\n>自动缩进当前行指令 `==`\n>\n>格式化当前光标接下来8行 `8=`\n>\n>格式化选中行(v模式), 再按`=`格式化代码代码段\n\n## 文本转换\n\n> （1） **g~** 反转大小写 **gu** 转小写 **gU**转大写，（**gUU** 当前行全传大写，还有 **gUaW** [当前字 ]、**gUap** [当前段落]）\n> （2）~ 当前字符替换大小写\n\n## 代码块折叠\n\n> `:set foldmethod=manual`\n\n| 指令(操作)  | 描述                                       |\n| ----------- | ------------------------------------------ |\n| zf56j       | 向下折叠56行                               |\n| zf56G       | 创建从当前行起到56行的代码折叠             |\n| `zd` | `zo` | 打开折叠                                   |\n| `zc`        | 再次折叠                                   |\n| zC          | 范围内所有嵌套的折叠点折叠                 |\n| zO          | 对所在范围内所有嵌套的折叠点展开           |\n| zE          | 除去当前窗口所有折叠                       |\n| zf%         | 折叠对应匹配的括号(要先移动到对应符号上)   |\n| zf          | 折叠选择的行 [ 可视化模式下 ]              |\n| zfa(        | 折叠括号（比如()、[]、{}、><等）包围的区域 |\n| :mkview     | 保存当前的折叠状态                         |\n| :loadview   | 载入记忆的折叠信息                         |\n|             |                                            |\n\n```text\n\n```\n\n## 制表符号\n\n| 指令                                                         | 描述                        |\n| ------------------------------------------------------------ | --------------------------- |\n| `>>`  || `<<`                                               | 可以缩进或缩出              |\n| `n>>`  || `n<<`（ n自然数 ）                                 | 可以缩进或缩出n次           |\n| visual状态, 选定多行，用“n >或< n” ( n为自然数 )             | 缩进或缩出                  |\n| ：m,n>  \\|\\| ：m,n<  ( 输入多个 < \\|\\| > , 就可移动对应对应数) | 第m行到第n行左(右)移一个tab |\n| :.,+3 >                                                      | 当前行往下及往下三行都右移  |\n|                                                              |                             |\n|                                                              |                             |\n\n## mark使用\n\n> `:mark 标记名`  :  设置标签\n>\n> ``标记名` :  跳转到该标签\n\n## 替换\n\n> c    [number]   motion\n>\n> `ce` : 会进入插入模式\n\n| 指令 | 描述                   |\n| ---- | ---------------------- |\n| `r`  | 替换当前光标选择的字符 |\n| `cw` | 修改光标到该单词末尾   |\n> `:s/old/new/g` : 可以替换 old 为 new\n>\n> `:#,#s/old/new/g`   其中 #,# 代表的是替换操作的若干行中首尾两行的行号。\n> `:%s/old/new/g`     则是替换整个文件中的每个匹配串。\n> `:%s/old/new/gc`    会找到整个文件中的每个匹配串，并且对每个匹配串\n> 提示是否进行替换。\n\n### 替換（substitute）\n\n> ```shell\n> :[range]s/pattern/string/[c,e,g,i]5.1\n> // 我的常用写法\n> :.,+10s/pattern/string/g => 修改当前行往下十行\n> ```\n\n| **range**   | 指的是範圍<br/>1,7 指從第一行至第七行<br>a1,$ 指從第一行至最後一行，也可以 % 代表。還記得嗎？ % 是目前編輯的文章，# 是前一次編輯的文章。 |\n| ----------- | ------------------------------------------------------------ |\n| **pattern** | 就是要被替換掉的字串，可以用 regexp 來表示。                 |\n| **string**  | 將 pattern 由 string 所取代。                                |\n| **c**       | confirm，每次替換前會詢問。                                  |\n| **e**       | 不顯示 error。                                               |\n| **g**       | globe，不詢問，整行替換。                                    |\n| **i**       | ignore 不分大小寫。                                          |\n\n> - `$`:  最后一行\n>\n> - `.`:  第一行\n> - `%`:  每一行\n>\n> - 当`/`是需要匹配的字符, 可以使用`#` 或`+`\n>   - `:s#vivian/#sky/# 替换当前行第一个 vivian/ 为 sky/`\n>   - `:%s+/oradata/apras/+/user01/apras1+ （使用+ 来 替换 / ）： /oradata/apras/替换成/user01/apras1/`\n\n```shell\n替换一行的字符\n\n:s/vivian/sky/ 替换当前行第一个 vivian 为 sky\n:s/vivian/sky/g 替换当前行所有 vivian 为 sky\n\n\n替换第n行到最后一行 $=>指向最后一行, 若n位. 则表示第一行开始\n\n:n,$s/vivian/sky/ 替换第 n 行开始到最后一行中每一行的第一个 vivian 为 sky\n:n,$s/vivian/sky/g 替换第 n 行开始到最后一行中每一行所有 vivian 为 sky\n\n\n替换每一行的字符\n:%s/vivian/sky/（等同于 :g/vivian/s//sky/） 替换每一行的第一个 vivian 为 sky\n:%s/vivian/sky/g（等同于 :g/vivian/s//sky/g） 替换每一行中所有 vivian 为 sky\n\n可以使用 # 作为分隔符，此时中间出现的 / 不会作为分隔符\n:s#vivian/#sky/# 替换当前行第一个 vivian/ 为 sky/\n:%s+/oradata/apras/+/user01/apras1+ （使用+ 来 替换 / ）： /oradata/apras/替换成/user01/apras1/\n:s/vivian/sky/ 替换当前行第一个 vivian 为 sky\n:s/vivian/sky/g 替换当前行所有 vivian 为 sky\n:n,$s/vivian/sky/ 替换第 n 行开始到最后一行中每一行的第一个 vivian 为 sky\n:n,$s/vivian/sky/g 替换第 n 行开始到最后一行中每一行所有 vivian 为 sky\n\n(n 为数字，若 n 为 .，表示从当前行开始到最后一行)\n:%s/vivian/sky/（等同于 :g/vivian/s//sky/） 替换每一行的第一个 vivian 为 sky\n:%s/vivian/sky/g（等同于 :g/vivian/s//sky/g） 替换每一行中所有 vivian 为 sky\n可以使用 # 作为分隔符，此时中间出现的 / 不会作为分隔符\n:s#vivian/#sky/# 替换当前行第一个 vivian/ 为 sky/\n\n利用 :s 命令可以实现字符串的替换。具体的用法包括：\n:s/str1/str2/ 用字符串 str2 替换行中首次出现的字符串 str1\n:s/str1/str2/g 用字符串 str2 替换行中所有出现的字符串 str1\n:.,$ s/str1/str2/g 用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1\n:1,$ s/str1/str2/g 用字符串 str2 替换正文中所有出现的字符串 str1\n:g/str1/s//str2/g 功能同上\n从上述替换命令可以看到：g 放在命令末尾，表示对搜索字符串的每次出现进行替换；不加 g，表示只对搜索\n字符串的首次出现进行替换；g 放在命令开头，表示对正文中所有包含搜索字符串的行进行替换操作。\n```\n\n### 其他\n\n> 换行  : \\r\n\n## 搜索类\n\n> `/ +string` : 以在当前文件中查找该字符串\n>\n> - `N`: 上一个查找处\n> - `n`:  下一个查找处\n\n## 保存&退出\n\n> `!` : 强制控制\n\n命令 | 简单说明\n:---:|:---:\n:w | 保存, 不退出\n:wq | 保存文件内容后退出, 另外一种替代的方法是用ZZ命令。\nZZ | 保存文件内容后退出\n:q | 在未做任何编辑处理而准备退出\n\n## 终端\n\n> - 目前觉得不好用\n>\n> ter: 打开终端\n>\n> exit 退出\n\n## 其他\n\n>   3. 输入 :help cmd 可以找到关于 cmd 命令的帮助。\n>\n>   4. 输入 CTRL-W CTRL-W  可以使您在窗口之间跳转。\n>\n>   5. 输入 :q 以关闭帮助窗口\n>\n>   6. 您可以创建一个 vimrc 启动脚本文件用来保存您偏好的设置。\n>\n>   7. 当输入 : 命令时，按 CTRL-D 可以查看可能的补全结果。\n>      按 <TAB> 可以使用一个补全。\n\n## 浏览器vim\n\n> extension://aibcglbfblnogfjhbcmmpobjhnomhcdo/pages/options.html#commands\n>\n> - `o`:  跳转到输入地址\n>\n> - 复制与window复制相通\n\n### 网页滚动\n\n| 指令 | 描述     |\n| ---- | -------- |\n| j    | 上滚     |\n| k    | 下滚     |\n| h    | 左滚     |\n| l    | 右滚     |\n| gg   | 滚到顶部 |\n| G    | 滚到底部 |\n| d | 上滚半个页面 |\n| u | 下滚半个页面 |\n\n### 常用指令\n\n| 指令    | 描述                             |\n| ------- | -------------------------------- |\n| r       | 刷新页面                         |\n| yy      | 复制当前链接                     |\n| f       | 点击网页中的链接和按钮           |\n| t       | 新开一个页面                     |\n| o[小写] | 显示多功能搜索框                 |\n| O[大写] | 搜索混合内容, 并在新的标签页打开 |\n| /       | 在业内查找模式                   |\n| n       | 查找下一处                       |\n| N       | 查找上一处                       |\n| H       | 在历史记录后退                   |\n| L       | 在历史记录中前进                 |\n| K       | 切换到右边的标签页               |\n| J       | 切换到左边的标签页               |\n|g0|切换到最左侧的标签页|\n|x|关闭标签|\n|X|恢复最近关闭标签|\n|<< \\| >>|左  \\|  右移动标签页|\n","children":[]}]},{"name":"vscode","path":"../guanruihua.github.io/Tool","data":"","children":[{"name":"api","path":"../guanruihua.github.io/Tool/vscode","data":"","children":[{"name":"主题颜色.md","path":"../guanruihua.github.io/Tool/vscode/api","data":"# [`主题颜色`](https://code.visualstudio.com/api/references/theme-color)\r\n\r\n> - 使用用户设置自定义活动的 Visual Studio Code颜色主题。`workbench.colorCustomizations`  \r\n> - 翻译时间: `2022-11-22 17:29:11`\r\n\r\n```js\r\n{\r\n  \"workbench.colorCustomizations\": {\r\n    \"activityBar.background\": \"#00AA00\"\r\n  }\r\n}\r\n```\r\n\r\n> 注意:如果要使用现有颜色主题，请参阅颜色主题，您将了解如何通过“首选项:颜色主题”下拉列表（`Ctrl+K` `Ctrl+T`）设置活动颜色主题。\r\n\r\n> 主题颜色在Web 视图中可用作 CSS 变量，并且有一个扩展可用于为它们提供智能感知。\r\n\r\n## 颜色格式\r\n\r\n> - 可以在 RGB 颜色模型中定义颜色值，并使用 Alpha 通道实现透明度。作为格式，支持以下十六进制表示法:`#RGB`，`#RGBA`，和 `#RRGGBBAA`。 R（红色）、G（绿色）、B（蓝色）和 A（字母）是十六进制字符（0-9、a-f 或 A-F）。三位表示法 （） 是六位形式 （） 的较短版本，四位 RGB 表示法 （） 是八位形式 （） 的较短版本。例如是相同的颜色。#RGB #RGBA #RRGGBB #RRGGBBAA #RGB #RRGGBB #RGBA #RRGGBBAA #e35f #ee3355ff\r\n> - 如果未定义 alpha 值，则默认为（不透明，无透明度）。如果设置为 alpha，则颜色完全透明。ff00\r\n> - 某些颜色不应不透明，以免覆盖其他注释。检查颜色说明以查看适用于哪些颜色\r\n\r\n## 对比色\r\n\r\n对比度颜色通常仅针对高对比度主题设置。如果设置，它们会在 UI 中的项目周围添加额外的边框以增加对比度。\r\n\r\ncontrastActiveBorder:活动元素周围多出边框，将它们与其他元素分开，对比度更高。\r\ncontrastBorder:元素周围有额外的边框，以将它们与其他元素分开，以获得更大的对比度。\r\n\r\n## 基色\r\n\r\n- `focusBorder`: 聚焦元素的整体边框颜色。仅当未被组件覆盖时，才使用此颜色\r\n- `foreground`: 整体前景色。仅当未被组件覆盖时，才使用此颜色\r\n- `disabledForeground`: 禁用元素的整体前景。仅当未被组件覆盖时，才使用此颜色\r\n- `widget.shadow`: 编辑器中的查找/替换等小部件的阴影颜色\r\n- `selection.background`: 工作台中文本选择的背景色（对于输入字段或文本区域，不适用于编辑器和终端中的选择）\r\n- `descriptionForeground`: 说明文本的前景色，提供附加信息，例如标签\r\n- `errorForeground`: 错误消息的整体前景色（仅当未被组件覆盖时才使用此颜色）\r\n- `icon.foreground`: 工作台中图标的默认颜色\r\n- `sash.hoverBorder`: 可拖动窗框的悬停边框颜色\r\n\r\n## 窗口边框\r\n\r\n> VS Code 窗口边框的主题颜色。\r\n\r\n- `window.activeBorder`: 活动（焦点）窗口的边框颜色。\r\n- `window.inactiveBorder`: 非活动（未聚焦）窗口的边框颜色。\r\n\r\n## 文本颜色\r\n\r\n> 文本文档中的颜色，例如欢迎页面\r\n\r\n- `textBlockQuote.background`: 文本中块引用的背景颜色\r\n- `textBlockQuote.border`: 文本中块引号的边框颜色\r\n- `textCodeBlock.background`: 文本中代码块的背景色\r\n- `textLink.activeForeground`: 单击鼠标悬停时文本中链接的前景色\r\n- `textLink.foreground`: 文本中链接的前景色\r\n- `textPreformat.foreground`: 预设格式的文本段的前景色\r\n- `textSeparator.foreground`: 文本分隔符的颜色\r\n\r\n## 动作色\r\n\r\n> 一组颜色，用于控制与整个工作台上的操作的交互\r\n\r\n- `toolbar.hoverBackground`: 使用鼠标将鼠标悬停在操作上时的工具栏背景\r\n- `toolbar.hoverOutline`: 使用鼠标将鼠标悬停在操作上时的工具栏轮廓\r\n- `toolbar.activeBackground`: 将鼠标悬停在操作上时的工具栏背景\r\n\r\n## 按钮控制\r\n\r\n> 按钮微件的一组颜色，例如新窗口资源管理器中的“打开文件夹”按钮\r\n\r\n![](./__assets__/主题颜色-2022-11-22-17-15-54.png)\r\n\r\n- `button.background`:按钮背景色\r\n- `button.foreground`:按钮前景色\r\n- `button.border`:按钮边框颜色\r\n- `button.separator`:按钮分隔符颜色\r\n- `button.hoverBackground`:悬停时按钮背景色\r\n- `button.secondaryForeground`:辅助按钮前景色\r\n- `button.secondaryBackground`:辅助按钮背景色\r\n- `button.secondaryHoverBackground`:悬停时辅助按钮背景色\r\n- `checkbox.background`:复选框小部件的背景颜色\r\n- `checkbox.foreground`:复选框构件的前景色\r\n- `checkbox.border`:复选框构件的边框颜色\r\n\r\n## 下拉控件\r\n\r\n> 所有下拉构件（例如在“集成终端”或“输出”面板中）的一组颜色。请注意， 下拉控件目前未在 macOS 上使用\r\n\r\n![](./__assets__/主题颜色-2022-11-22-17-23-04.png)\r\n\r\n- `dropdown.background`:下拉背景\r\n- `dropdown.listBackground`:下拉列表背景\r\n- `dropdown.border`:下拉边框\r\n- `dropdown.foreground`:下拉前景\r\n\r\n## 输入控制\r\n\r\n> 输入控件的颜色，例如在“搜索”视图或“查找/替换”对话框中\r\n\r\n![](./__assets__/主题颜色-2022-11-22-17-23-57.png)\r\n\r\n- `input.background`:输入框背景\r\n- `input.border`:输入框边框\r\n- `input.foreground`:输入框前景\r\n- `input.placeholderForeground`:占位符文本的输入框前景色\r\n- `inputOption.activeBackground`:输入字段中已激活选项的背景颜色\r\n- `inputOption.activeBorder`:输入字段中已激活选项的边框颜色\r\n- `inputOption.activeForeground`:输入字段中已激活选项的前景色\r\n- `inputOption.hoverBackground`:输入字段中已激活选项的背景颜色\r\n- `inputValidation.errorBackground`:输入错误严重性的验证背景颜色\r\n- `inputValidation.errorForeground`:输入错误严重性的验证前景色\r\n- `inputValidation.errorBorder`:输入错误严重性的验证边框颜色\r\n- `inputValidation.infoBackground`:输入信息严重性的验证背景颜色\r\n- `inputValidation.infoForeground`:输入信息严重性的验证前景色\r\n- `inputValidation.infoBorder`:输入信息严重性的验证边框颜色\r\n- `inputValidation.warningBackground`:输入信息警告的验证背景颜色\r\n- `inputValidation.warningForeground`:输入验证前景色以表示警告严重性\r\n- `inputValidation.warningBorder`:输入警告严重性的验证边框颜色\r\n\r\n## 滚动条控件\r\n\r\n- `scrollbar.shadow`:滚动条滑块阴影，指示视图已滚动\r\n- `scrollbarSlider.activeBackground`:单击时滚动条滑块背景颜色\r\n- `scrollbarSlider.background`:滚动条滑块背景色\r\n- `scrollbarSlider.hoverBackground`:悬停时滚动条滑块背景色\r\n\r\n## 徽章\r\n\r\n> 徽章是小信息标签，例如搜索结果计数\r\n\r\n- `badge.foreground`:徽章前景色\r\n- `badge.background`:徽章背景颜色\r\n\r\n## 进度条\r\n\r\n`progressBar.background`: 长时间运行的操作显示的进度条的背景色\r\n\r\n## 列表和树\r\n\r\n> 列表和树的颜色等，如文件资源管理器。活动列表/树具有键盘焦点，非活动列表/树没有\r\n\r\n- `list.activeSelectionBackground`: 列表/树处于活动状态时所选项目的列表/树背景色\r\n- `list.activeSelectionForeground`: 列表/树处于活动状态时所选项目的列表/树前景色\r\n- `list.activeSelectionIconForeground`: 列表/树处于活动状态时所选项目的列表/树图标前景色。活动列表/树具有键盘焦点，非活动列表/树没有\r\n- `list.dropBackground`: 使用鼠标移动项目时列表/树拖放背景\r\n- `list.focusBackground`: 列表/树处于活动状态时焦点项目的列表/树背景颜色\r\n- `list.focusForeground`: 列表/树处于活动状态时焦点项目的列表/树前景色。活动列表/树具有键盘焦点，非活动列表/树没有\r\n- `list.focusHighlightForeground`: 在列表/树内搜索时，匹配项的列表/树前景色会突出显示活动焦点项目\r\n- `list.focusOutline`: 列表/树处于活动状态时焦点项目的列表/树轮廓颜色。活动列表/树具有键盘焦点，非活动列表/树没有\r\n- `list.focusAndSelectionOutline`: 当列表/树处于活动状态并选择时，焦点项目的列表/树轮廓颜色。活动列表/树具有键盘焦点，非活动列表/树没有\r\n- `list.highlightForeground`: 在列表/树内搜索时匹配突出显示的列表/树前景色\r\n- `list.hoverBackground`: 使用鼠标将鼠标悬停在项目上时的列表/树背景\r\n- `list.hoverForeground`: 使用鼠标将鼠标悬停在项目上时的列表/树前景\r\n- `list.inactiveSelectionBackground`: 列表/树处于非活动状态时所选项目的列表/树背景色\r\n- `list.inactiveSelectionForeground`: 当列表/树处于非活动状态时，所选项目的列表/树前景色。活动列表/树具有键盘焦点，非活动列表/树没有\r\n- `list.inactiveSelectionIconForeground`: 列表/树处于非活动状态时所选项目的列表/树图标前景色。活动列表/树具有键盘焦点，非活动列表/树没有\r\n- `list.inactiveFocusBackground`: 当列表处于非活动状态时，焦点项目的列表背景色。活动列表具有键盘焦点，非活动列表没有。目前仅在列表中受支持\r\n- `list.inactiveFocusOutline`: 列表/树处于非活动状态时焦点项目的列表/树轮廓颜色。活动列表/树具有键盘焦点，非活动列表/树没有\r\n- `list.invalidItemForeground`: 无效项的列表/树前景色，例如资源管理器中未解析的根\r\n- `list.errorForeground`: 包含错误的列表项的前景色\r\n- `list.warningForeground`: 包含警告的列表项的前景色\r\n- `listFilterWidget.background`: 列表/树 在列表/树内搜索时过滤键入文本的背景颜色\r\n- `listFilterWidget.outline`: 在列表/树内搜索时，列表/树过滤器小部件的键入文本的轮廓颜色\r\n- `listFilterWidget.noMatchesOutline`: 在列表/树内搜索时未找到键入文本匹配项时的列表/树过滤器小部件的轮廓颜色\r\n- `listFilterWidget.shadow`: 列表和树中类型过滤器小部件的缩减颜\r\n- `list.filterMatchBackground`: 列表和树中筛选的匹配项的背景色\r\n- `list.filterMatchBorder`: 列表和树中筛选的匹配项的边框颜色\r\n- `list.deemphasizedForeground`: 取消强调的项目的列表/树前景色\r\n- `tree.indentGuidesStroke`: 树构件的缩进参考线的描边颜色\r\n- `tree.tableColumnsBorder`: 缩进参考线的树形描边颜色\r\n- `tree.tableOddRowsBackground`: 奇数表行的背景色\r\n\r\n## 活动栏\r\n\r\n> 活动栏显示在工作台的最左侧或右侧，并允许在侧边栏的视图之间快速切换。\r\n\r\n- `activityBar.background`: 活动栏背景色\r\n- `activityBar.dropBorder`: 拖放活动栏项的反馈颜色。活动栏显示在最左侧或右侧，并允许在侧边栏的视图之间切换\r\n- `activityBar.foreground`: 活动栏前景色（例如用于图标）\r\n- `activityBar.inactiveForeground`: 活动栏项目处于非活动状态时的前景色\r\n- `activityBar.border`: 活动栏边框颜色与侧边栏\r\n- `activityBarBadge.background`: 活动通知徽章背景颜色\r\n- `activityBarBadge.foreground`: 活动通知徽章前景色\r\n- `activityBar.activeBorder`: 活动栏活动指示器边框颜色\r\n- `activityBar.activeBackground`: 活动元素的活动栏可选背景色\r\n- `activityBar.activeFocusBorder`: 活动项的活动栏焦点边框颜色\r\n- `activityBarItem.settingsProfilesForeground`: 活动栏上设置配置文件条目的前景色\r\n- `activityBarItem.settingsProfilesHoverForeground`: 悬停时活动栏上设置配置文件条目的前景色\r\n- `activityBarItem.settingsProfilesBackground`: 活动栏上设置配置文件条目的背景色\r\n\r\n## 侧边栏\r\n\r\n> 侧边栏包含资源管理器和搜索等视图\r\n\r\n- `sideBar.background`: 侧边栏背景颜色\r\n- `sideBar.foreground`: 侧边栏前景色。侧边栏是资源管理器和搜索等视图的容器\r\n- `sideBar.border`: 分隔编辑器一侧的侧边栏边框颜色\r\n- `sideBar.dropBackground`: 拖放侧边栏部分的反馈颜色。颜色应具有透明度，以便侧边栏部分仍然可以发光\r\n- `sideBarTitle.foreground`: 侧边栏标题前景色\r\n- `sideBarSectionHeader.background`: 侧边栏部分标题背景颜色\r\n- `sideBarSectionHeader.foreground`: 侧边栏部分标题前景色\r\n- `sideBarSectionHeader.border`: 侧边栏部分标题边框颜色\r\n\r\n## 小地图\r\n\r\n> 小地图显示当前文件的缩小版本\r\n\r\n- `minimap.findMatchHighlight`: 突出显示文件中搜索的匹配项的颜色\r\n- `minimap.selectionHighlight`: 编辑器选择的高亮颜色\r\n- `minimap.errorHighlight`: 突出显示编辑器中错误的颜色\r\n- `minimap.warningHighlight`: 在编辑器中突出显示警告的颜色\r\n- `minimap.background`: 小地图背景颜色\r\n- `minimap.selectionOccurrenceHighlight`: 用于重复编辑器选择的小地图标记颜色\r\n- `minimap.foregroundOpacity`: 小地图中渲染的前景元素的不透明度。例如，“#000000c0”将以 75% 的不透明度呈现元素\r\n- `minimapSlider.background`: 小地图滑块背景色\r\n- `minimapSlider.hoverBackground`: 悬停时的小地图滑块背景色\r\n- `minimapSlider.activeBackground`: 点击时的小地图滑块背景色\r\n- `minimapGutter.addedBackground`: 添加内容的小地图装订线颜色\r\n- `minimapGutter.modifiedBackground`: 修改内容的小地图装订线颜色\r\n- `minimapGutter.deletedBackground`: 已删除内容的小地图装订线颜色\r\n\r\n## 编辑器组和选项卡\r\n\r\n> 编辑器组是编辑器的容器。可以有许多编辑器组。选项卡是编辑器的容器。可以在一个编辑器组中打开多个选项卡\r\n\r\n编辑器组是编辑器的容器。可以有许多编辑器组。选项卡是编辑器的容器。可以在一个编辑器组中打开多个选项卡。\r\n\r\n- `editorGroup.border`: 用于分隔多个编辑器组的颜色\r\n  - ![](./__assets__/editorGroup-border.gif)\r\n- `editorGroup.dropBackground`: 拖动编辑器时的背景色\r\n  - ![](./__assets__/editorGroup-dropbackground.gif)\r\n- `editorGroupHeader.noTabsBackground`: 禁用选项卡（设置）时编辑器组标题标题的背景色。`\"workbench.editor.showTabs\": false`\r\n  - ![](./__assets__/editorgroupheader-notabsbackground.gif)\r\n\r\n- `editorGroupHeader.tabsBackground`: 选项卡容器的背景色\r\n  - ![](./__assets__/editorgroupheader-tabsbackground.gif)\r\n- `editorGroupHeader.tabsBorder`: 启用选项卡时编辑器选项卡控件下方的边框颜色\r\n  - ![](./__assets__/editorgroupheader-tabsborder.gif)\r\n\r\n- `editorGroupHeader.border`: 编辑器组标题和编辑器之间的边框颜色（如果启用，则位于痕迹导航下方）\r\n- `editorGroup.emptyBackground`: 空编辑器组的背景色\r\n- `editorGroup.focusedEmptyBorder`: 获得焦点的空编辑器组的边框颜色\r\n- `editorGroup.dropIntoPromptForeground`: 拖动文件时在编辑器上显示的文本的前景色。此文本通知用户可以按住 shift 键放入编辑器\r\n- `editorGroup.dropIntoPromptBackground`: 拖动文件时在编辑器上显示的文本的背景色。此文本通知用户可以按住 shift 键放入编辑器\r\n- `editorGroup.dropIntoPromptBorder`: 拖动文件时在编辑器上显示的文本的边框颜色。此文本通知用户可以按住 shift 键放入编辑器\r\n- `tab.activeBackground`: 活动组中的活动选项卡背景色\r\n- `tab.unfocusedActiveBackground`: 非活动编辑器组中的活动选项卡背景色\r\n- `tab.activeForeground`: 活动组中的活动制表符前景色\r\n- `tab.border`: 用于分隔制表符的边框\r\n- `tab.activeBorder`: 活动选项卡的下边框\r\n- `tab.unfocusedActiveBorder`: 非活动编辑器组中活动选项卡的下边框\r\n- `tab.activeBorderTop`: 活动选项卡的上边框\r\n- `tab.unfocusedActiveBorderTop`: 非活动编辑器组中活动选项卡的上边\r\n- `tab.lastPinnedBorder`: 最后一个固定编辑器右侧的边框，用于与未固定的编辑器分开\r\n- `tab.inactiveBackground`: 非活动选项卡背景色\r\n- `tab.unfocusedInactiveBackground`: 非焦点组中的非活动选项卡背景\r\n- `tab.inactiveForeground`: 活动组中的非活动制表符前景色\r\n- `tab.unfocusedActiveForeground`: 非活动编辑器组中的活动选项卡前景色\r\n- `tab.unfocusedInactiveForeground`: 非活动编辑器组中的非活动制表前景色\r\n- `tab.hoverBackground`: 悬停时选项卡背景颜\r\n- `tab.unfocusedHoverBackground`: 悬停时未聚焦组中的选项卡背景\r\n- `tab.hoverForeground`: 悬停时选项卡前景\r\n- `tab.unfocusedHoverForeground`: 悬停时在未对焦的组中使用前景色选项\r\n- `tab.hoverBorder`: 悬停时突出显示标签页的边\r\n- `tab.unfocusedHoverBorder`: 悬停时突出显示未聚焦组中的选项卡的边\r\n- `tab.activeModifiedBorder`: 活动组中已修改（dirty）活动选项卡顶部的边框\r\n- `tab.inactiveModifiedBorder`: 活动组中已修改（dirty）非活动选项卡顶部的边框\r\n- `tab.unfocusedActiveModifiedBorder`: 未聚焦组中已修改（dirty）活动选项卡顶部的边框\r\n- `tab.unfocusedInactiveModifiedBorder`: 未聚焦组中已修改（dirty）非活动选项卡顶部的边框\r\n- `editorPane.background`: 编辑器窗格的背景色在居中的编辑器布局的左侧和右侧可见\r\n- `sideBySideEditor.horizontalBorder`: 在编辑器组中从上到下并排显示时，用于将两个编辑器彼此分开的颜色\r\n- `sideBySideEditor.verticalBorder`: 在编辑器组中从左到右并排显示时，用于将两个编辑器彼此分开的颜色\r\n\r\n## 编辑器颜色\r\n\r\n> 最突出的编辑器颜色是用于语法突出显示的标记颜色，并且基于安装的语言语法。这些颜色由颜色主题定义，但也可以使用设置进行自定义。有关更新颜色主题和可用令牌类型的详细信息，请参阅[自定义颜色主题](https://code.visualstudio.com/docs/getstarted/themes#_customizing-a-color-theme)。`editor.tokenColorCustomizations`\r\n\r\n### 所有其他编辑器颜色\r\n\r\n- `editor.background`: 编辑器背景色\r\n- `editor.foreground`: 编辑器默认前景色\r\n- `editorLineNumber.foreground`: 编辑器行号的颜色\r\n- `editorLineNumber.activeForeground`: 活动编辑器行号的颜色\r\n- `editorCursor.background`: 编辑器光标的背景色。允许自定义块光标重叠的字符的颜色\r\n- `editorCursor.foreground`: 编辑器光标的颜色\r\n\r\n### 选中高亮\r\n\r\n> 选择一个或多个字符时，选择颜色可见。除了选择之外，还会突出显示具有相同内容的所有区域。\r\n\r\n![](./__assets__/主题颜色-2022-11-22-20-48-16.png)\r\n\r\n- `editor.selectionBackground`: 编辑器选择的颜色\r\n- `editor.selectionForeground`: 所选文本的颜色以获得高对比度\r\n- `editor.inactiveSelectionBackground`: 非活动编辑器中所选内容的颜色。颜色不得不透明，以免隐藏底层装饰\r\n- `editor.selectionHighlightBackground`: 与所选内容相同的区域的颜色。颜色不得不透明，以免隐藏底层装饰\r\n- `editor.selectionHighlightBorder`: 与所选内容相同的区域的边框颜色\r\n  \r\n### 选中单词高亮\r\n\r\n> 当光标位于符号或单词内时，单词突出显示颜色可见。根据文件类型可用的语言支持，将突出显示所有匹配的引用和声明，并且读取和写入访问将获得不同的颜色。如果文档符号语言支持不可用，则回退到单词突出显示。\r\n\r\n![](./__assets__/主题颜色-2022-11-22-20-50-39.png)\r\n\r\n- `editor.wordHighlightBackground`: 读取访问期间符号的背景颜色，例如读取变量时。颜色不得不透明，以免隐藏底层装饰\r\n- `editor.wordHighlightBorder`: 读取访问期间符号的边框颜色，例如读取变量时\r\n- `editor.wordHighlightStrongBackground`: 写入访问期间符号的背景颜色，例如写入变量时。颜色不得不透明，以免隐藏底层装饰\r\n- `editor.wordHighlightStrongBorder`: 写入访问期间符号的边框颜色，例如写入变量时\r\n\r\n### 查找高亮\r\n\r\n> 查找颜色取决于“查找/替换”对话框中的当前查找字符串\r\n\r\n![](./__assets__/主题颜色-2022-11-22-20-52-03.png)\r\n\r\n- `editor.findMatchBackground`: 当前搜索匹配项的颜色\r\n- `editor.findMatchHighlightBackground`: 其他搜索匹配项的颜色。颜色不得不透明，以免隐藏底层装饰\r\n- `editor.findRangeHighlightBackground`: 为限制搜索的范围着色（在查找小部件中启用“在所选内容中查找”）。颜色不得不透明，以免隐藏底层装饰\r\n- `editor.findMatchBorder`: 当前搜索匹配项的边框颜色\r\n- `editor.findMatchHighlightBorder`: 其他搜索匹配项的边框颜色\r\n- `editor.findRangeHighlightBorder`: 边框颜色限制搜索的范围（在查找小部件中启用“在选择中查找”）\r\n\r\n### 搜索编辑器\r\n\r\n> 搜索编辑器颜色突出显示搜索编辑器中的结果。这可以与其他查找匹配项分开配置，以便在同一编辑器中更好地区分不同类别的匹配项。\r\n\r\n![](./__assets__/主题颜色-2022-11-22-20-52-51.png)\r\n\r\n- `searchEditor.findMatchBackground`: 编辑器结果的颜色\r\n- `searchEditor.findMatchBorder`: 编辑器结果的边框颜色\r\n- `searchEditor.textInputBorder`: 搜索编辑器文本输入框边框\r\n\r\n### 悬浮高亮\r\n\r\n> 悬停高亮显示显示在显示悬停的符号后面\r\n\r\n![](./__assets__/主题颜色-2022-11-22-20-56-16.png)\r\n\r\n- `editor.hoverHighlightBackground`: 突出显示显示悬停的字词下方。颜色不得不透明，以免隐藏底层装饰\r\n\r\n> 当前线条通常显示为背景突出显示或边框（而不是两者）。\r\n\r\n![](./__assets__/主题颜色-2022-11-22-20-56-59.png)\r\n\r\n- `editor.lineHighlightBackground`: 光标位置处线条高亮显示的背景色\r\n- `editor.lineHighlightBorder`: 光标位置处线条周围边框的背景色\r\n\r\n> 统一码突出显示的颜色\r\n\r\n- `editorUnicodeHighlight.border`: 用于突出显示 unicode 字符的边框颜色\r\n- `editorUnicodeHighlight.background`: 用于突出显示 unicode 字符的背景色\r\n\r\n> 单击链接时，链接颜色可见\r\n\r\n![](./__assets__/主题颜色-2022-11-22-20-58-38.png)\r\n\r\n`editorLink.activeForeground`: 活动链接的颜色\r\n\r\n> 选择搜索结果时，范围突出显示可见\r\n\r\n![](./__assets__/主题颜色-2022-11-22-20-59-12.png)\r\n\r\n- `editor.rangeHighlightBackground`: 突出显示范围的背景色，由“快速打开”、“文件中的符号”和“查找”功能使用。颜色不得不透明，以免隐藏底层装饰\r\n- `editor.rangeHighlightBorder`: 突出显示范围周围边框的背景色\r\n\r\n> 通过诸如“转至定义”等命令导航到符号时，符号高亮显示可见\r\n\r\n- `editor.symbolHighlightBackground`: 突出显示符号的背景颜色。颜色不得不透明，以免隐藏底层装饰\r\n- `editor.symbolHighlightBorder`: 突出显示的符号周围边框的背景色\r\n\r\n> 要查看编辑器空白，请启用切换渲染空白。\r\n\r\n- `editorWhitespace.foreground`: 编辑器中空格字符的颜色\r\n\r\n> 要查看编辑器缩进指南，请设置。\"editor.guides.indentation\": true\"editor.guides.highlightActiveIndentation\": true\r\n\r\n- `editorIndentGuide.background`:编辑器缩进参考线的颜色\r\n- `editorIndentGuide.activeBackground`:活动编辑器缩进参考线的颜色\r\n\r\n> 要查看编辑器内联提示，请设置。\"editor.inlineSuggest.enabled\": true\r\n\r\n- `editorInlayHint.background`: 内联提示的背景色\r\n- `editorInlayHint.foreground`: 内联提示的前景色\r\n- `editorInlayHint.typeForeground`: 类型的内联提示的前景色\r\n- `editorInlayHint.typeBackground`: 类型的内联提示的背景色\r\n- `editorInlayHint.parameterForeground`: 参数内联提示的前景色\r\n- `editorInlayHint.parameterBackground`: 参数内联提示的背景色\r\n\r\n> 要查看编辑器标尺，请使用\"editor.rulers\"\r\n\r\n- `editorRuler.foreground`: 编辑器标尺的颜色\r\n\r\n- `editor.linkedEditingBackground`: 编辑器处于链接编辑模式时的背景颜色\r\n\r\n代码镜头:\r\n\r\n![](./__assets__/主题颜色-2022-11-22-21-01-15.png)\r\n\r\n- `editorCodeLens.foreground`: 编辑器代码镜头的前景色\r\n\r\n灯泡:\r\n\r\n`editorLightBulb.foreground`:用于灯泡操作图标的颜色\r\n`editorLightBulbAutoFix.foreground`:用于灯泡自动修复操作图标的颜色\r\n\r\n### 括号颜色\r\n\r\n![](./__assets__/主题颜色-2022-11-22-20-28-01.png)\r\n\r\n- `editorBracketMatch.background`: 匹配括号后面的背景色\r\n- `editorBracketMatch.border`: 匹配括号框的颜色\r\n\r\n#### 支架对着色\r\n\r\n- `editorBracketHighlight.foreground1`: 括号 （1） 的前景色。需要启用括号对着色\r\n- `editorBracketHighlight.foreground2`: 括号 （2） 的前景色。需要启用括号对着色\r\n- `editorBracketHighlight.foreground3`: 括号 （3） 的前景色。需要启用括号对着色\r\n- `editorBracketHighlight.foreground4`: 括号（4）的前景色。需要启用括号对着色\r\n- `editorBracketHighlight.foreground5`: 括号 （5） 的前景色。需要启用括号对着色\r\n- `editorBracketHighlight.foreground6`: 方括号（6）的前景色。需要启用括号对着色\r\n- `editorBracketHighlight.unexpectedBracket.foreground`: 意外括号的前景色\r\n\r\n#### 支架对导轨\r\n\r\n- `editorBracketPairGuide.activeBackground1`: 活动支架对导轨的背景色 （1）, 需要启用支架对导轨\r\n- `editorBracketPairGuide.activeBackground2`: 活动支架对导轨的背景色 （2）, 需要启用支架对导轨\r\n- `editorBracketPairGuide.activeBackground3`: 主动支架对导轨的背景色 （3）, 需要启用支架对导轨\r\n- `editorBracketPairGuide.activeBackground4`: 活动支架对导轨的背景色 （4）, 需要启用支架对导轨\r\n- `editorBracketPairGuide.activeBackground5`: 活动支架对导轨的背景色 （5）, 需要启用支架对导轨\r\n- `editorBracketPairGuide.activeBackground6`: 活动支架对导轨的背景色 （6）, 需要启用支架对导轨\r\n- `editorBracketPairGuide.background1`: 非活动支架对导轨的背景颜色 （1）, 需要启用支架对导轨\r\n- `editorBracketPairGuide.background2`: 非活动支架对导轨的背景颜色 （2）, 需要启用支架对导轨\r\n- `editorBracketPairGuide.background3`: 非活动支架对导轨的背景色 （3）, 需要启用支架对导轨\r\n- `editorBracketPairGuide.background4`: 非活动支架对导轨的背景色 （4）, 需要启用支架对导轨\r\n- `editorBracketPairGuide.background5`: 非活动支架对导轨的背景色 （5）, 需要启用支架对导轨\r\n- `editorBracketPairGuide.background6`: 非活动支架对导轨的背景色 （6）, 需要启用支架对导轨\r\n\r\n#### 折叠\r\n\r\n- `editor.foldBackground`: 折叠范围的背景色。颜色不得不透明，以免隐藏底层装饰\r\n\r\n#### 概述标尺\r\n\r\n> 此标尺位于编辑器右边缘的滚动条下方，用于概述编辑器中的装饰\r\n\r\n- `editorOverviewRuler.background`: 编辑器概述标尺的背景色。仅在启用小地图并将其放置在编辑器右侧时使用\r\n- `editorOverviewRuler.border`: 概览标尺边框的颜色\r\n- `editorOverviewRuler.findMatchForeground`: 查找匹配项的概述标尺标记颜色。颜色不得不透明，以免隐藏底层装饰\r\n- `editorOverviewRuler.rangeHighlightForeground`: 突出显示范围的概述标尺标记颜色，例如快速打开，文件中的符号和查找功能。颜色不得不透明，以免隐藏底层装饰\r\n- `editorOverviewRuler.selectionHighlightForeground`: 用于选择高亮显示的概览标尺标记颜色。颜色不得不透明，以免隐藏底层装饰\r\n- `editorOverviewRuler.wordHighlightForeground`: 符号高亮显示的概览标尺标记颜色。颜色不得不透明，以免隐藏底层装饰\r\n- `editorOverviewRuler.wordHighlightStrongForeground`: 写入访问符号突出显示的概述标尺标记颜色。颜色不得不透明，以免隐藏底层装饰\r\n- `editorOverviewRuler.modifiedForeground`: 已修改内容的概览标尺标记颜色\r\n- `editorOverviewRuler.addedForeground`: 添加内容的概述标尺标记颜色\r\n- `editorOverviewRuler.deletedForeground`: 已删除内容的概览标尺标记颜色\r\n- `editorOverviewRuler.errorForeground`: 概述标尺标记颜色以显示错误\r\n- `editorOverviewRuler.warningForeground`: 警告的概述标尺标记颜色\r\n- `editorOverviewRuler.infoForeground`: 信息的概述标尺标记颜色\r\n- `editorOverviewRuler.bracketMatchForeground`: 匹配方括号的概览标尺标记颜色\r\n\r\n#### 错误和警告\r\n\r\n- `editorError.foreground`: 编辑器中错误波浪线的前景色\r\n- `editorError.border`: 编辑器中错误框的边框颜色\r\n- `editorError.background`: 编辑器中错误文本的背景色。颜色不得不透明，以免隐藏底层装饰\r\n- `editorWarning.foreground`: 编辑器中警告波浪线的前景色\r\n- `editorWarning.border`: 编辑器中警告框的边框颜色\r\n- `editorWarning.background`: 编辑器中警告文本的背景色。颜色不得不透明，以免隐藏底层装饰\r\n- `editorInfo.foreground`: 编辑器中信息波浪线的前景色\r\n- `editorInfo.border`: 编辑器中信息框的边框颜色\r\n- `editorInfo.background`: 编辑器中信息文本的背景色。颜色不得不透明，以免隐藏底层装饰\r\n- `editorHint.foreground`: 编辑器中提示的前景色\r\n- `editorHint.border`: 编辑器中提示框的边框颜色\r\n- `problemsErrorIcon.foreground`: 用于问题错误图标的颜色\r\n- `problemsWarningIcon.foreground`: 用于问题警告图标的颜色\r\n- `problemsInfoIcon.foreground`: 用于问题信息图标的颜色\r\n\r\n#### 未使用的源代码\r\n\r\n- `editorUnnecessaryCode.border`: 编辑器中不必要（未使用）源代码的边框颜色\r\n- `editorUnnecessaryCode.opacity`: 编辑器中不必要（未使用）源代码的不透明度。例如，将以 75% 的不透明度呈现代码。对于高对比度主题，请使用主题颜色为不必要的代码添加下划线，而不是淡出它。``\"#000000c0\" \"editorUnnecessaryCode.border\"`\r\n\r\n#### 装订线包含字形边距和行号\r\n\r\n- `editorGutter.background`: 编辑器装订线的背景色。装订线包含字形边距和行号\r\n- `editorGutter.modifiedBackground`: 已修改线条的编辑器装订线背景色\r\n- `editorGutter.addedBackground`: 添加的线条的编辑器装订线背景色\r\n- `editorGutter.deletedBackground`: 删除线条的编辑器装订线背景色\r\n- `editorGutter.commentRangeForeground`: 注释范围的编辑器装订线装饰颜色\r\n- `editorGutter.foldingControlForeground`: 编辑器装订线中折叠控件的颜色\r\n\r\n#### 在查看拉取请求时可以看到编辑器注释小部件\r\n\r\n- `editorCommentsWidget.resolvedBorder`: 边框和箭头的颜色，用于解决评论\r\n- `editorCommentsWidget.unresolvedBorder`: 边框和箭头的颜色，用于未解决的评论\r\n- `editorCommentsWidget.rangeBackground`: 注释范围的背景颜色\r\n- `editorCommentsWidget.rangeBorder`: 注释范围的边框颜色\r\n- `editorCommentsWidget.rangeActiveBackground`: 当前选定或悬停的评论范围的背景颜色\r\n- `editorCommentsWidget.rangeActiveBorder`: 当前选定或悬停的注释范围的边框颜色\r\n\r\n## 比较编辑器颜色\r\n\r\n> 要为插入和删除的文本着色，请使用背景或边框颜色，但不能同时使用两者\r\n\r\n- `diffEditor.insertedTextBackground`: 插入的文本的背景色。颜色不得不透明，以免隐藏底层装饰\r\n- `diffEditor.insertedTextBorder`: 插入的文本的轮廓颜色\r\n- `diffEditor.removedTextBackground`: 已删除文本的背景色。颜色不得不透明，以免隐藏底层装饰\r\n- `diffEditor.removedTextBorder`: 已删除文本的轮廓颜色\r\n- `diffEditor.border`: 两个文本编辑器之间的边框颜色\r\n- `diffEditor.diagonalFill`: 比较编辑器对角线填充的颜色。对角线填充用于并排比较视图\r\n- `diffEditor.insertedLineBackground`: 插入的线条的背景色。颜色不得不透明，以免隐藏底层装饰\r\n- `diffEditor.removedLineBackground`: 已删除线条的背景色。颜色不得不透明，以免隐藏底层装饰\r\n- `diffEditorGutter.insertedLineBackground`: 插入线条的边距的背景色\r\n- `diffEditorGutter.removedLineBackground`: 删除线条的边距的背景色\r\n- `diffEditorOverview.insertedForeground`: 插入内容的差异概述标尺前景\r\n- `diffEditorOverview.removedForeground`: 已删除内容的差异概述标尺前景\r\n\r\n### 编辑器微件颜色\r\n\r\n> “编辑器”微件显示在编辑器内容的前面。示例包括“查找/替换”对话框、建议微件和编辑器悬停\r\n\r\n- `editorWidget.foreground` :编辑器构件的前景色，例如查找/替换。\r\n- `editorWidget.background` :编辑器小部件的背景色，例如查找/替换。\r\n- `editorWidget.border` :编辑器构件的边框颜色，除非构件不包含边框或定义自己的边框颜色。\r\n- `editorWidget.resizeBorder` :编辑器微件大小调整栏的边框颜色。仅当构件选择具有调整边框大小且颜色未被微件覆盖时，才使用颜色。\r\n- `editorSuggestWidget.background` :建议微件的背景色。\r\n- `editorSuggestWidget.border` :建议微件的边框颜色。\r\n- `editorSuggestWidget.foreground` :建议微件的前景色。\r\n- `editorSuggestWidget.focusHighlightForeground` :聚焦项目时，建议微件中突出显示的匹配颜色。\r\n- `editorSuggestWidget.highlightForeground` :建议微件中匹配突出显示的颜色。\r\n- `editorSuggestWidget.selectedBackground` :建议微件中所选条目的背景色。\r\n- `editorSuggestWidget.selectedForeground` :建议构件中所选条目的前景色。\r\n- `editorSuggestWidget.selectedIconForeground` :建议微件中所选条目的图标前景色。\r\n- `editorSuggestWidgetStatus.foreground` :建议微件状态的前景色。\r\n- `editorHoverWidget.foreground` :编辑器悬停的前景色。\r\n- `editorHoverWidget.background` :编辑器悬停的背景色。\r\n- `editorHoverWidget.border` :编辑器悬停的边框颜色。\r\n- `editorHoverWidget.highlightForeground` :参数提示中活动项目的前景色。\r\n- `editorHoverWidget.statusBarBackground` :编辑器悬停状态栏的背景色。\r\n- `editorGhostText.border` :内联完成提供程序和建议预览显示的虚影文本的边框颜色。\r\n- `editorGhostText.background` :编辑器中虚影文本的背景色。\r\n- `editorGhostText.foreground` :内联完成提供程序和建议预览显示的虚影文本的前景色。\r\n- `editorStickyScroll.background` :编辑器粘滞滚动背景色\r\n- `editorStickyScrollHover.background` :悬停背景颜色上的编辑器粘滞滚动\r\n\r\n> “调试异常”小组件是一个速览视图，当调试在异常处停止时，该视图会显示在编辑器中。\r\n\r\n- `debugExceptionWidget.background` :异常小部件背景颜色。\r\n- `debugExceptionWidget.border` :异常小部件边框颜色。\r\n\r\n> 导航到编辑器中的错误和警告时会显示编辑器标记视图（转到“下一个错误”或“警告”命令）。\r\n\r\n- `editorMarkerNavigation.background` :编辑器标记导航微件背景。\r\n- `editorMarkerNavigationError.background` :编辑器标记导航微件错误颜色。\r\n- `editorMarkerNavigationWarning.background` :编辑器标记导航微件警告颜色。\r\n- `editorMarkerNavigationInfo.background` :编辑器标记导航微件信息颜色。\r\n- `editorMarkerNavigationError.headerBackground` :编辑器标记导航小部件错误标题背景。\r\n- `editorMarkerNavigationWarning.headerBackground` :编辑器标记导航小部件警告标题背景。\r\n- `editorMarkerNavigationInfo.headerBackground` :编辑器标记导航微件信息标题背景。\r\n\r\n## 速览视图颜色\r\n\r\n> 速览视图用于将引用和声明显示为编辑器中的视图\r\n\r\n![](./__assets__/主题颜色-2022-11-22-21-09-44.png)\r\n\r\n- `peekView.border`:速览视图边框和箭头的颜色\r\n- `peekViewEditor.background`:速览视图编辑器的背景色\r\n- `peekViewEditorGutter.background`:速览视图编辑器中装订线的背景色\r\n- `peekViewEditor.matchHighlightBackground`:在速览视图编辑器中匹配突出显示颜色\r\n- `peekViewEditor.matchHighlightBorder`:匹配速览视图编辑器中的高亮边框颜色\r\n- `peekViewResult.background`:速览视图结果列表的背景色\r\n- `peekViewResult.fileForeground`:速览视图结果列表中文件节点的前景色\r\n- `peekViewResult.lineForeground`:速览视图结果列表中线条节点的前景色\r\n- `peekViewResult.matchHighlightBackground`:匹配速览视图结果列表中的突出显示颜色\r\n- `peekViewResult.selectionBackground`:速览视图结果列表中所选条目的背景色\r\n- `peekViewResult.selectionForeground`:速览视图结果列表中所选条目的前景色\r\n- `peekViewTitle.background`:速览视图标题区域的背景色\r\n- `peekViewTitleDescription.foreground`:速览视图标题信息的颜色\r\n- `peekViewTitleLabel.foreground`:速览视图标题的颜色\r\n\r\n## 合并冲突颜色\r\n\r\n> 当编辑器包含特殊的差异范围时，将显示合并冲突修饰。\r\n\r\n![](./__assets__/主题颜色-2022-11-22-21-11-44.png)\r\n\r\n- `merge.currentHeaderBackground`: 内联合并冲突中的当前标头背景。颜色不得不透明，以免隐藏底层装饰\r\n- `merge.currentContentBackground`: 内联合并冲突中的当前内容背景。颜色不得不透明，以免隐藏底层装饰\r\n- `merge.incomingHeaderBackground`: 内联合并冲突中的传入标头背景。颜色不得不透明，以免隐藏底层装饰\r\n- `merge.incomingContentBackground`: 内联合并冲突中的传入内容背景。颜色不得不透明，以免隐藏底层装饰\r\n- `merge.border`: 标题上的边框颜色和内联合并中的拆分器冲突\r\n- `merge.commonContentBackground`: 内联合并冲突中的常见祖先内容背景。颜色不得不透明，以免隐藏底层装饰\r\n- `merge.commonHeaderBackground`: 内联合并冲突中的常见祖先标头背景。颜色不得不透明，以免隐藏底层装饰\r\n- `editorOverviewRuler.currentContentForeground`: 内联合并冲突的当前概述标尺前景\r\n- `editorOverviewRuler.incomingContentForeground`: 内联合并冲突的传入概述标尺前景\r\n- `editorOverviewRuler.commonContentForeground`: 内联合并冲突的共同祖先概述标尺前景\r\n- `mergeEditor.change.background`:更改的背景色。\r\n- `mergeEditor.change.word.background`:单词的背景颜色发生变化。\r\n- `mergeEditor.conflict.unhandledUnfocused.border`:未处理的未聚焦冲突的边框颜色。\r\n- `mergeEditor.conflict.unhandledFocused.border`:未处理的焦点冲突的边框颜色。\r\n- `mergeEditor.conflict.handledUnfocused.border`:已处理的未聚焦冲突的边框颜色。\r\n- `mergeEditor.conflict.handledFocused.border`:已处理焦点冲突的边框颜色。\r\n- `mergeEditor.conflict.handled.minimapOverViewRuler`:输入 1 中更改的前景色。\r\n- `mergeEditor.conflict.unhandled.minimapOverViewRuler`:输入 1 中更改的前景色。\r\n- `mergeEditor.conflictingLines.background`:“冲突线”文本的背景。\r\n- `mergeEditor.changeBase.background`:基底变化的背景色。\r\n- `mergeEditor.changeBase.word.background`:单词的背景颜色在基数中发生变化。\r\n- `mergeEditor.conflict.input1.background`:输入 1 中装饰品的背景色。\r\n- `mergeEditor.conflict.input2.background`:输入 2 中装饰品的背景色。\r\n\r\n## 面板颜色\r\n\r\n> 面板显示在编辑器区域下方，包含输出和集成终端等视图。\r\n\r\n- `panel.background`:面板背景颜色\r\n- `panel.border`:面板边框颜色，用于将面板与编辑器分开\r\n- `panel.dropBorder`:拖放面板标题的反馈颜色。面板显示在编辑器区域下方，包含输出和集成终端等视图\r\n- `panelTitle.activeBorder`:活动面板标题的边框颜色\r\n- `panelTitle.activeForeground`:活动面板的标题颜色\r\n- `panelTitle.inactiveForeground`:非活动面板的标题颜色\r\n- `panelInput.border`:面板中输入的输入框边框\r\n- `panelSection.border`:在面板中水平堆叠多个视图时使用的面板部分边框颜色。面板显示在编辑器区域下方，包含输出和集成终端等视图\r\n- `panelSection.dropBackground`:拖放面板部分的反馈颜色。颜色应具有透明度，以便面板部分仍然可以发光。面板显示在编辑器区域下方，包含输出和集成终端等视图\r\n- `panelSectionHeader.background`:面板部分标题背景颜色。面板显示在编辑器区域下方，包含输出和集成终端等视图\r\n- `panelSectionHeader.foreground`:面板部分标题前景色。面板显示在编辑器区域下方，包含输出和集成终端等视图\r\n- `panelSectionHeader.border`:在面板中垂直堆叠多个视图时使用的面板部分标题边框颜色。面板显示在编辑器区域下方，包含输出和集成终端等视图\r\n\r\n## 状态栏颜色\r\n\r\n> 状态栏显示在工作台的底部\r\n\r\n- `statusBar.background`: 标准状态栏背景色\r\n- `statusBar.foreground`: 状态栏前景色\r\n- `statusBar.border`: 分隔状态栏和编辑器的状态栏边框颜色\r\n- `statusBar.debuggingBackground`: 调试程序时的状态栏背景色\r\n- `statusBar.debuggingForeground`: 调试程序时的状态栏前景色\r\n- `statusBar.debuggingBorder`: 状态栏边框颜色，用于在调试程序时分隔状态栏和编辑器\r\n- `statusBar.noFolderForeground`: 未打开文件夹时的状态栏前景色\r\n- `statusBar.noFolderBackground`: 未打开文件夹时的状态栏背景色\r\n- `statusBar.noFolderBorder`: 状态栏边框颜色，未打开文件夹时分隔状态栏和编辑器\r\n- `statusBarItem.activeBackground`: 单击时的状态栏项目背景色\r\n- `statusBarItem.hoverBackground`: 悬停时的状态栏项目背景色\r\n- `statusBarItem.prominentForeground`: 状态栏突出显示项目前景色\r\n- `statusBarItem.prominentBackground`: 状态栏突出显示项目背景色\r\n- `statusBarItem.prominentHoverBackground`: 悬停时状态栏突出显示项目背景颜色\r\n- `statusBarItem.remoteBackground`: 状态栏上远程指示器的背景色\r\n- `statusBarItem.remoteForeground`: 状态栏上远程指示器的前景色\r\n- `statusBarItem.errorBackground`: 状态栏错误项背景色。错误项从其他状态栏条目中突出显示，以指示错误条件\r\n- `statusBarItem.errorForeground`: 状态栏错误项目前景色。错误项从其他状态栏条目中突出显示，以指示错误条件\r\n- `statusBarItem.warningBackground`: 状态栏警告项目背景色。警告项从其他状态栏条目中突出显示，以指示警告条件。状态栏显示在窗口底部\r\n- `statusBarItem.warningForeground`: 状态栏警告项前景色。警告项从其他状态栏条目中突出显示，以指示警告条件。状态栏显示在窗口底部\r\n- `statusBarItem.compactHoverBackground`: 将鼠标悬停在包含两个悬停器的项目上时的状态栏项目背景色。状态栏显示在窗口底部\r\n- `statusBarItem.focusBorder`: 聚焦于键盘导航时的状态栏项目边框颜色。状态栏显示在窗口底部\r\n- `statusBar.focusBorder`: 聚焦于键盘导航时的状态栏边框颜色。状态栏显示在窗口底部\r\n\r\n> 突出显示的项目从其他状态栏条目中突出显示，以指示重要性。例如，切换 Tab 键移动焦点命令更改模式指示器。\r\n\r\n## 标题栏颜色\r\n\r\n- `titleBar.activeBackground`: 窗口处于活动状态时的标题栏背景\r\n- `titleBar.activeForeground`: 窗口处于活动状态时的标题栏前景\r\n- `titleBar.inactiveBackground`: 窗口处于非活动状态时的标题栏背景\r\n- `titleBar.inactiveForeground`: 窗口处于非活动状态时的标题栏前景\r\n- `titleBar.border`: 标题栏边框颜色\r\n\r\n## 菜单栏颜色\r\n\r\n- `menubar.selectionForeground`: 菜单栏中所选菜单项的前景色\r\n- `menubar.selectionBackground`: 菜单栏中所选菜单项的背景色\r\n- `menubar.selectionBorder`: 菜单栏中所选菜单项的边框颜色\r\n- `menu.foreground`: 菜单项的前景色\r\n- `menu.background`: 菜单项的背景色\r\n- `menu.selectionForeground`: 菜单中所选菜单项的前景色\r\n- `menu.selectionBackground`: 菜单中所选菜单项的背景色\r\n- `menu.selectionBorder`: 菜单中所选菜单项的边框颜色\r\n- `menu.separatorBackground`: 菜单中分隔符菜单项的颜色\r\n- `menu.border`: 菜单的边框颜色\r\n\r\n## 指挥中心颜色\r\n\r\n- `commandCenter.foreground`: 指挥中心的前景色。\r\n- `commandCenter.activeForeground`: 指挥中心的活动前景色。\r\n- `commandCenter.background`: 指挥中心的背景色。\r\n- `commandCenter.activeBackground`: 指挥中心的活动背景色。\r\n- `commandCenter.border`: 指挥中心的边框颜色。\r\n- `commandCenter.inactiveForeground`: 窗口处于非活动状态时命令中心的前景色。\r\n- `commandCenter.inactiveBorder`: 窗口处于非活动状态时命令中心的边框颜色。\r\n\r\n## 通知颜色\r\n\r\n> 通知吐司从工作台的右下角向上滑动。\r\n\r\n![Notification Toasts](./__assets__/主题颜色-2022-11-22-21-18-33.png)\r\n\r\n在通知中心打开后，它们将显示在带有标题的列表中:\r\n\r\n![Notification Center](./__assets__/主题颜色-2022-11-22-21-19-02.png)\r\n\r\n- `notificationCenter.border`: 通知中心边框颜色\r\n- `notificationCenterHeader.foreground`: 通知中心页眉前景色\r\n- `notificationCenterHeader.background`: 通知中心标题背景色\r\n- `notificationToast.border`: 通知吐司边框颜色\r\n- `notifications.foreground`: 通知前景色\r\n- `notifications.background`: 通知背景色\r\n- `notifications.border`: 通知边框颜色与通知中心中的其他通知分开\r\n- `notificationLink.foreground`: 通知链接前景色\r\n- `notificationsErrorIcon.foreground`: 用于通知错误图标的颜色\r\n- `notificationsWarningIcon.foreground`: 用于通知警告图标的颜色\r\n- `notificationsInfoIcon.foreground`: 用于通知信息图标的颜色\r\n\r\n## 横幅颜色\r\n\r\n> 横幅显示在标题栏下方，并在可见时跨越工作台的整个宽度\r\n\r\n- `banner.background`: 横幅背景颜色\r\n- `banner.foreground`: 横幅前景色\r\n- `banner.iconForeground`: 横幅文本前面图标的颜色\r\n\r\n## 扩展颜色\r\n\r\n- `extensionButton.prominentForeground`: 扩展视图按钮前景色（例如“安装”按钮）\r\n- `extensionButton.prominentBackground`: 扩展视图按钮背景色\r\n- `extensionButton.prominentHoverBackground`: 扩展视图按钮背景悬停颜色\r\n- `extensionButton.background`: 扩展操作的按钮背景色\r\n- `extensionButton.foreground`: 扩展操作的按钮前景色\r\n- `extensionButton.hoverBackground`: 扩展操作的按钮背景悬停颜色\r\n- `extensionButton.separator`: 扩展操作的按钮分隔符颜色\r\n- `extensionBadge.remoteBackground`: 扩展视图中远程徽章的背景颜色\r\n- `extensionBadge.remoteForeground`: 扩展视图中远程锁屏提醒的前景色\r\n- `extensionIcon.starForeground`: 扩展评级的图标颜色\r\n- `extensionIcon.verifiedForeground`: 扩展程序验证发布者的图标颜色\r\n- `extensionIcon.preReleaseForeground`: 预发布扩展的图标颜色\r\n- `extensionIcon.sponsorForeground`: 扩展发起人的图标颜色\r\n\r\n## 快速选择器颜色\r\n\r\n- `pickerGroup.border`: 用于分组边框的快速选取器（快速打开）颜色\r\n- `pickerGroup.foreground`: 用于标签分组的快速选取器（快速打开）颜色\r\n- `quickInput.background`: 快速输入背景颜色。快速输入小部件是颜色主题选取器等视图的容器\r\n- `quickInput.foreground`: 快速输入前景色。快速输入小部件是颜色主题选取器等视图的容器\r\n- `quickInputList.focusBackground`: 焦点项目的快速选取器背景色\r\n- `quickInputList.focusForeground`: 焦点项目的快速选取器前景色\r\n- `quickInputList.focusIconForeground`: 焦点项目的快速选取器图标前景色\r\n- `quickInputTitle.background`: 快速选取器标题背景颜色。快速选取器小组件是命令面板等选取器的容器\r\n\r\n## 键绑定标签颜色\r\n\r\n> 当存在与命令关联的键绑定时，将显示键绑定标签。可以在命令面板中看到键绑定标签的示例:\r\n\r\n![Keybinding label](./__assets__/主题颜色-2022-11-22-21-21-57.png)\r\n\r\n键绑定标签的用法包括（但不限于）:\r\n\r\n- 命令面板\r\n- 键盘快捷键编辑器\r\n- 键盘快捷键记录器模式\r\n- 扩展市场页面的“功能贡献”部分\r\n\r\n以下自定义项可用:\r\n\r\n- `keybindingLabel.background`: 键绑定标签背景颜色。键绑定标签用于表示键盘快捷键\r\n- `keybindingLabel.foreground`: 键绑定标签前景色。键绑定标签用于表示键盘快捷键\r\n- `keybindingLabel.border`: 键绑定标签边框颜色。键绑定标签用于表示键盘快捷键\r\n- `keybindingLabel.bottomBorder`: 键绑定标签边框底部颜色。键绑定标签用于表示键盘快捷键\r\n\r\n## 键盘快捷键表颜色\r\n\r\n- `keybindingTable.headerBackground`: 键盘快捷键表格标题的背景色\r\n- `keybindingTable.rowsBackground`: 键盘快捷键表交替行的背景色\r\n\r\n## 集成端子颜色\r\n\r\n- `terminal.background`: 集成终端视口的背景。\r\n- `terminal.border`: 分隔终端内拆分窗格的边框的颜色。这默认为 `panel.border`。\r\n- `terminal.foreground`: 集成终端的默认前景色。\r\n- `terminal.ansiBlack`: 终端中的“黑色”ANSI 颜色。\r\n- `terminal.ansiBlue`: 终端中的“蓝色”ANSI 颜色。\r\n- `terminal.ansiBrightBlack`: 终端中的“亮黑色”ANSI 颜色。\r\n- `terminal.ansiBrightBlue`: 终端中的“亮蓝色”ANSI 颜色。\r\n- `terminal.ansiBrightCyan`: 终端中的“亮青色”ANSI 颜色。\r\n- `terminal.ansiBrightGreen`: 终端中的“亮绿色”ANSI 颜色。\r\n- `terminal.ansiBrightMagenta`: 终端中的“亮洋红色”ANSI 颜色。\r\n- `terminal.ansiBrightRed`: 终端中的“亮红色”ANSI 颜色。\r\n- `terminal.ansiBrightWhite`: 终端中的“亮白色”ANSI 颜色。\r\n- `terminal.ansiBrightYellow`: 终端中的“亮黄色”ANSI 颜色。\r\n- `terminal.ansiCyan`: 终端中的“青色”ANSI 颜色。\r\n- `terminal.ansiGreen`: 终端中的“绿色”ANSI 颜色。\r\n- `terminal.ansiMagenta`: 终端中的“洋红色”ANSI 颜色。\r\n- `terminal.ansiRed`: 终端中的“红色”ANSI 颜色。\r\n- `terminal.ansiWhite`: 终端中的“白色”ANSI 颜色。\r\n- `terminal.ansiYellow`: 终端中的“黄色”ANSI 颜色。\r\n- `terminal.selectionBackground`: 终端的选择背景颜色。\r\n- `terminal.selectionForeground`: 选择终端的前景色。当此值为 null 时，将保留选区前景并应用最小对比度功能。\r\n- `terminal.inactiveSelectionBackground`: 终端没有焦点时的选择背景色。\r\n- `terminal.findMatchBackground`: 终端中当前搜索匹配项的颜色。颜色不得不透明，以免隐藏底层终端内容。\r\n- `terminal.findMatchBorder`: 终端中当前搜索匹配项的边框颜色。\r\n- `terminal.findMatchHighlightBackground`: 终端中其他搜索匹配项的颜色。颜色不得不透明，以免隐藏底层终端内容。\r\n- `terminal.findMatchHighlightBorder`: 终端中其他搜索匹配项的边框颜色。\r\n- `terminalCursor.background`: 终端光标的背景色。允许自定义块光标重叠的字符的颜色。\r\n- `terminalCursor.foreground`: 终端光标的前景色。\r\n- `terminal.dropBackground`: 在终端顶部拖动时的背景色。颜色应具有透明度，以便终端内容物仍然可以发光。\r\n- `terminal.tab.activeBorder`:面板中终端选项卡一侧的边框。这默认为。`tab.activeBorder`\r\n- `terminalCommandDecoration.defaultBackground`: 默认终端命令修饰背景色。\r\n- `terminalCommandDecoration.successBackground`: 成功命令的终端命令装饰背景色。\r\n- `terminalCommandDecoration.errorBackground`: 错误命令的终端命令修饰背景色。\r\n- `terminalOverviewRuler.cursorForeground`: 概览标尺光标颜色。\r\n- `terminalOverviewRuler.findMatchForeground`: 在终端中查找匹配项的概述标尺标记颜色。\r\n\r\n## 调试颜色\r\n\r\n- `debugToolBar.background`: 调试工具栏背景色。\r\n- `debugToolBar.border`: 调试工具栏边框颜色。\r\n- `editor.stackFrameHighlightBackground`: 编辑器中顶部堆栈帧高亮显示的背景色。\r\n- `editor.focusedStackFrameHighlightBackground`: 编辑器中聚焦堆栈帧高亮显示的背景色。\r\n- `editor.inlineValuesForeground`: 调试内联值文本的颜色。\r\n- `editor.inlineValuesBackground`: 调试内联值背景的颜色。\r\n- `debugView.exceptionLabelForeground`: 调试器因异常而中断时，“调用堆栈”视图中显示的标签的前景色\r\n- `debugView.exceptionLabelBackground`: 调试器因异常而中断时在调用堆栈视图中显示的标签的背景色\r\n- `debugView.stateLabelForeground`: 调用堆栈视图中标签的前景色，显示当前会话或线程的状态\r\n- `debugView.stateLabelBackground`: 调用堆栈视图中标签的背景色，显示当前会话或线程的状态\r\n- `debugView.valueChangedHighlight`: 用于突出显示调试视图中的值更改的颜色（即在变量视图中）\r\n- `debugTokenExpression.name`: 调试视图（即“变量”或“监视”视图）中显示的令牌名称的前景色\r\n- `debugTokenExpression.value`: 调试视图中显示的令牌值的前景色\r\n- `debugTokenExpression.string`: 调试视图中字符串的前景色\r\n- `debugTokenExpression.boolean`: 调试视图中布尔值的前景色\r\n- `debugTokenExpression.number`: 调试视图中数字的前景色\r\n- `debugTokenExpression.error`: 调试视图中表达式错误的前景色\r\n\r\n## 测试颜色\r\n\r\n- `testing.iconFailed`:测试资源管理器中“失败”图标的颜色。\r\n- `testing.iconErrored`:测试资源管理器中“错误”图标的颜色。\r\n- `testing.iconPassed`:测试资源管理器中“通过”图标的颜色。\r\n- `testing.runAction`:编辑器中“运行”图标的颜色。\r\n- `testing.iconQueued`:测试资源管理器中“已排队”图标的颜色。\r\n- `testing.iconUnset`:测试资源管理器中“未设置”图标的颜色。\r\n- `testing.iconSkipped`:测试资源管理器中“跳过”图标的颜色。\r\n- `testing.peekBorder`:速览视图边框和箭头的颜色。\r\n- `testing.peekHeaderBackground`:速览视图边框和箭头的颜色。\r\n- `testing.message.error.decorationForeground`: 在编辑器中以内联方式显示的测试错误消息的文本颜色。\r\n- `testing.message.error.lineBackground`: 编辑器中以内联方式显示的错误消息旁边的边距颜色。\r\n- `testing.message.info.decorationForeground`: 在编辑器中内联显示的测试信息消息的文本颜色。\r\n- `testing.message.info.lineBackground`: 在编辑器中以内联方式显示的信息消息旁边的边距颜色。\r\n\r\n## 欢迎页面颜色\r\n\r\n- `welcomePage.background`: 欢迎页面的背景色\r\n- `welcomePage.progress.background`:欢迎页面进度条的前景色\r\n- `welcomePage.progress.foreground`:欢迎页面进度条的背景色\r\n- `welcomePage.tileBackground`: “入门”页面上磁贴的背景色\r\n- `welcomePage.tileHoverBackground`: 将鼠标悬停在“入门”上的磁贴背景颜色\r\n- `welcomePage.tileShadow`: 欢迎页面演练类别按钮的阴影颜色\r\n- `walkThrough.embeddedEditorBackground`: 交互式操场上嵌入式编辑器的背景色\r\n\r\n## 源代码管理颜色\r\n\r\n- `scm.providerBorder`: `SCM` 提供程序分隔符边框。\r\n\r\n## 吉特颜色\r\n\r\n- `gitDecoration.addedResourceForeground`: 添加的 Git 资源的颜色。用于文件标签和 SCM 查看器。\r\n- `gitDecoration.modifiedResourceForeground`: 修改后的 Git 资源的颜色。用于文件标签和 SCM 查看器。\r\n- `gitDecoration.deletedResourceForeground`: 已删除 Git 资源的颜色。用于文件标签和 SCM 查看器。\r\n- `gitDecoration.renamedResourceForeground`: 重命名或复制的 Git 资源的颜色。用于文件标签和 SCM 查看器。\r\n- `gitDecoration.stageModifiedResourceForeground`: 分阶段修改git装饰的颜色。用于文件标签和 SCM 查看器。\r\n- `gitDecoration.stageDeletedResourceForeground`: 分阶段删除 git 装饰的颜色。用于文件标签和 SCM 查看器。\r\n- `gitDecoration.untrackedResourceForeground`: 未跟踪的 Git 资源的颜色。用于文件标签和 SCM 查看器。\r\n- `gitDecoration.ignoredResourceForeground`: 忽略的 Git 资源的颜色。用于文件标签和 SCM 查看器。\r\n- `gitDecoration.conflictingResourceForeground`: 冲突的 Git 资源的颜色。用于文件标签和 SCM 查看器。\r\n- `gitDecoration.submoduleResourceForeground`: 子模块资源的颜色。\r\n\r\n## 设置编辑器颜色\r\n\r\n> 注意:这些颜色适用于可以使用命令打开的 GUI 设置编辑器。`Preferences: Open Settings (UI)`\r\n\r\n- `settings.headerForeground`: 节标题或活动标题的前景色。\r\n- `settings.modifiedItemIndicator`: 指示已修改设置的行。\r\n- `settings.dropdownBackground`: 下拉背景。\r\n- `settings.dropdownForeground`: 下拉前景。\r\n- `settings.dropdownBorder`: 下拉边框。\r\n- `settings.dropdownListBorder`: 下拉列表边框。\r\n- `settings.checkboxBackground`: 复选框背景。\r\n- `settings.checkboxForeground`: 复选框前景。\r\n- `settings.checkboxBorder`: 复选框边框。\r\n- `settings.rowHoverBackground`: 悬停时设置行的背景色。\r\n- `settings.textInputBackground`: 文本输入框背景。\r\n- `settings.textInputForeground`: 文本输入框前景。\r\n- `settings.textInputBorder`: 文本输入框边框。\r\n- `settings.numberInputBackground`: 数字输入框背景。\r\n- `settings.numberInputForeground`: 数字输入框前景。\r\n- `settings.numberInputBorder`: 数字输入框边框。\r\n- `settings.focusedRowBackground`: 焦点设置行的背景色。\r\n- `settings.focusedRowBorder`: 行聚焦时行的上边框和下边框的颜色。\r\n- `settings.headerBorder`: 标题容器边框的颜色。\r\n- `settings.sashBorder`: 设置编辑器分割视图窗扇边框的颜色。\r\n\r\n## 面包屑颜色\r\n\r\n痕迹导航的主题颜色:\r\n\r\n- `breadcrumb.foreground`: 面包屑物品的颜色。\r\n- `breadcrumb.background`: 面包屑项目的背景色。\r\n- `breadcrumb.focusForeground`: 重点面包屑项目的颜色。\r\n- `breadcrumb.activeSelectionForeground`: 所选痕迹导航项目的颜色。\r\n- `breadcrumbPicker.background`: 痕迹导航项选取器的背景色。\r\n\r\n## 代码段颜色\r\n\r\n片段的主题颜色:\r\n\r\n- `editor.snippetTabstopHighlightBackground`: 突出显示代码段制表位的背景色\r\n- `editor.snippetTabstopHighlightBorder`: 突出显示代码段制表位的边框颜色\r\n- `editor.snippetFinalTabstopHighlightBackground`: 突出显示代码段的最后一个制表位的背景色\r\n- `editor.snippetFinalTabstopHighlightBorder`: 突出显示代码段最后一个制表位的边框颜色\r\n\r\n## 符号图标颜色\r\n\r\n显示在大纲视图、痕迹导航和建议微件中的符号图标的主题颜色:\r\n\r\n- `symbolIcon.arrayForeground`: 数组符号的前景色\r\n- `symbolIcon.booleanForeground`: 布尔符号的前景色\r\n- `symbolIcon.classForeground`: 类符号的前景色\r\n- `symbolIcon.colorForeground`: 颜色符号的前景色\r\n- `symbolIcon.constantForeground`: 常量符号的前景色\r\n- `symbolIcon.constructorForeground`: 构造函数符号的前景色\r\n- `symbolIcon.enumeratorForeground`: 枚举器符号的前景色\r\n- `symbolIcon.enumeratorMemberForeground`: 枚举器成员符号的前景色\r\n- `symbolIcon.eventForeground`: 事件符号的前景色\r\n- `symbolIcon.fieldForeground`: 字段符号的前景色\r\n- `symbolIcon.fileForeground`: 文件元件的前景色\r\n- `symbolIcon.folderForeground`: 文件夹元件的前景色\r\n- `symbolIcon.functionForeground`: 函数符号的前景色\r\n- `symbolIcon.interfaceForeground`: 界面符号的前景色\r\n- `symbolIcon.keyForeground`: 关键符号的前景色\r\n- `symbolIcon.keywordForeground`: 关键字符号的前景色\r\n- `symbolIcon.methodForeground`: 方法符号的前景色\r\n- `symbolIcon.moduleForeground`: 模块符号的前景色\r\n- `symbolIcon.namespaceForeground`: 命名空间符号的前景色\r\n- `symbolIcon.nullForeground`: 空符号的前景色\r\n- `symbolIcon.numberForeground`: 数字符号的前景色\r\n- `symbolIcon.objectForeground`: 对象符号的前景色\r\n- `symbolIcon.operatorForeground`: 运算符符号的前景色\r\n- `symbolIcon.packageForeground`: 包符号的前景色\r\n- `symbolIcon.propertyForeground`: 属性符号的前景色\r\n- `symbolIcon.referenceForeground`: 参考符号的前景色\r\n- `symbolIcon.snippetForeground`: 代码段符号的前景色\r\n- `symbolIcon.stringForeground`: 字符串符号的前景色\r\n- `symbolIcon.structForeground`: 结构符号的前景色\r\n- `symbolIcon.textForeground`: 文本符号的前景色\r\n- `symbolIcon.typeParameterForeground`: 类型参数符号的前景色\r\n- `symbolIcon.unitForeground`: 单位符号的前景色\r\n- `symbolIcon.variableForeground`: 可变符号的前景色\r\n\r\n## 调试图标颜色\r\n\r\n- `debugIcon.breakpointForeground`: 断点的图标颜色\r\n- `debugIcon.breakpointDisabledForeground`: 禁用断点的图标颜色\r\n- `debugIcon.breakpointUnverifiedForeground`: 未经验证的断点的图标颜色\r\n- `debugIcon.breakpointCurrentStackframeForeground`: 当前断点堆栈帧的图标颜色\r\n- `debugIcon.breakpointStackframeForeground`: 所有断点堆栈帧的图标颜色\r\n- `debugIcon.startForeground`: 用于开始调试的调试工具栏图标\r\n- `debugIcon.pauseForeground`: 用于暂停的调试工具栏图标\r\n- `debugIcon.stopForeground`: 停止的调试工具栏图标\r\n- `debugIcon.disconnectForeground`: 用于断开连接的调试工具栏图标\r\n- `debugIcon.restartForeground`: 用于重新启动的调试工具栏图标\r\n- `debugIcon.stepOverForeground`: 用于跨步执行的调试工具栏图标\r\n- `debugIcon.stepIntoForeground`: 用于单步执行的调试工具栏图标\r\n- `debugIcon.stepOutForeground`: 用于跨步执行的调试工具栏图标\r\n- `debugIcon.continueForeground`: 用于继续的调试工具栏图标\r\n- `debugIcon.stepBackForeground`: 用于后退的调试工具栏图标\r\n- `debugConsole.infoForeground`: 调试 REPL 控制台中信息消息的前景色\r\n- `debugConsole.warningForeground`: 调试 REPL 控制台中警告消息的前景色\r\n- `debugConsole.errorForeground`: 调试 REPL 控制台中错误消息的前景色\r\n- `debugConsole.sourceForeground`: 调试 REPL 控制台中源文件名的前景色\r\n- `debugConsoleInputIcon.foreground`: 调试控制台输入标记图标的前景色\r\n\r\n## 笔记本颜色\r\n\r\n- `notebook.editorBackground`: 笔记本背景色\r\n- `notebook.cellBorderColor`: 笔记本单元格的边框颜色\r\n- `notebook.cellHoverBackground`: 悬停单元格时单元格的背景色\r\n- `notebook.cellInsertionIndicator`: 笔记本单元格插入指示器的颜色\r\n- `notebook.cellStatusBarItemHoverBackground`: 笔记本单元格状态栏项目的背景色\r\n- `notebook.cellToolbarSeparator`: 单元格底部工具栏中分隔符的颜\r\n- `notebook.cellEditorBackground`: 笔记本单元格编辑器背景的颜\r\n- `notebook.focusedCellBackground`: 聚焦单元格时单元格的背景色\r\n- `notebook.focusedCellBorder`: 单元格聚焦时单元格焦点指示器边框的颜色\r\n- `notebook.focusedEditorBorder`: 笔记本单元格编辑器边框的颜色\r\n- `notebook.inactiveFocusedCellBorder`: 当主要焦点位于编辑器外部时，单元格聚焦时单元格的上边框和下边框的颜色\r\n- `notebook.inactiveSelectedCellBorder`: 选择多个单元格时单元格边框的颜色\r\n- `notebook.outputContainerBackgroundColor`: 笔记本输出容器背景的颜色\r\n- `notebook.outputContainerBorderColor`: 笔记本输出容器的边框颜色\r\n- `notebook.selectedCellBackground`: 选择单元格时单元格的背景色\r\n- `notebook.selectedCellBorder`: 单元格处于选中状态但未聚焦时单元格的上边框和下边框的颜色\r\n- `notebook.symbolHighlightBackground`: 突出显示单元格的背景\r\n- `notebookScrollbarSlider.activeBackground`: 单击时笔记本滚动条滑块背景色\r\n- `notebookScrollbarSlider.background`: 笔记本滚动条滑块背景色\r\n- `notebookScrollbarSlider.hoverBackground`: 悬停时笔记本滚动条滑块背景色\r\n- `notebookStatusErrorIcon.foreground`: 单元格状态栏中笔记本单元格的错误图标颜色\r\n- `notebookStatusRunningIcon.foreground`: 单元格状态栏中笔记本单元格的运行图标颜色\r\n- `notebookStatusSuccessIcon.foreground`: 单元格状态栏中笔记本单元格的成功图标颜色\r\n\r\n## 图表颜色\r\n\r\n- `charts.foreground`: 图表中文本的对比度颜色。\r\n- `charts.lines`: 图表中线条的颜色。\r\n- `charts.red`: 图表中红色元素的颜色。\r\n- `charts.blue`: 图表中蓝色元素的颜色。\r\n- `charts.yellow`: 图表中黄色元素的颜色。\r\n- `charts.orange`: 图表中橙色元素的颜色。\r\n- `charts.green`: 图表中绿色元素的颜色。\r\n- `charts.purple`: 图表中紫色元素的颜色。\r\n\r\n## 端口颜色\r\n\r\n- `ports.iconRunningProcessForeground`: 具有关联正在运行的进程的端口的图标颜色\r\n\r\n## 扩展颜色\r\n\r\n颜色 ID 也可以通过颜色贡献点的扩展来贡献。在设置和颜色主题定义文件中使用代码完成时，也会显示这些颜色。用户可以在扩展贡献选项卡中查看扩展定义的颜色。`workbench.colorCustomizations`\r\n","children":[]}]},{"name":"emmet.md","path":"../guanruihua.github.io/Tool/vscode","data":"# Emmet\n\n|  符号   | 描述    |     |\n| --- | --- | --- |\n| >    |  后代   |     |\n|  +   |   兄弟  |     |\n| ^ | 上级 |\n| () | 分组 |\n| * | 多个 |\n| $ | 自增 |\n|  {}   |  文本   |     |\n| # | id |\n| . | class |\n| [title=\"hello world\"]| 自定义属性 |\n","children":[]},{"name":"index.md","path":"../guanruihua.github.io/Tool/vscode","data":"# VSCode 插件开发\n\n> [Your First Extension | Visual Studio Code Extension API](https://code.visualstudio.com/api/get-started/your-first-extension)\n>\n> `npm install -g yo generator-code`\n\n## 组件开发\n\n```shell\nyo code\n```\n\n### 选择要开发的类型\n\n```\nNew Extension(TypeScript) // 基于TS的插件\nNew Extension(JavaScript) // 基于JS的插件\nNew Color Theme // 颜色主题\nNew Language Support // 语言支持\nNew Code Snippets // 代码片段\nNew Keymap // 键值映射\nNew Extension Pack \nNew Lanuage Pack(Localization) // 语言包\nNew Notebook Renderer(TypeScript)\n```\n\n### 填写对应信息\n\n1. 插件的名称\n2. 插件的id，最终会和你的开发者账号做拼接。比如大帅的开发者账号叫ezshine，最终会拼接为 `ezshine.插件id`\n3. 插件的介绍\n4. 是否开启类型检查\n5. 初始化git仓库（不是非要开启，以后手动开也行）\n6. 选择使用npm还是yarn来管理依赖\n","children":[]},{"name":"question.md","path":"../guanruihua.github.io/Tool/vscode","data":"# VScode问题\n\n## Problems loading reference 'https://json.schemastore.org/package': Unable to load schema from 'https://json.schemastore.org/package': connect ECONNREFUSED 127.0.0.1:8890\n\n> 由于本机的同源策略安全设置，不允许跨域访问资源，所有会将该请求的响应数据拦截\nsetting.json 设置\n\n```js\n\"http.proxyAuthorization\": \"false\",\n```\n\n## CPU占用过高\n\n> rg.exe占用过高\n\n1. search.followSymlinks 取消该配置项的勾选\n2. files.exclude 添加``node_modules`, 这样子就不会加载该文件夹, 可以减少加载该导致的资源的浪费\n\n## vscode中Comments are not permitted in JSON的解决办法\n\n> 1. 点击vscode 右下角的 ==JSON==\n>\n>    ![img](question.assets/20201226182440237.png)\n>\n> 2. 选择Configure File Association for '.json'\n>\n> ![img](question.assets/20201226182903753.png)\n>\n> 3. 输入json, 选择JSON with Comments\n>\n>    ![img](question.assets/20201226182923589.png)\n","children":[]},{"name":"vscode.md","path":"../guanruihua.github.io/Tool/vscode","data":"# vscode\n\n> [Visual Studio Code Extension API](https://code.visualstudio.com/api/references/extension-guidelines)\n\n## Launch\n\n> vscode 调试 react 项目\n\n```json\n{\n    // 使用 IntelliSense 了解相关属性。 \n    // 悬停以查看现有属性的描述。\n    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"type\": \"chrome\",\n            \"request\": \"launch\",\n            \"name\": \"Launch Chrome against localhost\",\n            \"url\": \"http://localhost:3000\",\n            \"webRoot\": \"${workspaceRoot}\"\n        }\n    ]\n}\n```\n\n## 修改快捷键\n\n| 快捷键         | 描述     |\n| -------------- | -------- |\n| ctrl + alt + s | 触发建议 |\n| alt + ,        | 展开折叠 |\n| alt + .        | 折叠代码 |\n|                |          |\n\n## 窗口布局\n\n| 快捷键                | 描述                 |\n| --------------------- | -------------------- |\n| `ctrl + shift + b` | 活动栏的显隐(自定义) |\n| <code>ctrl + `</code> | 缩略图显隐(自定义) |\n| `ctrl + shift + f` | 全局搜索 |\n| `ctrl + shift + e` | 定位到文件树 |\n| `ctrl + shift + x` | 打开插件(拓展) |\n| `ctrl + \\` | 分屏打开当前文件 |\n\n## 光标\n\n| 快捷键                | 描述                 |\n| --------------------- | -------------------- |\n| `ctrl + 0`            | 将光标移动到文件树   |\n| `alt + [数字]`        | 切换当前窗口对应文件 |\n| `ctrl + [数字(非零)]` | 切换分屏             |\n|`ctrl + shift + >`| 通过大纲进行跳转 |\n| | |\n| | |\n\n## 文件树\n\n> 添加\n\n| 快捷键                | 描述                 |\n| --------------------- | -------------------- |\n| `ctrl + shift + e` | 定位到文件树 |\n| `h | j` | 文件树 |\n| `a` | 新建文件 |\n| `A` | 新建文件夹 |\n| `o` | 打开文件 |\n| `ctrl + 1` | 分屏打开文件 |\n\n## 添加代码块\n\n> 文件/首选项/用户片段\n\n```json\n{\n \"React Component\":{\n    \"prefix\": \"rc\",    \n    \"body\": [\n   \"import React, { Component } from 'react'\",\n   \"\",\n   \"class Index extends Component {\",\n   \"\\trender() {\",\n   \"\\t\\treturn (\",\n   \"\\t\\t\\t<div>\",\n   \"\\t\\t\\t\\tIndex\",\n   \"\\t\\t\\t</div>\",\n   \"\\t\\t)\",\n   \"\\t}\",\n   \"}\",\n   \"\",\n   \"export default Index;\",\n  ],\n  \"description\": \"react component\"   \n  },\n  \"React function\" : {\n   \"prefix\": \"rf\",    \n   \"body\": [\n    \"import React, { Component } from 'react'\",\n    \"\",\n    \"function Index() {\",\n    \"\\treturn (\",\n    \"\\t\\t<div>\",\n    \"\\t\\t\\tIndex\",\n    \"\\t\\t</div>\",\n    \"\\t)\",\n    \"}\",\n    \"\",\n    \"export default Index;\",\n   ],\n   \"description\": \"react component\"   \n   },\n   \"React const \" : {\n    \"prefix\": \"rco\",    \n    \"body\": [\n     \"import React, { Component } from 'react'\",\n     \"\",\n     \"const Index = () => {\",\n     \"\\treturn (\",\n     \"\\t\\t<div>\",\n     \"\\t\\t\\tIndex\",\n     \"\\t\\t</div>\",\n     \"\\t)\",\n     \"}\",\n     \"\",\n     \"export default Index;\",\n    ],\n    \"description\": \"react component\"   \n    }\n\n}\n```\n\n## 快捷键\n\n### 主命令框\n\n| 快捷键                 | 描述                                           |\n| ---------------------- | ---------------------------------------------- |\n| `F1` 或 `ctrl + shift + p` |  `ctrl+J`|  ctrl+ \\` | 打开命令面板                                   |\n| `ctrl + p`             | 下拉菜单<br>再输入`>`进入ctrl + shift + p 模式 |\n|`ctrl + k, ctrl + 0[数字]`|折叠所有代码块|\n|`ctrl + k, ctrl + j`|展示所有代码块|\n|`ctrl + k, ctrl + f`|自动格式代码|\n\n### 边界器与窗口管理\n\n| 快捷键           | 描述                             |\n| ---------------- | -------------------------------- |\n| ctrl  + n        | 新建文件                         |\n| ctrl + tap       | 文件之间切换                     |\n| ctrl + shift + n | 打开一个新的vscode编辑器         |\n| ctrl + w         | 关闭当前窗口                     |\n| ctrl + shift + w | 关闭当前vscode编辑器             |\n| ctrl + \\         | 切出一个新的编辑器窗口(最多三个) |\n| ctrl + 1/2/3     | 切换到3个便捷窗口                |\n\n### 代码编辑\n\n| 快捷键                                           | 描述                 |\n| ------------------------------------------------ | -------------------- |\n| shift + alt + f                                  | 代码格式化           |\n| alt + up 或 alt + down                           | 向上或向下移动一行   |\n| shift + alt + up 或 shift + alt + down           | 向上或向下复制一行   |\n| ctrl + enter                                     | 在下方插入一行       |\n| ctrl + shift + enter                             | 在前一行插入一行     |\n| alt + shift + 鼠标 左键  或  Ctrl+ alt + down/up | 多行编辑             |\n| Shift+Alt+Right 和 Shift+Alt+Left                | 扩展/缩小选取范围：  |\n| ctrl + delete                                    | 删除光标后面内容     |\n| Ctrl + u                                         | 回退上一个光标的操作 |\n| Ctrl + h                                         | 查找替换             |\n\n### 显示相关\n\n| 快捷键            | 描述           |\n| ----------------- | -------------- |\n| ctrl + b          | 侧栏显示或隐藏 |\n| ctrl + shift  + d | 显示 debug     |\n| ctrl + shift + u  | 显示 output    |\n\n## 修改默认配置\n\n### 自动保存\n\n`file -> autoSave`或Ctrl + shift + p ,输入auto\n\n### 修改默认快捷键\n\n打开默认键盘快捷方式设置：**File** -> **Preferences** -> **Keyboard Shortcuts**( 中文界面时：“**文件**”->\"**首选项**\"->\"**键盘快捷方式**\")，或者：Alt+F -> p -> k -> Enter，进入后如下图一所示。\n\n## 修改上下左右快捷键\n\n```js\n// 将键绑定放在此文件中以覆盖默认值\n[\n  // ctrl+shift+/多行注释\n  {\n    \"key\": \"ctrl+shift+/\",\n    \"command\": \"editor.action.blockComment\",\n    \"when\": \"editorTextFocus\"\n  },\n  // 上\n  {\n    \"key\": \"alt+k\",\n    \"command\": \"cursorUp\",\n    \"when\": \"textInputFocus\"\n  },\n  {\n    \"key\": \"up\",\n    \"command\": \"cursorUp\",\n    \"when\": \"textInputFocus\"\n  },\n  // 下\n  {\n    \"key\": \"alt+j\",\n    \"command\": \"cursorDown\",\n    \"when\": \"textInputFocus\"\n  },\n  {\n    \"key\": \"down\",\n    \"command\": \"cursorDown\",\n    \"when\": \"textInputFocus\"\n  },\n\n  // 左\n  {\n    \"key\": \"alt+h\",\n    \"command\": \"cursorLeft\",\n    \"when\": \"textInputFocus\"\n  },\n  {\n    \"key\": \"left\",\n    \"command\": \"cursorLeft\",\n    \"when\": \"textInputFocus\"\n  },\n  // 右\n  {\n    \"key\": \"alt+l\",\n    \"command\": \"cursorRight\",\n    \"when\": \"textInputFocus\"\n  },\n  {\n    \"key\": \"right\",\n    \"command\": \"cursorRight\",\n    \"when\": \"textInputFocus\"\n  },\n\n  {\n    \"key\": \"down\",\n    \"command\": \"list.focusDown\",\n    \"when\": \"listFocus && !inputFocus\"\n  },\n  {\n    \"key\": \"down\",\n    \"command\": \"selectNextSuggestion\",\n    \"when\": \"suggestWidgetMultipleSuggestions && suggestWidgetVisible && textInputFocus\"\n  },\n  {\n    \"key\": \"alt+k\",\n    \"command\": \"selectNextSuggestion\",\n    \"when\": \"suggestWidgetMultipleSuggestions && suggestWidgetVisible && textInputFocus\"\n  },\n  {\n    \"key\": \"up\",\n    \"command\": \"selectPrevSuggestion\",\n    \"when\": \"suggestWidgetMultipleSuggestions && suggestWidgetVisible && textInputFocus\"\n  },\n k {\n    \"key\": \"alt+i\",\n    \"command\": \"selectPrevSuggestion\",\n    \"when\": \"suggestWidgetMultipleSuggestions && suggestWidgetVisible && textInputFocus\"\n  },\n]\n```\n\n## 插件\n\n### React 快速生成模板插件\n\n#### VS Code ES7 React/Redux/React-Native/JS snippets\n\n> `CTRL + ALT + R` : 查看快捷键\n> [*Windows*](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf): `Ctrl+P`  然后输入 `ext install dsznajder.es7-react-js-snippets`\n\n#### React\n\n| jPrefix | Method                                                       |\n| :------ | :----------------------------------------------------------- |\n| `cwm→`  | `componentWillMount = () => { }` DEPRECATED!!!               |\n| `cdm→`  | `componentDidMount = () => { }`                              |\n| `cwr→`  | `componentWillReceiveProps = (nextProps) => { }` DEPRECATED!!! |\n| `scu→`  | `shouldComponentUpdate = (nextProps, nextState) => { }`      |\n| `cwup→` | `componentWillUpdate = (nextProps, nextState) => { }` DEPRECATED!!! |\n| `cdup→` | `componentDidUpdate = (prevProps, prevState) => { }`         |\n| `cwun→` | `componentWillUnmount = () => { }`                           |\n\n#### PropTypes\n\n> 格式要求 :`[A].[B][C]`\n>\n> - `A` : `pt (PropTypes)`\n> - `B` : `a (array)` | `b (bool)` | `f (func)`| `n(number)` | `o(object)` | `s(string)`| `nd(node)` | `el(element)` | `i (instaneof(name))` | `e(oneof([name]))` | `et(oneOfType([name]))` | `ao(arrayOf(name))` | `oo(objectOf(name))` | `sh(shape({}))` | `any(any)`\n> - `C` :`r: isRequired` (非必要)\n>\n> 特例:`ptypes :static propTypes = {}`\n\n| Prefix    | Method                                   |\n| :-------- | :--------------------------------------- |\n| `pta→`    | `PropTypes.array`                        |\n| `ptar→`   | `PropTypes.array.isRequired`             |\n| `ptb→`    | `PropTypes.bool`                         |\n| `ptbr→`   | `PropTypes.bool.isRequired`              |\n| `ptf→`    | `PropTypes.func`                         |\n| `ptfr→`   | `PropTypes.func.isRequired`              |\n| `ptn→`    | `PropTypes.number`                       |\n| `ptnr→`   | `PropTypes.number.isRequired`            |\n| `pto→`    | `PropTypes.object`                       |\n| `ptor→`   | `PropTypes.object.isRequired`            |\n| `pts→`    | `PropTypes.string`                       |\n| `ptsr→`   | `PropTypes.string.isRequired`            |\n| `ptnd→`   | `PropTypes.node`                         |\n| `ptndr→`  | `PropTypes.node.isRequired`              |\n| `ptel→`   | `PropTypes.element`                      |\n| `ptelr→`  | `PropTypes.element.isRequired`           |\n| `pti→`k   | `PropTypes.instanceOf(name)`             |\n| `ptir→`   | `PropTypes.instanceOf(name).isRequired`  |\n| `pte→`    | `PropTypes.oneOf([name])`                |\n| `pter→`   | `PropTypes.oneOf([name]).isRequired`     |\n| `ptet→`   | `PropTypes.oneOfType([name])`            |\n| `ptetr→`  | `PropTypes.oneOfType([name]).isRequired` |\n| `ptao→`   | `PropTypes.arrayOf(name)`                |\n| `ptaor→`  | `PropTypes.arrayOf(name).isRequired`     |\n| `ptoo→`   | `PropTypes.objectOf(name)`               |\n| `ptoor→`  | `PropTypes.objectOf(name).isRequired`    |\n| `ptsh→`   | `PropTypes.shape({ })`                   |\n| `ptshr→`  | `PropTypes.shape({ }).isRequired`        |\n| `ptany→`  | `PropTypes.any`                          |\n| `ptypes→` | `static propTypes = {}`                  |\n\n#### Console\n\n| Prefix | Method                              |\n| :----- | :---------------------------------- |\n| `clg→` | `console.log(object)`               |\n| `clo→` | `console.log(\"object\", object)`     |\n| `ctm→` | `console.time(\"timeId\")`            |\n| `cte→` | `console.timeEnd(\"timeId\")`         |\n| `cer→` | `console.error(object)`             |\n| `cwa→` | `console.warn`                      |\n| `cin→` | `console.info`                      |\n\n#### React Components\n\n> - 第一个字母:\n>\n> - `r` : react 项目\n>\n> - 第二个字母:\n>   - `f` : function组件\n>   - `c`: class组件\n> - `af` : const 定义组件\n>\n> - 第三个字母\n>\n>   - `c` : 定义处导出\n> - `e` : 结尾处导出\n>\n> - 第四个字母:\n>\n>   - `p` : 添加``PropTypes`组件\n>\n>\n\n##### `rcc`\n\n```javascript\nimport React, { Component } from 'react'\n\nexport default class FileName extends Component {\n  render() {\n    return <div>$2</div>\n  }\n}\n```\n\n##### `rce`\n\n```javascript\nimport React, { Component } from 'react'\n\nexport class FileName extends Component {\n  render() {\n    return <div>$2</div>\n  }\n}\n\nexport default $1\n```\n\n##### `rcep`\n\n```javascript\nimport React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nexport class FileName extends Component {\n  static propTypes = {}\n\n  render() {\n    return <div>$2</div>\n  }\n}\n\nexport default $1\n```\n\n##### `rccp`\n\n```javascript\nimport React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nexport default class FileName extends Component {\n  static propTypes = {\n    $2: $3,\n  }\n\n  render() {\n    return <div>$4</div>\n  }\n}\n```\n\n##### `rfcp`\n\n```javascript\nimport React from 'react'\nimport PropTypes from 'prop-types'\n\nfunction $1(props) {\n  return <div>$0</div>\n}\n\n$1.propTypes = {}\n\nexport default $1\n```\n\n##### `rfc`\n\n```javascript\nimport React from 'react'\n\nexport default function $1() {\n  return <div>$0</div>\n}\n```\n\n##### `rfce`\n\n```javascript\nimport React from 'react'\n\nfunction $1() {\n  return <div>$0</div>\n}\n\nexport default $1\n```\n\n##### `rafcp`\n\n```javascript\nimport React from 'react'\nimport PropTypes from 'prop-types'\n\nconst $1 = (props) => {\n  return <div>$0</div>\n}\n\n$1.propTypes = {}\n\nexport default $1\n```\n\n##### `rafc`\n\n```javascript\nimport React from 'react'\n\nexport const $1 = () => {\n  return <div>$0</div>\n}\n```\n\n##### `rafce`\n\n```javascript\nimport React from 'react'\n\nconst $1 = () => {\n  return <div>$0</div>\n}\n\nexport default $1\n```\n\n### vscode&vim\n\n> vim 提供了 3 个基本模式：normal ， insert ,  visual\n\n![](https://upload-images.jianshu.io/upload_images/66696-5bc30a92ae0f73a6.gif?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)\n","children":[]},{"name":"代码片段.md","path":"../guanruihua.github.io/Tool/vscode","data":"# 代码片段\n\n### Variables：变量\n\n> `$name`或`${name:default}`\n\n```txt\nTM_CURRENT_WORD：光标所处单词或空字符串\nTM_SELECTED_TEXT：当前选定的文本或空字符串\nTM_LINE_INDEX：行号（从零开始）\nTM_LINE_NUMBER：行号（从一开始）\nTM_FILENAME：当前文档的文件名\nTM_FILENAME_BASE：当前文档的文件名（不含后缀名）\nTM_DIRECTORY：当前文档所在目录\nTM_FILEPATH：当前文档的完整文件路径\nCLIPBOARD：当前剪贴板中内容\nCURRENT_YEAR: 当前年份\nCURRENT_YEAR_SHORT: 当前年份的后两位\nCURRENT_MONTH: 格式化为两位数字的当前月份，如 02\nCURRENT_MONTH_NAME: 当前月份的全称，如 July\nCURRENT_MONTH_NAME_SHORT: 当前月份的简称，如 Jul\nCURRENT_DATE: 当天月份第几天\nCURRENT_DAY_NAME: 当天周几，如 Monday\nCURRENT_DAY_NAME_SHORT: 当天周几的简称，如 Mon\nCURRENT_HOUR: 当前小时（24 小时制）\nCURRENT_MINUTE: 当前分钟\nCURRENT_SECOND: 当前秒数\n```\n","children":[]},{"name":"插件","path":"../guanruihua.github.io/Tool/vscode","data":"","children":[{"name":"betterComments.md","path":"../guanruihua.github.io/Tool/vscode/插件","data":"# Better Comments\r\n\r\n```shell\r\n// ! 红色的高亮注释\r\n// ? 蓝色的高亮注释\r\n// * 绿色的高亮注释\r\n// todo 橙色的高亮注释\r\n// // 灰色带删除线的注释\r\n// 普通的注释  \r\n\r\n/**  \r\n // ! 红色的高亮注释  \r\n // ? 蓝色的高亮注释  \r\n // * 绿色的高亮注释  \r\n // todo 橙色的高亮注释  \r\n // // 灰色带删除线的注释\r\n */\r\n```\r\n","children":[]},{"name":"制作插件.md","path":"../guanruihua.github.io/Tool/vscode/插件","data":"# vsocde 插件开发\n\n```shell\nnpm install -g yo generator-code\nyo code\n```\n\n![](./__assets__/制作插件-2022-10-21-10-03-23.png)\n\n对应意思:\n\n- 新的插件（Typescript）\n- 新的插件（JavaScript）\n- 新的主题颜色\n- 新的语言支持\n- 新的代码片段\n- 新的键值绑定\n- 新的插件包\n- 新的语言包（本土化）\n\n```json\n{\n  \"name\": \"test-extension\", // 插件的名字\n  \"displayName\": \"test-extension\", // 在插件市场展示的名字\n  \"description\": \"vscode extension sample\", // 插件描述\n  \"version\": \"0.0.1\", // 插件版本\n  \"engines\": { // 最低支持 vscode 的版本\n    \"vscode\": \"^1.52.0\"\n  },\n  \"categories\": [ // 插件的类别，用于在插件市场做区分\n    \"Other\"\n  ],\n  \"activationEvents\": [ // 插件激活的事件列表，可以有多个触发机制，所以是数组形式\n    \"onCommand:test-extension.helloWorld\",\n    // \"*\"  // 插件一开始就激活并注册事件\n  ],\n  \"main\": \"./extension.js\", // 插件主入口\n  \"contributes\": { // 贡献点，用于拓展插件功能的配置项，这里不会细讲，先用 command 举例\n    \"commands\": [\n      {\n        \"command\": \"test-extension.helloWorld\",\n        \"title\": \"Hello World\"\n      }\n    ]\n  },\n  \"scripts\": {\n    \"vscode:prepublish\": \"pnpm run package\",\n    \"compile\": \"webpack\",\n    \"watch\": \"webpack --watch\",\n    \"package\": \"webpack --mode production --devtool hidden-source-map\",\n    \"compile-tests\": \"tsc -p . --outDir out\",\n    \"watch-tests\": \"tsc -p . -w --outDir out\",\n    \"pretest\": \"pnpm run compile-tests && pnpm run compile && pnpm run lint\",\n    \"lint\": \"eslint src --ext ts\",\n    \"test\": \"node ./out/test/runTest.js\"\n  },\n  \"devDependencies\": {\n    \"@types/vscode\": \"^1.72.0\",\n    \"@types/glob\": \"^8.0.0\",\n    \"@types/mocha\": \"^10.0.0\",\n    \"@types/node\": \"16.x\",\n    \"@typescript-eslint/eslint-plugin\": \"^5.38.1\",\n    \"@typescript-eslint/parser\": \"^5.38.1\",\n    \"eslint\": \"^8.24.0\",\n    \"glob\": \"^8.0.3\",\n    \"mocha\": \"^10.0.0\",\n    \"typescript\": \"^4.8.4\",\n    \"ts-loader\": \"^9.4.1\",\n    \"webpack\": \"^5.74.0\",\n    \"webpack-cli\": \"^4.10.0\",\n    \"@vscode/test-electron\": \"^2.1.5\"\n  }\n}\n\n```\n","children":[]}]},{"name":"格式化配置文件.md","path":"../guanruihua.github.io/Tool/vscode","data":"# .prettierrc.json\n\n> 使用Eslint时，vscode格式化后的代码会补全分号及双引号，使得运行时报错。\n> .prettierrc.json文件可以配置格式化选项\n\n```cpp\n{\n    \"semi\": false,    // 使用分号, 默认true\n    \"singleQuote\": true,   // 使用单引号, 默认false(在jsx中配置无效, 默认都是双引号)\n    \"bracketSpacing\": true，   // 对象中的空格 默认true\n    \"tabWidth\": 4，   // tab缩进大小\n}\n\n！使用时删除注释\n```\n","children":[]},{"name":"正则替换.md","path":"../guanruihua.github.io/Tool/vscode","data":"# 正则替换\n\n>**’.’：通配符\n>‘+’: 匹配一个或多个\n>‘?’: 匹配0个或一个\n>‘*’: 匹配0个或多个\n>‘.*’:贪婪匹配（匹配到一个就会回溯）\n>'*?'非贪婪匹配（匹配到不回溯，一直匹配到结尾）\n>\n>捕获组：loadScript\\((.*?),(.*?)\\)\n>替换 ： loadScript($1,id,$2)\n>其中$1代表代表捕获组中第一个括号里匹配到的包裹内容\n>$2代表捕获组中第二个括号里匹配到的包裹内容\n\n## 选择全部空行\n\n> `^\\s*(?=\\r?$)\\n`\n","children":[]},{"name":"配置参数.md","path":"../guanruihua.github.io/Tool/vscode","data":"# 配置参数\r\n\r\n- `${currentFileName}`：带有 ext 的当前文件名\r\n- `${currentFileNameWithoutExt}`：不带 ext 的当前文件名\r\n- `${currentFileDir}`：包含当前编辑文件的目录的路径\r\n- `${projectRoot}`：在 vscode 中打开的项目的路径\r\n","children":[]}]},{"name":"windows_Terminal.md","path":"../guanruihua.github.io/Tool","data":"# Terminal\n\n## 常用指令\n\n| 指令                     | 描述                               |\n| ------------------------ | ---------------------------------- |\n| `ls`                     | 查看当前目录下的文件和文件夹       |\n| `dir`                    | 和`ls`一样                         |\n| `mkdir`                  | 创建文件夹                         |\n| `echo 'hello'>index.txt` | 创建一个文件, 里面 的内容为'hello' |\n| `cls`                    | 清理控制台                         |\n| `ctrl +|-`               | 放大 \\| 缩小字体                   |\n| `ctrl+shift+t`           | 新建tap                            |\n| `ctrl+tap`               | tap页面切换                        |\n| `ctrl+shift+n`           | 新建窗口                           |\n\n## 分屏\n\n> `shift alt +|-`  :  水平 | 垂直 分屏\n>\n> `alt + 方向键`: 光标移动到对应的窗口\n>\n> `alt+shift+[ 方向键 ]` : 改变窗口的大小\n>\n> `alt+shift+d`: 复制打开窗格\n>\n> `ctrl+shift+w`: 关闭当前分屏\n\n## 配置文件\n\n```json\n// This file was initially generated by Windows Terminal 1.4.3243.0\n// It should still be usable in newer versions, but newer versions might have additional\n// settings, help text, or changes that you will not see unless you clear this file\n// and let us generate a new one for you.\n// To view the default settings, hold \"alt\" while clicking on the \"Settings\" button.\n// For documentation on these settings, see: https://aka.ms/terminal-documentation\n{\n  \"$schema\": \"https://aka.ms/terminal-profiles-schema\",\n  \"defaultProfile\": \"{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\",\n  \"colorScheme\": \"COLOR SCHEME NAME\",\n  // You can add more global application settings here.\n  // To learn more about global settings, visit https://aka.ms/terminal-global-settings\n  // If enabled, selections are automatically copied to your clipboard.\n  \"copyOnSelect\": false,\n  // If enabled, formatted data is also copied to your clipboard\n  \"copyFormatting\": false,\n  // A profile specifies a command to execute paired with information about how it should look and feel.\n  // Each one of them will appear in the 'New Tab' dropdown,\n  //   and can be invoked from the commandline with `wt.exe -p xxx`\n  // To learn more about profiles, visit https://aka.ms/terminal-profile-settings\n  \"profiles\": {\n    \"defaults\": {\n      // Put settings here that you want to apply to all profiles.\n    },\n    \"list\": [\n      {\n        // Make changes here to the powershell.exe profile.\n        \"guid\": \"{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\",\n        \"name\": \"Windows PowerShell\",\n        \"commandline\": \"powershell.exe\",\n        \"hidden\": false\n      },\n      {\n        // Make changes here to the cmd.exe profile.\n        \"guid\": \"{0caa0dad-35be-5f56-a8ff-afceeeaa6101}\",\n        \"name\": \"Command Prompt\",\n        \"commandline\": \"cmd.exe\",\n        \"hidden\": false\n      },\n      {\n        \"guid\": \"{b453ae62-4e3d-5e58-b989-0a998ec441b8}\",\n        \"hidden\": false,\n        \"name\": \"Azure Cloud Shell\",\n        \"source\": \"Windows.Terminal.Azure\"\n      }\n    ]\n  },\n  // Add custom color schemes to this array.\n  // To learn more about color schemes, visit https://aka.ms/terminal-color-schemes\n  \"schemes\": [\n    {\n      \"name\": \"Campbell\",\n      \"cursorColor\": \"#FFFFFF\",\n      \"selectionBackground\": \"#FFFFFF\",\n      \"background\": \"#0C0C0C\",\n      \"foreground\": \"#CCCCCC\",\n      \"black\": \"#0C0C0C\",\n      \"blue\": \"#0037DA\",\n      \"cyan\": \"#3A96DD\",\n      \"green\": \"#13A10E\",\n      \"purple\": \"#881798\",\n      \"red\": \"#C50F1F\",\n      \"white\": \"#CCCCCC\",\n      \"yellow\": \"#C19C00\",\n      \"brightBlack\": \"#767676\",\n      \"brightBlue\": \"#3B78FF\",\n      \"brightCyan\": \"#61D6D6\",\n      \"brightGreen\": \"#16C60C\",\n      \"brightPurple\": \"#B4009E\",\n      \"brightRed\": \"#E74856\",\n      \"brightWhite\": \"#F2F2F2\",\n      \"brightYellow\": \"#F9F1A5\"\n    },\n  ],\n  // Add custom actions and keybindings to this array.\n  // To unbind a key combination from your defaults.json, set the command to \"unbound\".\n  // To learn more about actions and keybindings, visit https://aka.ms/terminal-keybindings\n  \"actions\": [\n    // Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json.\n    // These two lines additionally bind them to Ctrl+C and Ctrl+V.\n    // To learn more about selection, visit https://aka.ms/terminal-selection\n    {\n      \"command\": {\n        \"action\": \"copy\",\n        \"singleLine\": false\n      },\n      \"keys\": \"ctrl+c\"\n    },\n    {\n      \"command\": \"paste\",\n      \"keys\": \"ctrl+v\"\n    },\n    // Press Ctrl+Shift+F to open the search box\n    {\n      \"command\": \"find\",\n      \"keys\": \"ctrl+shift+f\"\n    },\n    // Press Alt+Shift+D to open a new pane.\n    // - \"split\": \"auto\" makes this pane open in the direction that provides the most surface area.\n    // - \"splitMode\": \"duplicate\" makes the new pane use the focused pane's profile.\n    // To learn more about panes, visit https://aka.ms/terminal-panes\n    {\n      \"command\": {\n        \"action\": \"splitPane\",\n        \"split\": \"auto\",\n        \"splitMode\": \"duplicate\"\n      },\n      \"keys\": \"alt+shift+d\"\n    },\n    {\n      \"command\": {\n        \"action\": \"splitPane\",\n        \"split\": \"vertical\"\n      },\n      \"keys\": \"alt+shift+plus\"\n    },\n    {\n      \"command\": {\n        \"action\": \"splitPane\",\n        \"split\": \"horizontal\"\n      },\n      \"keys\": \"alt+shift+-\"\n    },\n    {\n      \"command\": {\n        \"action\": \"splitPane\",\n        \"split\": \"auto\"\n      },\n      \"keys\": \"alt+shift+|\"\n    },\n    {\n      \"command\": {\n        \"action\": \"moveFocus\",\n        \"direction\": \"down\"\n      },\n      \"keys\": \"alt+down\"\n    },\n    {\n      \"command\": {\n        \"action\": \"moveFocus\",\n        \"direction\": \"left\"\n      },\n      \"keys\": \"alt+left\"\n    },\n    {\n      \"command\": {\n        \"action\": \"moveFocus\",\n        \"direction\": \"right\"\n      },\n      \"keys\": \"alt+right\"\n    },\n    {\n      \"command\": {\n        \"action\": \"moveFocus\",\n        \"direction\": \"up\"\n      },\n      \"keys\": \"alt+up\"\n    },\n    {\n      \"command\": {\n        \"action\": \"resizePane\",\n        \"direction\": \"down\"\n      },\n      \"keys\": \"alt+shift+down\"\n    },\n    {\n      \"command\": {\n        \"action\": \"resizePane\",\n        \"direction\": \"left\"\n      },\n      \"keys\": \"alt+shift+left\"\n    },\n    {\n      \"command\": {\n        \"action\": \"resizePane\",\n        \"direction\": \"right\"\n      },\n      \"keys\": \"alt+shift+right\"\n    },\n    {\n      \"command\": {\n        \"action\": \"resizePane\",\n        \"direction\": \"up\"\n      },\n      \"keys\": \"alt+shift+up\"\n    },\n    {\n      \"command\": \"closePane\",\n      \"keys\": \"ctrl+shift+w\"\n    }\n  ]\n}\n```\n","children":[]},{"name":"_sidebar.md","path":"../guanruihua.github.io/Tool","data":"* [autohotkey](autohotkey/index.md)\n  * [autohotkey-config](autohotkey/autohotkey-config.md)\n  * [home](autohotkey/index.md)\n* bat\n  * [bat](bat/bat.md)\n  * [bat_script](bat/bat_script.md)\n* [eclipse](eclipse/index.md)\n  * [home](eclipse/index.md)\n* git\n  * [gitee](git/gitee.md)\n  * [github](git/github.md)\n  * [type](git/type.md)\n  * [命令](git/命令/index.md)\n    * [git](git/命令/git.md)\n    * [home](git/命令/index.md)\n    * [分支](git/命令/分支.md)\n    * [切换远程地址](git/命令/切换远程地址.md)\n    * [基于主线分支创建新娘分支](git/命令/基于主线分支创建新娘分支.md)\n    * [指定版本创建分支](git/命令/指定版本创建分支.md)\n    * [推送代码时打tag](git/命令/推送代码时打tag.md)\n    * [撤销commit](git/命令/撤销commit.md)\n  * [拉取某个文件](git/拉取某个文件.md)\n  * [提交pr](git/提交pr.md)\n  * [配置](git/配置/index.md)\n    * [home](git/配置/index.md)\n  * [钩子](git/钩子/index.md)\n    * [home](git/钩子/index.md)\n  * [错误](git/错误/index.md)\n    * [home](git/错误/index.md)\n    * [timeout](git/错误/timeout.md)\n* [idea](idea.md)\n* PC\n  * PC相关技术\n    * [host](PC/PC相关技术/host.md)\n    * [search-tips](PC/PC相关技术/search-tips.md)\n    * [window](PC/PC相关技术/window.md)\n    * [内网穿透](PC/PC相关技术/内网穿透.md)\n    * [端口号占用处理](PC/PC相关技术/端口号占用处理.md)\n  * 脚本\n* [ps](ps.md)\n* svn\n  * [svn](svn/svn.md)\n* vim\n  * [nvim](vim/nvim.md)\n  * [space-vim](vim/space-vim.md)\n  * [vim-plug](vim/vim-plug.md)\n  * [vim](vim/vim.md)\n* [vscode](vscode/index.md)\n  * api\n    * [主题颜色](vscode/api/主题颜色.md)\n  * [emmet](vscode/emmet.md)\n  * [home](vscode/index.md)\n  * [question](vscode/question.md)\n  * [vscode](vscode/vscode.md)\n  * [代码片段](vscode/代码片段.md)\n  * 插件\n    * [betterComments](vscode/插件/betterComments.md)\n    * [制作插件](vscode/插件/制作插件.md)\n  * [格式化配置文件](vscode/格式化配置文件.md)\n  * [正则替换](vscode/正则替换.md)\n  * [配置参数](vscode/配置参数.md)\n* [windows_Terminal](windows_Terminal.md)\n","children":[]}]},{"name":"TypeScript","path":"../guanruihua.github.io","data":"","children":[{"name":"error_code.md","path":"../guanruihua.github.io/TypeScript","data":"# typescript TS 错误码大全\n\n| code  | 类型 | 英文描述  &  中文描述                                                                                                                                                                                                                                                                                                                                            |\n| :---- | :--- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 1002  | 错误 | Unterminated string literal.    未终止的字符串文本。                                                                                                                                                                                                                                                                                                             |\n| 1003  | 错误 | Identifier expected.    应为标识符。                                                                                                                                                                                                                                                                                                                             |\n| 1005  | 错误 | '{0}' expected.    应为“{0}”。                                                                                                                                                                                                                                                                                                                                   |\n| 1006  | 错误 | A file cannot have a reference to itself.    文件不能引用自身。                                                                                                                                                                                                                                                                                                  |\n| 1009  | 错误 | Trailing comma not allowed.    不允许使用尾随逗号。                                                                                                                                                                                                                                                                                                              |\n| 1010  | 错误 | '*/' expected.     应为 \"*/\"。                                                                                                                                                                                                                                                                                                                                   |\n| 1012  | 错误 | Unexpected token.    意外的标记。                                                                                                                                                                                                                                                                                                                                |\n| 1014  | 错误 | A rest parameter must be last in a parameter list.     rest 参数必须是参数列表中的最后一个参数。                                                                                                                                                                                                                                                                 |\n| 1015  | 错误 | Parameter cannot have question mark and initializer.    参数不能包含问号和初始化表达式。                                                                                                                                                                                                                                                                         |\n| 1016  | 错误 | A required parameter cannot follow an optional parameter.    必选参数不能位于可选参数后。                                                                                                                                                                                                                                                                        |\n| 1017  | 错误 | An index signature cannot have a rest parameter.     索引签名不能包含 rest 参数。                                                                                                                                                                                                                                                                                |\n| 1018  | 错误 | An index signature parameter cannot have an accessibility modifier.    索引签名参数不能具有可访问性修饰符。                                                                                                                                                                                                                                                      |\n| 1019  | 错误 | An index signature parameter cannot have a question mark.    索引签名参数不能包含问号。                                                                                                                                                                                                                                                                          |\n| 1020  | 错误 | An index signature parameter cannot have an initializer.    索引签名参数不能具有初始化表达式。                                                                                                                                                                                                                                                                   |\n| 1021  | 错误 | An index signature must have a type annotation.    索引签名必须具有类型批注。                                                                                                                                                                                                                                                                                    |\n| 1022  | 错误 | An index signature parameter must have a type annotation.    索引签名参数必须具有类型批注。                                                                                                                                                                                                                                                                      |\n| 1023  | 错误 | An index signature parameter type must be 'string' or 'number'.    索引签名参数类型必须为 \"string\" 或 \"number\"。                                                                                                                                                                                                                                                 |\n| 1024  | 错误 | 'readonly' modifier can only appear on a property declaration or index signature.                                                                                                                                                                                                                                                                                |\n| 1028  | 错误 | Accessibility modifier already seen.    已看到可访问性修饰符。                                                                                                                                                                                                                                                                                                   |\n| 1029  | 错误 | '{0}' modifier must precede '{1}' modifier.    “{0}”修饰符必须位于“{1}”修饰符之前。                                                                                                                                                                                                                                                                              |\n| 1030  | 错误 | '{0}' modifier already seen.    已看到“{0}”修饰符。                                                                                                                                                                                                                                                                                                              |\n| 1031  | 错误 | '{0}' modifier cannot appear on a class element.     “{0}”修饰符不能出现在类元素上。                                                                                                                                                                                                                                                                             |\n| 1034  | 错误 | 'super' must be followed by an argument list or member access.      \"super\" 后面必须是参数列表或成员访问。                                                                                                                                                                                                                                                       |\n| 1035  | 错误 | Only ambient modules can use quoted names.    仅环境模块可使用带引号的名称。                                                                                                                                                                                                                                                                                     |\n| 1036  | 错误 | Statements are not allowed in ambient contexts.    不允许在环境上下文中使用语句。                                                                                                                                                                                                                                                                                |\n| 1038  | 错误 | A 'declare' modifier cannot be used in an already ambient context.    不能在已有的环境上下文中使用 \"declare\" 修饰符。                                                                                                                                                                                                                                            |\n| 1039  | 错误 | Initializers are not allowed in ambient contexts.    不允许在环境上下文中使用初始化表达式。                                                                                                                                                                                                                                                                      |\n| 1040  | 错误 | '{0}' modifier cannot be used in an ambient context.    “{0}”修饰符不能在环境上下文中使用。                                                                                                                                                                                                                                                                      |\n| 1041  | 错误 | '{0}' modifier cannot be used with a class declaration.    “{0}”修饰符不能与类声明一起使用。                                                                                                                                                                                                                                                                     |\n| 1042  | 错误 | '{0}' modifier cannot be used here.     “{0}”修饰符不能在此处使用。                                                                                                                                                                                                                                                                                              |\n| 1043  | 错误 | '{0}' modifier cannot appear on a data property.    “{0}”修饰符不能出现在数据属性上。                                                                                                                                                                                                                                                                            |\n| 1044  | 错误 | '{0}' modifier cannot appear on a module or namespace element.    “{0}”修饰符不能出现在模块元素上。                                                                                                                                                                                                                                                              |\n| 1045  | 错误 | A '{0}' modifier cannot be used with an interface declaration.    “{0}”修饰符不能与接口声明一起使用。                                                                                                                                                                                                                                                            |\n| 1046  | 错误 | A 'declare' modifier is required for a top level declaration in a .d.ts file.    在 .d.ts 文件中的顶层声明需要 \"declare\" 修饰符。                                                                                                                                                                                                                                |\n| 1047  | 错误 | A rest parameter cannot be optional.    rest 参数不能为可选参数。                                                                                                                                                                                                                                                                                                |\n| 1048  | 错误 | A rest parameter cannot have an initializer.    rest 参数不能具有初始化表达式。                                                                                                                                                                                                                                                                                  |\n| 1049  | 错误 | A 'set' accessor must have exactly one parameter.    \"set\" 访问器必须正好具有一个参数。                                                                                                                                                                                                                                                                          |\n| 1051  | 错误 | A 'set' accessor cannot have an optional parameter.    \"set\" 访问器不能具有可选参数。                                                                                                                                                                                                                                                                            |\n| 1052  | 错误 | A 'set' accessor parameter cannot have an initializer.    \"set\" 访问器参数不能包含初始化表达式。                                                                                                                                                                                                                                                                 |\n| 1053  | 错误 | A 'set' accessor cannot have rest parameter.     \"set\" 访问器不能具有 rest 参数。                                                                                                                                                                                                                                                                                |\n| 1054  | 错误 | A 'get' accessor cannot have parameters.    \"get\" 访问器不能具有参数。                                                                                                                                                                                                                                                                                           |\n| 1055  | 错误 | Type '{0}' is not a valid async function return type in ES5/ES3 because it does not refer to a Promise-compatible constructor value.    类型“{0}”不是有效的异步函数返回类型。                                                                                                                                                                                    |\n| 1056  | 错误 | Accessors are only available when targeting ECMAScript 5 and higher.    访问器仅在面向 ECMAScript 5 和更高版本时可用。                                                                                                                                                                                                                                           |\n| 1057  | 错误 | An async function or method must have a valid awaitable return type.    异步函数或方法必须具有有效的可等待返回类型。                                                                                                                                                                                                                                             |\n| 1058  | 错误 | Operand for 'await' does not have a valid callable 'then' member.    \"await\" 的操作数不具有有效的可调用 \"then\" 成员。                                                                                                                                                                                                                                            |\n| 1059  | 错误 | Return expression in async function does not have a valid callable 'then' member.    异步函数中的返回表达式不具有有效的可调用 \"then\" 成员。                                                                                                                                                                                                                      |\n| 1060  | 错误 | Expression body for async arrow function does not have a valid callable 'then' member.    异步箭头函数的表达式主体不具有有效的可调用 \"then\" 成员。                                                                                                                                                                                                               |\n| 1061  | 错误 | Enum member must have initializer.    枚举成员必须具有初始化表达式。                                                                                                                                                                                                                                                                                             |\n| 1062  | 错误 | {0} is referenced directly or indirectly in the fulfillment callback of its own 'then' method.    {0} 在其自身的 \"then\" 方法的 fulfillment 回调中得到直接或间接引用。                                                                                                                                                                                            |\n| 1063  | 错误 | An export assignment cannot be used in a namespace.    不能在命名空间中使用导出分配。                                                                                                                                                                                                                                                                            |\n| 1064  | 错误 | The return type of an async function or method must be the global Promise type.    The return type of an async function or method must be the global Promise type.                                                                                                                                                                                               |\n| 1066  | 错误 | In ambient enum declarations member initializer must be constant expression.    在环境枚举声明中，成员初始化表达式必须是常数表达式。                                                                                                                                                                                                                             |\n| 1068  | 错误 | Unexpected token. A constructor, method, accessor, or property was expected.    意外的标记。应为构造函数、方法、访问器或属性。                                                                                                                                                                                                                                   |\n| 1070  | 错误 | '{0}' modifier cannot appear on a type member.                                                                                                                                                                                                                                                                                                                   |\n| 1071  | 错误 | '{0}' modifier cannot appear on an index signature.                                                                                                                                                                                                                                                                                                              |\n| 1079  | 错误 | A '{0}' modifier cannot be used with an import declaration.     “{0}”修饰符不能与导入声明一起使用。                                                                                                                                                                                                                                                              |\n| 1084  | 错误 | Invalid 'reference' directive syntax.     \"reference\" 指令语法无效。                                                                                                                                                                                                                                                                                             |\n| 1085  | 错误 | Octal literals are not available when targeting ECMAScript 5 and higher. Use the syntax '{0}'.    面向 ECMAScript 5 和更高版本时，八进制文本不可用。                                                                                                                                                                                                             |\n| 1086  | 错误 | An accessor cannot be declared in an ambient context.    不能在环境上下文中声明访问器。                                                                                                                                                                                                                                                                          |\n| 1089  | 错误 | '{0}' modifier cannot appear on a constructor declaration.    “{0}”修饰符不能出现在构造函数声明中。                                                                                                                                                                                                                                                              |\n| 1090  | 错误 | '{0}' modifier cannot appear on a parameter.     “{0}”修饰符不能出现在参数中。                                                                                                                                                                                                                                                                                   |\n| 1091  | 错误 | Only a single variable declaration is allowed in a 'for...in' statement.    \"for...in\" 语句中只允许单个变量声明。                                                                                                                                                                                                                                                |\n| 1092  | 错误 | Type parameters cannot appear on a constructor declaration.    类型参数不能出现在构造函数声明中。                                                                                                                                                                                                                                                                |\n| 1093  | 错误 | Type annotation cannot appear on a constructor declaration.    类型批注不能出现在构造函数声明中。                                                                                                                                                                                                                                                                |\n| 1094  | 错误 | An accessor cannot have type parameters.    访问器不能具有类型参数。                                                                                                                                                                                                                                                                                             |\n| 1095  | 错误 | A 'set' accessor cannot have a return type annotation.    \"set\" 访问器不能具有返回类型批注。                                                                                                                                                                                                                                                                     |\n| 1096  | 错误 | An index signature must have exactly one parameter.    索引签名必须正好具有一个参数。                                                                                                                                                                                                                                                                            |\n| 1097  | 错误 | '{0}' list cannot be empty.    “{0}”列表不能为空。                                                                                                                                                                                                                                                                                                               |\n| 1098  | 错误 | Type parameter list cannot be empty.    类型参数列表不能为空。                                                                                                                                                                                                                                                                                                   |\n| 1099  | 错误 | Type argument list cannot be empty.    类型参数列表不能为空。                                                                                                                                                                                                                                                                                                    |\n| 1100  | 错误 | Invalid use of '{0}' in strict mode.    严格模式下“{0}”的使用无效。                                                                                                                                                                                                                                                                                              |\n| 1101  | 错误 | 'with' statements are not allowed in strict mode.    严格模式下不允许使用 \"with\" 语句。                                                                                                                                                                                                                                                                          |\n| 1102  | 错误 | 'delete' cannot be called on an identifier in strict mode.    在严格模式下，无法对标识符调用 \"delete\"。                                                                                                                                                                                                                                                          |\n| 1104  | 错误 | A 'continue' statement can only be used within an enclosing iteration statement.    \"continue\" 语句只能在封闭迭代语句内使用。                                                                                                                                                                                                                                    |\n| 1105  | 错误 | A 'break' statement can only be used within an enclosing iteration or switch statement.      \"break\" 语句只能在封闭迭代或 switch 语句内使用。                                                                                                                                                                                                                    |\n| 1107  | 错误 | Jump target cannot cross function boundary.    跳转目标不能跨越函数边界。                                                                                                                                                                                                                                                                                        |\n| 1108  | 错误 | A 'return' statement can only be used within a function body.    \"return\" 语句只能在函数体中使用。                                                                                                                                                                                                                                                               |\n| 1109  | 错误 | Expression expected.    应为表达式。                                                                                                                                                                                                                                                                                                                             |\n| 1110  | 错误 | Type expected.    应为类型。                                                                                                                                                                                                                                                                                                                                     |\n| 1113  | 错误 | A 'default' clause cannot appear more than once in a 'switch' statement.    \"default\" 子句在\"switch\" 语句中只能出现一次。                                                                                                                                                                                                                                        |\n| 1114  | 错误 | Duplicate label '{0}'    标签“{0}”重复                                                                                                                                                                                                                                                                                                                           |\n| 1115  | 错误 | A 'continue' statement can only jump to a label of an enclosing iteration statement.    \"continue\" 语句只能跳转到封闭迭代语句的标签。                                                                                                                                                                                                                            |\n| 1116  | 错误 | A 'break' statement can only jump to a label of an enclosing statement.    \"break\" 语句只能跳转到封闭语句的标签。                                                                                                                                                                                                                                                |\n| 1117  | 错误 | An object literal cannot have multiple properties with the same name in strict mode.    严格模式下，对象文字不能包含多个具有相同名称的属性。                                                                                                                                                                                                                     |\n| 1118  | 错误 | An object literal cannot have multiple get/set accessors with the same name.    对象文字不能具有多个具有相同名称的 get/set 访问器。                                                                                                                                                                                                                              |\n| 1119  | 错误 | An object literal cannot have property and accessor with the same name.    对象文字不能包含具有相同名称的属性和访问器。                                                                                                                                                                                                                                          |\n| 1120  | 错误 | An export assignment cannot have modifiers.    导出分配不能具有修饰符。                                                                                                                                                                                                                                                                                          |\n| 1121  | 错误 | Octal literals are not allowed in strict mode.    严格模式下不允许使用八进制文本。                                                                                                                                                                                                                                                                               |\n| 1122  | 错误 | A tuple type element list cannot be empty.    元组类型元素列表不能为空。                                                                                                                                                                                                                                                                                         |\n| 1123  | 错误 | Variable declaration list cannot be empty.    变量声明列表不能为空。                                                                                                                                                                                                                                                                                             |\n| 1124  | 错误 | Digit expected.    应为数字。                                                                                                                                                                                                                                                                                                                                    |\n| 1125  | 错误 | Hexadecimal digit expected.    应为十六进制数字。                                                                                                                                                                                                                                                                                                                |\n| 1126  | 错误 | Unexpected end of text.    文本意外结束。                                                                                                                                                                                                                                                                                                                        |\n| 1127  | 错误 | Invalid character.    无效的字符。                                                                                                                                                                                                                                                                                                                               |\n| 1128  | 错误 | Declaration or statement expected.    应为声明或语句。                                                                                                                                                                                                                                                                                                           |\n| 1129  | 错误 | Statement expected.    应为语句。                                                                                                                                                                                                                                                                                                                                |\n| 1130  | 错误 | 'case' or 'default' expected.    应为 \"case\" 或 \"default\"。                                                                                                                                                                                                                                                                                                      |\n| 1131  | 错误 | Property or signature expected.    应为属性或签名。                                                                                                                                                                                                                                                                                                              |\n| 1132  | 错误 | Enum member expected.    应为枚举成员。                                                                                                                                                                                                                                                                                                                          |\n| 1134  | 错误 | Variable declaration expected.    应为变量声明。                                                                                                                                                                                                                                                                                                                 |\n| 1135  | 错误 | Argument expression expected.    应为参数表达式。                                                                                                                                                                                                                                                                                                                |\n| 1136  | 错误 | Property assignment expected.    应为属性分配。                                                                                                                                                                                                                                                                                                                  |\n| 1137  | 错误 | Expression or comma expected.    应为表达式或逗号。                                                                                                                                                                                                                                                                                                              |\n| 1138  | 错误 | Parameter declaration expected.    应为参数声明。                                                                                                                                                                                                                                                                                                                |\n| 1139  | 错误 | Type parameter declaration expected.    应为类型参数声明。                                                                                                                                                                                                                                                                                                       |\n| 1140  | 错误 | Type argument expected.    应为类型参数。                                                                                                                                                                                                                                                                                                                        |\n| 1141  | 错误 | String literal expected.    应为字符串文本。                                                                                                                                                                                                                                                                                                                     |\n| 1142  | 错误 | Line break not permitted here.    不允许在此处换行。                                                                                                                                                                                                                                                                                                             |\n| 1144  | 错误 | '{' or ';' expected.    应为 \"{\" 或 \";\"。                                                                                                                                                                                                                                                                                                                        |\n| 1146  | 错误 | Declaration expected.    应为声明。                                                                                                                                                                                                                                                                                                                              |\n| 1147  | 错误 | Import declarations in a namespace cannot reference a module.    命名空间中的导入声明不能引用模块。                                                                                                                                                                                                                                                              |\n| 1148  | 错误 | Cannot use imports, exports, or module augmentations when '--module' is 'none'.    Cannot compile modules unless the '--module' flag is provided with a valid module type. Consider setting the 'module' compiler option in a 'tsconfig.json' file.                                                                                                              |\n| 1149  | 错误 | File name '{0}' differs from already included file name '{1}' only in casing    文件名“{0}”仅在大小写方面与包含的文件名“{1}”不同                                                                                                                                                                                                                                 |\n| 1150  | 错误 | 'new T[]' cannot be used to create an array. Use 'new Array ()' instead.    \"new T[]\" 不能用于创建数组。请改用 \"new Array ()\"。                                                                                                                                                                                                                                  |\n| 1155  | 错误 | 'const' declarations must be initialized    必须初始化 \"const\" 声明                                                                                                                                                                                                                                                                                              |\n| 1156  | 错误 | 'const' declarations can only be declared inside a block.    \"const\" 声明只能在块的内部声明。                                                                                                                                                                                                                                                                    |\n| 1157  | 错误 | 'let' declarations can only be declared inside a block.    \"let\" 声明只能在块的内部声明。                                                                                                                                                                                                                                                                        |\n| 1160  | 错误 | Unterminated template literal.    未终止的模板文本。                                                                                                                                                                                                                                                                                                             |\n| 1161  | 错误 | Unterminated regular expression literal.    未终止的正则表达式文本。                                                                                                                                                                                                                                                                                             |\n| 1162  | 错误 | An object member cannot be declared optional.    对象成员无法声明为可选。                                                                                                                                                                                                                                                                                        |\n| 1163  | 错误 | A 'yield' expression is only allowed in a generator body.    只允许在生成器正文中使用 \"yield\" 表达式。                                                                                                                                                                                                                                                           |\n| 1164  | 错误 | Computed property names are not allowed in enums.    枚举中不允许计算属性名。                                                                                                                                                                                                                                                                                    |\n| 1165  | 错误 | A computed property name in an ambient context must directly refer to a built-in symbol.    环境上下文中的计算属性名必须直接引用内置符号。                                                                                                                                                                                                                       |\n| 1166  | 错误 | A computed property name in a class property declaration must directly refer to a built-in symbol.    类属性声明中的计算属性名必须直接引用内置符号。                                                                                                                                                                                                             |\n| 1168  | 错误 | A computed property name in a method overload must directly refer to a built-in symbol.    方法重载中的计算属性名必须直接引用内置符号。                                                                                                                                                                                                                          |\n| 1169  | 错误 | A computed property name in an interface must directly refer to a built-in symbol.    接口中的计算属性名必须直接引用内置符号。                                                                                                                                                                                                                                   |\n| 1170  | 错误 | A computed property name in a type literal must directly refer to a built-in symbol.    类型文本中的计算属性名必须直接引用内置符号。                                                                                                                                                                                                                             |\n| 1171  | 错误 | A comma expression is not allowed in a computed property name.    计算属性名中不允许逗号表达式。                                                                                                                                                                                                                                                                 |\n| 1172  | 错误 | 'extends' clause already seen.    已看到 \"extends\" 子句。                                                                                                                                                                                                                                                                                                        |\n| 1173  | 错误 | 'extends' clause must precede 'implements' clause.    \"extends\" 子句必须位于 \"implements\" 子句之前。                                                                                                                                                                                                                                                             |\n| 1174  | 错误 | Classes can only extend a single class.    类只能扩展一个类。                                                                                                                                                                                                                                                                                                    |\n| 1175  | 错误 | 'implements' clause already seen.    已看到 \"implements\" 子句。                                                                                                                                                                                                                                                                                                  |\n| 1176  | 错误 | Interface declaration cannot have 'implements' clause.    接口声明不能有 \"implements\" 子句。                                                                                                                                                                                                                                                                     |\n| 1177  | 错误 | Binary digit expected.    需要二进制数字。                                                                                                                                                                                                                                                                                                                       |\n| 1178  | 错误 | Octal digit expected.    需要八进制数字。                                                                                                                                                                                                                                                                                                                        |\n| 1179  | 错误 | Unexpected token. '{' expected.    意外标记。应为 \"{\"。                                                                                                                                                                                                                                                                                                          |\n| 1180  | 错误 | Property destructuring pattern expected.    应为属性析构模式。                                                                                                                                                                                                                                                                                                   |\n| 1181  | 错误 | Array element destructuring pattern expected.    应为数组元素析构模式。                                                                                                                                                                                                                                                                                          |\n| 1182  | 错误 | A destructuring declaration must have an initializer.    析构声明必须具有初始化表达式。                                                                                                                                                                                                                                                                          |\n| 1183  | 错误 | An implementation cannot be declared in ambient contexts.    不能在环境上下文中声明实现。                                                                                                                                                                                                                                                                        |\n| 1184  | 错误 | Modifiers cannot appear here.    修饰符不能出现在此处。                                                                                                                                                                                                                                                                                                          |\n| 1185  | 错误 | Merge conflict marker encountered.    遇到合并冲突标记。                                                                                                                                                                                                                                                                                                         |\n| 1186  | 错误 | A rest element cannot have an initializer.    rest 元素不能具有初始化表达式。                                                                                                                                                                                                                                                                                    |\n| 1187  | 错误 | A parameter property may not be declared using a binding pattern.    参数属性不能为绑定模式。                                                                                                                                                                                                                                                                    |\n| 1188  | 错误 | Only a single variable declaration is allowed in a 'for...of' statement.     \"for...of\" 语句中只允许单个变量声明。                                                                                                                                                                                                                                               |\n| 1189  | 错误 | The variable declaration of a 'for...in' statement cannot have an initializer.    \"for...in\" 语句的变量声明不能有初始化表达式。                                                                                                                                                                                                                                  |\n| 1190  | 错误 | The variable declaration of a 'for...of' statement cannot have an initializer.    \"for...of\" 语句的变量声明不能有初始化表达式。                                                                                                                                                                                                                                  |\n| 1191  | 错误 | An import declaration cannot have modifiers.    导入声明不能有修饰符。                                                                                                                                                                                                                                                                                           |\n| 1192  | 错误 | Module '{0}' has no default export.    模块“{0}”没有默认导出。                                                                                                                                                                                                                                                                                                   |\n| 1193  | 错误 | An export declaration cannot have modifiers.    导出声明不能有修饰符。                                                                                                                                                                                                                                                                                           |\n| 1194  | 错误 | Export declarations are not permitted in a namespace.    命名空间中不允许有导出声明。                                                                                                                                                                                                                                                                            |\n| 1196  | 错误 | Catch clause variable cannot have a type annotation.    Catch 子句变量不能有类型批注。                                                                                                                                                                                                                                                                           |\n| 1197  | 错误 | Catch clause variable cannot have an initializer.    Catch 子句变量不能有初始化表达式。                                                                                                                                                                                                                                                                          |\n| 1198  | 错误 | An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.    扩展的 Unicode 转义值必须介于(含) 0x0 和 0x10FFFF 之间。                                                                                                                                                                                                                         |\n| 1199  | 错误 | Unterminated Unicode escape sequence.    未终止的 Unicode 转义序列。                                                                                                                                                                                                                                                                                             |\n| 1200  | 错误 | Line terminator not permitted before arrow.    箭头前不允许有行终止符。                                                                                                                                                                                                                                                                                          |\n| 1202  | 错误 | Import assignment cannot be used when targeting ECMAScript 2015 modules. Consider using 'import *as ns from \"mod\"', 'import {a} from \"mod\"', 'import d from \"mod\"', or another module format instead.    当面向 ECMAScript 6 模块时，不能使用导入分配。请考虑改用 \"import* as ns from \"mod\"\" 、\"import {a} from \"mod\"\" 或 \"import d from \"mod\"\" 或其他模块格式。 |\n| 1203  | 错误 | Export assignment cannot be used when targeting ECMAScript 2015 modules. Consider using 'export default' or another module format instead.    当面向 ECMAScript 6 模块时，不能使用导出分配。请考虑改用“导出默认”或其他模块格式。                                                                                                                                 |\n| 1206  | 错误 | Decorators are not valid here.    修饰器在此处无效。                                                                                                                                                                                                                                                                                                             |\n| 1207  | 错误 | Decorators cannot be applied to multiple get/set accessors of the same name.    不能向多个同名的 get/set 访问器应用修饰器。                                                                                                                                                                                                                                      |\n| 1208  | 错误 | Cannot compile namespaces when the '--isolatedModules' flag is provided.    提供 \"--isolatedModules\" 标志时无法编译命名空间。                                                                                                                                                                                                                                    |\n| 1209  | 错误 | Ambient const enums are not allowed when the '--isolatedModules' flag is provided.    提供 \"--isolatedModules\" 标志的情况下不允许使用环境常数枚举。                                                                                                                                                                                                              |\n| 1210  | 错误 | Invalid use of '{0}'. Class definitions are automatically in strict mode.    “{0}”的使用无效。类定义自动处于严格模式。                                                                                                                                                                                                                                           |\n| 1211  | 错误 | A class declaration without the 'default' modifier must have a name    不带 \"default\" 修饰符的类声明必须具有名称                                                                                                                                                                                                                                                 |\n| 1212  | 错误 | Identifier expected. '{0}' is a reserved word in strict mode     应为标识符。“{0}”在严格模式下是保留字                                                                                                                                                                                                                                                           |\n| 1213  | 错误 | Identifier expected. '{0}' is a reserved word in strict mode. Class definitions are automatically in strict mode.    应为标识符。“{0}”在严格模式下是保留字。类定义自动处于严格模式。                                                                                                                                                                             |\n| 1214  | 错误 | Identifier expected. '{0}' is a reserved word in strict mode. Modules are automatically in strict mode.    应为标识符。“{0}”是严格模式下的保留字。模块自动处于严格模式。                                                                                                                                                                                         |\n| 1215  | 错误 | Invalid use of '{0}'. Modules are automatically in strict mode.    “{0}”的使用无效。模块自动处于严格模式。                                                                                                                                                                                                                                                       |\n| 1218  | 错误 | Export assignment is not supported when '--module' flag is 'system'.    当 \"--module\" 标志是 \"system\" 时不支持导出分配。                                                                                                                                                                                                                                         |\n| 1219  | 错误 | Experimental support for decorators is a feature that is subject to change in a future release. Set the 'experimentalDecorators' option to remove this warning.    Experimental support for decorators is a feature that is subject to change in a future release. Set the 'experimentalDecorators' option to remove this warning.                               |\n| 1220  | 错误 | Generators are only available when targeting ECMAScript 2015 or higher.    仅当面向 ECMAScript 6 或更高版本时，生成器才可用。                                                                                                                                                                                                                                    |\n| 1221  | 错误 | Generators are not allowed in an ambient context.    不允许在环境上下文中使用生成器。                                                                                                                                                                                                                                                                            |\n| 1222  | 错误 | An overload signature cannot be declared as a generator.    重载签名无法声明为生成器。                                                                                                                                                                                                                                                                           |\n| 1223  | 错误 | '{0}' tag already specified.    已指定“{0}”标记。                                                                                                                                                                                                                                                                                                                |\n| 1224  | 错误 | Signature '{0}' must have a type predicate.    签名“{0}”必须具有类型谓词。                                                                                                                                                                                                                                                                                       |\n| 1225  | 错误 | Cannot find parameter '{0}'.    找不到参数“{0}”。                                                                                                                                                                                                                                                                                                                |\n| 1226  | 错误 | Type predicate '{0}' is not assignable to '{1}'.    类型谓词“{0}”不可分配给“{1}”。                                                                                                                                                                                                                                                                               |\n| 1227  | 错误 | Parameter '{0}' is not in the same position as parameter '{1}'.    参数“{0}”和参数“{1}”的位置不一样。                                                                                                                                                                                                                                                            |\n| 1228  | 错误 | A type predicate is only allowed in return type position for functions and methods.    只允许在函数和方法的返回类型位置使用类型谓词。                                                                                                                                                                                                                            |\n| 1229  | 错误 | A type predicate cannot reference a rest parameter.    类型谓词无法引用 rest 参数                                                                                                                                                                                                                                                                                |\n| 1230  | 错误 | A type predicate cannot reference element '{0}' in a binding pattern.    类型谓词无法在绑定模式中引用元素“{0}”。                                                                                                                                                                                                                                                 |\n| 1231  | 错误 | An export assignment can only be used in a module.    导出分配只能在模块中使用。                                                                                                                                                                                                                                                                                 |\n| 1232  | 错误 | An import declaration can only be used in a namespace or module.    导入声明只能在命名空间或模块中使用。                                                                                                                                                                                                                                                         |\n| 1233  | 错误 | An export declaration can only be used in a module.    导出声明只能在模块中使用。                                                                                                                                                                                                                                                                                |\n| 1234  | 错误 | An ambient module declaration is only allowed at the top level in a file.    只允许在文件的顶层中使用环境模块声明。                                                                                                                                                                                                                                              |\n| 1235  | 错误 | A namespace declaration is only allowed in a namespace or module.    只允许在命名空间或模块中使用命名空间声明。                                                                                                                                                                                                                                                  |\n| 1236  | 错误 | The return type of a property decorator function must be either 'void' or 'any'.    属性修饰器函数的返回类型必须为 \"void\" 或 \"any\"。                                                                                                                                                                                                                             |\n| 1237  | 错误 | The return type of a parameter decorator function must be either 'void' or 'any'.    参数修饰器函数的返回类型必须为 \"void\" 或 \"any\"。                                                                                                                                                                                                                            |\n| 1238  | 错误 | Unable to resolve signature of class decorator when called as an expression.    作为表达式调用时，无法解析类修饰器的签名。                                                                                                                                                                                                                                       |\n| 1239  | 错误 | Unable to resolve signature of parameter decorator when called as an expression.    作为表达式调用时，无法解析参数修饰器的签名。                                                                                                                                                                                                                                 |\n| 1240  | 错误 | Unable to resolve signature of property decorator when called as an expression.    作为表达式调用时，无法解析属性修饰器的签名。                                                                                                                                                                                                                                  |\n| 1241  | 错误 | Unable to resolve signature of method decorator when called as an expression.    作为表达式调用时，无法解析方法修饰器的签名。                                                                                                                                                                                                                                    |\n| 1242  | 错误 | 'abstract' modifier can only appear on a class, method, or property declaration.    \"abstract\" 修饰符只能出现在类声明或方法声明中。                                                                                                                                                                                                                              |\n| 1243  | 错误 | '{0}' modifier cannot be used with '{1}' modifier.    “{0}”修饰符不能与“{1}”修饰符一起使用。                                                                                                                                                                                                                                                                     |\n| 1244  | 错误 | Abstract methods can only appear within an abstract class.    抽象方法只能出现在抽象类中。                                                                                                                                                                                                                                                                       |\n| 1245  | 错误 | Method '{0}' cannot have an implementation because it is marked abstract.    方法“{0}”不能具有实现，因为它标记为抽象。                                                                                                                                                                                                                                           |\n| 1246  | 错误 | An interface property cannot have an initializer.    接口函数不能具有初始化表达式。                                                                                                                                                                                                                                                                              |\n| 1247  | 错误 | A type literal property cannot have an initializer.    类型文字数据不可具有初始化表达式。                                                                                                                                                                                                                                                                        |\n| 1248  | 错误 | A class member cannot have the '{0}' keyword.    A class member cannot have the '{0}' keyword.                                                                                                                                                                                                                                                                   |\n| 1249  | 错误 | A decorator can only decorate a method implementation, not an overload.    A decorator can only decorate a method implementation, not an overload.                                                                                                                                                                                                               |\n| 1250  | 错误 | Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'.                                                                                                                                                                                                                                                                |\n| 1251  | 错误 | Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'. Class definitions are automatically in strict mode.                                                                                                                                                                                                            |\n| 1252  | 错误 | Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'. Modules are automatically in strict mode.                                                                                                                                                                                                                      |\n| 1253  | 错误 | '{0}' tag cannot be used independently as a top level JSDoc tag.                                                                                                                                                                                                                                                                                                 |\n| 1254  | 错误 | A 'const' initializer in an ambient context must be a string or numeric literal.                                                                                                                                                                                                                                                                                 |\n| 1300  | 错误 | 'with' statements are not allowed in an async function block.     不允许在异步函数块中使用 \"with\" 语句。                                                                                                                                                                                                                                                         |\n| 1308  | 错误 | 'await' expression is only allowed within an async function.    只允许在异步函数中使用 \"await\" 表达式。                                                                                                                                                                                                                                                          |\n| 1312  | 错误 | '=' can only be used in an object literal property inside a destructuring assignment.    \"=\" 只可在重构赋值内部的对象文字属性中使用。                                                                                                                                                                                                                            |\n| 1313  | 错误 | The body of an 'if' statement cannot be the empty statement.    \"if\" 语句的正文不能为空语句。                                                                                                                                                                                                                                                                    |\n| 1314  | 错误 | Global module exports may only appear in module files.                                                                                                                                                                                                                                                                                                           |\n| 1315  | 错误 | Global module exports may only appear in declaration files.                                                                                                                                                                                                                                                                                                      |\n| 1316  | 错误 | Global module exports may only appear at top level.                                                                                                                                                                                                                                                                                                              |\n| 1317  | 错误 | A parameter property cannot be declared using a rest parameter.                                                                                                                                                                                                                                                                                                  |\n| 1318  | 错误 | An abstract accessor cannot have an implementation.                                                                                                                                                                                                                                                                                                              |\n| 1319  | 错误 | A default export can only be used in an ECMAScript-style module.                                                                                                                                                                                                                                                                                                 |\n| 2300  | 错误 | Duplicate identifier '{0}'.    标识符“{0}”重复。                                                                                                                                                                                                                                                                                                                 |\n| 2301  | 错误 | Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.    实例成员变量“{0}”的初始化表达式不能引用构造函数中声明的标识符“{1}”。                                                                                                                                                                             |\n| 2302  | 错误 | Static members cannot reference class type parameters.    静态成员不能引用类类型参数。                                                                                                                                                                                                                                                                           |\n| 2303  | 错误 | Circular definition of import alias '{0}'.    导入别名“{0}”的循环定义。                                                                                                                                                                                                                                                                                          |\n| 2304  | 错误 | Cannot find name '{0}'.    找不到名称“{0}”。                                                                                                                                                                                                                                                                                                                     |\n| 2305  | 错误 | Module '{0}' has no exported member '{1}'.    模块“{0}”没有导出的成员“{1}”。                                                                                                                                                                                                                                                                                     |\n| 2306  | 错误 | File '{0}' is not a module.    文件“{0}”不是模块。                                                                                                                                                                                                                                                                                                               |\n| 2307  | 错误 | Cannot find module '{0}'.    找不到模块“{0}”。                                                                                                                                                                                                                                                                                                                   |\n| 2308  | 错误 | Module {0} has already exported a member named '{1}'. Consider explicitly re-exporting to resolve the ambiguity.    模块 {0} 已导出一个名为“{1}”的成员。请考虑重新显式导出以解决歧义。                                                                                                                                                                           |\n| 2309  | 错误 | An export assignment cannot be used in a module with other exported elements.    不能在具有其他导出元素的模块中使用导出分配。                                                                                                                                                                                                                                    |\n| 2310  | 错误 | Type '{0}' recursively references itself as a base type.    类型“{0}”以递归方式将自身引用为基类。                                                                                                                                                                                                                                                                |\n| 2311  | 错误 | A class may only extend another class.    类只能扩展其他类。                                                                                                                                                                                                                                                                                                     |\n| 2312  | 错误 | An interface may only extend a class or another interface.    接口只能扩展类或其他接口。                                                                                                                                                                                                                                                                         |\n| 2313  | 错误 | Type parameter '{0}' has a circular constraint.    Type parameter '{0}' has a circular constraint.                                                                                                                                                                                                                                                               |\n| 2314  | 错误 | Generic type '{0}' requires {1} type argument(s).    泛型类型“{0}”需要 {1} 个类型参数。                                                                                                                                                                                                                                                                          |\n| 2315  | 错误 | Type '{0}' is not generic.    类型“{0}”不是泛型类型。                                                                                                                                                                                                                                                                                                            |\n| 2316  | 错误 | Global type '{0}' must be a class or interface type.    全局类型“{0}”必须为类或接口类型。                                                                                                                                                                                                                                                                        |\n| 2317  | 错误 | Global type '{0}' must have {1} type parameter(s).    全局类型“{0}”必须具有 {1} 个类型参数。                                                                                                                                                                                                                                                                     |\n| 2318  | 错误 | Cannot find global type '{0}'.    找不到全局类型“{0}”。                                                                                                                                                                                                                                                                                                          |\n| 2319  | 错误 | Named property '{0}' of types '{1}' and '{2}' are not identical.    “{1}”和“{2}”类型的命名属性“{0}”不完全相同。                                                                                                                                                                                                                                                  |\n| 2320  | 错误 | Interface '{0}' cannot simultaneously extend types '{1}' and '{2}'.    接口“{0}”不能同时扩展类型“{1}”和“{2}”。                                                                                                                                                                                                                                                   |\n| 2321  | 错误 | Excessive stack depth comparing types '{0}' and '{1}'.    与类型“{0}”和“{1}”相比，堆栈深度过高。                                                                                                                                                                                                                                                                 |\n| 2322  | 错误 | Type '{0}' is not assignable to type '{1}'.    不能将类型“{0}”分配给类型“{1}”。                                                                                                                                                                                                                                                                                  |\n| 2323  | 错误 | Cannot redeclare exported variable '{0}'.    无法重新声明导出的变量“{0}”。                                                                                                                                                                                                                                                                                       |\n| 2324  | 错误 | Property '{0}' is missing in type '{1}'.    类型“{1}”中缺少属性“{0}”。                                                                                                                                                                                                                                                                                           |\n| 2325  | 错误 | Property '{0}' is private in type '{1}' but not in type '{2}'.    属性“{0}”在类型“{1}”中是私有属性，但在类型“{2}”中不是。                                                                                                                                                                                                                                        |\n| 2326  | 错误 | Types of property '{0}' are incompatible.    属性“{0}”的类型不兼容。                                                                                                                                                                                                                                                                                             |\n| 2327  | 错误 | Property '{0}' is optional in type '{1}' but required in type '{2}'.    属性“{0}”在类型“{1}”中为可选，但在类型“{2}”中为必选。                                                                                                                                                                                                                                    |\n| 2328  | 错误 | Types of parameters '{0}' and '{1}' are incompatible.    参数“{0}”和“{1}” 的类型不兼容。                                                                                                                                                                                                                                                                         |\n| 2329  | 错误 | Index signature is missing in type '{0}'.    类型“{0}”中缺少索引签名。                                                                                                                                                                                                                                                                                           |\n| 2330  | 错误 | Index signatures are incompatible.    索引签名不兼容。                                                                                                                                                                                                                                                                                                           |\n| 2331  | 错误 | 'this' cannot be referenced in a module or namespace body.    不能在模块或命名空间体中引用 \"this\"。                                                                                                                                                                                                                                                              |\n| 2332  | 错误 | 'this' cannot be referenced in current location.    不能在当前位置引用 \"this\"。                                                                                                                                                                                                                                                                                  |\n| 2333  | 错误 | 'this' cannot be referenced in constructor arguments.    不能在构造函数参数中引用 \"this\"。                                                                                                                                                                                                                                                                       |\n| 2334  | 错误 | 'this' cannot be referenced in a static property initializer.    不能在静态属性初始化表达式中引用 \"this\"。                                                                                                                                                                                                                                                       |\n| 2335  | 错误 | 'super' can only be referenced in a derived class.    只能在派生类中引用 \"super\"。                                                                                                                                                                                                                                                                               |\n| 2336  | 错误 | 'super' cannot be referenced in constructor arguments.    不能在构造函数参数中引用 \"super\"。                                                                                                                                                                                                                                                                     |\n| 2337  | 错误 | Super calls are not permitted outside constructors or in nested functions inside constructors.    不允许在构造函数外部或在构造函数内的嵌套函数中进行 Super 调用。                                                                                                                                                                                                |\n| 2338  | 错误 | 'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.    只有构造函数、成员函数或派生类的成员访问器中才允许 \"super\" 属性访问。                                                                                                                                                                     |\n| 2339  | 错误 | Property '{0}' does not exist on type '{1}'.    类型“{1}”上不存在属性“{0}”。                                                                                                                                                                                                                                                                                     |\n| 2340  | 错误 | Only public and protected methods of the base class are accessible via the 'super' keyword.    通过 \"super\" 关键字只能访问基类的公共方法和受保护方法。                                                                                                                                                                                                           |\n| 2341  | 错误 | Property '{0}' is private and only accessible within class '{1}'.    属性“{0}”为私有属性，只能在类“{1}”中访问。                                                                                                                                                                                                                                                  |\n| 2342  | 错误 | An index expression argument must be of type 'string', 'number', 'symbol', or 'any'.    索引表达式参数必须为 \"string\"、\"number\"、\"symbol\" 或 \"any\" 类型。                                                                                                                                                                                                        |\n| 2343  | 错误 | This syntax requires an imported helper named '{1}', but module '{0}' has no exported member '{1}'.                                                                                                                                                                                                                                                              |\n| 2344  | 错误 | Type '{0}' does not satisfy the constraint '{1}'.    类型“{0}”不满足约束“{1}”。                                                                                                                                                                                                                                                                                  |\n| 2345  | 错误 | Argument of type '{0}' is not assignable to parameter of type '{1}'.    类型“{0}”的参数不能赋给类型“{1}”的参数。                                                                                                                                                                                                                                                 |\n| 2346  | 错误 | Supplied parameters do not match any signature of call target.    提供的参数与调用目标的任何签名都不匹配。                                                                                                                                                                                                                                                       |\n| 2347  | 错误 | Untyped function calls may not accept type arguments.    非类型化函数调用不能接受类型参数。                                                                                                                                                                                                                                                                      |\n| 2348  | 错误 | Value of type '{0}' is not callable. Did you mean to include 'new'?    类型“{0}”的值不可调用。是否希望包括 \"new\"?                                                                                                                                                                                                                                                |\n| 2349  | 错误 | Cannot invoke an expression whose type lacks a call signature. Type '{0}' has no compatible call signatures.    无法调用其类型缺少调用签名的表达式。                                                                                                                                                                                                             |\n| 2350  | 错误 | Only a void function can be called with the 'new' keyword.    使用 \"new\" 关键字只能调用 void 函数。                                                                                                                                                                                                                                                              |\n| 2351  | 错误 | Cannot use 'new' with an expression whose type lacks a call or construct signature.    其类型缺少调用或构造签名的表达式无法使用 \"new\"。                                                                                                                                                                                                                          |\n| 2352  | 错误 | Type '{0}' cannot be converted to type '{1}'.    类型“{0}”和类型“{1}”均不能赋给对方。                                                                                                                                                                                                                                                                            |\n| 2353  | 错误 | Object literal may only specify known properties, and '{0}' does not exist in type '{1}'.    对象文字可以只指定已知属性，并且“{0}”不在类型“{1}”中。                                                                                                                                                                                                              |\n| 2354  | 错误 | This syntax requires an imported helper but module '{0}' cannot be found.    返回表达式中不存在最佳通用类型。                                                                                                                                                                                                                                                    |\n| 2355  | 错误 | A function whose declared type is neither 'void' nor 'any' must return a value.    其声明类型不为 \"void\" 或 \"any\" 的函数必须返回值。                                                                                                                                                                                                                             |\n| 2356  | 错误 | An arithmetic operand must be of type 'any', 'number' or an enum type.    算术操作数必须为类型 \"any\"、\"number\" 或枚举类型。                                                                                                                                                                                                                                      |\n| 2357  | 错误 | The operand of an increment or decrement operator must be a variable or a property access.    增量或减量运算符的操作数必须为变量、属性或索引器。                                                                                                                                                                                                                 |\n| 2358  | 错误 | The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.    \"instanceof\" 表达式左侧必须是 \"any\" 类型、对象类型或类型参数。                                                                                                                                                                                    |\n| 2359  | 错误 | The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.    \"instanceof\" 表达式的右侧必须属于类型 \"any\"，或属于可分配给 \"Function\" 接口类型的类型。                                                                                                                                     |\n| 2360  | 错误 | The left-hand side of an 'in' expression must be of type 'any', 'string', 'number', or 'symbol'.    \"in\" 表达式左侧的类型必须为 \"any\"、\"string\"、\"number\" 或 \"symbol\"。                                                                                                                                                                                          |\n| 2361  | 错误 | The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter    \"in\" 表达式的右侧必须是 \"any\" 类型、对象类型或类型参数                                                                                                                                                                                                    |\n| 2362  | 错误 | The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.    算术运算左侧必须是 \"any\"、\"number\" 或枚举类型。                                                                                                                                                                                                                |\n| 2363  | 错误 | The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.    算术运算右侧必须是 \"any\"、\"number\" 或枚举类型。                                                                                                                                                                                                               |\n| 2364  | 错误 | The left-hand side of an assignment expression must be a variable or a property access.    赋值表达式左侧无效。                                                                                                                                                                                                                                                  |\n| 2365  | 错误 | Operator '{0}' cannot be applied to types '{1}' and '{2}'.    运算符“{0}”不能应用于类型“{1}”和“{2}”。                                                                                                                                                                                                                                                            |\n| 2366  | 错误 | Function lacks ending return statement and return type does not include 'undefined'.                                                                                                                                                                                                                                                                             |\n| 2368  | 错误 | Type parameter name cannot be '{0}'    类型参数名称不能为“{0}”                                                                                                                                                                                                                                                                                                   |\n| 2369  | 错误 | A parameter property is only allowed in a constructor implementation.    只允许在构造函数实现中使用参数属性。                                                                                                                                                                                                                                                    |\n| 2370  | 错误 | A rest parameter must be of an array type.    rest 参数必须是数组类型。                                                                                                                                                                                                                                                                                          |\n| 2371  | 错误 | A parameter initializer is only allowed in a function or constructor implementation.    只允许在函数或构造函数实现中使用参数初始化表达式。                                                                                                                                                                                                                       |\n| 2372  | 错误 | Parameter '{0}' cannot be referenced in its initializer.    参数“{0}”的初始化表达式中不能引用该参数自身。                                                                                                                                                                                                                                                        |\n| 2373  | 错误 | Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.    参数“{0}”的初始化表达式不能引用在它之后声明的标识符“{1}”。                                                                                                                                                                                                                |\n| 2374  | 错误 | Duplicate string index signature.    字符串索引签名重复。                                                                                                                                                                                                                                                                                                        |\n| 2375  | 错误 | Duplicate number index signature.    数字索引签名重复。                                                                                                                                                                                                                                                                                                          |\n| 2376  | 错误 | A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.    当类包含初始化的属性或参数属性时，\"super\" 调用必须是构造函数中的第一个语句。                                                                                                                                          |\n| 2377  | 错误 | Constructors for derived classes must contain a 'super' call.    派生类的构造函数必须包含 \"super\" 调用。                                                                                                                                                                                                                                                         |\n| 2378  | 错误 | A 'get' accessor must return a value.    \"get\" 访问器必须返回值。                                                                                                                                                                                                                                                                                                |\n| 2379  | 错误 | Getter and setter accessors do not agree in visibility.    Getter 和 setter 访问器在可见性上不一致。                                                                                                                                                                                                                                                             |\n| 2380  | 错误 | 'get' and 'set' accessor must have the same type.    \"get\" 和 \"set\" 访问器必须属于同一类型。                                                                                                                                                                                                                                                                     |\n| 2381  | 错误 | A signature with an implementation cannot use a string literal type.    具有实现的签名不能使用字符串文本类型。                                                                                                                                                                                                                                                   |\n| 2382  | 错误 | Specialized overload signature is not assignable to any non-specialized signature.    指定的重载签名不可分配给任何非专用化签名。                                                                                                                                                                                                                                 |\n| 2383  | 错误 | Overload signatures must all be exported or non-exported.    重载签名必须全部导出或全部不导出。                                                                                                                                                                                                                                                                  |\n| 2384  | 错误 | Overload signatures must all be ambient or non-ambient.    重载签名必须全部为环境签名或非环境签名。                                                                                                                                                                                                                                                              |\n| 2385  | 错误 | Overload signatures must all be public, private or protected.    重载签名必须全部是公共签名、私有签名或受保护签名。                                                                                                                                                                                                                                              |\n| 2386  | 错误 | Overload signatures must all be optional or required.    重载签名必须全部为可选签名或必需签名。                                                                                                                                                                                                                                                                  |\n| 2387  | 错误 | Function overload must be static.    函数重载必须为静态。                                                                                                                                                                                                                                                                                                        |\n| 2388  | 错误 | Function overload must not be static.    函数重载不能为静态。                                                                                                                                                                                                                                                                                                    |\n| 2389  | 错误 | Function implementation name must be '{0}'.    函数实现名称必须为“{0}”。                                                                                                                                                                                                                                                                                         |\n| 2390  | 错误 | Constructor implementation is missing.    缺少构造函数实现。                                                                                                                                                                                                                                                                                                     |\n| 2391  | 错误 | Function implementation is missing or not immediately following the declaration.    函数实现缺失或未立即出现在声明之后。                                                                                                                                                                                                                                         |\n| 2392  | 错误 | Multiple constructor implementations are not allowed.    不允许存在多个构造函数实现。                                                                                                                                                                                                                                                                            |\n| 2393  | 错误 | Duplicate function implementation.    函数实现重复。                                                                                                                                                                                                                                                                                                             |\n| 2394  | 错误 | Overload signature is not compatible with function implementation.    重载签名与函数实现不兼容。                                                                                                                                                                                                                                                                 |\n| 2395  | 错误 | Individual declarations in merged declaration '{0}' must be all exported or all local.    合并声明“{0}”中的单独声明必须全为导出或全为局部声明。                                                                                                                                                                                                                  |\n| 2396  | 错误 | Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.    标识符 \"arguments\" 重复。编译器使用 \"arguments\" 初始化 rest 参数。                                                                                                                                                                                                 |\n| 2397  | 错误 | Declaration name conflicts with built-in global identifier '{0}'.    Declaration name conflicts with built-in global identifier '{0}'.                                                                                                                                                                                                                           |\n| 2399  | 错误 | Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.    标识符 \"_this\" 重复。编译器使用变量声明 \"_this\" 来捕获 \"this\" 引用。                                                                                                                                                                                    |\n| 2400  | 错误 | Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.    表达式解析为编译器用于捕获 \"this\" 引用的变量声明 \"_this\"。                                                                                                                                                                                                |\n| 2401  | 错误 | Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.    标识符 \"_super\" 重复。编译器使用 \"_super\" 获取基类引用。                                                                                                                                                                                                               |\n| 2402  | 错误 | Expression resolves to '_super' that compiler uses to capture base class reference.    表达式解析为 \"_super\"，编译器使用 \"_super\" 获取基类引用。                                                                                                                                                                                                                 |\n| 2403  | 错误 | Subsequent variable declarations must have the same type. Variable '{0}' must be of type '{1}', but here has type '{2}'.    后续变量声明必须属于同一类型。变量“{0}”必须属于类型“{1}”，但此处却为类型“{2}”。                                                                                                                                                      |\n| 2404  | 错误 | The left-hand side of a 'for...in' statement cannot use a type annotation.    \"for...in\" 语句的左侧不能使用类型批注。                                                                                                                                                                                                                                            |\n| 2405  | 错误 | The left-hand side of a 'for...in' statement must be of type 'string' or 'any'.    \"for...in\" 语句的左侧必须是 \"string\" 或 \"any\" 类型。                                                                                                                                                                                                                          |\n| 2406  | 错误 | The left-hand side of a 'for...in' statement must be a variable or a property access.    \"for...in\" 语句左侧无效。                                                                                                                                                                                                                                               |\n| 2407  | 错误 | The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.    \"for...in\" 语句右侧必须是 \"any\" 类型、对象类型或类型参数。                                                                                                                                                                                           |\n| 2408  | 错误 | Setters cannot return a value.    Setter 不能返回值。                                                                                                                                                                                                                                                                                                            |\n| 2409  | 错误 | Return type of constructor signature must be assignable to the instance type of the class    构造函数签名的返回类型必须可赋给类的实例类型                                                                                                                                                                                                                        |\n| 2410  | 错误 | The 'with' statement is not supported. All symbols in a 'with' block will have type 'any'.    \"with\" 块内的所有符号都将被解析为 \"any\"。                                                                                                                                                                                                                          |\n| 2411  | 错误 | Property '{0}' of type '{1}' is not assignable to string index type '{2}'.    类型“{1}”的属性“{0}”不能赋给字符串索引类型“{2}”。                                                                                                                                                                                                                                  |\n| 2412  | 错误 | Property '{0}' of type '{1}' is not assignable to numeric index type '{2}'.    类型“{1}”的属性“{0}”不能赋给数值索引类型“{2}”。                                                                                                                                                                                                                                   |\n| 2413  | 错误 | Numeric index type '{0}' is not assignable to string index type '{1}'.    数字索引类型“{0}”不能赋给字符串索引类型“{1}”。                                                                                                                                                                                                                                         |\n| 2414  | 错误 | Class name cannot be '{0}'    类名不能为“{0}”                                                                                                                                                                                                                                                                                                                    |\n| 2415  | 错误 | Class '{0}' incorrectly extends base class '{1}'.    类“{0}”错误扩展基类“{1}”。                                                                                                                                                                                                                                                                                  |\n| 2417  | 错误 | Class static side '{0}' incorrectly extends base class static side '{1}'.    类静态侧“{0}”错误扩展基类静态侧“{1}”。                                                                                                                                                                                                                                              |\n| 2420  | 错误 | Class '{0}' incorrectly implements interface '{1}'.    类“{0}”错误实现接口“{1}”。                                                                                                                                                                                                                                                                                |\n| 2422  | 错误 | A class may only implement another class or interface.    类只能实现其他类或接口。                                                                                                                                                                                                                                                                               |\n| 2423  | 错误 | Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.    类“{0}”将“{1}”定义为实例成员函数，但扩展类“{2}”将其定义为实例成员访问器。                                                                                                                                                                |\n| 2424  | 错误 | Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.    类“{0}”将“{1}”定义为实例成员函数，但扩展类“{2}”将其定义为实例成员属性。                                                                                                                                                                  |\n| 2425  | 错误 | Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.    类“{0}”将“{1}”定义为实例成员属性，但扩展类“{2}”将其定义为实例成员函数。                                                                                                                                                                  |\n| 2426  | 错误 | Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.    类“{0}”将“{1}”定义为实例成员访问器，但扩展类“{2}”将其定义为实例成员函数。                                                                                                                                                                |\n| 2427  | 错误 | Interface name cannot be '{0}'    接口名不能为“{0}”                                                                                                                                                                                                                                                                                                              |\n| 2428  | 错误 | All declarations of '{0}' must have identical type parameters.    接口的所有声明必须具有相同的类型参数。                                                                                                                                                                                                                                                         |\n| 2430  | 错误 | Interface '{0}' incorrectly extends interface '{1}'.    接口“{0}”错误扩展接口“{1}”。                                                                                                                                                                                                                                                                             |\n| 2431  | 错误 | Enum name cannot be '{0}'    枚举名不能为“{0}”                                                                                                                                                                                                                                                                                                                   |\n| 2432  | 错误 | In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element.    在包含多个声明的枚举中，只有一个声明可以省略其第一个枚举元素的初始化表达式。                                                                                                                                                                  |\n| 2433  | 错误 | A namespace declaration cannot be in a different file from a class or function with which it is merged    命名空间声明不能位于与之合并的类或函数中的其他文件内                                                                                                                                                                                                   |\n| 2434  | 错误 | A namespace declaration cannot be located prior to a class or function with which it is merged    命名空间声明不能位于与之合并的类或函数前                                                                                                                                                                                                                       |\n| 2435  | 错误 | Ambient modules cannot be nested in other modules or namespaces.    环境模块不能嵌套在其他模块或命名空间中。                                                                                                                                                                                                                                                     |\n| 2436  | 错误 | Ambient module declaration cannot specify relative module name.    环境模块声明无法指定相对模块名。                                                                                                                                                                                                                                                              |\n| 2437  | 错误 | Module '{0}' is hidden by a local declaration with the same name    模块“{0}”被具有相同名称的局部声明隐藏                                                                                                                                                                                                                                                        |\n| 2438  | 错误 | Import name cannot be '{0}'    导入名称不能为“{0}”                                                                                                                                                                                                                                                                                                               |\n| 2439  | 错误 | Import or export declaration in an ambient module declaration cannot reference module through relative module name.    环境模块声明中的导入或导出声明不能通过相对模块名引用模块。                                                                                                                                                                                |\n| 2440  | 错误 | Import declaration conflicts with local declaration of '{0}'    导入声明与“{0}”的局部声明冲突                                                                                                                                                                                                                                                                    |\n| 2441  | 错误 | Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module.    标识符“{0}”重复。编译器在模块的顶层范围中保留名称“{1}”。                                                                                                                                                                                                             |\n| 2442  | 错误 | Types have separate declarations of a private property '{0}'.    类型具有私有属性“{0}”的单独声明。                                                                                                                                                                                                                                                               |\n| 2443  | 错误 | Property '{0}' is protected but type '{1}' is not a class derived from '{2}'.    属性“{0}”受保护，但类型“{1}”并不是从“{2}”派生的类。                                                                                                                                                                                                                             |\n| 2444  | 错误 | Property '{0}' is protected in type '{1}' but public in type '{2}'.    属性“{0}”在类型“{1}”中受保护，但在类型“{2}”中为公共属性。                                                                                                                                                                                                                                 |\n| 2445  | 错误 | Property '{0}' is protected and only accessible within class '{1}' and its subclasses.    属性“{0}”受保护，只能在类“{1}”及其子类中访问。                                                                                                                                                                                                                         |\n| 2446  | 错误 | Property '{0}' is protected and only accessible through an instance of class '{1}'.    属性“{0}”受保护，只能通过类“{1}”的实例访问。                                                                                                                                                                                                                              |\n| 2447  | 错误 | The '{0}' operator is not allowed for boolean types. Consider using '{1}' instead.    “{0}”运算符不允许用于布尔类型。请考虑改用“{1}”。                                                                                                                                                                                                                           |\n| 2448  | 错误 | Block-scoped variable '{0}' used before its declaration.    声明之前已使用的块范围变量“{0}”。                                                                                                                                                                                                                                                                    |\n| 2451  | 错误 | Cannot redeclare block-scoped variable '{0}'.    无法重新声明块范围变量“{0}”。                                                                                                                                                                                                                                                                                   |\n| 2452  | 错误 | An enum member cannot have a numeric name.    枚举成员不能具有数值名。                                                                                                                                                                                                                                                                                           |\n| 2453  | 错误 | The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.    无法从用法推断类型形参“{0}”的类型实参。可以考虑显式指定类型实参。                                                                                                                                                            |\n| 2454  | 错误 | Variable '{0}' is used before being assigned.                                                                                                                                                                                                                                                                                                                    |\n| 2455  | 错误 | Type argument candidate '{1}' is not a valid type argument because it is not a supertype of candidate '{0}'.    候选类型参数“{1}”不是有效的类型参数，因为它不是候选“{0}”的超类型。                                                                                                                                                                               |\n| 2456  | 错误 | Type alias '{0}' circularly references itself.    类型别名“{0}”循环引用自身。                                                                                                                                                                                                                                                                                    |\n| 2457  | 错误 | Type alias name cannot be '{0}'    类型别名不能为“{0}”                                                                                                                                                                                                                                                                                                           |\n| 2458  | 错误 | An AMD module cannot have multiple name assignments.    AMD 模块无法拥有多个名称分配。                                                                                                                                                                                                                                                                           |\n| 2459  | 错误 | Type '{0}' has no property '{1}' and no string index signature.    类型“{0}”不具有属性“{1}”和字符串索引签名。                                                                                                                                                                                                                                                    |\n| 2460  | 错误 | Type '{0}' has no property '{1}'.    类型“{0}”不具有属性“{1}”。                                                                                                                                                                                                                                                                                                  |\n| 2461  | 错误 | Type '{0}' is not an array type.    类型“{0}”不是数组类型。                                                                                                                                                                                                                                                                                                      |\n| 2462  | 错误 | A rest element must be last in a destructuring pattern    rest 元素必须在数组析构模式中位于最末                                                                                                                                                                                                                                                                  |\n| 2463  | 错误 | A binding pattern parameter cannot be optional in an implementation signature.    绑定模式参数在实现签名中不能为可选参数。                                                                                                                                                                                                                                       |\n| 2464  | 错误 | A computed property name must be of type 'string', 'number', 'symbol', or 'any'.    计算属性名的类型必须为 \"string\"、\"number\"、\"symbol\" 或 \"any\"。                                                                                                                                                                                                               |\n| 2465  | 错误 | 'this' cannot be referenced in a computed property name.    不能在计算属性名中引用 \"this\"。                                                                                                                                                                                                                                                                      |\n| 2466  | 错误 | 'super' cannot be referenced in a computed property name.    不能在计算属性名中引用 \"super\"。                                                                                                                                                                                                                                                                    |\n| 2467  | 错误 | A computed property name cannot reference a type parameter from its containing type.    计算属性名无法从其包含的类型引用类型参数。                                                                                                                                                                                                                               |\n| 2468  | 错误 | Cannot find global value '{0}'.    找不到全局值“{0}”。                                                                                                                                                                                                                                                                                                           |\n| 2469  | 错误 | The '{0}' operator cannot be applied to type 'symbol'.    “{0}”运算符不能应用于类型 \"symbol\"。                                                                                                                                                                                                                                                                   |\n| 2470  | 错误 | 'Symbol' reference does not refer to the global Symbol constructor object.    \"Symbol\" 引用不是指全局符号构造函数对象。                                                                                                                                                                                                                                          |\n| 2471  | 错误 | A computed property name of the form '{0}' must be of type 'symbol'.    窗体“{0}”的计算属性名必须是 \"symbol\" 类型。                                                                                                                                                                                                                                              |\n| 2472  | 错误 | Spread operator in 'new' expressions is only available when targeting ECMAScript 5 and higher.    仅当面向 ECMAScript 5 和更高版本时，\"new\" 表达式中的展开运算符才可用。                                                                                                                                                                                         |\n| 2473  | 错误 | Enum declarations must all be const or non-const.    枚举声明必须全为常数或非常数。                                                                                                                                                                                                                                                                              |\n| 2474  | 错误 | In 'const' enum declarations member initializer must be constant expression.    在 \"const\" 枚举声明中，成员初始化表达式必须是常数表达式。                                                                                                                                                                                                                        |\n| 2475  | 错误 | 'const' enums can only be used in property or index access expressions or the right hand side of an import declaration or export assignment.    \"const\" 枚举仅可在属性、索引访问表达式、导入声明的右侧或导出分配中使用。                                                                                                                                         |\n| 2476  | 错误 | A const enum member can only be accessed using a string literal.    只有使用字符串文本才能访问常数枚举成员。                                                                                                                                                                                                                                                     |\n| 2477  | 错误 | 'const' enum member initializer was evaluated to a non-finite value.    \"const\" 枚举成员初始化表达式的求值结果为非有限值。                                                                                                                                                                                                                                       |\n| 2478  | 错误 | 'const' enum member initializer was evaluated to disallowed value 'NaN'.    \"const\" 枚举成员初始化表达式的求值结果为不允许使用的值 \"NaN\"。                                                                                                                                                                                                                       |\n| 2479  | 错误 | Property '{0}' does not exist on 'const' enum '{1}'.    \"const\" 枚举“{1}”上不存在属性“{0}”。                                                                                                                                                                                                                                                                     |\n| 2480  | 错误 | 'let' is not allowed to be used as a name in 'let' or 'const' declarations.    \"let\" 不能用作 \"let\" 或 \"const\" 声明中的名称。                                                                                                                                                                                                                                    |\n| 2481  | 错误 | Cannot initialize outer scoped variable '{0}' in the same scope as block scoped declaration '{1}'.    无法在块范围声明“{1}”所在的范围内初始化外部范围变量“{0}”。                                                                                                                                                                                                 |\n| 2483  | 错误 | The left-hand side of a 'for...of' statement cannot use a type annotation.    \"for...of\" 语句的左侧不能使用类型批注。                                                                                                                                                                                                                                            |\n| 2484  | 错误 | Export declaration conflicts with exported declaration of '{0}'    导出声明与“{0}”的导出声明冲突                                                                                                                                                                                                                                                                 |\n| 2487  | 错误 | The left-hand side of a 'for...of' statement must be a variable or a property access.    \"for...of\" 语句左侧无效。                                                                                                                                                                                                                                               |\n| 2488  | 错误 | Type must have a 'Symbol.iterator' method that returns an iterator.    类型必须具有返回迭代器的 \"Symbol.iterator\" 方法。                                                                                                                                                                                                                                         |\n| 2489  | 错误 | An iterator must have a 'next()' method.    迭代器必须具有 \"next()\" 方法。                                                                                                                                                                                                                                                                                       |\n| 2490  | 错误 | The type returned by the 'next()' method of an iterator must have a 'value' property.    迭代器的 \"next()\" 方法返回的类型必须具有 \"value\" 属性。                                                                                                                                                                                                                 |\n| 2491  | 错误 | The left-hand side of a 'for...in' statement cannot be a destructuring pattern.    \"for...in\" 语句的左侧不能为析构模式。                                                                                                                                                                                                                                         |\n| 2492  | 错误 | Cannot redeclare identifier '{0}' in catch clause    无法在 catch 子句中重新声明标识符“{0}”                                                                                                                                                                                                                                                                      |\n| 2493  | 错误 | Tuple type '{0}' with length '{1}' cannot be assigned to tuple with length '{2}'.    不能将长度为“{1}”的元组类型“{0}”分配给长度为“{2}”的元组。                                                                                                                                                                                                                   |\n| 2494  | 错误 | Using a string in a 'for...of' statement is only supported in ECMAScript 5 and higher.    仅 ECMAScript 5 和更高版本支持在 \"for...of\" 语句中使用字符串。                                                                                                                                                                                                         |\n| 2495  | 错误 | Type '{0}' is not an array type or a string type.    类型“{0}”不是数组类型或字符串类型。                                                                                                                                                                                                                                                                         |\n| 2496  | 错误 | The 'arguments' object cannot be referenced in an arrow function in ES3 and ES5. Consider using a standard function expression.    ES3 和 ES5 中的箭头函数不能引用 \"arguments\" 对象。请考虑使用标准函数表达式。                                                                                                                                                  |\n| 2497  | 错误 | Module '{0}' resolves to a non-module entity and cannot be imported using this construct.    模块“{0}”解析为非模块实体，且不能使用此构造导入。                                                                                                                                                                                                                   |\n| 2498  | 错误 | Module '{0}' uses 'export =' and cannot be used with 'export *'.    模块“{0}”使用 \"export =\" 且无法与 \"export*\" 一起使用。                                                                                                                                                                                                                                       |\n| 2499  | 错误 | An interface can only extend an identifier/qualified-name with optional type arguments.    接口只能扩展具有可选类型参数的标识符/限定名称。                                                                                                                                                                                                                       |\n| 2500  | 错误 | A class can only implement an identifier/qualified-name with optional type arguments.    类只能实现具有可选类型参数的标识符/限定名称。                                                                                                                                                                                                                           |\n| 2501  | 错误 | A rest element cannot contain a binding pattern.    rest 元素不能包含绑定模式。                                                                                                                                                                                                                                                                                  |\n| 2502  | 错误 | '{0}' is referenced directly or indirectly in its own type annotation.    “{0}”在其自身的类型批注中得到直接或间接引用。                                                                                                                                                                                                                                          |\n| 2503  | 错误 | Cannot find namespace '{0}'.    找不到命名空间“{0}”。                                                                                                                                                                                                                                                                                                            |\n| 2505  | 错误 | A generator cannot have a 'void' type annotation.    生成器不能具有 \"void\" 类型批注。                                                                                                                                                                                                                                                                            |\n| 2506  | 错误 | '{0}' is referenced directly or indirectly in its own base expression.    “{0}”在其自身的基表达式中得到直接或间接引用。                                                                                                                                                                                                                                          |\n| 2507  | 错误 | Type '{0}' is not a constructor function type.    类型“{0}”不是构造函数类型。                                                                                                                                                                                                                                                                                    |\n| 2508  | 错误 | No base constructor has the specified number of type arguments.    没有任何基构造函数具有指定数量的类型参数。                                                                                                                                                                                                                                                    |\n| 2509  | 错误 | Base constructor return type '{0}' is not a class or interface type.    基构造函数返回类型“{0}”不是类或接口类型。                                                                                                                                                                                                                                                |\n| 2510  | 错误 | Base constructors must all have the same return type.    所有的基构造函数必须具有相同的返回类型。                                                                                                                                                                                                                                                                |\n| 2511  | 错误 | Cannot create an instance of the abstract class '{0}'.    无法创建抽象类“{0}”的实例。                                                                                                                                                                                                                                                                            |\n| 2512  | 错误 | Overload signatures must all be abstract or non-abstract.    重载签名必须全部为抽象签名或非抽象签名。                                                                                                                                                                                                                                                            |\n| 2513  | 错误 | Abstract method '{0}' in class '{1}' cannot be accessed via super expression.    无法通过 super 表达式访问“{1}”类中的“{0}”抽象方法。                                                                                                                                                                                                                             |\n| 2514  | 错误 | Classes containing abstract methods must be marked abstract.    包含抽象方法的类必须标记为抽象。                                                                                                                                                                                                                                                                 |\n| 2515  | 错误 | Non-abstract class '{0}' does not implement inherited abstract member '{1}' from class '{2}'.    非抽象类“{0}”不会实现继承自“{2}”类的抽象成员“{1}”。                                                                                                                                                                                                             |\n| 2516  | 错误 | All declarations of an abstract method must be consecutive.    抽象方法的所有声明必须是连续的。                                                                                                                                                                                                                                                                  |\n| 2517  | 错误 | Cannot assign an abstract constructor type to a non-abstract constructor type.    无法将抽象构造函数类型分配给非抽象构造函数类型。                                                                                                                                                                                                                               |\n| 2518  | 错误 | A 'this'-based type guard is not compatible with a parameter-based type guard.    A 'this'-based type guard is not compatible with a parameter-based type guard.                                                                                                                                                                                                 |\n| 2520  | 错误 | Duplicate identifier '{0}'. Compiler uses declaration '{1}' to support async functions.    标识符“{0}”重复。编译器使用“{1}”声明来支持异步函数。                                                                                                                                                                                                                  |\n| 2521  | 错误 | Expression resolves to variable declaration '{0}' that compiler uses to support async functions.    表达式解析为编译器用于支持异步函数的变量声明“{0}”。                                                                                                                                                                                                          |\n| 2522  | 错误 | The 'arguments' object cannot be referenced in an async function or method in ES3 and ES5. Consider using a standard function or method.    无法在异步箭头函数中引用 \"arguments\" 对象。请考虑使用标准的异步函数表达式。                                                                                                                                          |\n| 2523  | 错误 | 'yield' expressions cannot be used in a parameter initializer.    不能在参数初始化表达式中使用 \"yield\" 表达式。                                                                                                                                                                                                                                                  |\n| 2524  | 错误 | 'await' expressions cannot be used in a parameter initializer.    不能在参数初始化表达式中使用 \"await\" 表达式。                                                                                                                                                                                                                                                  |\n| 2525  | 错误 | Initializer provides no value for this binding element and the binding element has no default value.    初始化表达式没有为此绑定元素提供此任何值，且该绑定元素没有默认值。                                                                                                                                                                                       |\n| 2526  | 错误 | A 'this' type is available only in a non-static member of a class or interface.    \"this\" 类型仅在类或接口的非静态成员中可用。                                                                                                                                                                                                                                   |\n| 2527  | 错误 | The inferred type of '{0}' references an inaccessible 'this' type. A type annotation is necessary.    “{0}”的推断类型引用不可访问的 \"this\" 类型。需要类型批注。                                                                                                                                                                                                  |\n| 2528  | 错误 | A module cannot have multiple default exports.    一个模块不能具有多个默认导出。                                                                                                                                                                                                                                                                                 |\n| 2529  | 错误 | Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module containing async functions.    Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module containing async functions.                                                                                                                       |\n| 2530  | 错误 | Property '{0}' is incompatible with index signature.                                                                                                                                                                                                                                                                                                             |\n| 2531  | 错误 | Object is possibly 'null'.                                                                                                                                                                                                                                                                                                                                       |\n| 2532  | 错误 | Object is possibly 'undefined'.                                                                                                                                                                                                                                                                                                                                  |\n| 2533  | 错误 | Object is possibly 'null' or 'undefined'.                                                                                                                                                                                                                                                                                                                        |\n| 2534  | 错误 | A function returning 'never' cannot have a reachable end point.                                                                                                                                                                                                                                                                                                  |\n| 2535  | 错误 | Enum type '{0}' has members with initializers that are not literals.                                                                                                                                                                                                                                                                                             |\n| 2536  | 错误 | Type '{0}' cannot be used to index type '{1}'.                                                                                                                                                                                                                                                                                                                   |\n| 2537  | 错误 | Type '{0}' has no matching index signature for type '{1}'.                                                                                                                                                                                                                                                                                                       |\n| 2538  | 错误 | Type '{0}' cannot be used as an index type.                                                                                                                                                                                                                                                                                                                      |\n| 2539  | 错误 | Cannot assign to '{0}' because it is not a variable.                                                                                                                                                                                                                                                                                                             |\n| 2540  | 错误 | Cannot assign to '{0}' because it is a constant or a read-only property.                                                                                                                                                                                                                                                                                         |\n| 2541  | 错误 | The target of an assignment must be a variable or a property access.                                                                                                                                                                                                                                                                                             |\n| 2542  | 错误 | Index signature in type '{0}' only permits reading.                                                                                                                                                                                                                                                                                                              |\n| 2543  | 错误 | Duplicate identifier '_newTarget'. Compiler uses variable declaration '_newTarget' to capture 'new.target' meta-property reference.                                                                                                                                                                                                                              |\n| 2544  | 错误 | Expression resolves to variable declaration '_newTarget' that compiler uses to capture 'new.target' meta-property reference.                                                                                                                                                                                                                                     |\n| 2600  | 错误 | JSX element attributes type '{0}' may not be a union type.    JSX element attributes type '{0}' may not be a union type.                                                                                                                                                                                                                                         |\n| 2601  | 错误 | The return type of a JSX element constructor must return an object type.    JSX 元素构造函数的返回类型必须返回对象类型。                                                                                                                                                                                                                                         |\n| 2602  | 错误 | JSX element implicitly has type 'any' because the global type 'JSX.Element' does not exist.    JSX 元素隐式具有类型 \"any\"，因为不存在全局类型 \"JSX.Element\"。                                                                                                                                                                                                    |\n| 2603  | 错误 | Property '{0}' in type '{1}' is not assignable to type '{2}'    类型“{1}”中的属性“{0}”不可分配给类型“{2}”                                                                                                                                                                                                                                                        |\n| 2604  | 错误 | JSX element type '{0}' does not have any construct or call signatures.    JSX 元素类型“{0}”不具有任何构造签名或调用签名。                                                                                                                                                                                                                                        |\n| 2605  | 错误 | JSX element type '{0}' is not a constructor function for JSX elements.    JSX 元素类型“{0}”不是 JSX 元素的构造函数。                                                                                                                                                                                                                                             |\n| 2606  | 错误 | Property '{0}' of JSX spread attribute is not assignable to target property.    JSX 展开特性的“{0}”属性不能分配给目标属性。                                                                                                                                                                                                                                      |\n| 2607  | 错误 | JSX element class does not support attributes because it does not have a '{0}' property    JSX 元素类不支持特性，因为它不具有“{0}”属性                                                                                                                                                                                                                           |\n| 2608  | 错误 | The global type 'JSX.{0}' may not have more than one property    全局类型“JSX.{0}”不可以具有多个属性                                                                                                                                                                                                                                                             |\n| 2609  | 错误 | JSX spread child must be an array type.                                                                                                                                                                                                                                                                                                                          |\n| 2650  | 错误 | Cannot emit namespaced JSX elements in React    无法发出 React 中带命名空间的 JSX 元素                                                                                                                                                                                                                                                                           |\n| 2651  | 错误 | A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums.    枚举声明中的成员初始化表达式不能引用在其后声明的成员(包括在其他枚举中定义的成员)。                                                                                                                                           |\n| 2652  | 错误 | Merged declaration '{0}' cannot include a default export declaration. Consider adding a separate 'export default {0}' declaration instead.    合并声明“{0}”不能包含默认导出声明。请考虑改为添加一个独立的“导出默认 {0}”声明。                                                                                                                                    |\n| 2653  | 错误 | Non-abstract class expression does not implement inherited abstract member '{0}' from class '{1}'.    非抽象类表达式不会实现继承自“{1}”类的抽象成员“{0}”。                                                                                                                                                                                                       |\n| 2654  | 错误 | Exported external package typings file cannot contain tripleslash references. Please contact the package author to update the package definition.    导出的外部包键入文件不能包含三斜线引用。请与包作者联系或更新包定义。                                                                                                                                        |\n| 2656  | 错误 | Exported external package typings file '{0}' is not a module. Please contact the package author to update the package definition.    导出的外部包键入文件“{0}”不是一个模块。请与包作者联系或更新包定义。                                                                                                                                                         |\n| 2657  | 错误 | JSX expressions must have one parent element    JSX 表达式必须具有一个父元素                                                                                                                                                                                                                                                                                     |\n| 2658  | 错误 | Type '{0}' provides no match for the signature '{1}'    类型“{0}”提供程序与签名“{1}”不匹配                                                                                                                                                                                                                                                                       |\n| 2659  | 错误 | 'super' is only allowed in members of object literal expressions when option 'target' is 'ES2015' or higher.    'super' is only allowed in members of object literal expressions when option 'target' is 'ES2015' or higher.                                                                                                                                     |\n| 2660  | 错误 | 'super' can only be referenced in members of derived classes or object literal expressions.    'super' can only be referenced in members of derived classes or object literal expressions.                                                                                                                                                                       |\n| 2661  | 错误 | Cannot export '{0}'. Only local declarations can be exported from a module.    Cannot re-export name that is not defined in the module.                                                                                                                                                                                                                          |\n| 2662  | 错误 | Cannot find name '{0}'. Did you mean the static member '{1}.{0}'?    Cannot find name '{0}'. Did you mean the static member '{1}.{0}'?                                                                                                                                                                                                                           |\n| 2663  | 错误 | Cannot find name '{0}'. Did you mean the instance member 'this.{0}'?    Cannot find name '{0}'. Did you mean the instance member 'this.{0}'?                                                                                                                                                                                                                     |\n| 2664  | 错误 | Invalid module name in augmentation, module '{0}' cannot be found.    Invalid module name in augmentation, module '{0}' cannot be found.                                                                                                                                                                                                                         |\n| 2665  | 错误 | Invalid module name in augmentation. Module '{0}' resolves to an untyped module at '{1}', which cannot be augmented.    Module augmentation cannot introduce new names in the top level scope.                                                                                                                                                                   |\n| 2666  | 错误 | Exports and export assignments are not permitted in module augmentations.    Exports and export assignments are not permitted in module augmentations.                                                                                                                                                                                                           |\n| 2667  | 错误 | Imports are not permitted in module augmentations. Consider moving them to the enclosing external module.    Imports are not permitted in module augmentations. Consider moving them to the enclosing external module.                                                                                                                                           |\n| 2668  | 错误 | 'export' modifier cannot be applied to ambient modules and module augmentations since they are always visible.    'export' modifier cannot be applied to ambient modules and module augmentations since they are always visible.                                                                                                                                 |\n| 2669  | 错误 | Augmentations for the global scope can only be directly nested in external modules or ambient module declarations.    Augmentations for the global scope can only be directly nested in external modules or ambient module declarations.                                                                                                                         |\n| 2670  | 错误 | Augmentations for the global scope should have 'declare' modifier unless they appear in already ambient context.    Augmentations for the global scope should have 'declare' modifier unless they appear in already ambient context.                                                                                                                             |\n| 2671  | 错误 | Cannot augment module '{0}' because it resolves to a non-module entity.    Cannot augment module '{0}' because it resolves to a non-module entity.                                                                                                                                                                                                               |\n| 2672  | 错误 | Cannot assign a '{0}' constructor type to a '{1}' constructor type.                                                                                                                                                                                                                                                                                              |\n| 2673  | 错误 | Constructor of class '{0}' is private and only accessible within the class declaration.                                                                                                                                                                                                                                                                          |\n| 2674  | 错误 | Constructor of class '{0}' is protected and only accessible within the class declaration.                                                                                                                                                                                                                                                                        |\n| 2675  | 错误 | Cannot extend a class '{0}'. Class constructor is marked as private.                                                                                                                                                                                                                                                                                             |\n| 2676  | 错误 | Accessors must both be abstract or non-abstract.                                                                                                                                                                                                                                                                                                                 |\n| 2677  | 错误 | A type predicate's type must be assignable to its parameter's type.                                                                                                                                                                                                                                                                                              |\n| 2678  | 错误 | Type '{0}' is not comparable to type '{1}'.                                                                                                                                                                                                                                                                                                                      |\n| 2679  | 错误 | A function that is called with the 'new' keyword cannot have a 'this' type that is 'void'.                                                                                                                                                                                                                                                                       |\n| 2680  | 错误 | A 'this' parameter must be the first parameter.                                                                                                                                                                                                                                                                                                                  |\n| 2681  | 错误 | A constructor cannot have a 'this' parameter.                                                                                                                                                                                                                                                                                                                    |\n| 2682  | 错误 | 'get' and 'set' accessor must have the same 'this' type.                                                                                                                                                                                                                                                                                                         |\n| 2683  | 错误 | 'this' implicitly has type 'any' because it does not have a type annotation.                                                                                                                                                                                                                                                                                     |\n| 2684  | 错误 | The 'this' context of type '{0}' is not assignable to method's 'this' of type '{1}'.                                                                                                                                                                                                                                                                             |\n| 2685  | 错误 | The 'this' types of each signature are incompatible.                                                                                                                                                                                                                                                                                                             |\n| 2686  | 错误 | '{0}' refers to a UMD global, but the current file is a module. Consider adding an import instead.                                                                                                                                                                                                                                                               |\n| 2687  | 错误 | All declarations of '{0}' must have identical modifiers.                                                                                                                                                                                                                                                                                                         |\n| 2688  | 错误 | Cannot find type definition file for '{0}'.                                                                                                                                                                                                                                                                                                                      |\n| 2689  | 错误 | Cannot extend an interface '{0}'. Did you mean 'implements'?                                                                                                                                                                                                                                                                                                     |\n| 2690  | 错误 | A class must be declared after its base class.                                                                                                                                                                                                                                                                                                                   |\n| 2691  | 错误 | An import path cannot end with a '{0}' extension. Consider importing '{1}' instead.                                                                                                                                                                                                                                                                              |\n| 2692  | 错误 | '{0}' is a primitive, but '{1}' is a wrapper object. Prefer using '{0}' when possible.                                                                                                                                                                                                                                                                           |\n| 2693  | 错误 | '{0}' only refers to a type, but is being used as a value here.                                                                                                                                                                                                                                                                                                  |\n| 2694  | 错误 | Namespace '{0}' has no exported member '{1}'.                                                                                                                                                                                                                                                                                                                    |\n| 2695  | 错误 | Left side of comma operator is unused and has no side effects.                                                                                                                                                                                                                                                                                                   |\n| 2696  | 错误 | The 'Object' type is assignable to very few other types. Did you mean to use the 'any' type instead?                                                                                                                                                                                                                                                             |\n| 2697  | 错误 | An async function or method must return a 'Promise'. Make sure you have a declaration for 'Promise' or include 'ES2015' in your --lib option.                                                                                                                                                                                                                    |\n| 2698  | 错误 | Spread types may only be created from object types.                                                                                                                                                                                                                                                                                                              |\n| 2700  | 错误 | Rest types may only be created from object types.                                                                                                                                                                                                                                                                                                                |\n| 2701  | 错误 | The target of an object rest assignment must be a variable or a property access.                                                                                                                                                                                                                                                                                 |\n| 2702  | 错误 | '{0}' only refers to a type, but is being used as a namespace here.                                                                                                                                                                                                                                                                                              |\n| 2703  | 错误 | The operand of a delete operator must be a property reference                                                                                                                                                                                                                                                                                                    |\n| 2704  | 错误 | The operand of a delete operator cannot be a read-only property                                                                                                                                                                                                                                                                                                  |\n| 4000  | 错误 | Import declaration '{0}' is using private name '{1}'.    导入声明“{0}”使用的是专用名称“{1}”。                                                                                                                                                                                                                                                                    |\n| 4002  | 错误 | Type parameter '{0}' of exported class has or is using private name '{1}'.    导出类的类型参数“{0}”具有或正在使用专用名称“{1}”。                                                                                                                                                                                                                                 |\n| 4004  | 错误 | Type parameter '{0}' of exported interface has or is using private name '{1}'.    导出接口的类型参数“{0}”具有或正在使用专用名称“{1}”。                                                                                                                                                                                                                           |\n| 4006  | 错误 | Type parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.    导出接口中的构造函数签名的类型参数“{0}”具有或正在使用专用名称“{1}”。                                                                                                                                                                                |\n| 4008  | 错误 | Type parameter '{0}' of call signature from exported interface has or is using private name '{1}'.    导出接口中的调用签名的类型参数“{0}”具有或正在使用专用名称“{1}”。                                                                                                                                                                                           |\n| 4010  | 错误 | Type parameter '{0}' of public static method from exported class has or is using private name '{1}'.    导出类中的公共静态方法的类型参数“{0}”具有或正在使用专用名称“{1}”。                                                                                                                                                                                       |\n| 4012  | 错误 | Type parameter '{0}' of public method from exported class has or is using private name '{1}'.    导出类中的公共方法的类型参数“{0}”具有或正在使用专用名称“{1}”。                                                                                                                                                                                                  |\n| 4014  | 错误 | Type parameter '{0}' of method from exported interface has or is using private name '{1}'.    导出接口中的方法的类型参数“{0}”具有或正在使用专用名称“{1}”。                                                                                                                                                                                                       |\n| 4016  | 错误 | Type parameter '{0}' of exported function has or is using private name '{1}'.    导出函数的类型参数“{0}”具有或正在使用专用名称“{1}”。                                                                                                                                                                                                                            |\n| 4019  | 错误 | Implements clause of exported class '{0}' has or is using private name '{1}'.    导出的类“{0}”的 Implements 子句具有或正在使用专用名称“{1}”。                                                                                                                                                                                                                    |\n| 4020  | 错误 | Extends clause of exported class '{0}' has or is using private name '{1}'.    导出的类“{0}”的 extends 子句具有或正在使用专用名称“{1}”。                                                                                                                                                                                                                          |\n| 4022  | 错误 | Extends clause of exported interface '{0}' has or is using private name '{1}'.    导出接口“{0}”的 extends 子句具有或正在使用专用名称“{1}”。                                                                                                                                                                                                                      |\n| 4023  | 错误 | Exported variable '{0}' has or is using name '{1}' from external module {2} but cannot be named.    导出的变量“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。                                                                                                                                                                                    |\n| 4024  | 错误 | Exported variable '{0}' has or is using name '{1}' from private module '{2}'.    导出的变量“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。                                                                                                                                                                                                                       |\n| 4025  | 错误 | Exported variable '{0}' has or is using private name '{1}'.    导出的变量“{0}”具有或正在使用专用名称“{1}”。                                                                                                                                                                                                                                                      |\n| 4026  | 错误 | Public static property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.    导出类的公共静态属性“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。                                                                                                                                                   |\n| 4027  | 错误 | Public static property '{0}' of exported class has or is using name '{1}' from private module '{2}'.    导出类的公共静态属性“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”。                                                                                                                                                                                      |\n| 4028  | 错误 | Public static property '{0}' of exported class has or is using private name '{1}'.    导出类的公共静态属性“{0}”具有或正在使用专用名称“{1}”。                                                                                                                                                                                                                     |\n| 4029  | 错误 | Public property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.    导出类的公共属性“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。                                                                                                                                                              |\n| 4030  | 错误 | Public property '{0}' of exported class has or is using name '{1}' from private module '{2}'.    导出类的公共属性“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。                                                                                                                                                                                                 |\n| 4031  | 错误 | Public property '{0}' of exported class has or is using private name '{1}'.    导出类的公共属性“{0}”具有或正在使用专用名称“{1}”。                                                                                                                                                                                                                                |\n| 4032  | 错误 | Property '{0}' of exported interface has or is using name '{1}' from private module '{2}'.    导出接口的属性“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。                                                                                                                                                                                                      |\n| 4033  | 错误 | Property '{0}' of exported interface has or is using private name '{1}'.    导出接口的属性“{0}”具有或正在使用专用名称“{1}”。                                                                                                                                                                                                                                     |\n| 4034  | 错误 | Parameter '{0}' of public static property setter from exported class has or is using name '{1}' from private module '{2}'.    导出类中的公共静态属性 setter 的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。                                                                                                                                                |\n| 4035  | 错误 | Parameter '{0}' of public static property setter from exported class has or is using private name '{1}'.    导出类中的公共静态属性 setter 的参数“{0}”具有或正在使用专用名称“{1}”。                                                                                                                                                                               |\n| 4036  | 错误 | Parameter '{0}' of public property setter from exported class has or is using name '{1}' from private module '{2}'.    导出类中的公共属性 setter 的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。                                                                                                                                                           |\n| 4037  | 错误 | Parameter '{0}' of public property setter from exported class has or is using private name '{1}'.    导出类中的公共属性 setter 的参数“{0}”具有或正在使用专用名称“{1}”。                                                                                                                                                                                          |\n| 4038  | 错误 | Return type of public static property getter from exported class has or is using name '{0}' from external module {1} but cannot be named.    导出类中的公共静态属性 getter 的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。                                                                                                                  |\n| 4039  | 错误 | Return type of public static property getter from exported class has or is using name '{0}' from private module '{1}'.    导出类中的公共静态属性 getter 的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。                                                                                                                                                     |\n| 4040  | 错误 | Return type of public static property getter from exported class has or is using private name '{0}'.    导出类中的公共静态属性 getter 的返回类型具有或正在使用专用名称“{0}”。                                                                                                                                                                                    |\n| 4041  | 错误 | Return type of public property getter from exported class has or is using name '{0}' from external module {1} but cannot be named.    导出类中的公共属性 getter 的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。                                                                                                                             |\n| 4042  | 错误 | Return type of public property getter from exported class has or is using name '{0}' from private module '{1}'.    导出类中的公共属性 getter 的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。                                                                                                                                                                |\n| 4043  | 错误 | Return type of public property getter from exported class has or is using private name '{0}'.    导出类中的公共属性 getter 的返回类型具有或正在使用专用名称“{0}”。                                                                                                                                                                                               |\n| 4044  | 错误 | Return type of constructor signature from exported interface has or is using name '{0}' from private module '{1}'.    导出接口中的构造函数签名的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。                                                                                                                                                               |\n| 4045  | 错误 | Return type of constructor signature from exported interface has or is using private name '{0}'.    导出接口中的构造函数签名的返回类型具有或正在使用专用名称“{0}”。                                                                                                                                                                                              |\n| 4046  | 错误 | Return type of call signature from exported interface has or is using name '{0}' from private module '{1}'.    导出接口中的调用签名的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。                                                                                                                                                                          |\n| 4047  | 错误 | Return type of call signature from exported interface has or is using private name '{0}'.    导出接口中的调用签名的返回类型具有或正在使用专用名称“{0}”。                                                                                                                                                                                                         |\n| 4048  | 错误 | Return type of index signature from exported interface has or is using name '{0}' from private module '{1}'.    导出接口中的索引签名的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。                                                                                                                                                                         |\n| 4049  | 错误 | Return type of index signature from exported interface has or is using private name '{0}'.    导出接口中的索引签名的返回类型具有或正在使用专用名称“{0}”。                                                                                                                                                                                                        |\n| 4050  | 错误 | Return type of public static method from exported class has or is using name '{0}' from external module {1} but cannot be named.    导出类中的公共静态方法的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。                                                                                                                                   |\n| 4051  | 错误 | Return type of public static method from exported class has or is using name '{0}' from private module '{1}'.    导出类中的公共静态方法的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。                                                                                                                                                                      |\n| 4052  | 错误 | Return type of public static method from exported class has or is using private name '{0}'.    导出类中的公共静态方法的返回类型具有或正在使用专用名称“{0}”。                                                                                                                                                                                                     |\n| 4053  | 错误 | Return type of public method from exported class has or is using name '{0}' from external module {1} but cannot be named.    导出类中的公共方法的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。                                                                                                                                              |\n| 4054  | 错误 | Return type of public method from exported class has or is using name '{0}' from private module '{1}'.    导出类中的公共方法的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。                                                                                                                                                                                 |\n| 4055  | 错误 | Return type of public method from exported class has or is using private name '{0}'.    导出类中的公共方法的返回类型具有或正在使用专用名称“{0}”。                                                                                                                                                                                                                |\n| 4056  | 错误 | Return type of method from exported interface has or is using name '{0}' from private module '{1}'.    导出接口中的方法的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。                                                                                                                                                                                      |\n| 4057  | 错误 | Return type of method from exported interface has or is using private name '{0}'.    导出接口中的方法的返回类型具有或正在使用专用名称“{0}”。                                                                                                                                                                                                                     |\n| 4058  | 错误 | Return type of exported function has or is using name '{0}' from external module {1} but cannot be named.    导出函数的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。                                                                                                                                                                        |\n| 4059  | 错误 | Return type of exported function has or is using name '{0}' from private module '{1}'.    导出函数的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。                                                                                                                                                                                                           |\n| 4060  | 错误 | Return type of exported function has or is using private name '{0}'.    导出函数的返回类型具有或正在使用专用名称“{0}”。                                                                                                                                                                                                                                          |\n| 4061  | 错误 | Parameter '{0}' of constructor from exported class has or is using name '{1}' from external module {2} but cannot be named.    导出类中的构造函数的参数“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。                                                                                                                                           |\n| 4062  | 错误 | Parameter '{0}' of constructor from exported class has or is using name '{1}' from private module '{2}'.    导出类中的构造函数的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。                                                                                                                                                                              |\n| 4063  | 错误 | Parameter '{0}' of constructor from exported class has or is using private name '{1}'.    导出类中的构造函数的参数“{0}”具有或正在使用专用名称“{1}”。                                                                                                                                                                                                             |\n| 4064  | 错误 | Parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'.    导出接口中的构造函数签名的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。                                                                                                                                                          |\n| 4065  | 错误 | Parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.    导出接口中的构造函数签名的参数“{0}”具有或正在使用专用名称“{1}”。                                                                                                                                                                                         |\n| 4066  | 错误 | Parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'.    导出接口中的调用签名的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。                                                                                                                                                                     |\n| 4067  | 错误 | Parameter '{0}' of call signature from exported interface has or is using private name '{1}'.    导出接口中的调用签名的参数“{0}”具有或正在使用专用名称“{1}”。                                                                                                                                                                                                    |\n| 4068  | 错误 | Parameter '{0}' of public static method from exported class has or is using name '{1}' from external module {2} but cannot be named.    导出类中的公共静态方法的参数“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。                                                                                                                              |\n| 4069  | 错误 | Parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'.    导出类中的公共静态方法的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。                                                                                                                                                                 |\n| 4070  | 错误 | Parameter '{0}' of public static method from exported class has or is using private name '{1}'.    导出类中的公共静态方法的参数“{0}”具有或正在使用专用名称“{1}”。                                                                                                                                                                                                |\n| 4071  | 错误 | Parameter '{0}' of public method from exported class has or is using name '{1}' from external module {2} but cannot be named.    导出类中的公共方法的参数“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。                                                                                                                                         |\n| 4072  | 错误 | Parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'.    导出类中的公共方法的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。                                                                                                                                                                            |\n| 4073  | 错误 | Parameter '{0}' of public method from exported class has or is using private name '{1}'.    导出类中的公共方法的参数“{0}”具有或正在使用专用名称“{1}”。                                                                                                                                                                                                           |\n| 4074  | 错误 | Parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'.    导出接口中的方法的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。                                                                                                                                                                                 |\n| 4075  | 错误 | Parameter '{0}' of method from exported interface has or is using private name '{1}'.    导出接口中的方法的参数“{0}”具有或正在使用专用名称“{1}”。                                                                                                                                                                                                                |\n| 4076  | 错误 | Parameter '{0}' of exported function has or is using name '{1}' from external module {2} but cannot be named.    导出函数的参数“{0}”具有或正在使用外部模块 {2} 中的名称“{1}”，但不能为其命名。                                                                                                                                                                   |\n| 4077  | 错误 | Parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'.    导出函数的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。                                                                                                                                                                                                      |\n| 4078  | 错误 | Parameter '{0}' of exported function has or is using private name '{1}'.    导出函数的参数“{0}”具有或正在使用专用名称“{1}”。                                                                                                                                                                                                                                     |\n| 4081  | 错误 | Exported type alias '{0}' has or is using private name '{1}'.    导出的类型别名“{0}”已经或正在使用专用名称“{1}”。                                                                                                                                                                                                                                                |\n| 4082  | 错误 | Default export of the module has or is using private name '{0}'.    模块的默认导出具有或正在使用专用名称“{0}”。                                                                                                                                                                                                                                                  |\n| 4083  | 错误 | Type parameter '{0}' of exported type alias has or is using private name '{1}'.                                                                                                                                                                                                                                                                                  |\n| 4090  | 信息 | Conflicting definitions for '{0}' found at '{1}' and '{2}'. Consider installing a specific version of this library to resolve the conflict.                                                                                                                                                                                                                      |\n| 4091  | 错误 | Parameter '{0}' of index signature from exported interface has or is using name '{1}' from private module '{2}'.                                                                                                                                                                                                                                                 |\n| 4092  | 错误 | Parameter '{0}' of index signature from exported interface has or is using private name '{1}'.                                                                                                                                                                                                                                                                   |\n| 5001  | 错误 | The current host does not support the '{0}' option.    当前主机不支持“{0}”选项。                                                                                                                                                                                                                                                                                 |\n| 5009  | 错误 | Cannot find the common subdirectory path for the input files.    找不到输入文件的公共子目录路径。                                                                                                                                                                                                                                                                |\n| 5010  | 错误 | File specification cannot end in a recursive directory wildcard ('**'): '{0}'.                                                                                                                                                                                                                                                                                   |\n| 5011  | 错误 | File specification cannot contain multiple recursive directory wildcards ('**'): '{0}'.                                                                                                                                                                                                                                                                          |\n| 5012  | 错误 | Cannot read file '{0}': {1}    无法读取文件“{0}”: {1}                                                                                                                                                                                                                                                                                                            |\n| 5013  | 错误 | Unsupported file encoding.    文件编码不受支持。                                                                                                                                                                                                                                                                                                                 |\n| 5014  | 错误 | Failed to parse file '{0}': {1}.    未能分析文件“{0}”: {1}。                                                                                                                                                                                                                                                                                                     |\n| 5023  | 错误 | Unknown compiler option '{0}'.    未知的编译器选项“{0}”。                                                                                                                                                                                                                                                                                                        |\n| 5024  | 错误 | Compiler option '{0}' requires a value of type {1}.    编译器选项“{0}”需要类型 {1} 的值。                                                                                                                                                                                                                                                                        |\n| 5033  | 错误 | Could not write file '{0}': {1}    无法写入文件“{0}”: {1}                                                                                                                                                                                                                                                                                                        |\n| 5042  | 错误 | Option 'project' cannot be mixed with source files on a command line.    选项 \"project\" 在命令行上不能与源文件混合使用。                                                                                                                                                                                                                                         |\n| 5047  | 错误 | Option 'isolatedModules' can only be used when either option '--module' is provided or option 'target' is 'ES2015' or higher.    选项 \"isolatedModules\" 只可在提供了选项 \"--module\" 或者选项 \"target\" 是 \"ES2015\" 或更高版本时使用。                                                                                                                             |\n| 5051  | 错误 | Option '{0} can only be used when either option '--inlineSourceMap' or option '--sourceMap' is provided.    仅当提供了选项 \"--inlineSources\" 或选项 \"--sourceMap\" 时，才能使用选项 \"inlineSources\"。                                                                                                                                                             |\n| 5052  | 错误 | Option '{0}' cannot be specified without specifying option '{1}'.    无法在不指定选项“{1}”的情况下指定选项“{0}”。                                                                                                                                                                                                                                                |\n| 5053  | 错误 | Option '{0}' cannot be specified with option '{1}'.    选项“{0}”不能与选项“{1}”同时指定。                                                                                                                                                                                                                                                                        |\n| 5054  | 错误 | A 'tsconfig.json' file is already defined at: '{0}'.    已在“{0}”中定义了 \"tsconfig.json\" 文件。                                                                                                                                                                                                                                                                 |\n| 5055  | 错误 | Cannot write file '{0}' because it would overwrite input file.    无法写入文件“{0}”，因为它会覆盖输入文件。                                                                                                                                                                                                                                                      |\n| 5056  | 错误 | Cannot write file '{0}' because it would be overwritten by multiple input files.    无法写入文件“{0}”，因为它会被多个输入文件覆盖。                                                                                                                                                                                                                              |\n| 5057  | 错误 | Cannot find a tsconfig.json file at the specified directory: '{0}'    无法在指定目录找到 tsconfig.json 文件:“{0}”                                                                                                                                                                                                                                                |\n| 5058  | 错误 | The specified path does not exist: '{0}'    指定的路径不存在:“{0}”                                                                                                                                                                                                                                                                                               |\n| 5059  | 错误 | Invalid value for '--reactNamespace'. '{0}' is not a valid identifier.    Invalide value for '--reactNamespace'. '{0}' is not a valid identifier.                                                                                                                                                                                                                |\n| 5060  | 错误 | Option 'paths' cannot be used without specifying '--baseUrl' option.                                                                                                                                                                                                                                                                                             |\n| 5061  | 错误 | Pattern '{0}' can have at most one '*' character                                                                                                                                                                                                                                                                                                                 |\n| 5062  | 错误 | Substitution '{0}' in pattern '{1}' in can have at most one '*' character                                                                                                                                                                                                                                                                                        |\n| 5063  | 错误 | Substitutions for pattern '{0}' should be an array.                                                                                                                                                                                                                                                                                                              |\n| 5064  | 错误 | Substitution '{0}' for pattern '{1}' has incorrect type, expected 'string', got '{2}'.                                                                                                                                                                                                                                                                           |\n| 5065  | 错误 | File specification cannot contain a parent directory ('..') that appears after a recursive directory wildcard ('**'): '{0}'.                                                                                                                                                                                                                                     |\n| 5066  | 错误 | Substitutions for pattern '{0}' shouldn't be an empty array.                                                                                                                                                                                                                                                                                                     |\n| 5067  | 错误 | Invalid value for 'jsxFactory'. '{0}' is not a valid identifier or qualified-name.                                                                                                                                                                                                                                                                               |\n| 6001  | 信息 | Concatenate and emit output to single file.    连接输出并将其发出到单个文件。                                                                                                                                                                                                                                                                                    |\n| 6002  | 信息 | Generates corresponding '.d.ts' file.    生成相应的 \".d.ts\" 文件。                                                                                                                                                                                                                                                                                               |\n| 6003  | 信息 | Specify the location where debugger should locate map files instead of generated locations.    指定调试程序应放置映射文件的位置而不是生成的位置。                                                                                                                                                                                                                |\n| 6004  | 信息 | Specify the location where debugger should locate TypeScript files instead of source locations.    指定调试程序应放置 TypeScript 文件的位置而不是源位置。                                                                                                                                                                                                        |\n| 6005  | 信息 | Watch input files.    监视输入文件。                                                                                                                                                                                                                                                                                                                             |\n| 6006  | 信息 | Redirect output structure to the directory.    将输出结构重定向到目录。                                                                                                                                                                                                                                                                                          |\n| 6007  | 信息 | Do not erase const enum declarations in generated code.    请勿清除生成代码中的常数枚举声明。                                                                                                                                                                                                                                                                    |\n| 6008  | 信息 | Do not emit outputs if any errors were reported.    如果报告了任何错误，请不要发出输出。                                                                                                                                                                                                                                                                         |\n| 6009  | 信息 | Do not emit comments to output.    请勿将注释发出到输出。                                                                                                                                                                                                                                                                                                        |\n| 6010  | 信息 | Do not emit outputs.    请勿发出输出。                                                                                                                                                                                                                                                                                                                           |\n| 6011  | 信息 | Allow default imports from modules with no default export. This does not affect code emit, just typechecking.    允许从不带默认输出的模块中默认输入。这不会影响代码发出，只是类型检查。                                                                                                                                                                          |\n| 6012  | 信息 | Skip type checking of declaration files.                                                                                                                                                                                                                                                                                                                         |\n| 6015  | 信息 | Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'    指定 ECMAScript 目标版本: \"ES3\" (默认)、\"ES5\" 或 \"ES2015\" (实验)                                                                                                                                                                                         |\n| 6016  | 信息 | Specify module code generation: 'commonjs', 'amd', 'system', 'umd' or 'es2015'    指定模块代码生成: \"commonjs\"、\"amd\"、\"system\"、\"umd\" 或 \"es2015\"                                                                                                                                                                                                               |\n| 6017  | 信息 | Print this message.    打印此消息。                                                                                                                                                                                                                                                                                                                              |\n| 6019  | 信息 | Print the compiler's version.    打印编译器的版本。                                                                                                                                                                                                                                                                                                              |\n| 6020  | 信息 | Compile the project in the given directory.    在指定目录中编译项目。                                                                                                                                                                                                                                                                                            |\n| 6023  | 信息 | Syntax: {0}    语法: {0}                                                                                                                                                                                                                                                                                                                                         |\n| 6024  | 信息 | options    选项                                                                                                                                                                                                                                                                                                                                                  |\n| 6025  | 信息 | file    文件                                                                                                                                                                                                                                                                                                                                                     |\n| 6026  | 信息 | Examples: {0}    示例: {0}                                                                                                                                                                                                                                                                                                                                       |\n| 6027  | 信息 | Options:    选项:                                                                                                                                                                                                                                                                                                                                                |\n| 6029  | 信息 | Version {0}    版本 {0}                                                                                                                                                                                                                                                                                                                                          |\n| 6030  | 信息 | Insert command line options and files from a file.    从文件插入命令行选项和文件。                                                                                                                                                                                                                                                                               |\n| 6032  | 信息 | File change detected. Starting incremental compilation...    检测到文件更改。正在启动增量编译...                                                                                                                                                                                                                                                                 |\n| 6034  | 信息 | KIND    种类                                                                                                                                                                                                                                                                                                                                                     |\n| 6035  | 信息 | FILE    文件                                                                                                                                                                                                                                                                                                                                                     |\n| 6036  | 信息 | VERSION    版本                                                                                                                                                                                                                                                                                                                                                  |\n| 6037  | 信息 | LOCATION    位置                                                                                                                                                                                                                                                                                                                                                 |\n| 6038  | 信息 | DIRECTORY    目录                                                                                                                                                                                                                                                                                                                                                |\n| 6039  | 信息 | STRATEGY                                                                                                                                                                                                                                                                                                                                                         |\n| 6042  | 信息 | Compilation complete. Watching for file changes.    编译完成。查看文件更改。                                                                                                                                                                                                                                                                                     |\n| 6043  | 信息 | Generates corresponding '.map' file.    生成相应的 \".map\" 文件。                                                                                                                                                                                                                                                                                                 |\n| 6044  | 错误 | Compiler option '{0}' expects an argument.    编译器选项“{0}”需要参数。                                                                                                                                                                                                                                                                                          |\n| 6045  | 错误 | Unterminated quoted string in response file '{0}'.    响应文件“{0}”中引号不配对。                                                                                                                                                                                                                                                                                |\n| 6046  | 错误 | Argument for '{0}' option must be: {1}    Argument for '--module' option must be 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'none'.                                                                                                                                                                                                                        |\n| 6048  | 错误 | Locale must be of the form or - . For example '{0}' or '{1}'.    区域设置必须采用 <语言> 或 <语言>-<区域> 形式。例如“{0}”或“{1}”。                                                                                                                                                                                                                               |\n| 6049  | 错误 | Unsupported locale '{0}'.    区域设置“{0}”不受支持。                                                                                                                                                                                                                                                                                                             |\n| 6050  | 错误 | Unable to open file '{0}'.    无法打开文件“{0}”。                                                                                                                                                                                                                                                                                                                |\n| 6051  | 错误 | Corrupted locale file {0}.    区域设置文件 {0} 已损坏。                                                                                                                                                                                                                                                                                                          |\n| 6052  | 信息 | Raise error on expressions and declarations with an implied 'any' type.    对具有隐式 \"any\" 类型的表达式和声明引发错误。                                                                                                                                                                                                                                         |\n| 6053  | 错误 | File '{0}' not found.    找不到文件“{0}”。                                                                                                                                                                                                                                                                                                                       |\n| 6054  | 错误 | File '{0}' has unsupported extension. The only supported extensions are {1}.    不支持文件“{0}”的扩展名。唯一支持的扩展名为 {1}。                                                                                                                                                                                                                                |\n| 6055  | 信息 | Suppress noImplicitAny errors for indexing objects lacking index signatures.    抑制缺少索引签名的索引对象的 noImplicitAny 错误。                                                                                                                                                                                                                                |\n| 6056  | 信息 | Do not emit declarations for code that has an '@internal' annotation.    请勿对具有 \"@internal\" 注释的代码发出声明。                                                                                                                                                                                                                                             |\n| 6058  | 信息 | Specify the root directory of input files. Use to control the output directory structure with --outDir.    指定输入文件的根目录。与 --outDir 一起用于控制输出目录结构。                                                                                                                                                                                          |\n| 6059  | 错误 | File '{0}' is not under 'rootDir' '{1}'. 'rootDir' is expected to contain all source files.    文件“{0}”不在 \"rootDir\"“{1}”下。\"rootDir\" 应包含所有源文件。                                                                                                                                                                                                      |\n| 6060  | 信息 | Specify the end of line sequence to be used when emitting files: 'CRLF' (dos) or 'LF' (unix).    指定发出文件时要使用的行序列结尾: \"CRLF\" (dos)或 \"LF\" (unix)。                                                                                                                                                                                                  |\n| 6061  | 信息 | NEWLINE    换行符                                                                                                                                                                                                                                                                                                                                                |\n| 6064  | 错误 | Option '{0}' can only be specified in 'tsconfig.json' file.                                                                                                                                                                                                                                                                                                      |\n| 6065  | 信息 | Enables experimental support for ES7 decorators.    对 ES7 修饰器启用实验支持。                                                                                                                                                                                                                                                                                  |\n| 6066  | 信息 | Enables experimental support for emitting type metadata for decorators.    对发出修饰器的类型元数据启用实验支持。                                                                                                                                                                                                                                                |\n| 6068  | 信息 | Enables experimental support for ES7 async functions.    对 ES7 异步函数启用实验支持。                                                                                                                                                                                                                                                                           |\n| 6069  | 信息 | Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6).    指定模块解决策略: \"node\" (Node.js) 或 \"classic\" (TypeScript pre-1.6)。                                                                                                                                                                                                |\n| 6070  | 信息 | Initializes a TypeScript project and creates a tsconfig.json file.    初始化 TypeScript 项目并创建 tsconfig.json 文件。                                                                                                                                                                                                                                          |\n| 6071  | 信息 | Successfully created a tsconfig.json file.    已成功创建 tsconfig.json 文件。                                                                                                                                                                                                                                                                                    |\n| 6072  | 信息 | Suppress excess property checks for object literals.    取消对象文字的多余属性检查。                                                                                                                                                                                                                                                                             |\n| 6073  | 信息 | Stylize errors and messages using color and context. (experimental)    使用颜色和上下文风格化错误和消息。(实验)                                                                                                                                                                                                                                                  |\n| 6074  | 信息 | Do not report errors on unused labels.    不报告有关未使用的标签的错误。                                                                                                                                                                                                                                                                                         |\n| 6075  | 信息 | Report error when not all code paths in function return a value.    在函数中的所有代码路径并非都返回值时报告错误。                                                                                                                                                                                                                                               |\n| 6076  | 信息 | Report errors for fallthrough cases in switch statement.    报告 switch 语句中遇到 fallthrough 情况的错误。                                                                                                                                                                                                                                                      |\n| 6077  | 信息 | Do not report errors on unreachable code.    不报告有关不可访问的代码的错误。                                                                                                                                                                                                                                                                                    |\n| 6078  | 信息 | Disallow inconsistently-cased references to the same file.    不允许对同一文件采用大小不一致的引用。                                                                                                                                                                                                                                                             |\n| 6079  | 信息 | Specify library files to be included in the compilation:                                                                                                                                                                                                                                                                                                         |\n| 6080  | 信息 | Specify JSX code generation: 'preserve' or 'react'    指定 JSX 代码生成: \"preserve\" 或 \"react\"                                                                                                                                                                                                                                                                   |\n| 6081  | 信息 | File '{0}' has an unsupported extension, so skipping it.    \"--jsx\" 的参数必须为 \"preserve\" 或 \"react\"。                                                                                                                                                                                                                                                         |\n| 6082  | 错误 | Only 'amd' and 'system' modules are supported alongside --{0}.    --{0} 旁仅支持 \"amd\" 和 \"system\" 模块。                                                                                                                                                                                                                                                        |\n| 6083  | 信息 | Base directory to resolve non-absolute module names.    允许编译 JavaScript 文件。                                                                                                                                                                                                                                                                               |\n| 6084  | 信息 | Specify the object invoked for createElement and __spread when targeting 'react' JSX emit    Specifies the object invoked for createElement and__spread when targeting 'react' JSX emit                                                                                                                                                                          |\n| 6085  | 信息 | Enable tracing of the name resolution process.                                                                                                                                                                                                                                                                                                                   |\n| 6086  | 信息 | ======== Resolving module '{0}' from '{1}'. ========                                                                                                                                                                                                                                                                                                             |\n| 6087  | 信息 | Explicitly specified module resolution kind: '{0}'.                                                                                                                                                                                                                                                                                                              |\n| 6088  | 信息 | Module resolution kind is not specified, using '{0}'.                                                                                                                                                                                                                                                                                                            |\n| 6089  | 信息 | ======== Module name '{0}' was successfully resolved to '{1}'. ========                                                                                                                                                                                                                                                                                          |\n| 6090  | 信息 | ======== Module name '{0}' was not resolved. ========                                                                                                                                                                                                                                                                                                            |\n| 6091  | 信息 | 'paths' option is specified, looking for a pattern to match module name '{0}'.                                                                                                                                                                                                                                                                                   |\n| 6092  | 信息 | Module name '{0}', matched pattern '{1}'.                                                                                                                                                                                                                                                                                                                        |\n| 6093  | 信息 | Trying substitution '{0}', candidate module location: '{1}'.                                                                                                                                                                                                                                                                                                     |\n| 6094  | 信息 | Resolving module name '{0}' relative to base url '{1}' - '{2}'.                                                                                                                                                                                                                                                                                                  |\n| 6095  | 信息 | Loading module as file / folder, candidate module location '{0}', target file type '{1}'.                                                                                                                                                                                                                                                                        |\n| 6096  | 信息 | File '{0}' does not exist.                                                                                                                                                                                                                                                                                                                                       |\n| 6097  | 信息 | File '{0}' exist - use it as a name resolution result.                                                                                                                                                                                                                                                                                                           |\n| 6098  | 信息 | Loading module '{0}' from 'node_modules' folder, target file type '{1}'.                                                                                                                                                                                                                                                                                         |\n| 6099  | 信息 | Found 'package.json' at '{0}'.                                                                                                                                                                                                                                                                                                                                   |\n| 6100  | 信息 | 'package.json' does not have a 'types' or 'main' field.                                                                                                                                                                                                                                                                                                          |\n| 6101  | 信息 | 'package.json' has '{0}' field '{1}' that references '{2}'.                                                                                                                                                                                                                                                                                                      |\n| 6102  | 信息 | Allow javascript files to be compiled.                                                                                                                                                                                                                                                                                                                           |\n| 6103  | 错误 | Option '{0}' should have array of strings as a value.    Option '{0}' should have array of strings as a value.                                                                                                                                                                                                                                                   |\n| 6104  | 信息 | Checking if '{0}' is the longest matching prefix for '{1}' - '{2}'.                                                                                                                                                                                                                                                                                              |\n| 6105  | 信息 | Expected type of '{0}' field in 'package.json' to be 'string', got '{1}'.                                                                                                                                                                                                                                                                                        |\n| 6106  | 信息 | 'baseUrl' option is set to '{0}', using this value to resolve non-relative module name '{1}'                                                                                                                                                                                                                                                                     |\n| 6107  | 信息 | 'rootDirs' option is set, using it to resolve relative module name '{0}'                                                                                                                                                                                                                                                                                         |\n| 6108  | 信息 | Longest matching prefix for '{0}' is '{1}'                                                                                                                                                                                                                                                                                                                       |\n| 6109  | 信息 | Loading '{0}' from the root dir '{1}', candidate location '{2}'                                                                                                                                                                                                                                                                                                  |\n| 6110  | 信息 | Trying other entries in 'rootDirs'                                                                                                                                                                                                                                                                                                                               |\n| 6111  | 信息 | Module resolution using 'rootDirs' has failed                                                                                                                                                                                                                                                                                                                    |\n| 6112  | 信息 | Do not emit 'use strict' directives in module output.    Do not emit 'use strict' directives in module output.                                                                                                                                                                                                                                                   |\n| 6113  | 信息 | Enable strict null checks.                                                                                                                                                                                                                                                                                                                                       |\n| 6114  | 错误 | Unknown option 'excludes'. Did you mean 'exclude'?                                                                                                                                                                                                                                                                                                               |\n| 6115  | 信息 | Raise error on 'this' expressions with an implied 'any' type.                                                                                                                                                                                                                                                                                                    |\n| 6116  | 信息 | ======== Resolving type reference directive '{0}', containing file '{1}', root directory '{2}'. ========                                                                                                                                                                                                                                                         |\n| 6117  | 信息 | Resolving using primary search paths...                                                                                                                                                                                                                                                                                                                          |\n| 6118  | 信息 | Resolving from node_modules folder...                                                                                                                                                                                                                                                                                                                            |\n| 6119  | 信息 | ======== Type reference directive '{0}' was successfully resolved to '{1}', primary: {2}. ========                                                                                                                                                                                                                                                               |\n| 6120  | 信息 | ======== Type reference directive '{0}' was not resolved. ========                                                                                                                                                                                                                                                                                               |\n| 6121  | 信息 | Resolving with primary search path '{0}'                                                                                                                                                                                                                                                                                                                         |\n| 6122  | 信息 | Root directory cannot be determined, skipping primary search paths.                                                                                                                                                                                                                                                                                              |\n| 6123  | 信息 | ======== Resolving type reference directive '{0}', containing file '{1}', root directory not set. ========                                                                                                                                                                                                                                                       |\n| 6124  | 信息 | Type declaration files to be included in compilation.                                                                                                                                                                                                                                                                                                            |\n| 6125  | 信息 | Looking up in 'node_modules' folder, initial location '{0}'                                                                                                                                                                                                                                                                                                      |\n| 6126  | 信息 | Containing file is not specified and root directory cannot be determined, skipping lookup in 'node_modules' folder.                                                                                                                                                                                                                                              |\n| 6127  | 信息 | ======== Resolving type reference directive '{0}', containing file not set, root directory '{1}'. ========                                                                                                                                                                                                                                                       |\n| 6128  | 信息 | ======== Resolving type reference directive '{0}', containing file not set, root directory not set. ========                                                                                                                                                                                                                                                     |\n| 6129  | 错误 | The config file '{0}' found doesn't contain any source files.                                                                                                                                                                                                                                                                                                    |\n| 6130  | 信息 | Resolving real path for '{0}', result '{1}'                                                                                                                                                                                                                                                                                                                      |\n| 6131  | 错误 | Cannot compile modules using option '{0}' unless the '--module' flag is 'amd' or 'system'.                                                                                                                                                                                                                                                                       |\n| 6132  | 信息 | File name '{0}' has a '{1}' extension - stripping it                                                                                                                                                                                                                                                                                                             |\n| 6133  | 错误 | '{0}' is declared but never used.                                                                                                                                                                                                                                                                                                                                |\n| 6134  | 信息 | Report errors on unused locals.                                                                                                                                                                                                                                                                                                                                  |\n| 6135  | 信息 | Report errors on unused parameters.                                                                                                                                                                                                                                                                                                                              |\n| 6136  | 信息 | The maximum dependency depth to search under node_modules and load JavaScript files                                                                                                                                                                                                                                                                              |\n| 6137  | 信息 | No types specified in 'package.json', so returning 'main' value of '{0}'                                                                                                                                                                                                                                                                                         |\n| 6138  | 错误 | Property '{0}' is declared but never used.                                                                                                                                                                                                                                                                                                                       |\n| 6139  | 信息 | Import emit helpers from 'tslib'.                                                                                                                                                                                                                                                                                                                                |\n| 6140  | 错误 | Auto discovery for typings is enabled in project '{0}'. Running extra resolution pass for module '{1}' using cache location '{2}'.                                                                                                                                                                                                                               |\n| 6141  | 信息 | Parse in strict mode and emit \"use strict\" for each source file                                                                                                                                                                                                                                                                                                  |\n| 6142  | 错误 | Module '{0}' was resolved to '{1}', but '--jsx' is not set.                                                                                                                                                                                                                                                                                                      |\n| 6143  | 错误 | Module '{0}' was resolved to '{1}', but '--allowJs' is not set.                                                                                                                                                                                                                                                                                                  |\n| 6144  | 信息 | Module '{0}' was resolved as locally declared ambient module in file '{1}'.                                                                                                                                                                                                                                                                                      |\n| 6145  | 信息 | Module '{0}' was resolved as ambient module declared in '{1}' since this file was not modified.                                                                                                                                                                                                                                                                  |\n| 6146  | 信息 | Specify the JSX factory function to use when targeting 'react' JSX emit, e.g. 'React.createElement' or 'h'.                                                                                                                                                                                                                                                      |\n| 6147  | 信息 | Resolution for module '{0}' was found in cache.                                                                                                                                                                                                                                                                                                                  |\n| 6148  | 信息 | Directory '{0}' does not exist, skipping all lookups in it.                                                                                                                                                                                                                                                                                                      |\n| 7005  | 错误 | Variable '{0}' implicitly has an '{1}' type.    变量“{0}”隐式具有“{1}”类型。                                                                                                                                                                                                                                                                                     |\n| 7006  | 错误 | Parameter '{0}' implicitly has an '{1}' type.    参数“{0}”隐式具有“{1}”类型。                                                                                                                                                                                                                                                                                    |\n| 7008  | 错误 | Member '{0}' implicitly has an '{1}' type.    成员“{0}”隐式包含类型“{1}”。                                                                                                                                                                                                                                                                                       |\n| 7009  | 错误 | 'new' expression, whose target lacks a construct signature, implicitly has an 'any' type.    其目标缺少构造签名的 \"new\" 表达式隐式具有 \"any\" 类型。                                                                                                                                                                                                              |\n| 7010  | 错误 | '{0}', which lacks return-type annotation, implicitly has an '{1}' return type.    缺少返回类型批注的“{0}”隐式具有“{1}”返回类型。                                                                                                                                                                                                                                |\n| 7011  | 错误 | Function expression, which lacks return-type annotation, implicitly has an '{0}' return type.    缺少返回类型批注的函数表达式隐式具有“{0}”返回类型。                                                                                                                                                                                                             |\n| 7013  | 错误 | Construct signature, which lacks return-type annotation, implicitly has an 'any' return type.    缺少返回类型批注的构造签名隐式具有返回类型 \"any\"。                                                                                                                                                                                                              |\n| 7015  | 错误 | Element implicitly has an 'any' type because index expression is not of type 'number'.    Element implicitly has an 'any' type because index expression is not of type 'number'.                                                                                                                                                                                 |\n| 7016  | 错误 | Could not find a declaration file for module '{0}'. '{1}' implicitly has an 'any' type.    属性“{0}”隐式具有类型 \"any\"，因为其 \"set\" 访问器缺少类型批注。                                                                                                                                                                                                        |\n| 7017  | 错误 | Element implicitly has an 'any' type because type '{0}' has no index signature.    对象类型的索引签名隐式地含有 \"any\" 类型。                                                                                                                                                                                                                                     |\n| 7018  | 错误 | Object literal's property '{0}' implicitly has an '{1}' type.    对象文字的属性“{0}”隐式含有“{1}”类型。                                                                                                                                                                                                                                                          |\n| 7019  | 错误 | Rest parameter '{0}' implicitly has an 'any[]' type.    Rest 参数“{0}”隐式具有 \"any[]\" 类型。                                                                                                                                                                                                                                                                    |\n| 7020  | 错误 | Call signature, which lacks return-type annotation, implicitly has an 'any' return type.    缺少返回类型批注的调用签名隐式具有返回类型 \"any\"。                                                                                                                                                                                                                   |\n| 7022  | 错误 | '{0}' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.    “{0}”隐式具有类型 \"any\"，因为它不具有类型批注，且在其自身的初始化表达式中得到直接或间接引用。                                                                                                                     |\n| 7023  | 错误 | '{0}' implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.    由于“{0}'”不具有返回类型批注并且在它的一个返回表达式中得到直接或间接引用，因此它隐式具有返回类型 \"any\"。                                                                                  |\n| 7024  | 错误 | Function implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.    由于函数不具有返回类型批注并且在它的一个返回表达式中得到直接或间接引用，因此它隐式具有返回类型 \"any\"。                                                                                 |\n| 7025  | 错误 | Generator implicitly has type '{0}' because it does not yield any values. Consider supplying a return type.    生成器隐式具有类型“{0}”，因为它不生成任何值。请考虑提供一个返回类型。                                                                                                                                                                             |\n| 7026  | 错误 | JSX element implicitly has type 'any' because no interface 'JSX.{0}' exists    JSX 元素隐式具有类型 \"any\"，因为不存在接口“JSX.{0}”                                                                                                                                                                                                                               |\n| 7027  | 错误 | Unreachable code detected.    检测到无法访问的代码。                                                                                                                                                                                                                                                                                                             |\n| 7028  | 错误 | Unused label.    未使用的标签。                                                                                                                                                                                                                                                                                                                                  |\n| 7029  | 错误 | Fallthrough case in switch.    switch 语句中的 Fallthrough 情况。                                                                                                                                                                                                                                                                                                |\n| 7030  | 错误 | Not all code paths return a value.    并非所有代码路径都返回值。                                                                                                                                                                                                                                                                                                 |\n| 7031  | 错误 | Binding element '{0}' implicitly has an '{1}' type.                                                                                                                                                                                                                                                                                                              |\n| 7032  | 错误 | Property '{0}' implicitly has type 'any', because its set accessor lacks a parameter type annotation.                                                                                                                                                                                                                                                            |\n| 7033  | 错误 | Property '{0}' implicitly has type 'any', because its get accessor lacks a return type annotation.                                                                                                                                                                                                                                                               |\n| 7034  | 错误 | Variable '{0}' implicitly has type '{1}' in some locations where its type cannot be determined.                                                                                                                                                                                                                                                                  |\n| 8000  | 错误 | You cannot rename this element.    无法重命名此元素。                                                                                                                                                                                                                                                                                                            |\n| 8001  | 错误 | You cannot rename elements that are defined in the standard TypeScript library.    不能重命名标准 TypeScript 库中定义的元素。                                                                                                                                                                                                                                    |\n| 8002  | 错误 | 'import ... =' can only be used in a .ts file.    \"import ... =\" 只能在 .ts 文件中使用。                                                                                                                                                                                                                                                                         |\n| 8003  | 错误 | 'export=' can only be used in a .ts file.    \"export=\" 只能在 .ts 文件中使用。                                                                                                                                                                                                                                                                                   |\n| 8004  | 错误 | 'type parameter declarations' can only be used in a .ts file.    \"type parameter declarations\" 只能在 .ts 文件中使用。                                                                                                                                                                                                                                           |\n| 8005  | 错误 | 'implements clauses' can only be used in a .ts file.    \"implements clauses\" 只能在 .ts 文件中使用。                                                                                                                                                                                                                                                             |\n| 8006  | 错误 | 'interface declarations' can only be used in a .ts file.    \"interface declarations\" 只能在 .ts 文件中使用。                                                                                                                                                                                                                                                     |\n| 8007  | 错误 | 'module declarations' can only be used in a .ts file.    \"module declarations\" 只能在 .ts 文件中使用。                                                                                                                                                                                                                                                           |\n| 8008  | 错误 | 'type aliases' can only be used in a .ts file.    \"type aliases\" 只能在 .ts 文件中使用。                                                                                                                                                                                                                                                                         |\n| 8009  | 错误 | '{0}' can only be used in a .ts file.    “{0}”只能在 .ts 文件中使用。                                                                                                                                                                                                                                                                                            |\n| 8010  | 错误 | 'types' can only be used in a .ts file.    \"types\" 只能在 .ts 文件中使用。                                                                                                                                                                                                                                                                                       |\n| 8011  | 错误 | 'type arguments' can only be used in a .ts file.    \"type arguments\" 只能在 .ts 文件中使用。                                                                                                                                                                                                                                                                     |\n| 8012  | 错误 | 'parameter modifiers' can only be used in a .ts file.    \"parameter modifiers\" 只能在 .ts 文件中使用。                                                                                                                                                                                                                                                           |\n| 8015  | 错误 | 'enum declarations' can only be used in a .ts file.    \"enum declarations\" 只能在 .ts 文件中使用。                                                                                                                                                                                                                                                               |\n| 8016  | 错误 | 'type assertion expressions' can only be used in a .ts file.    \"type assertion expressions\" 只能在 .ts 文件中使用。                                                                                                                                                                                                                                             |\n| 9002  | 错误 | Only identifiers/qualified-names with optional type arguments are currently supported in a class 'extends' clauses.    类 \"extends\" 子句当前只支持具有可选类型参数的标识符/限定名称。                                                                                                                                                                            |\n| 9003  | 错误 | 'class' expressions are not currently supported.    当前不支持 \"class\" 表达式。                                                                                                                                                                                                                                                                                  |\n| 9004  | 错误 | Language service is disabled.                                                                                                                                                                                                                                                                                                                                    |\n| 17000 | 错误 | JSX attributes must only be assigned a non-empty 'expression'.    只能为 JSX 属性分配非空“表达式”。                                                                                                                                                                                                                                                              |\n| 17001 | 错误 | JSX elements cannot have multiple attributes with the same name.    JSX 元素不能具有多个名称相同的特性。                                                                                                                                                                                                                                                         |\n| 17002 | 错误 | Expected corresponding JSX closing tag for '{0}'.    “{0}”预期的相应 JSX 结束标记。                                                                                                                                                                                                                                                                              |\n| 17003 | 错误 | JSX attribute expected.    需要 JSX 属性。                                                                                                                                                                                                                                                                                                                       |\n| 17004 | 错误 | Cannot use JSX unless the '--jsx' flag is provided.    无法使用 JSX，除非提供了 \"--jsx\" 标志。                                                                                                                                                                                                                                                                   |\n| 17005 | 错误 | A constructor cannot contain a 'super' call when its class extends 'null'    当构造函数的类扩展 \"null\" 时，它不能包含 \"super\" 调用。                                                                                                                                                                                                                             |\n| 17006 | 错误 | An unary expression with the '{0}' operator is not allowed in the left-hand side of an exponentiation expression. Consider enclosing the expression in parentheses.    乘方表达式的左侧不允许存在具有“{0}”运算符的一元表达式。请考虑用括号将表达式括起。                                                                                                         |\n| 17007 | 错误 | A type assertion expression is not allowed in the left-hand side of an exponentiation expression. Consider enclosing the expression in parentheses.    乘方表达式的左侧不允许出现类型断言表达式。请考虑用括号将表达式括起。                                                                                                                                      |\n| 17008 | 错误 | JSX element '{0}' has no corresponding closing tag.    JSX element '{0}' has no corresponding closing tag.                                                                                                                                                                                                                                                       |\n| 17009 | 错误 | 'super' must be called before accessing 'this' in the constructor of a derived class.    'super' must be called before accessing 'this' in the constructor of a derived class.                                                                                                                                                                                   |\n| 17010 | 错误 | Unknown type acquisition option '{0}'.    Unknown typing option '{0}'.                                                                                                                                                                                                                                                                                           |\n| 17011 | 错误 | 'super' must be called before accessing a property of 'super' in the constructor of a derived class.                                                                                                                                                                                                                                                             |\n| 17012 | 错误 | '{0}' is not a valid meta-property for keyword '{1}'. Did you mean '{0}'?    Too many JavaScript files in the project. Consider specifying the 'exclude' setting in project configuration to limit included source folders. The likely folder to exclude is '{0}'. To disable the project size limit, set the 'disableSizeLimit' compiler option to 'true'.      |\n| 17013 | 错误 | Meta-property '{0}' is only allowed in the body of a function declaration, function expression, or constructor.                                                                                                                                                                                                                                                  |\n| 18000 | 错误 | Circularity detected while resolving configuration: {0}                                                                                                                                                                                                                                                                                                          |\n| 18001 | 错误 | A path in an 'extends' option must be relative or rooted, but '{0}' is not.                                                                                                                                                                                                                                                                                      |\n| 18002 | 错误 | The 'files' list in config file '{0}' is empty.                                                                                                                                                                                                                                                                                                                  |\n| 18003 | 错误 | No inputs were found in config file '{0}'. Specified 'include' paths were '{1}' and 'exclude' paths were '{2}'.                                                                                                                                                                                                                                                  |\n| 90001 | 信息 | Add missing 'super()' call.                                                                                                                                                                                                                                                                                                                                      |\n| 90002 | 信息 | Make 'super()' call the first statement in the constructor.                                                                                                                                                                                                                                                                                                      |\n| 90003 | 信息 | Change 'extends' to 'implements'.                                                                                                                                                                                                                                                                                                                                |\n| 90004 | 信息 | Remove unused identifiers.                                                                                                                                                                                                                                                                                                                                       |\n| 90006 | 信息 | Implement interface '{0}'.                                                                                                                                                                                                                                                                                                                                       |\n| 90007 | 信息 | Implement inherited abstract class.                                                                                                                                                                                                                                                                                                                              |\n| 90009 | 错误 | Adding a tsconfig.json file will help organize projects that contain both TypeScript and JavaScript files. Learn more at <https://aka.ms/tsconfig>                                                                                                                                                                                                               |\n| 90010 | 错误 | Type '{0}' is not assignable to type '{1}'. Two different types with this name exist, but they are unrelated.                                                                                                                                                                                                                                                    |\n| 90013 | 信息 | Import {0} from {1}                                                                                                                                                                                                                                                                                                                                              |\n| 90014 | 信息 | Change {0} to {1}                                                                                                                                                                                                                                                                                                                                                |\n| 90015 | 信息 | Add {0} to existing import declaration from {1}                                                                                                                                                                                                                                                                                                                  |\n| 8017  | 错误 | Octal literal types must use ES2015 syntax. Use the syntax '{0}'.                                                                                                                                                                                                                                                                                                |\n| 8018  | 错误 | Octal literals are not allowed in enums members initializer. Use the syntax '{0}'.                                                                                                                                                                                                                                                                               |\n","children":[]},{"name":"README.md","path":"../guanruihua.github.io/TypeScript","data":"# [ruihuag](https://guanruihua.github.io/#/)\r\n\r\n<!-- ![](../__assets__/001.jpg) -->\r\n<!-- ![Metrics](https://metrics.lecoq.io/guanruihua?template=classic&isocalendar=1&languages=1&base=header%2C%20activity%2C%20community%2C%20repositories%2C%20metadata&base.indepth=false&base.hireable=false&base.skip=false&isocalendar=false&isocalendar.duration=half-year&languages=false&languages.limit=8&languages.threshold=0%25&languages.other=false&languages.colors=github&languages.sections=most-used&languages.indepth=false&languages.analysis.timeout=15&languages.categories=markup%2C%20programming&languages.recent.categories=markup%2C%20programming&languages.recent.load=300&languages.recent.days=14&config.timezone=Asia%2FShanghai) -->\r\n","children":[]},{"name":"ts.md","path":"../guanruihua.github.io/TypeScript","data":"# TypeScript\n\n> - [JSX · TypeScript中文网 · TypeScript——JavaScript的超集 (tslang.cn)](https://www.tslang.cn/docs/handbook/jsx.html)\n> - [lib.d.ts | 深入理解 TypeScript (jkchao.github.io)](https://jkchao.github.io/typescript-book-chinese/typings/lib.html#使用例子)\n> - 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。\n> - 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。下图显示了 TypeScript 与 ES5、ES2015 和 ES2016 之间的关系：\n\n## 获取 TypeScript\n\n> 命令行的 TypeScript 编译器可以使用 Node.js 包来安装。\n\n### 1.安装 TypeScript\n\n> `$ npm install -g typescript`\n\n### 2.编译 TypeScript 文件\n\n$ tsc helloworld.ts\n helloworld.ts => helloworld.js\n\nTypeScript 在线平台 Playground：www.typescriptlang.org/play/\n\n## TypeScript 基础类型\n\n```ts\nBoolean 类型\nlet isDone: boolean = false;\n// ES5：var isDone = false;\n\nNumber 类型\nlet count: number = 10;\n// ES5：var count = 10;\n\nString 类型\nlet name: string = \"Ruihuag\";\n// ES5：var name = 'Ruihuag';\n\nArray 类型\nlet list: number[] = [1, 2, 3];\n// ES5：var list = [1,2,3];\n\nlet list: Array<number> = [1, 2, 3]; // Array<number>泛型语法\n// ES5：var list = [1,2,3];\n```\n\n## Enum 类型\n\n使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举。\n\n### 数字枚举\n\n```ts\nenum Direction {\n  NORTH,\n  SOUTH,\n  EAST,\n  WEST,\n}\n\nlet dir: Direction = Direction.NORTH;\n```\n\n> 默认情况下，NORTH 的初始值为 0，其余的成员会从 1 开始自动增长。\n>\n> 换句话说，Direction.SOUTH 的值为 1，Direction.EAST 的值为 2，Direction.WEST 的值为 3。上面的枚举示例代码经过编译后会生成以下代码：\n\n```ts\n\"use strict\";\nvar Direction;\n(function (Direction) {\n  Direction[(Direction[\"NORTH\"] = 0)] = \"NORTH\";\n  Direction[(Direction[\"SOUTH\"] = 1)] = \"SOUTH\";\n  Direction[(Direction[\"EAST\"] = 2)] = \"EAST\";\n  Direction[(Direction[\"WEST\"] = 3)] = \"WEST\";\n})(Direction || (Direction = {}));\nvar dir = Direction.NORTH;\n当然我们也可以设置 NORTH 的初始值，比如：\nenum Direction {\n  NORTH = 3,\n  SOUTH,\n  EAST,\n  WEST,\n}\n```\n\n### 字符串枚举\n\n```JS\n在 TypeScript 2.4 版本，允许我们使用字符串枚举。在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。\nenum Direction {\n  NORTH = \"NORTH\",\n  SOUTH = \"SOUTH\",\n  EAST = \"EAST\",\n  WEST = \"WEST\",\n}\n以上代码对于的 ES5 代码如下：\n\"use strict\";\nvar Direction;\n(function (Direction) {\n    Direction[\"NORTH\"] = \"NORTH\";\n    Direction[\"SOUTH\"] = \"SOUTH\";\n    Direction[\"EAST\"] = \"EAST\";\n    Direction[\"WEST\"] = \"WEST\";\n})(Direction || (Direction = {}));\n```\n\n### 异构枚举\n\n```JS\n异构枚举的成员值是数字和字符串的混合：\nenum Enum {\n  A,\n  B,\n  C = \"C\",\n  D = \"D\",\n  E = 8,\n  F,\n}\n以上代码对于的 ES5 代码如下：\n\"use strict\";\nvar Enum;\n(function (Enum) {\n    Enum[Enum[\"A\"] = 0] = \"A\";\n    Enum[Enum[\"B\"] = 1] = \"B\";\n    Enum[\"C\"] = \"C\";\n    Enum[\"D\"] = \"D\";\n    Enum[Enum[\"E\"] = 8] = \"E\";\n    Enum[Enum[\"F\"] = 9] = \"F\";\n})(Enum || (Enum = {}));\n通过观察上述生成的 ES5 代码，我们可以发现数字枚举相对字符串枚举多了 “反向映射”：\nconsole.log(Enum.A) //输出：0\nconsole.log(Enum[0]) // 输出：A\n2.6 Any 类型\n在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的顶级类型（也被称作全局超级类型）。\nlet notSure: any = 666;\nnotSure = \"Ruihuag\";\nnotSure = false;\nany 类型本质上是类型系统的一个逃逸舱。作为开发者，这给了我们很大的自由：TypeScript 允许我们对 any 类型的值执行任何操作，而无需事先执行任何形式的检查。比如：\nlet value: any;\n\nvalue.foo.bar; // OK\nvalue.trim(); // OK\nvalue(); // OK\nnew value(); // OK\nvalue[0][1]; // OK\n在许多场景下，这太宽松了。使用 any 类型，可以很容易地编写类型正确但在运行时有问题的代码。如果我们使用 any 类型，就无法使用 TypeScript 提供的大量的保护机制。为了解决 any 带来的问题，TypeScript 3.0 引入了 unknown 类型。\n2.7 Unknown 类型\n就像所有类型都可以赋值给 any，所有类型也都可以赋值给 unknown。这使得 unknown 成为 TypeScript 类型系统的另一种顶级类型（另一种是 any）。下面我们来看一下 unknown 类型的使用示例：\nlet value: unknown;\n\nvalue = true; // OK\nvalue = 42; // OK\nvalue = \"Hello World\"; // OK\nvalue = []; // OK\nvalue = {}; // OK\nvalue = Math.random; // OK\nvalue = null; // OK\nvalue = undefined; // OK\nvalue = new TypeError(); // OK\nvalue = Symbol(\"type\"); // OK\n对 value 变量的所有赋值都被认为是类型正确的。但是，当我们尝试将类型为 unknown 的值赋值给其他类型的变量时会发生什么？\nlet value: unknown;\n\nlet value1: unknown = value; // OK\nlet value2: any = value; // OK\nlet value3: boolean = value; // Error\nlet value4: number = value; // Error\nlet value5: string = value; // Error\nlet value6: object = value; // Error\nlet value7: any[] = value; // Error\nlet value8: Function = value; // Error\nunknown 类型只能被赋值给 any 类型和 unknown 类型本身。直观地说，这是有道理的：只有能够保存任意类型值的容器才能保存 unknown 类型的值。毕竟我们不知道变量 value 中存储了什么类型的值。\n现在让我们看看当我们尝试对类型为 unknown 的值执行操作时会发生什么。以下是我们在之前 any 章节看过的相同操作：\nlet value: unknown;\n\nvalue.foo.bar; // Error\nvalue.trim(); // Error\nvalue(); // Error\nnew value(); // Error\nvalue[0][1]; // Error\n将 value 变量类型设置为 unknown 后，这些操作都不再被认为是类型正确的。通过将 any 类型改变为 unknown 类型，我们已将允许所有更改的默认设置，更改为禁止任何更改。\n2.8 Tuple 类型\n众所周知，数组一般由同种类型的值组成，但有时我们需要在单个变量中存储不同类型的值，这时候我们就可以使用元组。在 JavaScript 中是没有元组的，元组是 TypeScript 中特有的类型，其工作方式类似于数组。\n元组可用于定义具有有限数量的未命名属性的类型。每个属性都有一个关联的类型。使用元组时，必须提供每个属性的值。为了更直观地理解元组的概念，我们来看一个具体的例子：\nlet tupleType: [string, boolean];\ntupleType = [\"Ruihuag\", true];\n在上面代码中，我们定义了一个名为 tupleType 的变量，它的类型是一个类型数组 [string, boolean]，然后我们按照正确的类型依次初始化 tupleType 变量。与数组一样，我们可以通过下标来访问元组中的元素：\nconsole.log(tupleType[0]); // Ruihuag\nconsole.log(tupleType[1]); // true\n在元组初始化的时候，如果出现类型不匹配的话，比如：\ntupleType = [true, \"Ruihuag\"];\n此时，TypeScript 编译器会提示以下错误信息：\n[0]: Type 'true' is not assignable to type 'string'.\n[1]: Type 'string' is not assignable to type 'boolean'.\n很明显是因为类型不匹配导致的。在元组初始化的时候，我们还必须提供每个属性的值，不然也会出现错误，比如：\ntupleType = [\"Ruihuag\"];\n此时，TypeScript 编译器会提示以下错误信息：\nProperty '1' is missing in type '[string]' but required in type '[string, boolean]'.\n2.9 Void 类型\n某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void：\n// 声明函数返回值为void\nfunction warnUser(): void {\n  console.log(\"This is my warning message\");\n}\n以上代码编译生成的 ES5 代码如下：\n\"use strict\";\nfunction warnUser() {\n  console.log(\"This is my warning message\");\n}\n需要注意的是，声明一个 void 类型的变量没有什么作用，因为它的值只能为 undefined 或 null：\nlet unusable: void = undefined;\n2.10 Null 和 Undefined 类型\nTypeScript 里，undefined 和 null 两者有各自的类型分别为 undefined 和 null。\nlet u: undefined = undefined;\nlet n: null = null;\n默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。然而，如果你指定了--strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自的类型。\n2.11 Never 类型\nnever 类型表示的是那些永不存在的值的类型。 例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。\n// 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never {\n  throw new Error(message);\n}\n\nfunction infiniteLoop(): never {\n  while (true) {}\n}\n在 TypeScript 中，可以利用 never 类型的特性来实现全面性检查，具体示例如下：\ntype Foo = string | number;\n\nfunction controlFlowAnalysisWithNever(foo: Foo) {\n  if (typeof foo === \"string\") {\n    // 这里 foo 被收窄为 string 类型\n  } else if (typeof foo === \"number\") {\n    // 这里 foo 被收窄为 number 类型\n  } else {\n    // foo 在这里是 never\n    const check: never = foo;\n  }\n}\n注意在 else 分支里面，我们把收窄为 never 的 foo 赋值给一个显示声明的 never 变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 Foo 的类型：\ntype Foo = string | number | boolean;\n然而他忘记同时修改 controlFlowAnalysisWithNever 方法中的控制流程，这时候 else 分支的 foo 类型会被收窄为 boolean 类型，导致无法赋值给 never 类型，这时就会产生一个编译错误。通过这个方式，我们可以确保\ncontrolFlowAnalysisWithNever 方法总是穷尽了 Foo 的所有可能类型。 通过这个示例，我们可以得出一个结论：使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。\n```\n\n三、TypeScript 断言\n有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。\n通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。\n类型断言有两种形式：\n3.1 “尖括号” 语法\nlet someValue: any = \"this is a string\";\nlet strLength: number = (<string>someValue).length;\n3.2 as 语法\nlet someValue: any = \"this is a string\";\nlet strLength: number = (someValue as string).length;\n复四、类型守卫\n\nA type guard is some expression that performs a runtime check that guarantees the type in some scope. —— TypeScript 官方文档\n\n类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。换句话说，类型保护可以保证一个字符串是一个字符串，尽管它的值也可以是一个数值。类型保护与特性检测并不是完全不同，其主要思想是尝试检测属性、方法或原型，以确定如何处理值。目前主要有四种的方式来实现类型保护：\n4.1 in 关键字\ninterface Admin {\n  name: string;\n  privileges: string[];\n}\n\ninterface Employee {\n  name: string;\n  startDate: Date;\n}\n\ntype UnknownEmployee = Employee | Admin;\n\nfunction printEmployeeInformation(emp: UnknownEmployee) {\n  console.log(\"Name: \" + emp.name);\n  if (\"privileges\" in emp) {\n    console.log(\"Privileges: \" + emp.privileges);\n  }\n  if (\"startDate\" in emp) {\n    console.log(\"Start Date: \" + emp.startDate);\n  }\n}\n4.2 typeof 关键字\nfunction padLeft(value: string, padding: string | number) {\n  if (typeof padding === \"number\") {\n      return Array(padding + 1).join(\" \") + value;\n  }\n  if (typeof padding === \"string\") {\n      return padding + value;\n  }\n  throw new Error(`Expected string or number, got '${padding}'.`);\n}\ntypeof 类型保护只支持两种形式：typeof v === \"typename\" 和 typeof v !== typename，\"typename\" 必须是 \"number\"， \"string\"， \"boolean\" 或 \"symbol\"。 但是 TypeScript 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。\n4.3 instanceof 关键字\ninterface Padder {\n  getPaddingString(): string;\n}\n\nclass SpaceRepeatingPadder implements Padder {\n  constructor(private numSpaces: number) {}\n  getPaddingString() {\n    return Array(this.numSpaces + 1).join(\" \");\n  }\n}\n\nclass StringPadder implements Padder {\n  constructor(private value: string) {}\n  getPaddingString() {\n    return this.value;\n  }\n}\n\nlet padder: Padder = new SpaceRepeatingPadder(6);\n\nif (padder instanceof SpaceRepeatingPadder) {\n  // padder的类型收窄为 'SpaceRepeatingPadder'\n}\n4.4 自定义类型保护的类型谓词\nfunction isNumber(x: any): x is number {\n  return typeof x === \"number\";\n}\n\nfunction isString(x: any): x is string {\n  return typeof x === \"string\";\n}\n五、联合类型和类型别名\n5.1 联合类型\n联合类型通常与 null 或 undefined 一起使用：\nconst sayHello = (name: string | undefined) => {\n  /*...*/\n};\n例如，这里 name 的类型是 string | undefined 意味着可以将 string 或 undefined 的值传递给sayHello 函数。\nsayHello(\"Ruihuag\");\nsayHello(undefined);\n通过这个示例，你可以凭直觉知道类型 A 和类型 B 联合后的类型是同时接受 A 和 B 值的类型。\n5.2 可辨识联合\nTypeScript 可辨识联合（Discriminated Unions）类型，也称为代数数据类型或标签联合类型。它包含 3 个要点：可辨识、联合类型和类型守卫。\n这种类型的本质是结合联合类型和字面量类型的一种类型保护方法。如果一个类型是多个类型的联合类型，且多个类型含有一个公共属性，那么就可以利用这个公共属性，来创建不同的类型保护区块。\n1.可辨识\n可辨识要求联合类型中的每个元素都含有一个单例类型属性，比如：\nenum CarTransmission {\n  Automatic = 200,\n  Manual = 300\n}\n\ninterface Motorcycle {\n  vType: \"motorcycle\"; // discriminant\n  make: number; // year\n}\n\ninterface Car {\n  vType: \"car\"; // discriminant\n  transmission: CarTransmission\n}\n\ninterface Truck {\n  vType: \"truck\"; // discriminant\n  capacity: number; // in tons\n}\n在上述代码中，我们分别定义了 Motorcycle、 Car 和 Truck 三个接口，在这些接口中都包含一个 vType 属性，该属性被称为可辨识的属性，而其它的属性只跟特性的接口相关。\n2.联合类型\n基于前面定义了三个接口，我们可以创建一个 Vehicle 联合类型：\ntype Vehicle = Motorcycle | Car | Truck;\n现在我们就可以开始使用 Vehicle 联合类型，对于 Vehicle 类型的变量，它可以表示不同类型的车辆。\n3.类型守卫\n下面我们来定义一个 evaluatePrice 方法，该方法用于根据车辆的类型、容量和评估因子来计算价格，具体实现如下：\nconst EVALUATION_FACTOR = Math.PI;\nfunction evaluatePrice(vehicle: Vehicle) {\n  return vehicle.capacity * EVALUATION_FACTOR;\n}\n\nconst myTruck: Truck = { vType: \"truck\", capacity: 9.5 };\nevaluatePrice(myTruck);\n对于以上代码，TypeScript 编译器将会提示以下错误信息：\nProperty 'capacity' does not exist on type 'Vehicle'.\nProperty 'capacity' does not exist on type 'Motorcycle'.\n原因是在 Motorcycle 接口中，并不存在 capacity 属性，而对于 Car 接口来说，它也不存在 capacity 属性。那么，现在我们应该如何解决以上问题呢？这时，我们可以使用类型守卫。下面我们来重构一下前面定义的 evaluatePrice 方法，重构后的代码如下：\nfunction evaluatePrice(vehicle: Vehicle) {\n  switch(vehicle.vType) {\n    case \"car\":\n      return vehicle.transmission *EVALUATION_FACTOR;\n    case \"truck\":\nreturn vehicle.capacity* EVALUATION_FACTOR;\n    case \"motorcycle\":\n      return vehicle.make * EVALUATION_FACTOR;\n  }\n}\n在以上代码中，我们使用 switch 和 case 运算符来实现类型守卫，从而确保在 evaluatePrice 方法中，我们可以安全地访问 vehicle 对象中的所包含的属性，来正确的计算该车辆类型所对应的价格。\n5.3 类型别名\n类型别名用来给一个类型起个新名字。\ntype Message = string | string[];\n\nlet greet = (message: Message) => {\n  // ...\n};\n六、交叉类型\nTypeScript 交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。\ninterface IPerson {\n  id: string;\n  age: number;\n}\n\ninterface IWorker {\n  companyId: string;\n}\n\ntype IStaff = IPerson & IWorker;\n\nconst staff: IStaff = {\n  id: 'E1006',\n  age: 33,\n  companyId: 'EFT'\n};\n\nconsole.dir(staff)\n在上面示例中，我们首先为 IPerson 和 IWorker 类型定义了不同的成员，然后通过 & 运算符定义了 IStaff  交叉类型，所以该类型同时拥有 IPerson 和 IWorker 这两种类型的成员。\n七、TypeScript 函数\n7.1 TypeScript 函数与 JavaScript 函数的区别\n\nTypeScript\nJavaScript\n\n含有类型\n无类型\n\n箭头函数\n箭头函数（ES2015）\n\n函数类型\n无函数类型\n\n必填和可选参数\n所有参数都是可选的\n\n默认参数\n默认参数\n\n剩余参数\n剩余参数\n\n函数重载\n无函数重载\n\n7.2 箭头函数\n1.常见语法\nmyBooks.forEach(() => console.log('reading'));\n\nmyBooks.forEach(title => console.log(title));\n\nmyBooks.forEach((title, idx, arr) =>\n  console.log(idx + '-' + title);\n);\n\nmyBooks.forEach((title, idx, arr) => {\n  console.log(idx + '-' + title);\n});\n2.使用示例\n// 未使用箭头函数\nfunction Book() {\n  let self = this;\n  self.publishDate = 2016;\n  setInterval(function () {\n    console.log(self.publishDate);\n  }, 1000);\n}\n\n// 使用箭头函数\nfunction Book() {\n  this.publishDate = 2016;\n  setInterval(() => {\n    console.log(this.publishDate);\n  }, 1000);\n}\n7.3 参数类型和返回类型\nfunction createUserId(name: string, id: number): string {\n  return name + id;\n}\n7.4 函数类型\nlet IdGenerator: (chars: string, nums: number) => string;\n\nfunction createUserId(name: string, id: number): string {\n  return name + id;\n}\n\nIdGenerator = createUserId;\n7.5 可选参数及默认参数\n// 可选参数\nfunction createUserId(name: string, id: number, age?: number): string {\n  return name + id;\n}\n\n// 默认参数\nfunction createUserId(\n  name: string = \"Ruihuag\",\n  id: number,\n  age?: number\n): string {\n  return name + id;\n}\n在声明函数时，可以通过 ? 号来定义可选参数，比如 age?: number 这种形式。在实际使用时，需要注意的是可选参数要放在普通参数的后面，不然会导致编译错误。\n7.6 剩余参数\nfunction push(array, ...items) {\n  items.forEach(function (item) {\n    array.push(item);\n  });\n}\n\nlet a = [];\npush(a, 1, 2, 3);\n7.7 函数重载\n函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。要解决前面遇到的问题，方法就是为同一个函数提供多个函数类型定义来进行函数重载，编译器会根据这个列表去处理函数的调用。\nfunction add(a: number, b: number): number;\nfunction add(a: string, b: string): string;\nfunction add(a: string, b: number): string;\nfunction add(a: number, b: string): string;\nfunction add(a: Combinable, b: Combinable) {\n  if (typeof a === \"string\" || typeof b === \"string\") {\n    return a.toString() + b.toString();\n  }\n  return a + b;\n}\n在以上代码中，我们为 add 函数提供了多个函数类型定义，从而实现函数的重载。之后，可恶的错误消息又消失了，因为这时 result 变量的类型是 string 类型。在 TypeScript 中除了可以重载普通函数之外，我们还可以重载类中的成员方法。\n方法重载是指在同一个类中方法同名，参数不同（参数类型不同、参数个数不同或参数个数相同时参数的先后顺序不同），调用时根据实参的形式，选择与它匹配的方法执行操作的一种技术。所以类中成员方法满足重载的条件是：在同一个类中，方法名相同且参数列表不同。下面我们来举一个成员方法重载的例子：\nclass Calculator {\n  add(a: number, b: number): number;\n  add(a: string, b: string): string;\n  add(a: string, b: number): string;\n  add(a: number, b: string): string;\n  add(a: Combinable, b: Combinable) {\n    if (typeof a === \"string\" || typeof b === \"string\") {\n      return a.toString() + b.toString();\n    }\n    return a + b;\n  }\n}\n\nconst calculator = new Calculator();\nconst result = calculator.add(\"Ruihuag\", \" Kakuqo\");\n这里需要注意的是，当 TypeScript 编译器处理函数重载时，它会查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。另外在 Calculator 类中，add(a: Combinable, b: Combinable){ } 并不是重载列表的一部分，因此对于 add 成员方法来说，我们只定义了四个重载方法。\n八、TypeScript 数组\n8.1 数组解构\nlet x: number; let y: number; let z: number;\nlet five_array = [0,1,2,3,4];\n[x,y,z] = five_array;\n8.2 数组展开运算符\nlet two_array = [0, 1];\nlet five_array = [...two_array, 2, 3, 4];\n8.3 数组遍历\nlet colors: string[] = [\"red\", \"green\", \"blue\"];\nfor (let i of colors) {\n  console.log(i);\n}\n九、TypeScript 对象\n9.1 对象解构\nlet person = {\n  name: \"Ruihuag\",\n  gender: \"Male\",\n};\n\nlet { name, gender } = person;\n9.2 对象展开运算符\nlet person = {\n  name: \"Ruihuag\",\n  gender: \"Male\",\n  address: \"Xiamen\",\n};\n\n// 组装对象\nlet personWithAge = { ...person, age: 33 };\n\n// 获取除了某些项外的其它项\nlet { name, ...rest } = person;\n十、TypeScript 接口\n在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。\nTypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。\n10.1 对象的形状\ninterface Person {\n  name: string;\n  age: number;\n}\n\nlet Ruihuag: Person = {\n  name: \"Ruihuag\",\n  age: 33,\n};\n10.2 可选 | 只读属性\ninterface Person {\n  readonly name: string;\n  age?: number;\n}\n只读属性用于限制只能在对象刚刚创建的时候修改其值。此外 TypeScript 还提供了 ReadonlyArray<T> 类型，它与 Array<T> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。\nlet a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray<number> = a;\nro[0] = 12; // error!\nro.push(5); // error!\nro.length = 100; // error!\na = ro; // error!\n十一、TypeScript 类\n11.1 类的属性与方法\n在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。\n在 TypeScript 中，我们可以通过 Class 关键字来定义一个类：\nclass Greeter {\n  // 静态属性\n  static cname: string = \"Greeter\";\n  // 成员属性\n  greeting: string;\n\n  // 构造函数 - 执行初始化操作\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  // 静态方法\n  static getClassName() {\n    return \"Class name is Greeter\";\n  }\n\n  // 成员方法\n  greet() {\n    return \"Hello, \" + this.greeting;\n  }\n}\n\nlet greeter = new Greeter(\"world\");\n那么成员属性与静态属性，成员方法与静态方法有什么区别呢？这里无需过多解释，我们直接看一下以下编译生成的 ES5 代码：\n\"use strict\";\nvar Greeter = /** @class */ (function () {\n    // 构造函数 - 执行初始化操作\n    function Greeter(message) {\n        this.greeting = message;\n    }\n    // 静态方法\n    Greeter.getClassName = function () {\n        return \"Class name is Greeter\";\n    };\n    // 成员方法\n    Greeter.prototype.greet = function () {\n        return \"Hello, \" + this.greeting;\n    };\n    // 静态属性\n    Greeter.cname = \"Greeter\";\n    return Greeter;\n}());\nvar greeter = new Greeter(\"world\");\n11.2 访问器\n在 TypeScript 中，我们可以通过 getter 和 setter 方法来实现数据的封装和有效性校验，防止出现异常数据。\nlet passcode = \"Hello TypeScript\";\n\nclass Employee {\n  private _fullName: string;\n\n  get fullName(): string {\n    return this._fullName;\n  }\n\n  set fullName(newName: string) {\n    if (passcode && passcode == \"Hello TypeScript\") {\n      this._fullName = newName;\n    } else {\n      console.log(\"Error: Unauthorized update of employee!\");\n    }\n  }\n}\n\nlet employee = new Employee();\nemployee.fullName = \"Ruihuag\";\nif (employee.fullName) {\n  console.log(employee.fullName);\n}\n11.3 类的继承\n继承 (Inheritance) 是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。\n继承是一种 is-a 关系：\n\n在 TypeScript 中，我们可以通过 extends 关键字来实现继承：\nclass Animal {\n  name: string;\n\n  constructor(theName: string) {\n    this.name = theName;\n  }\n\n  move(distanceInMeters: number = 0) {\n    console.log(`${this.name} moved ${distanceInMeters}m.`);\n  }\n}\n\nclass Snake extends Animal {\n  constructor(name: string) {\n    super(name);\n  }\n\n  move(distanceInMeters = 5) {\n    console.log(\"Slithering...\");\n    super.move(distanceInMeters);\n  }\n}\n\nlet sam = new Snake(\"Sammy the Python\");\nsam.move();\n11.4 ECMAScript 私有字段\n在 TypeScript 3.8 版本就开始支持ECMAScript 私有字段，使用方式如下：\nclass Person {\n  #name: string;\n\n  constructor(name: string) {\n    this.#name = name;\n  }\n\n  greet() {\n    console.log(`Hello, my name is ${this.#name}!`);\n  }\n}\n\nlet Ruihuag = new Person(\"Ruihuag\");\n\nRuihuag.#name;\n//     ~~~~~\n// Property '#name' is not accessible outside class 'Person'\n// because it has a private identifier.\n与常规属性（甚至使用 private 修饰符声明的属性）不同，私有字段要牢记以下规则：\n\n私有字段以 # 字符开头，有时我们称之为私有名称；\n每个私有字段名称都唯一地限定于其包含的类；\n不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）；\n私有字段不能在包含的类之外访问，甚至不能被检测到。\n\n十二、TypeScript 泛型\n软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。\n在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。\n设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。\n泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。\n12.1 泛型接口\ninterface GenericIdentityFn<T> {\n  (arg: T): T;\n}\n12.2 泛型类\nclass GenericNumber<T> {\n  zeroValue: T;\n  add: (x: T, y: T) => T;\n}\n\nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function (x, y) {\n  return x + y;\n};\n12.3 泛型变量\n对刚接触 TypeScript 泛型的小伙伴来说，看到 T 和 E，还有 K 和 V 这些泛型变量时，估计会一脸懵逼。其实这些大写字母并没有什么本质的区别，只不过是一个约定好的规范而已。也就是说使用大写字母 A-Z 定义的类型变量都属于泛型，把 T 换成 A，也是一样的。下面我们介绍一下一些常见泛型变量代表的意思：\n\nT（Type）：表示一个 TypeScript 类型\nK（Key）：表示对象中的键类型\nV（Value）：表示对象中的值类型\nE（Element）：表示元素类型\n\n12.4 泛型工具类型\n为了方便开发者 TypeScript 内置了一些常用的工具类型，比如 Partial、Required、Readonly、Record 和 ReturnType 等。出于篇幅考虑，这里我们只简单介绍 Partial 工具类型。不过在具体介绍之前，我们得先介绍一些相关的基础知识，方便读者自行学习其它的工具类型。\n1.typeof\n在 TypeScript 中，typeof 操作符可以用来获取一个变量声明或对象的类型。\ninterface Person {\n  name: string;\n  age: number;\n}\n\nconst sem: Person = { name: 'Ruihuag', age: 30 };\ntype Sem= typeof sem; // -> Person\n\nfunction toArray(x: number): Array<number> {\n  return [x];\n}\n\ntype Func = typeof toArray; // -> (x: number) => number[]\n2.keyof\nkeyof 操作符可以用来一个对象中的所有 key 值：\ninterface Person {\n    name: string;\n    age: number;\n}\n\ntype K1 = keyof Person; // \"name\" | \"age\"\ntype K2 = keyof Person[]; // \"length\" | \"toString\" | \"pop\" | \"push\" | \"concat\" | \"join\"\ntype K3 = keyof { [x: string]: Person };  // string | number\n3.in\nin 用来遍历枚举类型：\ntype Keys = \"a\" | \"b\" | \"c\"\n\ntype Obj =  {\n} // -> { a: any, b: any, c: any }\n4.infer\n在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用。\ntype ReturnType<T> = T extends (\n  ...args: any[]\n) => infer R ? R : any;\n以上代码中 infer R 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。\n5.extends\n有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。\ninterface ILengthwise {\n  length: number;\n}\n\nfunction loggingIdentity<T extends ILengthwise>(arg: T): T {\n  console.log(arg.length);\n  return arg;\n}\n现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：\nloggingIdentity(3);  // Error, number doesn't have a .length property\n这时我们需要传入符合约束类型的值，必须包含必须的属性：\nloggingIdentity({length: 10, value: 3});\n6.Partial\nPartial<T> 的作用就是将某个类型里的属性全部变为可选项 ?。\n定义：\n/**\n\n- node_modules/typescript/lib/lib.es5.d.ts\n- Make all properties in T optional\n */\n    type Partial<T> = {\n    [P in keyof T]?: T[P];\n    };\n    在以上代码中，首先通过 keyof T 拿到 T 的所有属性名，然后使用 in 进行遍历，将值赋给 P，最后通过 T[P] 取得相应的属性值。中间的 ? 号，用于将所有属性变为可选。\n    示例：\n    interface Todo {\n    title: string;\n    description: string;\n    }\n\nfunction updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {\n  return { ...todo, ...fieldsToUpdate };\n}\n\nconst todo1 = {\n  title: \"organize desk\",\n  description: \"clear clutter\",\n};\n\nconst todo2 = updateTodo(todo1, {\n  description: \"throw out trash\",\n});\n在上面的 updateTodo 方法中，我们利用 Partial<T> 工具类型，定义 fieldsToUpdate 的类型为 Partial<Todo>，即：\n{\n   title?: string | undefined;\n   description?: string | undefined;\n}\n十三、TypeScript 装饰器\n13.1 装饰器是什么\n\n它是一个表达式\n该表达式被执行后，返回一个函数\n函数的入参分别为 target、name 和 descriptor\n执行该函数后，可能返回 descriptor 对象，用于配置 target 对象\n\n13.2 装饰器的分类\n\n类装饰器（Class decorators）\n属性装饰器（Property decorators）\n方法装饰器（Method decorators）\n参数装饰器（Parameter decorators）\n\n13.3 类装饰器\n类装饰器声明：\ndeclare type ClassDecorator = <TFunction extends Function>(\n  target: TFunction\n) => TFunction | void;\n类装饰器顾名思义，就是用来装饰类的。它接收一个参数：\n\ntarget: TFunction - 被装饰的类\n\n看完第一眼后，是不是感觉都不好了。没事，我们马上来个例子：\nfunction Greeter(target: Function): void {\n  target.prototype.greet = function (): void {\n    console.log(\"Hello Ruihuag!\");\n  };\n}\n\n@Greeter\nclass Greeting {\n  constructor() {\n    // 内部实现\n  }\n}\n\nlet myGreeting = new Greeting();\nmyGreeting.greet(); // console output: 'Hello Ruihuag!';\n上面的例子中，我们定义了 Greeter 类装饰器，同时我们使用了 @Greeter 语法糖，来使用装饰器。\n\n友情提示：读者可以直接复制上面的代码，在 TypeScript Playground 中运行查看结果。\n\n有的读者可能想问，例子中总是输出 Hello Ruihuag! ，能自定义输出的问候语么 ？这个问题很好，答案是可以的。\n具体实现如下：\nfunction Greeter(greeting: string) {\n  return function (target: Function) {\n    target.prototype.greet = function (): void {\n      console.log(greeting);\n    };\n  };\n}\n\n@Greeter(\"Hello TS!\")\nclass Greeting {\n  constructor() {\n    // 内部实现\n  }\n}\n\nlet myGreeting = new Greeting();\nmyGreeting.greet(); // console output: 'Hello TS!';\n13.4 属性装饰器\n属性装饰器声明：\ndeclare type PropertyDecorator = (target:Object,\n  propertyKey: string | symbol ) => void;\n属性装饰器顾名思义，用来装饰类的属性。它接收两个参数：\n\ntarget: Object - 被装饰的类\npropertyKey: string | symbol - 被装饰类的属性名\n\n趁热打铁，马上来个例子热热身：\nfunction logProperty(target: any, key: string) {\n  delete target[key];\n\n  const backingField = \"_\" + key;\n\n  Object.defineProperty(target, backingField, {\n    writable: true,\n    enumerable: true,\n    configurable: true\n  });\n\n  // property getter\n  const getter = function (this: any) {\n    const currVal = this[backingField];\n    console.log(`Get: ${key} => ${currVal}`);\n    return currVal;\n  };\n\n  // property setter\n  const setter = function (this: any, newVal: any) {\n    console.log(`Set: ${key} => ${newVal}`);\n    this[backingField] = newVal;\n  };\n\n  // Create new property with getter and setter\n  Object.defineProperty(target, key, {\n    get: getter,\n    set: setter,\n    enumerable: true,\n    configurable: true\n  });\n}\n\nclass Person {\n  @logProperty\n  public name: string;\n\n  constructor(name : string) {\n    this.name = name;\n  }\n}\n\nconst p1 = new Person(\"Ruihuag\");\np1.name = \"kakuqo\";\n以上代码我们定义了一个 logProperty 函数，来跟踪用户对属性的操作，当代码成功运行后，在控制台会输出以下结果：\nSet: name => Ruihuag\nSet: name => kakuqo\n13.5 方法装饰器\n方法装饰器声明：\ndeclare type MethodDecorator = <T>(target:Object, propertyKey: string | symbol,\n  descriptor: TypePropertyDescript<T>) => TypedPropertyDescriptor<T> | void;\n方法装饰器顾名思义，用来装饰类的方法。它接收三个参数：\n\ntarget: Object - 被装饰的类\npropertyKey: string | symbol - 方法名\ndescriptor: TypePropertyDescript - 属性描述符\n\n废话不多说，直接上例子：\nfunction LogOutput(tarage: Function, key: string, descriptor: any) {\n  let originalMethod = descriptor.value;\n  let newMethod = function(...args: any[]): any {\n    let result: any = originalMethod.apply(this, args);\n    if(!this.loggedOutput) {\n      this.loggedOutput = new Array<any>();\n    }\n    this.loggedOutput.push({\n      method: key,\n      parameters: args,\n      output: result,\n      timestamp: new Date()\n    });\n    return result;\n  };\n  descriptor.value = newMethod;\n}\n\nclass Calculator {\n  @LogOutput\n  double (num: number): number {\n    return num * 2;\n  }\n}\n\nlet calc = new Calculator();\ncalc.double(11);\n// console ouput: [{method: \"double\", output: 22, ...}]\nconsole.log(calc.loggedOutput);\n下面我们来介绍一下参数装饰器。\n13.6 参数装饰器\n参数装饰器声明：\ndeclare type ParameterDecorator = (target: Object, propertyKey: string | symbol,\n  parameterIndex: number ) => void\n参数装饰器顾名思义，是用来装饰函数参数，它接收三个参数：\n\ntarget: Object - 被装饰的类\npropertyKey: string | symbol - 方法名\nparameterIndex: number - 方法中参数的索引值\n\nfunction Log(target: Function, key: string, parameterIndex: number) {\n  let functionLogged = key || target.prototype.constructor.name;\n  console.log(`The parameter in position ${parameterIndex} at ${functionLogged} has\n been decorated`);\n}\n\nclass Greeter {\n  greeting: string;\n  constructor(@Log phrase: string) {\n this.greeting = phrase;\n  }\n}\n\n// console output: The parameter in position 0\n// at Greeter has been decorated\n介绍完 TypeScript 入门相关的基础知识，猜测很多刚入门的小伙伴已有 “从入门到放弃” 的想法，最后我们来简单介绍一下编译上下文。\n十四、编译上下文\n14.1 tsconfig.json 的作用\n\n用于标识 TypeScript 项目的根路径；\n用于配置 TypeScript 编译器；\n用于指定编译的文件。\n\n14.2 tsconfig.json 重要字段\n\nfiles - 设置要编译的文件的名称；\ninclude - 设置需要进行编译的文件，支持路径模式匹配；\nexclude - 设置无需进行编译的文件，支持路径模式匹配；\ncompilerOptions - 设置与编译流程相关的选项。\n\n14.3 compilerOptions 选项\ncompilerOptions 支持很多选项，常见的有 baseUrl、 target、baseUrl、 moduleResolution 和 lib 等。\ncompilerOptions 每个选项的详细说明如下：\n{\n  \"compilerOptions\": {\n\n    /* 基本选项 */\n    \"target\": \"es5\",                       // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES6'/'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'\n    \"module\": \"commonjs\",                  // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'\n    \"lib\": [],                             // 指定要包含在编译中的库文件\n    \"allowJs\": true,                       // 允许编译 javascript 文件\n    \"checkJs\": true,                       // 报告 javascript 文件中的错误\n    \"jsx\": \"preserve\",                     // 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react'\n    \"declaration\": true,                   // 生成相应的 '.d.ts' 文件\n    \"sourceMap\": true,                     // 生成相应的 '.map' 文件\n    \"outFile\": \"./\",                       // 将输出文件合并为一个文件\n    \"outDir\": \"./\",                        // 指定输出目录\n    \"rootDir\": \"./\",                       // 用来控制输出目录结构 --outDir.\n    \"removeComments\": true,                // 删除编译后的所有的注释\n    \"noEmit\": true,                        // 不生成输出文件\n    \"importHelpers\": true,                 // 从 tslib 导入辅助工具函数\n    \"isolatedModules\": true,               // 将每个文件做为单独的模块 （与 'ts.transpileModule' 类似）.\n    \n    /* 严格的类型检查选项 */\n    \"strict\": true,                        // 启用所有严格类型检查选项\n    \"noImplicitAny\": true,                 // 在表达式和声明上有隐含的 any类型时报错\n    \"strictNullChecks\": true,              // 启用严格的 null 检查\n    \"noImplicitThis\": true,                // 当 this 表达式值为 any 类型的时候，生成一个错误\n    \"alwaysStrict\": true,                  // 以严格模式检查每个模块，并在每个文件里加入 'use strict'\n    \n    /* 额外的检查 */\n    \"noUnusedLocals\": true,                // 有未使用的变量时，抛出错误\n    \"noUnusedParameters\": true,            // 有未使用的参数时，抛出错误\n    \"noImplicitReturns\": true,             // 并不是所有函数里的代码都有返回值时，抛出错误\n    \"noFallthroughCasesInSwitch\": true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）\n    \n    /* 模块解析选项 */\n    \"moduleResolution\": \"node\",            // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)\n    \"baseUrl\": \"./\",                       // 用于解析非相对模块名称的基目录\n    \"paths\": {},                           // 模块名到基于 baseUrl 的路径映射的列表\n    \"rootDirs\": [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容\n    \"typeRoots\": [],                       // 包含类型声明的文件列表\n    \"types\": [],                           // 需要包含的类型声明文件名列表\n    \"allowSyntheticDefaultImports\": true,  // 允许从没有设置默认导出的模块中默认导入。\n    \n    /* Source Map Options */\n    \"sourceRoot\": \"./\",                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置\n    \"mapRoot\": \"./\",                       // 指定调试器应该找到映射文件而不是生成文件的位置\n    \"inlineSourceMap\": true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件\n    \"inlineSources\": true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性\n    \n    /* 其他选项 */\n    \"experimentalDecorators\": true,        // 启用装饰器\n    \"emitDecoratorMetadata\": true          // 为装饰器提供元数据的支持\n  }\n}\n看到这里的读者都是“真爱”，如果你还意犹未尽，那就来看看本人整理的 Github 上 1.5K+ 的开源项目：awesome-typescript。\n\ngithub.com/Ruihuag/a…\n\n十五、参考资源\n\nmariusschulz - the-unknown-type-in-typescript\n深入理解 TypeScript - 编译上下文\n\n 文章分类 前端 文章标签  JavaScript TypeScript\n      阿宝哥\n       「全栈修仙之路」公众号\n            发布了 77 篇专栏 ·\n\n          获得点赞 23,507 ·\n         \n          获得阅读 864,088\n         已关注 \n            安装掘金浏览器插件\n           打开新标签页发现好内容，掘金、GitHub、Dribbble、ProductHunt 等站点内容轻松获取。快来安装掘金浏览器插件获取高质量内容吧！        \n      蓝九九\n      么得感情的切图仔感谢大佬分享19天前  · 删除   回复  \n      阿宝哥\n      (作者)「全栈修仙之路」公众号不客气哈，可以阅读新版 1.8W 字： juejin.cn19天\n\n作者：阿宝哥\n链接：<https://juejin.cn/post/6844904182843965453>\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","children":[]},{"name":"typescript.md","path":"../guanruihua.github.io/TypeScript","data":"# Typescript\n\n> - [TypeScript: TS Playground - An online editor for exploring TypeScript and JavaScript (typescriptlang.org)](https://www.typescriptlang.org/play?#code/PTAEHUFMBsGMHsC2lQBd5oBYoCoE8AHSAZVgCcBLA1UABWgEM8BzM+AVwDsATAGiwoBnUENANQAd0gAjQRVSQAUCEmYKsTKGYUAbpGF4OY0BoadYKdJMoL+gzAzIoz3UNEiPOofEVKVqAHSKymAAmkYI7NCuqGqcANag8ABmIjQUXrFOKBJMggBcISGgoAC0oACCoASMFmgY7p7ehCTkVOle4jUMdRLYTqCc8LEZzCZmoNJODPHFZZXVtZYYkAAeRJTInDQS8po+rf40gnjbDKv8LqD2jpbYoACqAEoAMsK7sUmxkGSCc+VVQQuaTwVb1UBrDYULY7PagbgUZLJH6QbYmJAECjuMigZEMVDsJzCFLNXxtajBBCcQQ0MwAUVWDEQNUgADVHBQGNJ3KAALygABEAAkYNAMOB4GRogLFFTBPB3AExcwABT0xnM9zsyhc9wASmCKhwDQ8ZC8iElzhB7Bo3zcZmY7AYzEg-Fg0HUiS58D0Ii8AoZTJZggFSRxAvADlQAHJhAA5SASAVBFQAeW+ZF2gldWkgx1QjgUrmkeFATgtOlGWH0KAQiBhwiudokkuiIgMHBx3RYbC43CCJSAA)\n> - 包含了ES6和ES5的语法\n> - 微软开发\n> - 更像面向对象的语法\n> - ts>es2016>es2015>es5\n\n## js和ts区别\n\n| ts                                     | js                                   |\n| -------------------------------------- | ------------------------------------ |\n| js的超集, 用于解决大型项目的代码复杂性 | 脚本语言, 创建动态网页               |\n| 编译期间发现并纠正错误                 | 解释型语言, 只有在运行的时候发现错误 |\n| 强类型, 支持静态和动态类型             | 弱类型, 没有静态类型选项             |\n| 解释成js代码, 使浏览器理解             | 可直接在浏览器运行                   |\n| 支持模块, 泛型和接口                   | 不支持模块, 泛型或接口               |\n\n## ts工作流程\n\n```mermaid\ngraph LR\nA[TS a.ts b.ts c.ts] --> |编译 | B[JS a.js b.js c.js]\nB --> | 打包 | C[JS  main.js]\nC --> |部署| D[main.js]\n```\n\n## 使用typescript\n\n```shell\nnpm install -g typescript\ntsc helloworld.ts\n// helloworld.ts => helloworld.js\ntsc --init //创建tsconfig.js文件\n```\n\n## 初体验\n\n```ts\n// hello.ts\nfunction greet(person: string) {\n  return person;\n}\nconsole.log(greet('ts'))\n```\n\n执行该指令, 编译成`hello.js`\n\n```bash\ntsc hello.ts\n```\n\n```js\n\"use strcit\"\nfunction greet(persion) {\n return persion;\n} \nconsole.log(greet('ts'))\n```\n\n## 基本数据类型\n\n| 数据类型           | 栗子                                                         |\n| ------------------ | ------------------------------------------------------------ |\n| 布尔值boolean      | `let isDone: boolean = false`                                |\n| 数字number         | `let myNumber: number = 6 [十] | 0xf00d [十六] |0b1010 [二]| 0o744 [八]` |\n| 字符串string       | let name: string = \"hua\" ; <br/>let fullName = \\`  rui ${name} \\` ;  <br/>let sen: string = \"guan\"+( number + 1) +\"hua\" |\n| 数组(Array)        | let list: number[] = [1, 2, 3]; <br/>let list: Array<number> = [1, 2, 3]; |\n| 元组<br>[Tuple]    | let x: [string, number] ;<br/>x= ['hello', 10];<br>x[2] = 2; |\n| 枚举</br>[enum]    | enum Color { Red[ =1( 不赋值就会在0开始)], Green, Blue }<br>let c: Color = Color.Green;<br>取值: c[1], c.Red |\n| 任意值any          | let notSure : any = 4;//可以避开类型检查器<br>let list: any[] = [1, true, \"free\" ]<br>//类型的顶级类型 |\n| 空值null/void      | function fn() : void{}<br>只能复制null和defined              |\n| Null<br/>Unfefined | let u: undefined = undefined;<br>let n: null = null;         |\n| Never              | 是任何类型的子类型, 也可以赋值给任何类型, 即使any也不可以给never赋值<br>function error(message: string): never { throw new Error(message);}<br>function fail(): never { return error(\"Something failed\");<br>function infiniteLoop(): never { while(true){}} |\n| 类型断言           | let someValue: any = \"this is s string\";<br>let strLength: number = (someValue as string).length<br>let strLength: number = (<string> someValue>)length |\n| Symbol             | const sym = Symbol();<br>let obj = { [sym]: 'ts' }           |\n|Unknown|和any类似<br>let value: any;|\n|||\n\n### object, Object & {}\n\n#### object\n\n```ts\n// node_modules/typescript/lib/lib.es5.d.ts\ninterface ObjectConstructor {\n  create(o: object | null): any;\n  // ...\n}\n\nconst proto = {};\n\nObject.create(proto);     // OK\nObject.create(null);      // OK\nObject.create(undefined); // Error\nObject.create(1337);      // Error\nObject.create(true);      // Error\nObject.create(\"oops\");    // Error\n```\n\n#### Object\n\nOject接口定义了Object.prototype原型对象\n\n```ts\n// node_modules/typescript/lib/lib.es5.d.ts\ninterface Object {\n  constructor: Function;\n  toString(): string;\n  toLocaleString(): string;\n  valueOf(): Object;\n  hasOwnProperty(v: PropertyKey): boolean;\n  isPrototypeOf(v: Object): boolean;\n  propertyIsEnumerable(v: PropertyKey): boolean;\n}\n```\n\nObjectConstrucotor接口定义了Object类的属性\n\n```ts\n// node_modules/typescript/lib/lib.es5.d.ts\ninterface Object {\n  constructor: Function;\n  toString(): string;\n  toLocaleString(): string;\n  valueOf(): Object;\n  hasOwnProperty(v: PropertyKey): boolean;\n  isPrototypeOf(v: Object): boolean;\n  propertyIsEnumerable(v: PropertyKey): boolean;\n}\n```\n\n### {}\n\n```ts\n// Type {}\nconst obj = {}\n\nobj.prop = '123';// Error: Property 'prop' does not exist on type '{}'\nobj.toString();// \"[object object]\"\n```\n\n## 类型守卫\n\n> 类型保护是课执行运行时检查的一种表达式 用于确保类型在一定的范围内\n\n### in\n\n```ts\ninterface Admin {\n  name: string;\n  privileges: string[];\n}\n\ninterface Employee {\n  name: string;\n  startDate: Date;\n}\n\ntype UnknownEmployee = Employee | Admin;\n\nfunction printEmployeeInformation(emp: UnknownEmployee) {\n  console.log(\"Name: \" + emp.name);\n  if (\"privileges\" in emp) {\n    console.log(\"Privileges: \" + emp.privileges);\n  }\n  if (\"startDate\" in emp) {\n    console.log(\"Start Date: \" + emp.startDate);\n  }\n}\n```\n\n### typeof\n\n```ts\nfunction padLeft(value: string, padding: string | number) {\n  if (typeof padding === \"number\") {\n      return Array(padding + 1).join(\" \") + value;\n  }\n  if (typeof padding === \"string\") {\n      return padding + value;\n  }\n  throw new Error(`Expected string or number, got '${padding}'.`);\n}\n```\n\n### instanceof\n\n```ts\ninterface Padder {\n  getPaddingString(): string;\n}\n\nclass SpaceRepeatingPadder implements Padder {\n  constructor(private numSpaces: number) {}\n  getPaddingString() {\n    return Array(this.numSpaces + 1).join(\" \");\n  }\n}\n\nclass StringPadder implements Padder {\n  constructor(private value: string) {}\n  getPaddingString() {\n    return this.value;\n  }\n}\n\nlet padder: Padder = new SpaceRepeatingPadder(6);\n\nif (padder instanceof SpaceRepeatingPadder) {\n  // padder的类型收窄为 'SpaceRepeatingPadder'\n}\n```\n\n### 自定义保护的类型谓词\n\n```ts\nfunction isNumber(x: any): x is number {\n  return typeof x === \"number\";\n}\n\nfunction isString(x: any): x is string {\n  return typeof x === \"string\";\n}\n```\n\n## 联合类型和类型别名\n\n#### 联合类型\n\n联合类型通常与 `null` 或 `undefined` 一起使用：\n\n```\nconst sayHello = (name: string | undefined) => {\n  /* ... */\n};\n```\n\n `name` 的类型是 `string | undefined` 意味着可以将 `string` 或 `undefined` 的值传递给`sayHello` 函数。\n\n```\nsayHello(\"semlinker\");\nsayHello(undefined);\n```\n\n```\nlet num: 1 | 2 = 1;\ntype EventNames = 'click' | 'scroll' | 'mousemove';\n```\n\n#### 交叉类型\n\n> 将多个类型合并成一个类型, 通过&运算符\n\n```ts\ntype PartialPointX = { x: number; };\ntype Point = PartialPointX & { y: number; };\n\nlet point: Point = {\n  x: 1,\n  y: 1\n}\n\ninterface X {\n  c: string;\n  d: string;\n}\n\ninterface Y {\n  c: number;\n  e: string\n}\n\ntype XY = X & Y;\ntype YX = Y & X;\n\nlet p: XY;\nlet q: YX;\n// 这样子c的类型是never\n```\n\n## 函数\n\n### 普通函数\n\n```ts\nfunction createUserId(name: string, id: number): string {\n  return name + id;\n}\n```\n\n### 箭头函数\n\n```ts\nmyBooks.forEach(() => console.log('reading'));\n\nmyBooks.forEach(title => console.log(title));\n\nmyBooks.forEach((title, idx, arr) =>\n  console.log(idx + '-' + title);\n);\n\nmyBooks.forEach((title, idx, arr) => {\n  console.log(idx + '-' + title);\n});\n```\n\n### 可选参数以及默认参数\n\n```ts\n// 可选参数\nfunction createUserId(name: string, id: number, age?: number): string {\n  return name + id;\n}\n\n// 默认参数\nfunction createUserId(\n  name: string = \"semlinker\",\n  id: number,\n  age?: number\n): string {\n  return name + id;\n}\n```\n\n### 函数重载\n\n```ts\nfunction add(a: number, b: number): number;\nfunction add(a: string, b: string): string;\nfunction add(a: string, b: number): string;\nfunction add(a: number, b: string): string;\nfunction add(a: Combinable, b: Combinable) {\n  // type Combinable = string | number;\n  if (typeof a === 'string' || typeof b === 'string') {\n    return a.toString() + b.toString();\n  }\n  return a + b;\n}\n```\n\n## 接口\n\n> 作用: 为这些类型命名和代码或第三方代码定义契约\n\n```typescript\nfunction printLabel( labelledObj: { label: string }) {\n  console.log(labelledObj.label)\n}\nlet myObj = { size: 10, label: \"Size 10 Object\" };\nprintLabel(myObj);\n```\n\n```typescript\ninterface LavelledValue { label: string } \nfunction printLabel( lavelledObj: LabelledValue ){\n  console.log(lavelledObj.label);\n}\nlet myObj = { size: 10, label: \"Size 10 Object\"};\nprintLabel(myObj);\n```\n\n```typescript\n//?表示可选属性\ninterface SquareConfig { color?: string; width?: number; }\nfunction createSquare(config: SquareConfig): { color: string; area: numner} {\n  let newSquare = { color: \"white\", area: 100 };\n  if(config.color){\n    newSquare.color = config.color;\n  }\n  if(config.width){\n    newSquare.width = config.width * config.width;\n  }\n}\nlet mySquare = createSquare({ color: \"black\"})\n```\n\n```typescript\n//readonly 只读属性[只能在对象创建的时候修改其值]\ninterface Point { redonly x: number; readonly y: number; }\n//ReadonlyArray<T> 数组确保数组创建后不再修改\nlet a: number[] = [1, 2, 3, 4];\nlet ro: Readonly Array<numbers> = a;\na = ro as number[];// 断言重写\n```\n\n#### Extend\n\n> 接口和类型别名都能够被拓展, 但语法有所不同\n\n**Interface extends interface**\n\n```ts\ninterface PartialPointX { x: number; }\ninterface Point extends PartialPointX { \n  y: number; \n}\n```\n\n**Type alias extends type alias**\n\n```ts\ntype PartialPointX = { x: number; };\ntype Point = PartialPointX & { y: number; };\n```\n\n**Interface extends type alias**\n\n```ts\ntype PartialPointX = { x: number; };\ninterface Point extends PartialPointX { y: number; }\n```\n\n**Type alias extends interface**\n\n```ts\ninterface PartialPointX { x: number; }\ntype Point = PartialPointX & { y: number; };\n```\n\nimplements\n\n> 类可以以相同方式实现**接口**或**类型别名**, 但类不能实现使用类型别名定义的联合类型\n\n```ts\ninterface Point {\n  x: number;\n  y: number;\n}\n\nclass SomePoint implements Point {\n  x = 1;\n  y = 2;\n}\n\ntype Point2 = {\n  x: number;\n  y: number;\n};\n\nclass SomePoint2 implements Point2 {\n  x = 1;\n  y = 2;\n}\n\ntype PartialPoint = { x: number; } | { y: number; };\n\n// A class can only implement an object type or \n// intersection of object types with statically known members.\nclass SomePartialPoint implements PartialPoint { // Error\n  x = 1;\n  y = 2;\n}\n```\n\n## 类\n\n### 属性和方法\n\n```ts\nclass Greeter {\n  // 静态属性\n  static cname: string = \"Greeter\";\n  // 成员属性\n  greeting: string;\n\n  // 构造函数 - 执行初始化操作\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  // 静态方法\n  static getClassName() {\n    return \"Class name is Greeter\";\n  }\n\n  // 成员方法\n  greet() {\n    return \"Hello, \" + this.greeting;\n  }\n}\n\nlet greeter = new Greeter(\"world\");\n```\n\n编译成ES5代码\n\n```ts\n\"use strict\";\nvar Greeter = /** @class */ (function () {\n    // 构造函数 - 执行初始化操作\n    function Greeter(message) {\n      this.greeting = message;\n    }\n    // 静态方法\n    Greeter.getClassName = function () {\n      return \"Class name is Greeter\";\n    };\n    // 成员方法\n    Greeter.prototype.greet = function () {\n      return \"Hello, \" + this.greeting;\n    };\n    // 静态属性\n    Greeter.cname = \"Greeter\";\n    return Greeter;\n}());\nvar greeter = new Greeter(\"world\");\n```\n\n### ECMAScript私有字段\n\n> - 私有字段以`#`字符开头\n> - 每个私有字段名称都唯一地限定器包含的类\n> - 不能在私有字段使用ts可访问修饰符(public 或private等)\n> - 私有字段不能在包含的类之外访问, 甚至不能被被检测到\n\n```ts\nclass Person {\n  #name: string;\n\n  constructor(name: string) {\n    this.#name = name;\n  }\n\n  greet() {\n    console.log(`Hello, my name is ${this.#name}!`);\n  }\n}\n\nlet semlinker = new Person(\"Semlinker\");\n\nsemlinker.#name;\n//     ~~~~~\n// Property '#name' is not accessible outside class 'Person'\n// because it has a private identifier.\n```\n\n### 访问器\n\n> 通过getter和setter方法来实现数据的封装和有效性检验, 防止出现异常数据\n\n```ts\nlet passcode = \"Hello TypeScript\";\n\nclass Employee {\n  private _fullName: string;\n\n  get fullName(): string {\n    return this._fullName;\n  }\n\n  set fullName(newName: string) {\n    if (passcode && passcode == \"Hello TypeScript\") {\n      this._fullName = newName;\n    } else {\n      console.log(\"Error: Unauthorized update of employee!\");\n    }\n  }\n}\n\nlet employee = new Employee();\nemployee.fullName = \"Semlinker\";\nif (employee.fullName) {\n  console.log(employee.fullName);\n}\n```\n\n### 类的继承\n\n```ts\nclass Animal {\n  name: string;\n  \n  constructor(theName: string) {\n    this.name = theName;\n  }\n  \n  move(distanceInMeters: number = 0) {\n    console.log(`${this.name} moved ${distanceInMeters}m.`);\n  }\n}\n\nclass Snake extends Animal {\n  constructor(name: string) {\n    super(name); // 调用父类的构造函数\n  }\n  \n  move(distanceInMeters = 5) {\n    console.log(\"Slithering...\");\n    super.move(distanceInMeters);\n  }\n}\n\nlet sam = new Snake(\"Sammy the Python\");\nsam.move();\n```\n\n### 抽象类\n\n> `abstract`,\n>\n> 包含一个或多个抽象方法(不包含具体实现的方法)\n\n```ts\nabstract class Person {\n  constructor(public name: string){}\n // 抽象方法\n  abstract say(words: string) :void;\n}\n\n// Cannot create an instance of an abstract class.(2511)\nconst lolo = new Person(); // Error\n\nclass Developer extends Person {\n  constructor(name: string) {\n    super(name);\n  }\n  \n  say(words: string): void {\n    console.log(`${this.name} says ${words}`);\n  }\n}\n\nconst lolo = new Developer(\"lolo\");\nlolo.say(\"I love ts!\"); // lolo says I love ts!\n\n```\n\n### 类方法重载\n\n> 函数和类的方法都支持重载\n\n```ts\nclass ProductService {\n    getProducts(): void;\n    getProducts(id: number): void;\n    getProducts(id?: number) {\n      if(typeof id === 'number') {\n          console.log(`获取id为 ${id} 的产品信息`);\n      } else {\n          console.log(`获取所有的产品信息`);\n      }  \n    }\n}\n\nconst productService = new ProductService();\nproductService.getProducts(666); // 获取id为 666 的产品信息\nproductService.getProducts(); // 获取所有的产品信息 \n```\n\n## 泛型\n\n> - 用来创建课重用的组件, 一个组件可以支持多种类型的数据, 用户可使用自己的数据类型来使用组件\n> - 范类(Generics)是允许一个函数接受不同类型参数的一种模板\n\n```ts\nfunction identity <T, U>(value: T, message: U) : T {\n  console.log(message);\n  return value;\n}\n\nconsole.log(identity<Number, string>(68, \"Semlinker\"));\n```\n\n### 泛型工具类\n\n#### typeof\n\n> 获取一个变量声明或对象的类型\n\n```ts\ninterface Person {\n  name: string;\n  age: number;\n}\n\nconst sem: Person = { name: 'semlinker', age: 33 };\ntype Sem= typeof sem; // -> Person\n\nfunction toArray(x: number): Array<number> {\n  return [x];\n}\n\ntype Func = typeof toArray; // -> (x: number) => number[]\n```\n\n#### keyof\n\n> 获取某种类型的所有键, 其返回值是联合类型\n\n```ts\ninterface Person {\n  name: string;\n  age: number;\n}\n\ntype K1 = keyof Person; // \"name\" | \"age\"\ntype K2 = keyof Person[]; // \"length\" | \"toString\" | \"pop\" | \"push\" | \"concat\" | \"join\" \ntype K3 = keyof { [x: string]: Person };  // string | number\n```\n\n```ts\ninterface StringArray {\n  // 字符串索引 -> keyof StringArray => string | number\n  [index: string]: string; \n}\n// 使用数字索引时, js在执行索引操作时, 会先把索引转换为字符串先\n\n\ninterface StringArray1 {\n  // 数字索引 -> keyof StringArray1 => number\n  [index: number]: string;\n}\n```\n\n#### in\n\n> 遍历枚举类型\n\n```ts\ntype Keys = \"a\"|\"b\"|\"c\"\n\ntype Obj =  {\n  [p in Keys]: any\n} // -> { a: any, b: any, c: any }\n```\n\n#### infer\n\n> 声明一个类型变量, 并且对它进行使用\n\n```ts\ntype ReturnType<T> = T extends (\n  ...args: any[]\n) => infer R ? R : any;\n// 声明一个变量类继承传入函数签名的返回值类型\n// 渠道函数的返回值, 方便之后使用\n```\n\n#### extends\n\n```ts\ninterface Lengthwise {\n  length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length);\n  return arg;\n}\n\nloggingIdentity(3);// Error, number doesn't have a .length property\nloggingIdentity({length: 10, value: 3});\n\n```\n\n#### partial\n\n> 将某个类型里的属性全部变成为课选项`?`\n\n```ts\n/**\n * 定义\n * node_modules/typescript/lib/lib.es5.d.ts\n * Make all properties in T optional\n */\ntype Partial<T> = {\n  [P in keyof T]?: T[P];\n};\n// 通过keyof T拿到T所有属性名, 然后通过in 进行遍历, 将值赋给P, 最后通过T[P]取得相应的值, ? 使所有属性比那层可选属性\n\n```\n\n## 装饰类\n\n> 实验性功能\n>\n> - 类装饰器 ( Class decorators)\n> - 属性装饰器 ( Property decorators )\n> - 方法装饰器 ( Method decorators)\n> - 参数装饰器 ( Parameter decorators)\n\n## 编译上下文\n\n#### tsconfig.json 的作用\n\n- 用于标识 TypeScript 项目的根路径；\n- 用于配置 TypeScript 编译器；\n- 用于指定编译的文件。\n\n#### tsconfig.json 重要字段\n\n- files - 设置要编译的文件的名称；\n- include - 设置需要进行编译的文件，支持路径模式匹配；\n- exclude - 设置无需进行编译的文件，支持路径模式匹配；\n- compilerOptions - 设置与编译流程相关的选项。\n\n#### compilerOptions 选项\n\ncompilerOptions 支持很多选项，常见的有 `baseUrl`、 `target`、`baseUrl`、 `moduleResolution` 和 `lib` 等。\n\ncompilerOptions 每个选项的详细说明如下：\n\n`tsc --init //创建tsconfig.js文件`\n\n```json\n{\n  \"compilerOptions\": {\n\n    /* 基本选项 */\n    \"target\": \"es5\",                       // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES6'/'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'\n    \"module\": \"commonjs\",                  // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'\n    \"lib\": [],                             // 指定要包含在编译中的库文件\n    \"allowJs\": true,                       // 允许编译 javascript 文件\n    \"checkJs\": true,                       // 报告 javascript 文件中的错误\n    \"jsx\": \"preserve\",                     // 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react'\n    \"declaration\": true,                   // 生成相应的 '.d.ts' 文件\n    \"sourceMap\": true,                     // 生成相应的 '.map' 文件\n    \"outFile\": \"./\",                       // 将输出文件合并为一个文件\n    \"outDir\": \"./\",                        // 指定输出目录\n    \"rootDir\": \"./\",                       // 用来控制输出目录结构 --outDir.\n    \"removeComments\": true,                // 删除编译后的所有的注释\n    \"noEmit\": true,                        // 不生成输出文件\n    \"importHelpers\": true,                 // 从 tslib 导入辅助工具函数\n    \"isolatedModules\": true,               // 将每个文件做为单独的模块 （与 'ts.transpileModule' 类似）.\n\n    /* 严格的类型检查选项 */\n    \"strict\": true,                        // 启用所有严格类型检查选项\n    \"noImplicitAny\": true,                 // 在表达式和声明上有隐含的 any类型时报错\n    \"strictNullChecks\": true,              // 启用严格的 null 检查\n    \"noImplicitThis\": true,                // 当 this 表达式值为 any 类型的时候，生成一个错误\n    \"alwaysStrict\": true,                  // 以严格模式检查每个模块，并在每个文件里加入 'use strict'\n\n    /* 额外的检查 */\n    \"noUnusedLocals\": true,                // 有未使用的变量时，抛出错误\n    \"noUnusedParameters\": true,            // 有未使用的参数时，抛出错误\n    \"noImplicitReturns\": true,             // 并不是所有函数里的代码都有返回值时，抛出错误\n    \"noFallthroughCasesInSwitch\": true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）\n\n    /* 模块解析选项 */\n    \"moduleResolution\": \"node\",            // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)\n    \"baseUrl\": \"./\",                       // 用于解析非相对模块名称的基目录\n    \"paths\": {},                           // 模块名到基于 baseUrl 的路径映射的列表\n    \"rootDirs\": [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容\n    \"typeRoots\": [],                       // 包含类型声明的文件列表\n    \"types\": [],                           // 需要包含的类型声明文件名列表\n    \"allowSyntheticDefaultImports\": true,  // 允许从没有设置默认导出的模块中默认导入。\n\n    /* Source Map Options */\n    \"sourceRoot\": \"./\",                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置\n    \"mapRoot\": \"./\",                       // 指定调试器应该找到映射文件而不是生成文件的位置\n    \"inlineSourceMap\": true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件\n    \"inlineSources\": true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性\n\n    /* 其他选项 */\n    \"experimentalDecorators\": true,        // 启用装饰器\n    \"emitDecoratorMetadata\": true          // 为装饰器提供元数据的支持\n  }\n}\n```\n\n开发辅助工具\n\n[json to ts](http://www.jsontots.com/): 指定json 数据生成对应的typescript\n\n[Schemats](https://github.com/SweetIQ/schemats) :基于sql数据库中的schema自动生成typescript接口定义\n\n [TypeScript AST Viewer](https://ts-ast-viewer.com/) : 在线工具, 查看指定ts代码对应的ast抽象数\n\n[TypeDoc](https://typedoc.org/) : 将 TypeScript 源代码中的注释转换为 HTML 文档或 JSON 模型\n\n[TypeScript ESLint](https://typescript-eslint.io/) : 规范代码质量，提高团队开发效率。\n","children":[]},{"name":"_sidebar.md","path":"../guanruihua.github.io/TypeScript","data":"* [error_code](error_code.md)\n* [ts](ts.md)\n* [typescript](typescript.md)\n* [三斜线指令](三斜线指令.md)\n* [内置API](内置API/index.md)\n  * [ECMAScript](内置API/ECMAScript.md)\n  * [home](内置API/index.md)\n  * [lib.dom](内置API/lib.dom.md)\n* [声明文件](声明文件.md)\n* [特性](特性.md)\n* [类型体操](类型体操.md)\n* [类型工具](类型工具.md)\n* [类型过滤](类型过滤.md)\n* 错误\n  * [2709](错误/2709.md)\n","children":[]},{"name":"三斜线指令.md","path":"../guanruihua.github.io/TypeScript","data":"# 三斜线指令\r\n\r\n> 三斜线指令是包含单个XML标签的单行注释。 注释的内容会做为编译器指令使用。\r\n>\r\n> 三斜线指令仅可放在包含它的文件的最顶端。 一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。 如果它们出现在一个语句或声明之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义。\r\n\r\n## `/// <reference path=\"...\" />`\r\n\r\n> `/// <reference path=\"...\" />`指令是三斜线指令中最常见的一种。 它用于声明文件间的依赖。\r\n>\r\n> 三斜线引用告诉编译器在编译过程中要引入的额外的文件。\r\n>\r\n> 当使用--out或--outFile时，它也可以做为调整输出内容顺序的一种方法。 文件在输出文件内容中的位置与经过预处理后的输入顺序一致。\r\n\r\n## 预处理输入文件\r\n\r\n> 编译器会对输入文件进行预处理来解析所有三斜线引用指令。 在这个过程中，额外的文件会加到编译过程中。\r\n>\r\n> 这个过程会以一些根文件开始； 它们是在命令行中指定的文件或是在`tsconfig.json`中的`\"files\"`列表里的文件。 这些根文件按指定的顺序进行预处理。 在一个文件被加入列表前，它包含的所有三斜线引用都要被处理，还有它们包含的目标。 三斜线引用以它们在文件里出现的顺序，使用深度优先的方式解析。\r\n>\r\n> 一个三斜线引用路径是相对于包含它的文件的，如果不是根文件。\r\n\r\n### 错误\r\n\r\n> 引用不存在的文件会报错。 一个文件用三斜线指令引用自己会报错。\r\n\r\n### 使用 --noResolve\r\n\r\n> 如果指定了--noResolve编译选项，三斜线引用会被忽略；它们不会增加新文件，也不会改变给定文件的顺序。\r\n\r\n## `/// <reference types=\"...\" />`\r\n\r\n> 与`/// <reference path=\"...\" />`指令相似，这个指令是用来声明依赖的； 一个`/// <reference path=\"...\" />`指令声明了对@types包的一个依赖。\r\n>\r\n> 在声明文件里包含`/// <reference types=\"node\" />`，表明这个文件使用了`@types/node/index.d.ts`里面声明的名字； 并且，这个包要在编译阶段与声明文件一起被包含进来。\r\n>\r\n> 解析`@types`包的名字的过程与解析import语句里模块名的过程类似。 所以可以简单的把三斜线类型引用指令想像成针对包的import声明。\r\n>\r\n> 仅当在你需要写一个`d.ts`文件时才使用这个指令。\r\n>\r\n> 对于那些在编译阶段生成的声明文件，编译器会自动地添加`/// <reference types=\"...\" />`； 当且仅当结果文件中使用了引用的@types包里的声明时才会在生成的声明文件里添加`/// <reference types=\"...\" />`语句\r\n>\r\n> 若要在`.ts`文件里声明一个对@types包的依赖，使用`--types`命令行选项或在`tsconfig.json`里指定。 查看在`tsconfig.json`里使用`@types`，`typeRoots`和`types`了解详情。\r\n\r\n### `/// <reference no-default-lib=\"true\"/>`\r\n\r\n> 这个指令把一个文件标记成默认库。 你会在`lib.d.ts`文件和它不同的变体的顶端看到这个注释。\r\n\r\n这个指令告诉编译器在编译过程中不要包含这个默认库（比如，lib.d.ts）。 这与在命令行上使用--noLib相似。\r\n\r\n还要注意，当传递了--skipDefaultLibCheck时，编译器只会忽略检查带有`/// <reference no-default-lib=\"true\"/>`的文件。\r\n\r\n## `/// <amd-module />`\r\n\r\n> 默认情况下生成的AMD模块都是匿名的。 但是，当一些工具需要处理生成的模块时会产生问题，比如r.js。\r\n\r\namd-module指令允许给编译器传入一个可选的模块名：\r\n\r\n### `///<amd-module name='NamedModule'/>`\r\n\r\n```ts\r\nexport class C { }\r\n```\r\n\r\n这会将NamedModule传入到AMD define函数里：\r\n\r\n```ts\r\n//amdModule.js\r\ndefine(\"NamedModule\", [\"require\", \"exports\"], function (require, exports) {\r\n    var C = (function () {\r\n        function C() {\r\n        }\r\n        return C;\r\n    })();\r\n    exports.C = C;\r\n});\r\n```\r\n\r\n## `/// <amd-dependency />`\r\n\r\n> 注意：这个指令被废弃了。使用import \"moduleName\";语句代替。\r\n\r\n`/// <amd-dependency path=\"x\" />`告诉编译器有一个非TypeScript模块依赖需要被注入，做为目标模块require调用的一部分。\r\n\r\n`amd-dependency`指令也可以带一个可选的name属性；它允许我们为amd-dependency传入一个可选名字：\r\n\r\n### `/// <amd-dependency path=\"legacy/moduleA\" name=\"moduleA\"/>`\r\n\r\n```ts\r\ndeclare var moduleA:MyType\r\nmoduleA.callStuff()\r\n生成的JavaScript代码：\r\n\r\ndefine([\"require\", \"exports\", \"legacy/moduleA\"], function (require, exports, moduleA) {\r\n    moduleA.callStuff()\r\n});\r\n\r\n```\r\n","children":[]},{"name":"内置API","path":"../guanruihua.github.io/TypeScript","data":"","children":[{"name":"ECMAScript.md","path":"../guanruihua.github.io/TypeScript/内置API","data":"# ECMAScript APIs\r\n\r\n> lib.es5.d.ts 文件分析\r\n\r\n## 特殊\r\n\r\n### NaN\r\n\r\n```ts\r\ndeclare var NaN: number;\r\n/**\r\n * Returns a Boolean value that indicates whether a value is the reserved value NaN (not a number).\r\n * @param number A numeric value.\r\n */\r\ndeclare function isNaN(number: number): boolean;\r\n```\r\n\r\n### 未分类\r\n\r\n```ts\r\ndeclare var Infinity: number;\r\ninterface Symbol {\r\n    /** Returns a string representation of an object. */\r\n    toString(): string;\r\n\r\n    /** Returns the primitive value of the specified object. */\r\n    valueOf(): symbol;\r\n}\r\n```\r\n\r\n## Number\r\n\r\n```ts\r\n/**\r\n * Converts a string to an integer.\r\n * @param string A string to convert into a number.\r\n * @param radix A value between 2 and 36 that specifies the base of the number in `string`.\r\n * If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal.\r\n * All other strings are considered decimal.\r\n */\r\ndeclare function parseInt(string: string, radix?: number): number;\r\n\r\n/**\r\n * Converts a string to a floating-point number.\r\n * @param string A string that contains a floating-point number.\r\n */\r\ndeclare function parseFloat(string: string): number;\r\n\r\n/**\r\n * Determines whether a supplied number is finite.\r\n * @param number Any numeric value.\r\n */\r\ndeclare function isFinite(number: number): boolean;\r\ninterface Number {\r\n    /**\r\n     * Returns a string representation of an object.\r\n     * @param radix Specifies a radix for converting numeric values to strings. This value is only used for numbers.\r\n     */\r\n    toString(radix?: number): string;\r\n\r\n    /**\r\n     * Returns a string representing a number in fixed-point notation.\r\n     * @param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.\r\n     */\r\n    toFixed(fractionDigits?: number): string;\r\n\r\n    /**\r\n     * Returns a string containing a number represented in exponential notation.\r\n     * @param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.\r\n     */\r\n    toExponential(fractionDigits?: number): string;\r\n\r\n    /**\r\n     * Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.\r\n     * @param precision Number of significant digits. Must be in the range 1 - 21, inclusive.\r\n     */\r\n    toPrecision(precision?: number): string;\r\n\r\n    /** Returns the primitive value of the specified object. */\r\n    valueOf(): number;\r\n}\r\n\r\ninterface NumberConstructor {\r\n    new(value?: any): Number;\r\n    (value?: any): number;\r\n    readonly prototype: Number;\r\n\r\n    /** The largest number that can be represented in JavaScript. Equal to approximately 1.79E+308. */\r\n    readonly MAX_VALUE: number;\r\n\r\n    /** The closest number to zero that can be represented in JavaScript. Equal to approximately 5.00E-324. */\r\n    readonly MIN_VALUE: number;\r\n\r\n    /**\r\n     * A value that is not a number.\r\n     * In equality comparisons, NaN does not equal any value, including itself. To test whether a value is equivalent to NaN, use the isNaN function.\r\n     */\r\n    readonly NaN: number;\r\n\r\n    /**\r\n     * A value that is less than the largest negative number that can be represented in JavaScript.\r\n     * JavaScript displays NEGATIVE_INFINITY values as -infinity.\r\n     */\r\n    readonly NEGATIVE_INFINITY: number;\r\n\r\n    /**\r\n     * A value greater than the largest number that can be represented in JavaScript.\r\n     * JavaScript displays POSITIVE_INFINITY values as infinity.\r\n     */\r\n    readonly POSITIVE_INFINITY: number;\r\n}\r\n\r\n/** An object that represents a number of any kind. All JavaScript numbers are 64-bit floating-point numbers. */\r\ndeclare var Number: NumberConstructor;\r\n```\r\n\r\n## String\r\n\r\n```ts\r\n/**\r\n * Computes a new string in which certain characters have been replaced by a hexadecimal escape sequence.\r\n * @deprecated A legacy feature for browser compatibility\r\n * @param string A string value\r\n */\r\ndeclare function escape(string: string): string;\r\n\r\n/**\r\n * Computes a new string in which hexadecimal escape sequences are replaced with the character that it represents.\r\n * @deprecated A legacy feature for browser compatibility\r\n * @param string A string value\r\n */\r\ndeclare function unescape(string: string): string;\r\n\r\ninterface String {\r\n    /** Returns a string representation of a string. */\r\n    toString(): string;\r\n\r\n    /**\r\n     * Returns the character at the specified index.\r\n     * @param pos The zero-based index of the desired character.\r\n     */\r\n    charAt(pos: number): string;\r\n\r\n    /**\r\n     * Returns the Unicode value of the character at the specified location.\r\n     * @param index The zero-based index of the desired character. If there is no character at the specified index, NaN is returned.\r\n     */\r\n    charCodeAt(index: number): number;\r\n\r\n    /**\r\n     * Returns a string that contains the concatenation of two or more strings.\r\n     * @param strings The strings to append to the end of the string.\r\n     */\r\n    concat(...strings: string[]): string;\r\n\r\n    /**\r\n     * Returns the position of the first occurrence of a substring.\r\n     * @param searchString The substring to search for in the string\r\n     * @param position The index at which to begin searching the String object. If omitted, search starts at the beginning of the string.\r\n     */\r\n    indexOf(searchString: string, position?: number): number;\r\n\r\n    /**\r\n     * Returns the last occurrence of a substring in the string.\r\n     * @param searchString The substring to search for.\r\n     * @param position The index at which to begin searching. If omitted, the search begins at the end of the string.\r\n     */\r\n    lastIndexOf(searchString: string, position?: number): number;\r\n\r\n    /**\r\n     * Determines whether two strings are equivalent in the current locale.\r\n     * @param that String to compare to target string\r\n     */\r\n    localeCompare(that: string): number;\r\n\r\n    /**\r\n     * Matches a string with a regular expression, and returns an array containing the results of that search.\r\n     * @param regexp A variable name or string literal containing the regular expression pattern and flags.\r\n     */\r\n    match(regexp: string | RegExp): RegExpMatchArray | null;\r\n\r\n    /**\r\n     * Replaces text in a string, using a regular expression or search string.\r\n     * @param searchValue A string to search for.\r\n     * @param replaceValue A string containing the text to replace for every successful match of searchValue in this string.\r\n     */\r\n    replace(searchValue: string | RegExp, replaceValue: string): string;\r\n\r\n    /**\r\n     * Replaces text in a string, using a regular expression or search string.\r\n     * @param searchValue A string to search for.\r\n     * @param replacer A function that returns the replacement text.\r\n     */\r\n    replace(searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;\r\n\r\n    /**\r\n     * Finds the first substring match in a regular expression search.\r\n     * @param regexp The regular expression pattern and applicable flags.\r\n     */\r\n    search(regexp: string | RegExp): number;\r\n\r\n    /**\r\n     * Returns a section of a string.\r\n     * @param start The index to the beginning of the specified portion of stringObj.\r\n     * @param end The index to the end of the specified portion of stringObj. The substring includes the characters up to, but not including, the character indicated by end.\r\n     * If this value is not specified, the substring continues to the end of stringObj.\r\n     */\r\n    slice(start?: number, end?: number): string;\r\n\r\n    /**\r\n     * Split a string into substrings using the specified separator and return them as an array.\r\n     * @param separator A string that identifies character or characters to use in separating the string. If omitted, a single-element array containing the entire string is returned.\r\n     * @param limit A value used to limit the number of elements returned in the array.\r\n     */\r\n    split(separator: string | RegExp, limit?: number): string[];\r\n\r\n    /**\r\n     * Returns the substring at the specified location within a String object.\r\n     * @param start The zero-based index number indicating the beginning of the substring.\r\n     * @param end Zero-based index number indicating the end of the substring. The substring includes the characters up to, but not including, the character indicated by end.\r\n     * If end is omitted, the characters from start through the end of the original string are returned.\r\n     */\r\n    substring(start: number, end?: number): string;\r\n\r\n    /** Converts all the alphabetic characters in a string to lowercase. */\r\n    toLowerCase(): string;\r\n\r\n    /** Converts all alphabetic characters to lowercase, taking into account the host environment's current locale. */\r\n    toLocaleLowerCase(locales?: string | string[]): string;\r\n\r\n    /** Converts all the alphabetic characters in a string to uppercase. */\r\n    toUpperCase(): string;\r\n\r\n    /** Returns a string where all alphabetic characters have been converted to uppercase, taking into account the host environment's current locale. */\r\n    toLocaleUpperCase(locales?: string | string[]): string;\r\n\r\n    /** Removes the leading and trailing white space and line terminator characters from a string. */\r\n    trim(): string;\r\n\r\n    /** Returns the length of a String object. */\r\n    readonly length: number;\r\n\r\n    // IE extensions\r\n    /**\r\n     * Gets a substring beginning at the specified location and having the specified length.\r\n     * @deprecated A legacy feature for browser compatibility\r\n     * @param from The starting position of the desired substring. The index of the first character in the string is zero.\r\n     * @param length The number of characters to include in the returned substring.\r\n     */\r\n    substr(from: number, length?: number): string;\r\n\r\n    /** Returns the primitive value of the specified object. */\r\n    valueOf(): string;\r\n\r\n    readonly [index: number]: string;\r\n}\r\ninterface StringConstructor {\r\n    new(value?: any): String;\r\n    (value?: any): string;\r\n    readonly prototype: String;\r\n    fromCharCode(...codes: number[]): string;\r\n}\r\n\r\n/**\r\n * Allows manipulation and formatting of text strings and determination and location of substrings within strings.\r\n */\r\ndeclare var String: StringConstructor;\r\n```\r\n\r\n## Property\r\n\r\n> 状态\r\n\r\n```ts\r\ndeclare type PropertyKey = string | number | symbol;\r\n\r\ninterface PropertyDescriptor {\r\n    configurable?: boolean;\r\n    enumerable?: boolean;\r\n    value?: any;\r\n    writable?: boolean;\r\n    get?(): any;\r\n    set?(v: any): void;\r\n}\r\n\r\ninterface PropertyDescriptorMap {\r\n    [key: PropertyKey]: PropertyDescriptor;\r\n}\r\n```\r\n\r\n## Object\r\n\r\n```ts\r\ninterface Object {\r\n    /** The initial value of Object.prototype.constructor is the standard built-in Object constructor. */\r\n    constructor: Function;\r\n\r\n    /** Returns a string representation of an object. */\r\n    toString(): string;\r\n\r\n    /** Returns a date converted to a string using the current locale. */\r\n    toLocaleString(): string;\r\n\r\n    /** Returns the primitive value of the specified object. */\r\n    valueOf(): Object;\r\n\r\n    /**\r\n     * Determines whether an object has a property with the specified name.\r\n     * @param v A property name.\r\n     */\r\n    hasOwnProperty(v: PropertyKey): boolean;\r\n\r\n    /**\r\n     * Determines whether an object exists in another object's prototype chain.\r\n     * @param v Another object whose prototype chain is to be checked.\r\n     */\r\n    isPrototypeOf(v: Object): boolean;\r\n\r\n    /**\r\n     * Determines whether a specified property is enumerable.\r\n     * @param v A property name.\r\n     */\r\n    propertyIsEnumerable(v: PropertyKey): boolean;\r\n}\r\n\r\ninterface ObjectConstructor {\r\n    new(value?: any): Object;\r\n    (): any;\r\n    (value: any): any;\r\n\r\n    /** A reference to the prototype for a class of objects. */\r\n    readonly prototype: Object;\r\n\r\n    /**\r\n     * Returns the prototype of an object.\r\n     * @param o The object that references the prototype.\r\n     */\r\n    getPrototypeOf(o: any): any;\r\n\r\n    /**\r\n     * Gets the own property descriptor of the specified object.\r\n     * An own property descriptor is one that is defined directly on the object and is not inherited from the object's prototype.\r\n     * @param o Object that contains the property.\r\n     * @param p Name of the property.\r\n     */\r\n    getOwnPropertyDescriptor(o: any, p: PropertyKey): PropertyDescriptor | undefined;\r\n\r\n    /**\r\n     * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly\r\n     * on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions.\r\n     * @param o Object that contains the own properties.\r\n     */\r\n    getOwnPropertyNames(o: any): string[];\r\n\r\n    /**\r\n     * Creates an object that has the specified prototype or that has null prototype.\r\n     * @param o Object to use as a prototype. May be null.\r\n     */\r\n    create(o: object | null): any;\r\n\r\n    /**\r\n     * Creates an object that has the specified prototype, and that optionally contains specified properties.\r\n     * @param o Object to use as a prototype. May be null\r\n     * @param properties JavaScript object that contains one or more property descriptors.\r\n     */\r\n    create(o: object | null, properties: PropertyDescriptorMap & ThisType<any>): any;\r\n\r\n    /**\r\n     * Adds a property to an object, or modifies attributes of an existing property.\r\n     * @param o Object on which to add or modify the property. This can be a native JavaScript object (that is, a user-defined object or a built in object) or a DOM object.\r\n     * @param p The property name.\r\n     * @param attributes Descriptor for the property. It can be for a data property or an accessor property.\r\n     */\r\n    defineProperty<T>(o: T, p: PropertyKey, attributes: PropertyDescriptor & ThisType<any>): T;\r\n\r\n    /**\r\n     * Adds one or more properties to an object, and/or modifies attributes of existing properties.\r\n     * @param o Object on which to add or modify the properties. This can be a native JavaScript object or a DOM object.\r\n     * @param properties JavaScript object that contains one or more descriptor objects. Each descriptor object describes a data property or an accessor property.\r\n     */\r\n    defineProperties<T>(o: T, properties: PropertyDescriptorMap & ThisType<any>): T;\r\n\r\n    /**\r\n     * Prevents the modification of attributes of existing properties, and prevents the addition of new properties.\r\n     * @param o Object on which to lock the attributes.\r\n     */\r\n    seal<T>(o: T): T;\r\n\r\n    /**\r\n     * Prevents the modification of existing property attributes and values, and prevents the addition of new properties.\r\n     * @param a Object on which to lock the attributes.\r\n     */\r\n    freeze<T>(a: T[]): readonly T[];\r\n\r\n    /**\r\n     * Prevents the modification of existing property attributes and values, and prevents the addition of new properties.\r\n     * @param f Object on which to lock the attributes.\r\n     */\r\n    freeze<T extends Function>(f: T): T;\r\n\r\n    /**\r\n     * Prevents the modification of existing property attributes and values, and prevents the addition of new properties.\r\n     * @param o Object on which to lock the attributes.\r\n     */\r\n    freeze<T>(o: T): Readonly<T>;\r\n\r\n    /**\r\n     * Prevents the addition of new properties to an object.\r\n     * @param o Object to make non-extensible.\r\n     */\r\n    preventExtensions<T>(o: T): T;\r\n\r\n    /**\r\n     * Returns true if existing property attributes cannot be modified in an object and new properties cannot be added to the object.\r\n     * @param o Object to test.\r\n     */\r\n    isSealed(o: any): boolean;\r\n\r\n    /**\r\n     * Returns true if existing property attributes and values cannot be modified in an object, and new properties cannot be added to the object.\r\n     * @param o Object to test.\r\n     */\r\n    isFrozen(o: any): boolean;\r\n\r\n    /**\r\n     * Returns a value that indicates whether new properties can be added to an object.\r\n     * @param o Object to test.\r\n     */\r\n    isExtensible(o: any): boolean;\r\n\r\n    /**\r\n     * Returns the names of the enumerable string properties and methods of an object.\r\n     * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\r\n     */\r\n    keys(o: object): string[];\r\n}\r\n\r\n/**\r\n * Provides functionality common to all JavaScript objects.\r\n */\r\ndeclare var Object: ObjectConstructor;\r\n```\r\n\r\n## Function\r\n\r\n```ts\r\n\r\ninterface Function {\r\n    /**\r\n     * Calls the function, substituting the specified object for the this value of the function, and the specified array for the arguments of the function.\r\n     * @param thisArg The object to be used as the this object.\r\n     * @param argArray A set of arguments to be passed to the function.\r\n     */\r\n    apply(this: Function, thisArg: any, argArray?: any): any;\r\n\r\n    /**\r\n     * Calls a method of an object, substituting another object for the current object.\r\n     * @param thisArg The object to be used as the current object.\r\n     * @param argArray A list of arguments to be passed to the method.\r\n     */\r\n    call(this: Function, thisArg: any, ...argArray: any[]): any;\r\n\r\n    /**\r\n     * For a given function, creates a bound function that has the same body as the original function.\r\n     * The this object of the bound function is associated with the specified object, and has the specified initial parameters.\r\n     * @param thisArg An object to which the this keyword can refer inside the new function.\r\n     * @param argArray A list of arguments to be passed to the new function.\r\n     */\r\n    bind(this: Function, thisArg: any, ...argArray: any[]): any;\r\n\r\n    /** Returns a string representation of a function. */\r\n    toString(): string;\r\n\r\n    prototype: any;\r\n    readonly length: number;\r\n\r\n    // Non-standard extensions\r\n    arguments: any;\r\n    caller: Function;\r\n}\r\n\r\ninterface FunctionConstructor {\r\n    /**\r\n     * Creates a new function.\r\n     * @param args A list of arguments the function accepts.\r\n     */\r\n    new(...args: string[]): Function;\r\n    (...args: string[]): Function;\r\n    readonly prototype: Function;\r\n}\r\n\r\ndeclare var Function: FunctionConstructor;\r\n\r\n/**\r\n * Extracts the type of the 'this' parameter of a function type, or 'unknown' if the function type has no 'this' parameter.\r\n */\r\ntype ThisParameterType<T> = T extends (this: infer U, ...args: never) => any ? U : unknown;\r\n\r\n/**\r\n * Removes the 'this' parameter from a function type.\r\n */\r\ntype OmitThisParameter<T> = unknown extends ThisParameterType<T> ? T : T extends (...args: infer A) => infer R ? (...args: A) => R : T;\r\n\r\ninterface CallableFunction extends Function {\r\n    /**\r\n     * Calls the function with the specified object as the this value and the elements of specified array as the arguments.\r\n     * @param thisArg The object to be used as the this object.\r\n     * @param args An array of argument values to be passed to the function.\r\n     */\r\n    apply<T, R>(this: (this: T) => R, thisArg: T): R;\r\n    apply<T, A extends any[], R>(this: (this: T, ...args: A) => R, thisArg: T, args: A): R;\r\n\r\n    /**\r\n     * Calls the function with the specified object as the this value and the specified rest arguments as the arguments.\r\n     * @param thisArg The object to be used as the this object.\r\n     * @param args Argument values to be passed to the function.\r\n     */\r\n    call<T, A extends any[], R>(this: (this: T, ...args: A) => R, thisArg: T, ...args: A): R;\r\n\r\n    /**\r\n     * For a given function, creates a bound function that has the same body as the original function.\r\n     * The this object of the bound function is associated with the specified object, and has the specified initial parameters.\r\n     * @param thisArg The object to be used as the this object.\r\n     * @param args Arguments to bind to the parameters of the function.\r\n     */\r\n    bind<T>(this: T, thisArg: ThisParameterType<T>): OmitThisParameter<T>;\r\n    bind<T, A0, A extends any[], R>(this: (this: T, arg0: A0, ...args: A) => R, thisArg: T, arg0: A0): (...args: A) => R;\r\n    bind<T, A0, A1, A extends any[], R>(this: (this: T, arg0: A0, arg1: A1, ...args: A) => R, thisArg: T, arg0: A0, arg1: A1): (...args: A) => R;\r\n    bind<T, A0, A1, A2, A extends any[], R>(this: (this: T, arg0: A0, arg1: A1, arg2: A2, ...args: A) => R, thisArg: T, arg0: A0, arg1: A1, arg2: A2): (...args: A) => R;\r\n    bind<T, A0, A1, A2, A3, A extends any[], R>(this: (this: T, arg0: A0, arg1: A1, arg2: A2, arg3: A3, ...args: A) => R, thisArg: T, arg0: A0, arg1: A1, arg2: A2, arg3: A3): (...args: A) => R;\r\n    bind<T, AX, R>(this: (this: T, ...args: AX[]) => R, thisArg: T, ...args: AX[]): (...args: AX[]) => R;\r\n}\r\n\r\ninterface NewableFunction extends Function {\r\n    /**\r\n     * Calls the function with the specified object as the this value and the elements of specified array as the arguments.\r\n     * @param thisArg The object to be used as the this object.\r\n     * @param args An array of argument values to be passed to the function.\r\n     */\r\n    apply<T>(this: new () => T, thisArg: T): void;\r\n    apply<T, A extends any[]>(this: new (...args: A) => T, thisArg: T, args: A): void;\r\n\r\n    /**\r\n     * Calls the function with the specified object as the this value and the specified rest arguments as the arguments.\r\n     * @param thisArg The object to be used as the this object.\r\n     * @param args Argument values to be passed to the function.\r\n     */\r\n    call<T, A extends any[]>(this: new (...args: A) => T, thisArg: T, ...args: A): void;\r\n\r\n    /**\r\n     * For a given function, creates a bound function that has the same body as the original function.\r\n     * The this object of the bound function is associated with the specified object, and has the specified initial parameters.\r\n     * @param thisArg The object to be used as the this object.\r\n     * @param args Arguments to bind to the parameters of the function.\r\n     */\r\n    bind<T>(this: T, thisArg: any): T;\r\n    bind<A0, A extends any[], R>(this: new (arg0: A0, ...args: A) => R, thisArg: any, arg0: A0): new (...args: A) => R;\r\n    bind<A0, A1, A extends any[], R>(this: new (arg0: A0, arg1: A1, ...args: A) => R, thisArg: any, arg0: A0, arg1: A1): new (...args: A) => R;\r\n    bind<A0, A1, A2, A extends any[], R>(this: new (arg0: A0, arg1: A1, arg2: A2, ...args: A) => R, thisArg: any, arg0: A0, arg1: A1, arg2: A2): new (...args: A) => R;\r\n    bind<A0, A1, A2, A3, A extends any[], R>(this: new (arg0: A0, arg1: A1, arg2: A2, arg3: A3, ...args: A) => R, thisArg: any, arg0: A0, arg1: A1, arg2: A2, arg3: A3): new (...args: A) => R;\r\n    bind<AX, R>(this: new (...args: AX[]) => R, thisArg: any, ...args: AX[]): new (...args: AX[]) => R;\r\n}\r\n\r\ninterface IArguments {\r\n    [index: number]: any;\r\n    length: number;\r\n    callee: Function;\r\n}\r\n```\r\n\r\n## decodeURI\r\n\r\n```ts\r\n\r\n/**\r\n * Gets the unencoded version of an encoded Uniform Resource Identifier (URI).\r\n * @param encodedURI A value representing an encoded URI.\r\n */\r\ndeclare function decodeURI(encodedURI: string): string;\r\n\r\n/**\r\n * Gets the unencoded version of an encoded component of a Uniform Resource Identifier (URI).\r\n * @param encodedURIComponent A value representing an encoded URI component.\r\n */\r\ndeclare function decodeURIComponent(encodedURIComponent: string): string;\r\n\r\n/**\r\n * Encodes a text string as a valid Uniform Resource Identifier (URI)\r\n * @param uri A value representing an encoded URI.\r\n */\r\ndeclare function encodeURI(uri: string): string;\r\n\r\n/**\r\n * Encodes a text string as a valid component of a Uniform Resource Identifier (URI).\r\n * @param uriComponent A value representing an encoded URI component.\r\n */\r\ndeclare function encodeURIComponent(uriComponent: string | number | boolean): string;\r\n```\r\n\r\n## 方法\r\n\r\n```ts\r\n/**\r\n * Evaluates JavaScript code and executes it.\r\n * @param x A String value that contains valid JavaScript code.\r\n */\r\ndeclare function eval(x: string): any;\r\n```\r\n\r\n## Match\r\n\r\n```ts\r\n\r\ninterface Math {\r\n    /** The mathematical constant e. This is Euler's number, the base of natural logarithms. */\r\n    readonly E: number;\r\n    /** The natural logarithm of 10. */\r\n    readonly LN10: number;\r\n    /** The natural logarithm of 2. */\r\n    readonly LN2: number;\r\n    /** The base-2 logarithm of e. */\r\n    readonly LOG2E: number;\r\n    /** The base-10 logarithm of e. */\r\n    readonly LOG10E: number;\r\n    /** Pi. This is the ratio of the circumference of a circle to its diameter. */\r\n    readonly PI: number;\r\n    /** The square root of 0.5, or, equivalently, one divided by the square root of 2. */\r\n    readonly SQRT1_2: number;\r\n    /** The square root of 2. */\r\n    readonly SQRT2: number;\r\n    /**\r\n     * Returns the absolute value of a number (the value without regard to whether it is positive or negative).\r\n     * For example, the absolute value of -5 is the same as the absolute value of 5.\r\n     * @param x A numeric expression for which the absolute value is needed.\r\n     */\r\n    abs(x: number): number;\r\n    /**\r\n     * Returns the arc cosine (or inverse cosine) of a number.\r\n     * @param x A numeric expression.\r\n     */\r\n    acos(x: number): number;\r\n    /**\r\n     * Returns the arcsine of a number.\r\n     * @param x A numeric expression.\r\n     */\r\n    asin(x: number): number;\r\n    /**\r\n     * Returns the arctangent of a number.\r\n     * @param x A numeric expression for which the arctangent is needed.\r\n     */\r\n    atan(x: number): number;\r\n    /**\r\n     * Returns the angle (in radians) from the X axis to a point.\r\n     * @param y A numeric expression representing the cartesian y-coordinate.\r\n     * @param x A numeric expression representing the cartesian x-coordinate.\r\n     */\r\n    atan2(y: number, x: number): number;\r\n    /**\r\n     * Returns the smallest integer greater than or equal to its numeric argument.\r\n     * @param x A numeric expression.\r\n     */\r\n    ceil(x: number): number;\r\n    /**\r\n     * Returns the cosine of a number.\r\n     * @param x A numeric expression that contains an angle measured in radians.\r\n     */\r\n    cos(x: number): number;\r\n    /**\r\n     * Returns e (the base of natural logarithms) raised to a power.\r\n     * @param x A numeric expression representing the power of e.\r\n     */\r\n    exp(x: number): number;\r\n    /**\r\n     * Returns the greatest integer less than or equal to its numeric argument.\r\n     * @param x A numeric expression.\r\n     */\r\n    floor(x: number): number;\r\n    /**\r\n     * Returns the natural logarithm (base e) of a number.\r\n     * @param x A numeric expression.\r\n     */\r\n    log(x: number): number;\r\n    /**\r\n     * Returns the larger of a set of supplied numeric expressions.\r\n     * @param values Numeric expressions to be evaluated.\r\n     */\r\n    max(...values: number[]): number;\r\n    /**\r\n     * Returns the smaller of a set of supplied numeric expressions.\r\n     * @param values Numeric expressions to be evaluated.\r\n     */\r\n    min(...values: number[]): number;\r\n    /**\r\n     * Returns the value of a base expression taken to a specified power.\r\n     * @param x The base value of the expression.\r\n     * @param y The exponent value of the expression.\r\n     */\r\n    pow(x: number, y: number): number;\r\n    /** Returns a pseudorandom number between 0 and 1. */\r\n    random(): number;\r\n    /**\r\n     * Returns a supplied numeric expression rounded to the nearest integer.\r\n     * @param x The value to be rounded to the nearest integer.\r\n     */\r\n    round(x: number): number;\r\n    /**\r\n     * Returns the sine of a number.\r\n     * @param x A numeric expression that contains an angle measured in radians.\r\n     */\r\n    sin(x: number): number;\r\n    /**\r\n     * Returns the square root of a number.\r\n     * @param x A numeric expression.\r\n     */\r\n    sqrt(x: number): number;\r\n    /**\r\n     * Returns the tangent of a number.\r\n     * @param x A numeric expression that contains an angle measured in radians.\r\n     */\r\n    tan(x: number): number;\r\n}\r\n/** An intrinsic object that provides basic mathematics functionality and constants. */\r\ndeclare var Math: Math;\r\n```\r\n\r\n## Boolean\r\n\r\n```ts\r\n\r\ninterface Boolean {\r\n    /** Returns the primitive value of the specified object. */\r\n    valueOf(): boolean;\r\n}\r\n\r\ninterface BooleanConstructor {\r\n    new(value?: any): Boolean;\r\n    <T>(value?: T): boolean;\r\n    readonly prototype: Boolean;\r\n}\r\n\r\ndeclare var Boolean: BooleanConstructor;\r\n```\r\n\r\n## Date\r\n\r\n```ts\r\n\r\n/** Enables basic storage and retrieval of dates and times. */\r\ninterface Date {\r\n    /** Returns a string representation of a date. The format of the string depends on the locale. */\r\n    toString(): string;\r\n    /** Returns a date as a string value. */\r\n    toDateString(): string;\r\n    /** Returns a time as a string value. */\r\n    toTimeString(): string;\r\n    /** Returns a value as a string value appropriate to the host environment's current locale. */\r\n    toLocaleString(): string;\r\n    /** Returns a date as a string value appropriate to the host environment's current locale. */\r\n    toLocaleDateString(): string;\r\n    /** Returns a time as a string value appropriate to the host environment's current locale. */\r\n    toLocaleTimeString(): string;\r\n    /** Returns the stored time value in milliseconds since midnight, January 1, 1970 UTC. */\r\n    valueOf(): number;\r\n    /** Gets the time value in milliseconds. */\r\n    getTime(): number;\r\n    /** Gets the year, using local time. */\r\n    getFullYear(): number;\r\n    /** Gets the year using Universal Coordinated Time (UTC). */\r\n    getUTCFullYear(): number;\r\n    /** Gets the month, using local time. */\r\n    getMonth(): number;\r\n    /** Gets the month of a Date object using Universal Coordinated Time (UTC). */\r\n    getUTCMonth(): number;\r\n    /** Gets the day-of-the-month, using local time. */\r\n    getDate(): number;\r\n    /** Gets the day-of-the-month, using Universal Coordinated Time (UTC). */\r\n    getUTCDate(): number;\r\n    /** Gets the day of the week, using local time. */\r\n    getDay(): number;\r\n    /** Gets the day of the week using Universal Coordinated Time (UTC). */\r\n    getUTCDay(): number;\r\n    /** Gets the hours in a date, using local time. */\r\n    getHours(): number;\r\n    /** Gets the hours value in a Date object using Universal Coordinated Time (UTC). */\r\n    getUTCHours(): number;\r\n    /** Gets the minutes of a Date object, using local time. */\r\n    getMinutes(): number;\r\n    /** Gets the minutes of a Date object using Universal Coordinated Time (UTC). */\r\n    getUTCMinutes(): number;\r\n    /** Gets the seconds of a Date object, using local time. */\r\n    getSeconds(): number;\r\n    /** Gets the seconds of a Date object using Universal Coordinated Time (UTC). */\r\n    getUTCSeconds(): number;\r\n    /** Gets the milliseconds of a Date, using local time. */\r\n    getMilliseconds(): number;\r\n    /** Gets the milliseconds of a Date object using Universal Coordinated Time (UTC). */\r\n    getUTCMilliseconds(): number;\r\n    /** Gets the difference in minutes between the time on the local computer and Universal Coordinated Time (UTC). */\r\n    getTimezoneOffset(): number;\r\n    /**\r\n     * Sets the date and time value in the Date object.\r\n     * @param time A numeric value representing the number of elapsed milliseconds since midnight, January 1, 1970 GMT.\r\n     */\r\n    setTime(time: number): number;\r\n    /**\r\n     * Sets the milliseconds value in the Date object using local time.\r\n     * @param ms A numeric value equal to the millisecond value.\r\n     */\r\n    setMilliseconds(ms: number): number;\r\n    /**\r\n     * Sets the milliseconds value in the Date object using Universal Coordinated Time (UTC).\r\n     * @param ms A numeric value equal to the millisecond value.\r\n     */\r\n    setUTCMilliseconds(ms: number): number;\r\n\r\n    /**\r\n     * Sets the seconds value in the Date object using local time.\r\n     * @param sec A numeric value equal to the seconds value.\r\n     * @param ms A numeric value equal to the milliseconds value.\r\n     */\r\n    setSeconds(sec: number, ms?: number): number;\r\n    /**\r\n     * Sets the seconds value in the Date object using Universal Coordinated Time (UTC).\r\n     * @param sec A numeric value equal to the seconds value.\r\n     * @param ms A numeric value equal to the milliseconds value.\r\n     */\r\n    setUTCSeconds(sec: number, ms?: number): number;\r\n    /**\r\n     * Sets the minutes value in the Date object using local time.\r\n     * @param min A numeric value equal to the minutes value.\r\n     * @param sec A numeric value equal to the seconds value.\r\n     * @param ms A numeric value equal to the milliseconds value.\r\n     */\r\n    setMinutes(min: number, sec?: number, ms?: number): number;\r\n    /**\r\n     * Sets the minutes value in the Date object using Universal Coordinated Time (UTC).\r\n     * @param min A numeric value equal to the minutes value.\r\n     * @param sec A numeric value equal to the seconds value.\r\n     * @param ms A numeric value equal to the milliseconds value.\r\n     */\r\n    setUTCMinutes(min: number, sec?: number, ms?: number): number;\r\n    /**\r\n     * Sets the hour value in the Date object using local time.\r\n     * @param hours A numeric value equal to the hours value.\r\n     * @param min A numeric value equal to the minutes value.\r\n     * @param sec A numeric value equal to the seconds value.\r\n     * @param ms A numeric value equal to the milliseconds value.\r\n     */\r\n    setHours(hours: number, min?: number, sec?: number, ms?: number): number;\r\n    /**\r\n     * Sets the hours value in the Date object using Universal Coordinated Time (UTC).\r\n     * @param hours A numeric value equal to the hours value.\r\n     * @param min A numeric value equal to the minutes value.\r\n     * @param sec A numeric value equal to the seconds value.\r\n     * @param ms A numeric value equal to the milliseconds value.\r\n     */\r\n    setUTCHours(hours: number, min?: number, sec?: number, ms?: number): number;\r\n    /**\r\n     * Sets the numeric day-of-the-month value of the Date object using local time.\r\n     * @param date A numeric value equal to the day of the month.\r\n     */\r\n    setDate(date: number): number;\r\n    /**\r\n     * Sets the numeric day of the month in the Date object using Universal Coordinated Time (UTC).\r\n     * @param date A numeric value equal to the day of the month.\r\n     */\r\n    setUTCDate(date: number): number;\r\n    /**\r\n     * Sets the month value in the Date object using local time.\r\n     * @param month A numeric value equal to the month. The value for January is 0, and other month values follow consecutively.\r\n     * @param date A numeric value representing the day of the month. If this value is not supplied, the value from a call to the getDate method is used.\r\n     */\r\n    setMonth(month: number, date?: number): number;\r\n    /**\r\n     * Sets the month value in the Date object using Universal Coordinated Time (UTC).\r\n     * @param month A numeric value equal to the month. The value for January is 0, and other month values follow consecutively.\r\n     * @param date A numeric value representing the day of the month. If it is not supplied, the value from a call to the getUTCDate method is used.\r\n     */\r\n    setUTCMonth(month: number, date?: number): number;\r\n    /**\r\n     * Sets the year of the Date object using local time.\r\n     * @param year A numeric value for the year.\r\n     * @param month A zero-based numeric value for the month (0 for January, 11 for December). Must be specified if numDate is specified.\r\n     * @param date A numeric value equal for the day of the month.\r\n     */\r\n    setFullYear(year: number, month?: number, date?: number): number;\r\n    /**\r\n     * Sets the year value in the Date object using Universal Coordinated Time (UTC).\r\n     * @param year A numeric value equal to the year.\r\n     * @param month A numeric value equal to the month. The value for January is 0, and other month values follow consecutively. Must be supplied if numDate is supplied.\r\n     * @param date A numeric value equal to the day of the month.\r\n     */\r\n    setUTCFullYear(year: number, month?: number, date?: number): number;\r\n    /** Returns a date converted to a string using Universal Coordinated Time (UTC). */\r\n    toUTCString(): string;\r\n    /** Returns a date as a string value in ISO format. */\r\n    toISOString(): string;\r\n    /** Used by the JSON.stringify method to enable the transformation of an object's data for JavaScript Object Notation (JSON) serialization. */\r\n    toJSON(key?: any): string;\r\n}\r\n\r\ninterface DateConstructor {\r\n    new(): Date;\r\n    new(value: number | string): Date;\r\n    new(year: number, month: number, date?: number, hours?: number, minutes?: number, seconds?: number, ms?: number): Date;\r\n    (): string;\r\n    readonly prototype: Date;\r\n    /**\r\n     * Parses a string containing a date, and returns the number of milliseconds between that date and midnight, January 1, 1970.\r\n     * @param s A date string\r\n     */\r\n    parse(s: string): number;\r\n    /**\r\n     * Returns the number of milliseconds between midnight, January 1, 1970 Universal Coordinated Time (UTC) (or GMT) and the specified date.\r\n     * @param year The full year designation is required for cross-century date accuracy. If year is between 0 and 99 is used, then year is assumed to be 1900 + year.\r\n     * @param month The month as a number between 0 and 11 (January to December).\r\n     * @param date The date as a number between 1 and 31.\r\n     * @param hours Must be supplied if minutes is supplied. A number from 0 to 23 (midnight to 11pm) that specifies the hour.\r\n     * @param minutes Must be supplied if seconds is supplied. A number from 0 to 59 that specifies the minutes.\r\n     * @param seconds Must be supplied if milliseconds is supplied. A number from 0 to 59 that specifies the seconds.\r\n     * @param ms A number from 0 to 999 that specifies the milliseconds.\r\n     */\r\n    UTC(year: number, month: number, date?: number, hours?: number, minutes?: number, seconds?: number, ms?: number): number;\r\n    now(): number;\r\n}\r\n\r\ndeclare var Date: DateConstructor;\r\n```\r\n\r\n## Array\r\n\r\n```ts\r\ninterface TemplateStringsArray extends ReadonlyArray<string> {\r\n    readonly raw: readonly string[];\r\n}\r\n```\r\n\r\n## Import\r\n\r\n```ts\r\n/**\r\n * The type of `import.meta`.\r\n *\r\n * If you need to declare that a given property exists on `import.meta`,\r\n * this type may be augmented via interface merging.\r\n */\r\ninterface ImportMeta {\r\n}\r\n\r\n/**\r\n * The type for the optional second argument to `import()`.\r\n *\r\n * If your host environment supports additional options, this type may be\r\n * augmented via interface merging.\r\n */\r\ninterface ImportCallOptions {\r\n    assert?: ImportAssertions;\r\n}\r\n\r\n/**\r\n * The type for the `assert` property of the optional second argument to `import()`.\r\n */\r\ninterface ImportAssertions {\r\n    [key: string]: string;\r\n}\r\n```\r\n\r\n## RegExp\r\n\r\n```ts\r\ninterface RegExpMatchArray extends Array<string> {\r\n    index?: number;\r\n    input?: string;\r\n}\r\n\r\ninterface RegExpExecArray extends Array<string> {\r\n    index: number;\r\n    input: string;\r\n}\r\n\r\ninterface RegExp {\r\n    /**\r\n     * Executes a search on a string using a regular expression pattern, and returns an array containing the results of that search.\r\n     * @param string The String object or string literal on which to perform the search.\r\n     */\r\n    exec(string: string): RegExpExecArray | null;\r\n\r\n    /**\r\n     * Returns a Boolean value that indicates whether or not a pattern exists in a searched string.\r\n     * @param string String on which to perform the search.\r\n     */\r\n    test(string: string): boolean;\r\n\r\n    /** Returns a copy of the text of the regular expression pattern. Read-only. The regExp argument is a Regular expression object. It can be a variable name or a literal. */\r\n    readonly source: string;\r\n\r\n    /** Returns a Boolean value indicating the state of the global flag (g) used with a regular expression. Default is false. Read-only. */\r\n    readonly global: boolean;\r\n\r\n    /** Returns a Boolean value indicating the state of the ignoreCase flag (i) used with a regular expression. Default is false. Read-only. */\r\n    readonly ignoreCase: boolean;\r\n\r\n    /** Returns a Boolean value indicating the state of the multiline flag (m) used with a regular expression. Default is false. Read-only. */\r\n    readonly multiline: boolean;\r\n\r\n    lastIndex: number;\r\n\r\n    // Non-standard extensions\r\n    /** @deprecated A legacy feature for browser compatibility */\r\n    compile(pattern: string, flags?: string): this;\r\n}\r\n\r\ninterface RegExpConstructor {\r\n    new(pattern: RegExp | string): RegExp;\r\n    new(pattern: string, flags?: string): RegExp;\r\n    (pattern: RegExp | string): RegExp;\r\n    (pattern: string, flags?: string): RegExp;\r\n    readonly prototype: RegExp;\r\n\r\n    // Non-standard extensions\r\n    /** @deprecated A legacy feature for browser compatibility */\r\n    $1: string;\r\n    /** @deprecated A legacy feature for browser compatibility */\r\n    $2: string;\r\n    /** @deprecated A legacy feature for browser compatibility */\r\n    $3: string;\r\n    /** @deprecated A legacy feature for browser compatibility */\r\n    $4: string;\r\n    /** @deprecated A legacy feature for browser compatibility */\r\n    $5: string;\r\n    /** @deprecated A legacy feature for browser compatibility */\r\n    $6: string;\r\n    /** @deprecated A legacy feature for browser compatibility */\r\n    $7: string;\r\n    /** @deprecated A legacy feature for browser compatibility */\r\n    $8: string;\r\n    /** @deprecated A legacy feature for browser compatibility */\r\n    $9: string;\r\n    /** @deprecated A legacy feature for browser compatibility */\r\n    input: string;\r\n    /** @deprecated A legacy feature for browser compatibility */\r\n    $_: string;\r\n    /** @deprecated A legacy feature for browser compatibility */\r\n    lastMatch: string;\r\n    /** @deprecated A legacy feature for browser compatibility */\r\n    \"$&\": string;\r\n    /** @deprecated A legacy feature for browser compatibility */\r\n    lastParen: string;\r\n    /** @deprecated A legacy feature for browser compatibility */\r\n    \"$+\": string;\r\n    /** @deprecated A legacy feature for browser compatibility */\r\n    leftContext: string;\r\n    /** @deprecated A legacy feature for browser compatibility */\r\n    \"$`\": string;\r\n    /** @deprecated A legacy feature for browser compatibility */\r\n    rightContext: string;\r\n    /** @deprecated A legacy feature for browser compatibility */\r\n    \"$'\": string;\r\n}\r\n\r\ndeclare var RegExp: RegExpConstructor;\r\n```\r\n\r\n## 未分类\r\n\r\n```ts\r\n\r\ninterface Error {\r\n    name: string;\r\n    message: string;\r\n    stack?: string;\r\n}\r\n\r\ninterface ErrorConstructor {\r\n    new(message?: string): Error;\r\n    (message?: string): Error;\r\n    readonly prototype: Error;\r\n}\r\n\r\ndeclare var Error: ErrorConstructor;\r\n\r\ninterface EvalError extends Error {\r\n}\r\n\r\ninterface EvalErrorConstructor extends ErrorConstructor {\r\n    new(message?: string): EvalError;\r\n    (message?: string): EvalError;\r\n    readonly prototype: EvalError;\r\n}\r\n\r\ndeclare var EvalError: EvalErrorConstructor;\r\n\r\ninterface RangeError extends Error {\r\n}\r\n\r\ninterface RangeErrorConstructor extends ErrorConstructor {\r\n    new(message?: string): RangeError;\r\n    (message?: string): RangeError;\r\n    readonly prototype: RangeError;\r\n}\r\n\r\ndeclare var RangeError: RangeErrorConstructor;\r\n\r\ninterface ReferenceError extends Error {\r\n}\r\n\r\ninterface ReferenceErrorConstructor extends ErrorConstructor {\r\n    new(message?: string): ReferenceError;\r\n    (message?: string): ReferenceError;\r\n    readonly prototype: ReferenceError;\r\n}\r\n\r\ndeclare var ReferenceError: ReferenceErrorConstructor;\r\n\r\ninterface SyntaxError extends Error {\r\n}\r\n\r\ninterface SyntaxErrorConstructor extends ErrorConstructor {\r\n    new(message?: string): SyntaxError;\r\n    (message?: string): SyntaxError;\r\n    readonly prototype: SyntaxError;\r\n}\r\n\r\ndeclare var SyntaxError: SyntaxErrorConstructor;\r\n\r\ninterface TypeError extends Error {\r\n}\r\n\r\ninterface TypeErrorConstructor extends ErrorConstructor {\r\n    new(message?: string): TypeError;\r\n    (message?: string): TypeError;\r\n    readonly prototype: TypeError;\r\n}\r\n\r\ndeclare var TypeError: TypeErrorConstructor;\r\n\r\ninterface URIError extends Error {\r\n}\r\n\r\ninterface URIErrorConstructor extends ErrorConstructor {\r\n    new(message?: string): URIError;\r\n    (message?: string): URIError;\r\n    readonly prototype: URIError;\r\n}\r\n\r\ndeclare var URIError: URIErrorConstructor;\r\n\r\ninterface JSON {\r\n    /**\r\n     * Converts a JavaScript Object Notation (JSON) string into an object.\r\n     * @param text A valid JSON string.\r\n     * @param reviver A function that transforms the results. This function is called for each member of the object.\r\n     * If a member contains nested objects, the nested objects are transformed before the parent object is.\r\n     */\r\n    parse(text: string, reviver?: (this: any, key: string, value: any) => any): any;\r\n    /**\r\n     * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\r\n     * @param value A JavaScript value, usually an object or array, to be converted.\r\n     * @param replacer A function that transforms the results.\r\n     * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\r\n     */\r\n    stringify(value: any, replacer?: (this: any, key: string, value: any) => any, space?: string | number): string;\r\n    /**\r\n     * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\r\n     * @param value A JavaScript value, usually an object or array, to be converted.\r\n     * @param replacer An array of strings and numbers that acts as an approved list for selecting the object properties that will be stringified.\r\n     * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\r\n     */\r\n    stringify(value: any, replacer?: (number | string)[] | null, space?: string | number): string;\r\n}\r\n\r\n/**\r\n * An intrinsic object that provides functions to convert JavaScript values to and from the JavaScript Object Notation (JSON) format.\r\n */\r\ndeclare var JSON: JSON;\r\n\r\n\r\n/////////////////////////////\r\n/// ECMAScript Array API (specially handled by compiler)\r\n/////////////////////////////\r\n\r\ninterface ReadonlyArray<T> {\r\n    /**\r\n     * Gets the length of the array. This is a number one higher than the highest element defined in an array.\r\n     */\r\n    readonly length: number;\r\n    /**\r\n     * Returns a string representation of an array.\r\n     */\r\n    toString(): string;\r\n    /**\r\n     * Returns a string representation of an array. The elements are converted to string using their toLocaleString methods.\r\n     */\r\n    toLocaleString(): string;\r\n    /**\r\n     * Combines two or more arrays.\r\n     * @param items Additional items to add to the end of array1.\r\n     */\r\n    concat(...items: ConcatArray<T>[]): T[];\r\n    /**\r\n     * Combines two or more arrays.\r\n     * @param items Additional items to add to the end of array1.\r\n     */\r\n    concat(...items: (T | ConcatArray<T>)[]): T[];\r\n    /**\r\n     * Adds all the elements of an array separated by the specified separator string.\r\n     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.\r\n     */\r\n    join(separator?: string): string;\r\n    /**\r\n     * Returns a section of an array.\r\n     * @param start The beginning of the specified portion of the array.\r\n     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.\r\n     */\r\n    slice(start?: number, end?: number): T[];\r\n    /**\r\n     * Returns the index of the first occurrence of a value in an array.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\r\n     */\r\n    indexOf(searchElement: T, fromIndex?: number): number;\r\n    /**\r\n     * Returns the index of the last occurrence of a specified value in an array.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.\r\n     */\r\n    lastIndexOf(searchElement: T, fromIndex?: number): number;\r\n    /**\r\n     * Determines whether all the members of an array satisfy the specified test.\r\n     * @param predicate A function that accepts up to three arguments. The every method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value false, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];\r\n    /**\r\n     * Determines whether all the members of an array satisfy the specified test.\r\n     * @param predicate A function that accepts up to three arguments. The every method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value false, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;\r\n    /**\r\n     * Determines whether the specified callback function returns true for any element of an array.\r\n     * @param predicate A function that accepts up to three arguments. The some method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value true, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;\r\n    /**\r\n     * Performs the specified action for each element in an array.\r\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.\r\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;\r\n    /**\r\n     * Calls a defined callback function on each element of an array, and returns an array that contains the results.\r\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];\r\n    /**\r\n     * Returns the elements of an array that meet the condition specified in a callback function.\r\n     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];\r\n    /**\r\n     * Returns the elements of an array that meet the condition specified in a callback function.\r\n     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\r\n     */\r\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;\r\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\r\n     */\r\n    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\r\n     */\r\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;\r\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\r\n     */\r\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;\r\n\r\n    readonly [n: number]: T;\r\n}\r\n\r\ninterface ConcatArray<T> {\r\n    readonly length: number;\r\n    readonly [n: number]: T;\r\n    join(separator?: string): string;\r\n    slice(start?: number, end?: number): T[];\r\n}\r\n\r\ninterface Array<T> {\r\n    /**\r\n     * Gets or sets the length of the array. This is a number one higher than the highest index in the array.\r\n     */\r\n    length: number;\r\n    /**\r\n     * Returns a string representation of an array.\r\n     */\r\n    toString(): string;\r\n    /**\r\n     * Returns a string representation of an array. The elements are converted to string using their toLocaleString methods.\r\n     */\r\n    toLocaleString(): string;\r\n    /**\r\n     * Removes the last element from an array and returns it.\r\n     * If the array is empty, undefined is returned and the array is not modified.\r\n     */\r\n    pop(): T | undefined;\r\n    /**\r\n     * Appends new elements to the end of an array, and returns the new length of the array.\r\n     * @param items New elements to add to the array.\r\n     */\r\n    push(...items: T[]): number;\r\n    /**\r\n     * Combines two or more arrays.\r\n     * This method returns a new array without modifying any existing arrays.\r\n     * @param items Additional arrays and/or items to add to the end of the array.\r\n     */\r\n    concat(...items: ConcatArray<T>[]): T[];\r\n    /**\r\n     * Combines two or more arrays.\r\n     * This method returns a new array without modifying any existing arrays.\r\n     * @param items Additional arrays and/or items to add to the end of the array.\r\n     */\r\n    concat(...items: (T | ConcatArray<T>)[]): T[];\r\n    /**\r\n     * Adds all the elements of an array into a string, separated by the specified separator string.\r\n     * @param separator A string used to separate one element of the array from the next in the resulting string. If omitted, the array elements are separated with a comma.\r\n     */\r\n    join(separator?: string): string;\r\n    /**\r\n     * Reverses the elements in an array in place.\r\n     * This method mutates the array and returns a reference to the same array.\r\n     */\r\n    reverse(): T[];\r\n    /**\r\n     * Removes the first element from an array and returns it.\r\n     * If the array is empty, undefined is returned and the array is not modified.\r\n     */\r\n    shift(): T | undefined;\r\n    /**\r\n     * Returns a copy of a section of an array.\r\n     * For both start and end, a negative index can be used to indicate an offset from the end of the array.\r\n     * For example, -2 refers to the second to last element of the array.\r\n     * @param start The beginning index of the specified portion of the array.\r\n     * If start is undefined, then the slice begins at index 0.\r\n     * @param end The end index of the specified portion of the array. This is exclusive of the element at the index 'end'.\r\n     * If end is undefined, then the slice extends to the end of the array.\r\n     */\r\n    slice(start?: number, end?: number): T[];\r\n    /**\r\n     * Sorts an array in place.\r\n     * This method mutates the array and returns a reference to the same array.\r\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\r\n     * a negative value if the first argument is less than the second argument, zero if they're equal, and a positive\r\n     * value otherwise. If omitted, the elements are sorted in ascending, ASCII character order.\r\n     * ```ts\r\n     * [11,2,22,1].sort((a, b) => a - b)\r\n     * ```\r\n     */\r\n    sort(compareFn?: (a: T, b: T) => number): this;\r\n    /**\r\n     * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\r\n     * @param start The zero-based location in the array from which to start removing elements.\r\n     * @param deleteCount The number of elements to remove.\r\n     * @returns An array containing the elements that were deleted.\r\n     */\r\n    splice(start: number, deleteCount?: number): T[];\r\n    /**\r\n     * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\r\n     * @param start The zero-based location in the array from which to start removing elements.\r\n     * @param deleteCount The number of elements to remove.\r\n     * @param items Elements to insert into the array in place of the deleted elements.\r\n     * @returns An array containing the elements that were deleted.\r\n     */\r\n    splice(start: number, deleteCount: number, ...items: T[]): T[];\r\n    /**\r\n     * Inserts new elements at the start of an array, and returns the new length of the array.\r\n     * @param items Elements to insert at the start of the array.\r\n     */\r\n    unshift(...items: T[]): number;\r\n    /**\r\n     * Returns the index of the first occurrence of a value in an array, or -1 if it is not present.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\r\n     */\r\n    indexOf(searchElement: T, fromIndex?: number): number;\r\n    /**\r\n     * Returns the index of the last occurrence of a specified value in an array, or -1 if it is not present.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin searching backward. If fromIndex is omitted, the search starts at the last index in the array.\r\n     */\r\n    lastIndexOf(searchElement: T, fromIndex?: number): number;\r\n    /**\r\n     * Determines whether all the members of an array satisfy the specified test.\r\n     * @param predicate A function that accepts up to three arguments. The every method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value false, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    every<S extends T>(predicate: (value: T, index: number, array: T[]) => value is S, thisArg?: any): this is S[];\r\n    /**\r\n     * Determines whether all the members of an array satisfy the specified test.\r\n     * @param predicate A function that accepts up to three arguments. The every method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value false, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    every(predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): boolean;\r\n    /**\r\n     * Determines whether the specified callback function returns true for any element of an array.\r\n     * @param predicate A function that accepts up to three arguments. The some method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value true, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    some(predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): boolean;\r\n    /**\r\n     * Performs the specified action for each element in an array.\r\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.\r\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;\r\n    /**\r\n     * Calls a defined callback function on each element of an array, and returns an array that contains the results.\r\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];\r\n    /**\r\n     * Returns the elements of an array that meet the condition specified in a callback function.\r\n     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    filter<S extends T>(predicate: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[];\r\n    /**\r\n     * Returns the elements of an array that meet the condition specified in a callback function.\r\n     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    filter(predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): T[];\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\r\n     */\r\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;\r\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\r\n     */\r\n    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\r\n     */\r\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;\r\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\r\n     */\r\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\r\n\r\n    [n: number]: T;\r\n}\r\n\r\ninterface ArrayConstructor {\r\n    new(arrayLength?: number): any[];\r\n    new <T>(arrayLength: number): T[];\r\n    new <T>(...items: T[]): T[];\r\n    (arrayLength?: number): any[];\r\n    <T>(arrayLength: number): T[];\r\n    <T>(...items: T[]): T[];\r\n    isArray(arg: any): arg is any[];\r\n    readonly prototype: any[];\r\n}\r\n\r\ndeclare var Array: ArrayConstructor;\r\n\r\ninterface TypedPropertyDescriptor<T> {\r\n    enumerable?: boolean;\r\n    configurable?: boolean;\r\n    writable?: boolean;\r\n    value?: T;\r\n    get?: () => T;\r\n    set?: (value: T) => void;\r\n}\r\n\r\ndeclare type ClassDecorator = <TFunction extends Function>(target: TFunction) => TFunction | void;\r\ndeclare type PropertyDecorator = (target: Object, propertyKey: string | symbol) => void;\r\ndeclare type MethodDecorator = <T>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>) => TypedPropertyDescriptor<T> | void;\r\ndeclare type ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) => void;\r\n\r\ndeclare type PromiseConstructorLike = new <T>(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void) => PromiseLike<T>;\r\n\r\ninterface PromiseLike<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): PromiseLike<TResult1 | TResult2>;\r\n}\r\n\r\n/**\r\n * Represents the completion of an asynchronous operation\r\n */\r\ninterface Promise<T> {\r\n    /**\r\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\r\n     * @param onfulfilled The callback to execute when the Promise is resolved.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of which ever callback is executed.\r\n     */\r\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\r\n\r\n    /**\r\n     * Attaches a callback for only the rejection of the Promise.\r\n     * @param onrejected The callback to execute when the Promise is rejected.\r\n     * @returns A Promise for the completion of the callback.\r\n     */\r\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\r\n}\r\n\r\n/**\r\n * Recursively unwraps the \"awaited type\" of a type. Non-promise \"thenables\" should resolve to `never`. This emulates the behavior of `await`.\r\n */\r\ntype Awaited<T> =\r\n    T extends null | undefined ? T : // special case for `null | undefined` when not in `--strictNullChecks` mode\r\n        T extends object & { then(onfulfilled: infer F): any } ? // `await` only unwraps object types with a callable `then`. Non-object types are not unwrapped\r\n            F extends ((value: infer V, ...args: any) => any) ? // if the argument to `then` is callable, extracts the first argument\r\n                Awaited<V> : // recursively unwrap the value\r\n                never : // the argument to `then` was not callable\r\n        T; // non-object or non-thenable\r\n\r\ninterface ArrayLike<T> {\r\n    readonly length: number;\r\n    readonly [n: number]: T;\r\n}\r\n\r\n/**\r\n * Make all properties in T optional\r\n */\r\ntype Partial<T> = {\r\n    [P in keyof T]?: T[P];\r\n};\r\n\r\n/**\r\n * Make all properties in T required\r\n */\r\ntype Required<T> = {\r\n    [P in keyof T]-?: T[P];\r\n};\r\n\r\n/**\r\n * Make all properties in T readonly\r\n */\r\ntype Readonly<T> = {\r\n    readonly [P in keyof T]: T[P];\r\n};\r\n\r\n/**\r\n * From T, pick a set of properties whose keys are in the union K\r\n */\r\ntype Pick<T, K extends keyof T> = {\r\n    [P in K]: T[P];\r\n};\r\n\r\n/**\r\n * Construct a type with a set of properties K of type T\r\n */\r\ntype Record<K extends keyof any, T> = {\r\n    [P in K]: T;\r\n};\r\n\r\n/**\r\n * Exclude from T those types that are assignable to U\r\n */\r\ntype Exclude<T, U> = T extends U ? never : T;\r\n\r\n/**\r\n * Extract from T those types that are assignable to U\r\n */\r\ntype Extract<T, U> = T extends U ? T : never;\r\n\r\n/**\r\n * Construct a type with the properties of T except for those in type K.\r\n */\r\ntype Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;\r\n\r\n/**\r\n * Exclude null and undefined from T\r\n */\r\ntype NonNullable<T> = T extends null | undefined ? never : T;\r\n\r\n/**\r\n * Obtain the parameters of a function type in a tuple\r\n */\r\ntype Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;\r\n\r\n/**\r\n * Obtain the parameters of a constructor function type in a tuple\r\n */\r\ntype ConstructorParameters<T extends abstract new (...args: any) => any> = T extends abstract new (...args: infer P) => any ? P : never;\r\n\r\n/**\r\n * Obtain the return type of a function type\r\n */\r\ntype ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;\r\n\r\n/**\r\n * Obtain the return type of a constructor function type\r\n */\r\ntype InstanceType<T extends abstract new (...args: any) => any> = T extends abstract new (...args: any) => infer R ? R : any;\r\n\r\n/**\r\n * Convert string literal type to uppercase\r\n */\r\ntype Uppercase<S extends string> = intrinsic;\r\n\r\n/**\r\n * Convert string literal type to lowercase\r\n */\r\ntype Lowercase<S extends string> = intrinsic;\r\n\r\n/**\r\n * Convert first character of string literal type to uppercase\r\n */\r\ntype Capitalize<S extends string> = intrinsic;\r\n\r\n/**\r\n * Convert first character of string literal type to lowercase\r\n */\r\ntype Uncapitalize<S extends string> = intrinsic;\r\n\r\n/**\r\n * Marker for contextual 'this' type\r\n */\r\ninterface ThisType<T> { }\r\n\r\n/**\r\n * Represents a raw buffer of binary data, which is used to store data for the\r\n * different typed arrays. ArrayBuffers cannot be read from or written to directly,\r\n * but can be passed to a typed array or DataView Object to interpret the raw\r\n * buffer as needed.\r\n */\r\ninterface ArrayBuffer {\r\n    /**\r\n     * Read-only. The length of the ArrayBuffer (in bytes).\r\n     */\r\n    readonly byteLength: number;\r\n\r\n    /**\r\n     * Returns a section of an ArrayBuffer.\r\n     */\r\n    slice(begin: number, end?: number): ArrayBuffer;\r\n}\r\n\r\n/**\r\n * Allowed ArrayBuffer types for the buffer of an ArrayBufferView and related Typed Arrays.\r\n */\r\ninterface ArrayBufferTypes {\r\n    ArrayBuffer: ArrayBuffer;\r\n}\r\ntype ArrayBufferLike = ArrayBufferTypes[keyof ArrayBufferTypes];\r\n\r\ninterface ArrayBufferConstructor {\r\n    readonly prototype: ArrayBuffer;\r\n    new(byteLength: number): ArrayBuffer;\r\n    isView(arg: any): arg is ArrayBufferView;\r\n}\r\ndeclare var ArrayBuffer: ArrayBufferConstructor;\r\n\r\ninterface ArrayBufferView {\r\n    /**\r\n     * The ArrayBuffer instance referenced by the array.\r\n     */\r\n    buffer: ArrayBufferLike;\r\n\r\n    /**\r\n     * The length in bytes of the array.\r\n     */\r\n    byteLength: number;\r\n\r\n    /**\r\n     * The offset in bytes of the array.\r\n     */\r\n    byteOffset: number;\r\n}\r\n\r\ninterface DataView {\r\n    readonly buffer: ArrayBuffer;\r\n    readonly byteLength: number;\r\n    readonly byteOffset: number;\r\n    /**\r\n     * Gets the Float32 value at the specified byte offset from the start of the view. There is\r\n     * no alignment constraint; multi-byte values may be fetched from any offset.\r\n     * @param byteOffset The place in the buffer at which the value should be retrieved.\r\n     */\r\n    getFloat32(byteOffset: number, littleEndian?: boolean): number;\r\n\r\n    /**\r\n     * Gets the Float64 value at the specified byte offset from the start of the view. There is\r\n     * no alignment constraint; multi-byte values may be fetched from any offset.\r\n     * @param byteOffset The place in the buffer at which the value should be retrieved.\r\n     */\r\n    getFloat64(byteOffset: number, littleEndian?: boolean): number;\r\n\r\n    /**\r\n     * Gets the Int8 value at the specified byte offset from the start of the view. There is\r\n     * no alignment constraint; multi-byte values may be fetched from any offset.\r\n     * @param byteOffset The place in the buffer at which the value should be retrieved.\r\n     */\r\n    getInt8(byteOffset: number): number;\r\n\r\n    /**\r\n     * Gets the Int16 value at the specified byte offset from the start of the view. There is\r\n     * no alignment constraint; multi-byte values may be fetched from any offset.\r\n     * @param byteOffset The place in the buffer at which the value should be retrieved.\r\n     */\r\n    getInt16(byteOffset: number, littleEndian?: boolean): number;\r\n    /**\r\n     * Gets the Int32 value at the specified byte offset from the start of the view. There is\r\n     * no alignment constraint; multi-byte values may be fetched from any offset.\r\n     * @param byteOffset The place in the buffer at which the value should be retrieved.\r\n     */\r\n    getInt32(byteOffset: number, littleEndian?: boolean): number;\r\n\r\n    /**\r\n     * Gets the Uint8 value at the specified byte offset from the start of the view. There is\r\n     * no alignment constraint; multi-byte values may be fetched from any offset.\r\n     * @param byteOffset The place in the buffer at which the value should be retrieved.\r\n     */\r\n    getUint8(byteOffset: number): number;\r\n\r\n    /**\r\n     * Gets the Uint16 value at the specified byte offset from the start of the view. There is\r\n     * no alignment constraint; multi-byte values may be fetched from any offset.\r\n     * @param byteOffset The place in the buffer at which the value should be retrieved.\r\n     */\r\n    getUint16(byteOffset: number, littleEndian?: boolean): number;\r\n\r\n    /**\r\n     * Gets the Uint32 value at the specified byte offset from the start of the view. There is\r\n     * no alignment constraint; multi-byte values may be fetched from any offset.\r\n     * @param byteOffset The place in the buffer at which the value should be retrieved.\r\n     */\r\n    getUint32(byteOffset: number, littleEndian?: boolean): number;\r\n\r\n    /**\r\n     * Stores an Float32 value at the specified byte offset from the start of the view.\r\n     * @param byteOffset The place in the buffer at which the value should be set.\r\n     * @param value The value to set.\r\n     * @param littleEndian If false or undefined, a big-endian value should be written,\r\n     * otherwise a little-endian value should be written.\r\n     */\r\n    setFloat32(byteOffset: number, value: number, littleEndian?: boolean): void;\r\n\r\n    /**\r\n     * Stores an Float64 value at the specified byte offset from the start of the view.\r\n     * @param byteOffset The place in the buffer at which the value should be set.\r\n     * @param value The value to set.\r\n     * @param littleEndian If false or undefined, a big-endian value should be written,\r\n     * otherwise a little-endian value should be written.\r\n     */\r\n    setFloat64(byteOffset: number, value: number, littleEndian?: boolean): void;\r\n\r\n    /**\r\n     * Stores an Int8 value at the specified byte offset from the start of the view.\r\n     * @param byteOffset The place in the buffer at which the value should be set.\r\n     * @param value The value to set.\r\n     */\r\n    setInt8(byteOffset: number, value: number): void;\r\n\r\n    /**\r\n     * Stores an Int16 value at the specified byte offset from the start of the view.\r\n     * @param byteOffset The place in the buffer at which the value should be set.\r\n     * @param value The value to set.\r\n     * @param littleEndian If false or undefined, a big-endian value should be written,\r\n     * otherwise a little-endian value should be written.\r\n     */\r\n    setInt16(byteOffset: number, value: number, littleEndian?: boolean): void;\r\n\r\n    /**\r\n     * Stores an Int32 value at the specified byte offset from the start of the view.\r\n     * @param byteOffset The place in the buffer at which the value should be set.\r\n     * @param value The value to set.\r\n     * @param littleEndian If false or undefined, a big-endian value should be written,\r\n     * otherwise a little-endian value should be written.\r\n     */\r\n    setInt32(byteOffset: number, value: number, littleEndian?: boolean): void;\r\n\r\n    /**\r\n     * Stores an Uint8 value at the specified byte offset from the start of the view.\r\n     * @param byteOffset The place in the buffer at which the value should be set.\r\n     * @param value The value to set.\r\n     */\r\n    setUint8(byteOffset: number, value: number): void;\r\n\r\n    /**\r\n     * Stores an Uint16 value at the specified byte offset from the start of the view.\r\n     * @param byteOffset The place in the buffer at which the value should be set.\r\n     * @param value The value to set.\r\n     * @param littleEndian If false or undefined, a big-endian value should be written,\r\n     * otherwise a little-endian value should be written.\r\n     */\r\n    setUint16(byteOffset: number, value: number, littleEndian?: boolean): void;\r\n\r\n    /**\r\n     * Stores an Uint32 value at the specified byte offset from the start of the view.\r\n     * @param byteOffset The place in the buffer at which the value should be set.\r\n     * @param value The value to set.\r\n     * @param littleEndian If false or undefined, a big-endian value should be written,\r\n     * otherwise a little-endian value should be written.\r\n     */\r\n    setUint32(byteOffset: number, value: number, littleEndian?: boolean): void;\r\n}\r\n\r\ninterface DataViewConstructor {\r\n    readonly prototype: DataView;\r\n    new(buffer: ArrayBufferLike, byteOffset?: number, byteLength?: number): DataView;\r\n}\r\ndeclare var DataView: DataViewConstructor;\r\n\r\n/**\r\n * A typed array of 8-bit integer values. The contents are initialized to 0. If the requested\r\n * number of bytes could not be allocated an exception is raised.\r\n */\r\ninterface Int8Array {\r\n    /**\r\n     * The size in bytes of each element in the array.\r\n     */\r\n    readonly BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n     * The ArrayBuffer instance referenced by the array.\r\n     */\r\n    readonly buffer: ArrayBufferLike;\r\n\r\n    /**\r\n     * The length in bytes of the array.\r\n     */\r\n    readonly byteLength: number;\r\n\r\n    /**\r\n     * The offset in bytes of the array.\r\n     */\r\n    readonly byteOffset: number;\r\n\r\n    /**\r\n     * Returns the this object after copying a section of the array identified by start and end\r\n     * to the same array starting at position target\r\n     * @param target If target is negative, it is treated as length+target where length is the\r\n     * length of the array.\r\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\r\n     * is treated as length+end.\r\n     * @param end If not specified, length of the this object is used as its default value.\r\n     */\r\n    copyWithin(target: number, start: number, end?: number): this;\r\n\r\n    /**\r\n     * Determines whether all the members of an array satisfy the specified test.\r\n     * @param predicate A function that accepts up to three arguments. The every method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value false, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    every(predicate: (value: number, index: number, array: Int8Array) => unknown, thisArg?: any): boolean;\r\n\r\n    /**\r\n     * Changes all array elements from `start` to `end` index to a static `value` and returns the modified array\r\n     * @param value value to fill array section with\r\n     * @param start index to start filling the array at. If start is negative, it is treated as\r\n     * length+start where length is the length of the array.\r\n     * @param end index to stop filling the array at. If end is negative, it is treated as\r\n     * length+end.\r\n     */\r\n    fill(value: number, start?: number, end?: number): this;\r\n\r\n    /**\r\n     * Returns the elements of an array that meet the condition specified in a callback function.\r\n     * @param predicate A function that accepts up to three arguments. The filter method calls\r\n     * the predicate function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    filter(predicate: (value: number, index: number, array: Int8Array) => any, thisArg?: any): Int8Array;\r\n\r\n    /**\r\n     * Returns the value of the first element in the array where predicate is true, and undefined\r\n     * otherwise.\r\n     * @param predicate find calls predicate once for each element of the array, in ascending\r\n     * order, until it finds one where predicate returns true. If such an element is found, find\r\n     * immediately returns that element value. Otherwise, find returns undefined.\r\n     * @param thisArg If provided, it will be used as the this value for each invocation of\r\n     * predicate. If it is not provided, undefined is used instead.\r\n     */\r\n    find(predicate: (value: number, index: number, obj: Int8Array) => boolean, thisArg?: any): number | undefined;\r\n\r\n    /**\r\n     * Returns the index of the first element in the array where predicate is true, and -1\r\n     * otherwise.\r\n     * @param predicate find calls predicate once for each element of the array, in ascending\r\n     * order, until it finds one where predicate returns true. If such an element is found,\r\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\r\n     * @param thisArg If provided, it will be used as the this value for each invocation of\r\n     * predicate. If it is not provided, undefined is used instead.\r\n     */\r\n    findIndex(predicate: (value: number, index: number, obj: Int8Array) => boolean, thisArg?: any): number;\r\n\r\n    /**\r\n     * Performs the specified action for each element in an array.\r\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    forEach(callbackfn: (value: number, index: number, array: Int8Array) => void, thisArg?: any): void;\r\n\r\n    /**\r\n     * Returns the index of the first occurrence of a value in an array.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\r\n     *  search starts at index 0.\r\n     */\r\n    indexOf(searchElement: number, fromIndex?: number): number;\r\n\r\n    /**\r\n     * Adds all the elements of an array separated by the specified separator string.\r\n     * @param separator A string used to separate one element of an array from the next in the\r\n     * resulting String. If omitted, the array elements are separated with a comma.\r\n     */\r\n    join(separator?: string): string;\r\n\r\n    /**\r\n     * Returns the index of the last occurrence of a value in an array.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\r\n     * search starts at index 0.\r\n     */\r\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\r\n\r\n    /**\r\n     * The length of the array.\r\n     */\r\n    readonly length: number;\r\n\r\n    /**\r\n     * Calls a defined callback function on each element of an array, and returns an array that\r\n     * contains the results.\r\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    map(callbackfn: (value: number, index: number, array: Int8Array) => number, thisArg?: any): Int8Array;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array. The return value of\r\n     * the callback function is the accumulated result, and is provided as an argument in the next\r\n     * call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number): number;\r\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number, initialValue: number): number;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array. The return value of\r\n     * the callback function is the accumulated result, and is provided as an argument in the next\r\n     * call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array) => U, initialValue: U): U;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array, in descending order.\r\n     * The return value of the callback function is the accumulated result, and is provided as an\r\n     * argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\r\n     * the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an\r\n     * argument instead of an array value.\r\n     */\r\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number): number;\r\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number, initialValue: number): number;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array, in descending order.\r\n     * The return value of the callback function is the accumulated result, and is provided as an\r\n     * argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\r\n     * the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array) => U, initialValue: U): U;\r\n\r\n    /**\r\n     * Reverses the elements in an Array.\r\n     */\r\n    reverse(): Int8Array;\r\n\r\n    /**\r\n     * Sets a value or an array of values.\r\n     * @param array A typed or untyped array of values to set.\r\n     * @param offset The index in the current array at which the values are to be written.\r\n     */\r\n    set(array: ArrayLike<number>, offset?: number): void;\r\n\r\n    /**\r\n     * Returns a section of an array.\r\n     * @param start The beginning of the specified portion of the array.\r\n     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.\r\n     */\r\n    slice(start?: number, end?: number): Int8Array;\r\n\r\n    /**\r\n     * Determines whether the specified callback function returns true for any element of an array.\r\n     * @param predicate A function that accepts up to three arguments. The some method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value true, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    some(predicate: (value: number, index: number, array: Int8Array) => unknown, thisArg?: any): boolean;\r\n\r\n    /**\r\n     * Sorts an array.\r\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\r\n     * a negative value if first argument is less than second argument, zero if they're equal and a positive\r\n     * value otherwise. If omitted, the elements are sorted in ascending order.\r\n     * ```ts\r\n     * [11,2,22,1].sort((a, b) => a - b)\r\n     * ```\r\n     */\r\n    sort(compareFn?: (a: number, b: number) => number): this;\r\n\r\n    /**\r\n     * Gets a new Int8Array view of the ArrayBuffer store for this array, referencing the elements\r\n     * at begin, inclusive, up to end, exclusive.\r\n     * @param begin The index of the beginning of the array.\r\n     * @param end The index of the end of the array.\r\n     */\r\n    subarray(begin?: number, end?: number): Int8Array;\r\n\r\n    /**\r\n     * Converts a number to a string by using the current locale.\r\n     */\r\n    toLocaleString(): string;\r\n\r\n    /**\r\n     * Returns a string representation of an array.\r\n     */\r\n    toString(): string;\r\n\r\n    /** Returns the primitive value of the specified object. */\r\n    valueOf(): Int8Array;\r\n\r\n    [index: number]: number;\r\n}\r\ninterface Int8ArrayConstructor {\r\n    readonly prototype: Int8Array;\r\n    new(length: number): Int8Array;\r\n    new(array: ArrayLike<number> | ArrayBufferLike): Int8Array;\r\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Int8Array;\r\n\r\n    /**\r\n     * The size in bytes of each element in the array.\r\n     */\r\n    readonly BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n     * Returns a new array from a set of elements.\r\n     * @param items A set of elements to include in the new array object.\r\n     */\r\n    of(...items: number[]): Int8Array;\r\n\r\n    /**\r\n     * Creates an array from an array-like or iterable object.\r\n     * @param arrayLike An array-like or iterable object to convert to an array.\r\n     */\r\n    from(arrayLike: ArrayLike<number>): Int8Array;\r\n\r\n    /**\r\n     * Creates an array from an array-like or iterable object.\r\n     * @param arrayLike An array-like or iterable object to convert to an array.\r\n     * @param mapfn A mapping function to call on every element of the array.\r\n     * @param thisArg Value of 'this' used to invoke the mapfn.\r\n     */\r\n    from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number, thisArg?: any): Int8Array;\r\n\r\n\r\n}\r\ndeclare var Int8Array: Int8ArrayConstructor;\r\n\r\n/**\r\n * A typed array of 8-bit unsigned integer values. The contents are initialized to 0. If the\r\n * requested number of bytes could not be allocated an exception is raised.\r\n */\r\ninterface Uint8Array {\r\n    /**\r\n     * The size in bytes of each element in the array.\r\n     */\r\n    readonly BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n     * The ArrayBuffer instance referenced by the array.\r\n     */\r\n    readonly buffer: ArrayBufferLike;\r\n\r\n    /**\r\n     * The length in bytes of the array.\r\n     */\r\n    readonly byteLength: number;\r\n\r\n    /**\r\n     * The offset in bytes of the array.\r\n     */\r\n    readonly byteOffset: number;\r\n\r\n    /**\r\n     * Returns the this object after copying a section of the array identified by start and end\r\n     * to the same array starting at position target\r\n     * @param target If target is negative, it is treated as length+target where length is the\r\n     * length of the array.\r\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\r\n     * is treated as length+end.\r\n     * @param end If not specified, length of the this object is used as its default value.\r\n     */\r\n    copyWithin(target: number, start: number, end?: number): this;\r\n\r\n    /**\r\n     * Determines whether all the members of an array satisfy the specified test.\r\n     * @param predicate A function that accepts up to three arguments. The every method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value false, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    every(predicate: (value: number, index: number, array: Uint8Array) => unknown, thisArg?: any): boolean;\r\n\r\n    /**\r\n     * Changes all array elements from `start` to `end` index to a static `value` and returns the modified array\r\n     * @param value value to fill array section with\r\n     * @param start index to start filling the array at. If start is negative, it is treated as\r\n     * length+start where length is the length of the array.\r\n     * @param end index to stop filling the array at. If end is negative, it is treated as\r\n     * length+end.\r\n     */\r\n    fill(value: number, start?: number, end?: number): this;\r\n\r\n    /**\r\n     * Returns the elements of an array that meet the condition specified in a callback function.\r\n     * @param predicate A function that accepts up to three arguments. The filter method calls\r\n     * the predicate function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    filter(predicate: (value: number, index: number, array: Uint8Array) => any, thisArg?: any): Uint8Array;\r\n\r\n    /**\r\n     * Returns the value of the first element in the array where predicate is true, and undefined\r\n     * otherwise.\r\n     * @param predicate find calls predicate once for each element of the array, in ascending\r\n     * order, until it finds one where predicate returns true. If such an element is found, find\r\n     * immediately returns that element value. Otherwise, find returns undefined.\r\n     * @param thisArg If provided, it will be used as the this value for each invocation of\r\n     * predicate. If it is not provided, undefined is used instead.\r\n     */\r\n    find(predicate: (value: number, index: number, obj: Uint8Array) => boolean, thisArg?: any): number | undefined;\r\n\r\n    /**\r\n     * Returns the index of the first element in the array where predicate is true, and -1\r\n     * otherwise.\r\n     * @param predicate find calls predicate once for each element of the array, in ascending\r\n     * order, until it finds one where predicate returns true. If such an element is found,\r\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\r\n     * @param thisArg If provided, it will be used as the this value for each invocation of\r\n     * predicate. If it is not provided, undefined is used instead.\r\n     */\r\n    findIndex(predicate: (value: number, index: number, obj: Uint8Array) => boolean, thisArg?: any): number;\r\n\r\n    /**\r\n     * Performs the specified action for each element in an array.\r\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    forEach(callbackfn: (value: number, index: number, array: Uint8Array) => void, thisArg?: any): void;\r\n\r\n    /**\r\n     * Returns the index of the first occurrence of a value in an array.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\r\n     *  search starts at index 0.\r\n     */\r\n    indexOf(searchElement: number, fromIndex?: number): number;\r\n\r\n    /**\r\n     * Adds all the elements of an array separated by the specified separator string.\r\n     * @param separator A string used to separate one element of an array from the next in the\r\n     * resulting String. If omitted, the array elements are separated with a comma.\r\n     */\r\n    join(separator?: string): string;\r\n\r\n    /**\r\n     * Returns the index of the last occurrence of a value in an array.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\r\n     * search starts at index 0.\r\n     */\r\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\r\n\r\n    /**\r\n     * The length of the array.\r\n     */\r\n    readonly length: number;\r\n\r\n    /**\r\n     * Calls a defined callback function on each element of an array, and returns an array that\r\n     * contains the results.\r\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    map(callbackfn: (value: number, index: number, array: Uint8Array) => number, thisArg?: any): Uint8Array;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array. The return value of\r\n     * the callback function is the accumulated result, and is provided as an argument in the next\r\n     * call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number): number;\r\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue: number): number;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array. The return value of\r\n     * the callback function is the accumulated result, and is provided as an argument in the next\r\n     * call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array) => U, initialValue: U): U;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array, in descending order.\r\n     * The return value of the callback function is the accumulated result, and is provided as an\r\n     * argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\r\n     * the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an\r\n     * argument instead of an array value.\r\n     */\r\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number): number;\r\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue: number): number;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array, in descending order.\r\n     * The return value of the callback function is the accumulated result, and is provided as an\r\n     * argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\r\n     * the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array) => U, initialValue: U): U;\r\n\r\n    /**\r\n     * Reverses the elements in an Array.\r\n     */\r\n    reverse(): Uint8Array;\r\n\r\n    /**\r\n     * Sets a value or an array of values.\r\n     * @param array A typed or untyped array of values to set.\r\n     * @param offset The index in the current array at which the values are to be written.\r\n     */\r\n    set(array: ArrayLike<number>, offset?: number): void;\r\n\r\n    /**\r\n     * Returns a section of an array.\r\n     * @param start The beginning of the specified portion of the array.\r\n     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.\r\n     */\r\n    slice(start?: number, end?: number): Uint8Array;\r\n\r\n    /**\r\n     * Determines whether the specified callback function returns true for any element of an array.\r\n     * @param predicate A function that accepts up to three arguments. The some method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value true, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    some(predicate: (value: number, index: number, array: Uint8Array) => unknown, thisArg?: any): boolean;\r\n\r\n    /**\r\n     * Sorts an array.\r\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\r\n     * a negative value if first argument is less than second argument, zero if they're equal and a positive\r\n     * value otherwise. If omitted, the elements are sorted in ascending order.\r\n     * ```ts\r\n     * [11,2,22,1].sort((a, b) => a - b)\r\n     * ```\r\n     */\r\n    sort(compareFn?: (a: number, b: number) => number): this;\r\n\r\n    /**\r\n     * Gets a new Uint8Array view of the ArrayBuffer store for this array, referencing the elements\r\n     * at begin, inclusive, up to end, exclusive.\r\n     * @param begin The index of the beginning of the array.\r\n     * @param end The index of the end of the array.\r\n     */\r\n    subarray(begin?: number, end?: number): Uint8Array;\r\n\r\n    /**\r\n     * Converts a number to a string by using the current locale.\r\n     */\r\n    toLocaleString(): string;\r\n\r\n    /**\r\n     * Returns a string representation of an array.\r\n     */\r\n    toString(): string;\r\n\r\n    /** Returns the primitive value of the specified object. */\r\n    valueOf(): Uint8Array;\r\n\r\n    [index: number]: number;\r\n}\r\n\r\ninterface Uint8ArrayConstructor {\r\n    readonly prototype: Uint8Array;\r\n    new(length: number): Uint8Array;\r\n    new(array: ArrayLike<number> | ArrayBufferLike): Uint8Array;\r\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Uint8Array;\r\n\r\n    /**\r\n     * The size in bytes of each element in the array.\r\n     */\r\n    readonly BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n     * Returns a new array from a set of elements.\r\n     * @param items A set of elements to include in the new array object.\r\n     */\r\n    of(...items: number[]): Uint8Array;\r\n\r\n    /**\r\n     * Creates an array from an array-like or iterable object.\r\n     * @param arrayLike An array-like or iterable object to convert to an array.\r\n     */\r\n    from(arrayLike: ArrayLike<number>): Uint8Array;\r\n\r\n    /**\r\n     * Creates an array from an array-like or iterable object.\r\n     * @param arrayLike An array-like or iterable object to convert to an array.\r\n     * @param mapfn A mapping function to call on every element of the array.\r\n     * @param thisArg Value of 'this' used to invoke the mapfn.\r\n     */\r\n    from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number, thisArg?: any): Uint8Array;\r\n\r\n}\r\ndeclare var Uint8Array: Uint8ArrayConstructor;\r\n\r\n/**\r\n * A typed array of 8-bit unsigned integer (clamped) values. The contents are initialized to 0.\r\n * If the requested number of bytes could not be allocated an exception is raised.\r\n */\r\ninterface Uint8ClampedArray {\r\n    /**\r\n     * The size in bytes of each element in the array.\r\n     */\r\n    readonly BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n     * The ArrayBuffer instance referenced by the array.\r\n     */\r\n    readonly buffer: ArrayBufferLike;\r\n\r\n    /**\r\n     * The length in bytes of the array.\r\n     */\r\n    readonly byteLength: number;\r\n\r\n    /**\r\n     * The offset in bytes of the array.\r\n     */\r\n    readonly byteOffset: number;\r\n\r\n    /**\r\n     * Returns the this object after copying a section of the array identified by start and end\r\n     * to the same array starting at position target\r\n     * @param target If target is negative, it is treated as length+target where length is the\r\n     * length of the array.\r\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\r\n     * is treated as length+end.\r\n     * @param end If not specified, length of the this object is used as its default value.\r\n     */\r\n    copyWithin(target: number, start: number, end?: number): this;\r\n\r\n    /**\r\n     * Determines whether all the members of an array satisfy the specified test.\r\n     * @param predicate A function that accepts up to three arguments. The every method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value false, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    every(predicate: (value: number, index: number, array: Uint8ClampedArray) => unknown, thisArg?: any): boolean;\r\n\r\n    /**\r\n     * Changes all array elements from `start` to `end` index to a static `value` and returns the modified array\r\n     * @param value value to fill array section with\r\n     * @param start index to start filling the array at. If start is negative, it is treated as\r\n     * length+start where length is the length of the array.\r\n     * @param end index to stop filling the array at. If end is negative, it is treated as\r\n     * length+end.\r\n     */\r\n    fill(value: number, start?: number, end?: number): this;\r\n\r\n    /**\r\n     * Returns the elements of an array that meet the condition specified in a callback function.\r\n     * @param predicate A function that accepts up to three arguments. The filter method calls\r\n     * the predicate function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    filter(predicate: (value: number, index: number, array: Uint8ClampedArray) => any, thisArg?: any): Uint8ClampedArray;\r\n\r\n    /**\r\n     * Returns the value of the first element in the array where predicate is true, and undefined\r\n     * otherwise.\r\n     * @param predicate find calls predicate once for each element of the array, in ascending\r\n     * order, until it finds one where predicate returns true. If such an element is found, find\r\n     * immediately returns that element value. Otherwise, find returns undefined.\r\n     * @param thisArg If provided, it will be used as the this value for each invocation of\r\n     * predicate. If it is not provided, undefined is used instead.\r\n     */\r\n    find(predicate: (value: number, index: number, obj: Uint8ClampedArray) => boolean, thisArg?: any): number | undefined;\r\n\r\n    /**\r\n     * Returns the index of the first element in the array where predicate is true, and -1\r\n     * otherwise.\r\n     * @param predicate find calls predicate once for each element of the array, in ascending\r\n     * order, until it finds one where predicate returns true. If such an element is found,\r\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\r\n     * @param thisArg If provided, it will be used as the this value for each invocation of\r\n     * predicate. If it is not provided, undefined is used instead.\r\n     */\r\n    findIndex(predicate: (value: number, index: number, obj: Uint8ClampedArray) => boolean, thisArg?: any): number;\r\n\r\n    /**\r\n     * Performs the specified action for each element in an array.\r\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    forEach(callbackfn: (value: number, index: number, array: Uint8ClampedArray) => void, thisArg?: any): void;\r\n\r\n    /**\r\n     * Returns the index of the first occurrence of a value in an array.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\r\n     *  search starts at index 0.\r\n     */\r\n    indexOf(searchElement: number, fromIndex?: number): number;\r\n\r\n    /**\r\n     * Adds all the elements of an array separated by the specified separator string.\r\n     * @param separator A string used to separate one element of an array from the next in the\r\n     * resulting String. If omitted, the array elements are separated with a comma.\r\n     */\r\n    join(separator?: string): string;\r\n\r\n    /**\r\n     * Returns the index of the last occurrence of a value in an array.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\r\n     * search starts at index 0.\r\n     */\r\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\r\n\r\n    /**\r\n     * The length of the array.\r\n     */\r\n    readonly length: number;\r\n\r\n    /**\r\n     * Calls a defined callback function on each element of an array, and returns an array that\r\n     * contains the results.\r\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    map(callbackfn: (value: number, index: number, array: Uint8ClampedArray) => number, thisArg?: any): Uint8ClampedArray;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array. The return value of\r\n     * the callback function is the accumulated result, and is provided as an argument in the next\r\n     * call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => number): number;\r\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => number, initialValue: number): number;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array. The return value of\r\n     * the callback function is the accumulated result, and is provided as an argument in the next\r\n     * call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => U, initialValue: U): U;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array, in descending order.\r\n     * The return value of the callback function is the accumulated result, and is provided as an\r\n     * argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\r\n     * the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an\r\n     * argument instead of an array value.\r\n     */\r\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => number): number;\r\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => number, initialValue: number): number;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array, in descending order.\r\n     * The return value of the callback function is the accumulated result, and is provided as an\r\n     * argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\r\n     * the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => U, initialValue: U): U;\r\n\r\n    /**\r\n     * Reverses the elements in an Array.\r\n     */\r\n    reverse(): Uint8ClampedArray;\r\n\r\n    /**\r\n     * Sets a value or an array of values.\r\n     * @param array A typed or untyped array of values to set.\r\n     * @param offset The index in the current array at which the values are to be written.\r\n     */\r\n    set(array: ArrayLike<number>, offset?: number): void;\r\n\r\n    /**\r\n     * Returns a section of an array.\r\n     * @param start The beginning of the specified portion of the array.\r\n     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.\r\n     */\r\n    slice(start?: number, end?: number): Uint8ClampedArray;\r\n\r\n    /**\r\n     * Determines whether the specified callback function returns true for any element of an array.\r\n     * @param predicate A function that accepts up to three arguments. The some method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value true, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    some(predicate: (value: number, index: number, array: Uint8ClampedArray) => unknown, thisArg?: any): boolean;\r\n\r\n    /**\r\n     * Sorts an array.\r\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\r\n     * a negative value if first argument is less than second argument, zero if they're equal and a positive\r\n     * value otherwise. If omitted, the elements are sorted in ascending order.\r\n     * ```ts\r\n     * [11,2,22,1].sort((a, b) => a - b)\r\n     * ```\r\n     */\r\n    sort(compareFn?: (a: number, b: number) => number): this;\r\n\r\n    /**\r\n     * Gets a new Uint8ClampedArray view of the ArrayBuffer store for this array, referencing the elements\r\n     * at begin, inclusive, up to end, exclusive.\r\n     * @param begin The index of the beginning of the array.\r\n     * @param end The index of the end of the array.\r\n     */\r\n    subarray(begin?: number, end?: number): Uint8ClampedArray;\r\n\r\n    /**\r\n     * Converts a number to a string by using the current locale.\r\n     */\r\n    toLocaleString(): string;\r\n\r\n    /**\r\n     * Returns a string representation of an array.\r\n     */\r\n    toString(): string;\r\n\r\n    /** Returns the primitive value of the specified object. */\r\n    valueOf(): Uint8ClampedArray;\r\n\r\n    [index: number]: number;\r\n}\r\n\r\ninterface Uint8ClampedArrayConstructor {\r\n    readonly prototype: Uint8ClampedArray;\r\n    new(length: number): Uint8ClampedArray;\r\n    new(array: ArrayLike<number> | ArrayBufferLike): Uint8ClampedArray;\r\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Uint8ClampedArray;\r\n\r\n    /**\r\n     * The size in bytes of each element in the array.\r\n     */\r\n    readonly BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n     * Returns a new array from a set of elements.\r\n     * @param items A set of elements to include in the new array object.\r\n     */\r\n    of(...items: number[]): Uint8ClampedArray;\r\n\r\n    /**\r\n     * Creates an array from an array-like or iterable object.\r\n     * @param arrayLike An array-like or iterable object to convert to an array.\r\n     */\r\n    from(arrayLike: ArrayLike<number>): Uint8ClampedArray;\r\n\r\n    /**\r\n     * Creates an array from an array-like or iterable object.\r\n     * @param arrayLike An array-like or iterable object to convert to an array.\r\n     * @param mapfn A mapping function to call on every element of the array.\r\n     * @param thisArg Value of 'this' used to invoke the mapfn.\r\n     */\r\n    from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number, thisArg?: any): Uint8ClampedArray;\r\n}\r\ndeclare var Uint8ClampedArray: Uint8ClampedArrayConstructor;\r\n\r\n/**\r\n * A typed array of 16-bit signed integer values. The contents are initialized to 0. If the\r\n * requested number of bytes could not be allocated an exception is raised.\r\n */\r\ninterface Int16Array {\r\n    /**\r\n     * The size in bytes of each element in the array.\r\n     */\r\n    readonly BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n     * The ArrayBuffer instance referenced by the array.\r\n     */\r\n    readonly buffer: ArrayBufferLike;\r\n\r\n    /**\r\n     * The length in bytes of the array.\r\n     */\r\n    readonly byteLength: number;\r\n\r\n    /**\r\n     * The offset in bytes of the array.\r\n     */\r\n    readonly byteOffset: number;\r\n\r\n    /**\r\n     * Returns the this object after copying a section of the array identified by start and end\r\n     * to the same array starting at position target\r\n     * @param target If target is negative, it is treated as length+target where length is the\r\n     * length of the array.\r\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\r\n     * is treated as length+end.\r\n     * @param end If not specified, length of the this object is used as its default value.\r\n     */\r\n    copyWithin(target: number, start: number, end?: number): this;\r\n\r\n    /**\r\n     * Determines whether all the members of an array satisfy the specified test.\r\n     * @param predicate A function that accepts up to three arguments. The every method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value false, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    every(predicate: (value: number, index: number, array: Int16Array) => unknown, thisArg?: any): boolean;\r\n\r\n    /**\r\n     * Changes all array elements from `start` to `end` index to a static `value` and returns the modified array\r\n     * @param value value to fill array section with\r\n     * @param start index to start filling the array at. If start is negative, it is treated as\r\n     * length+start where length is the length of the array.\r\n     * @param end index to stop filling the array at. If end is negative, it is treated as\r\n     * length+end.\r\n     */\r\n    fill(value: number, start?: number, end?: number): this;\r\n\r\n    /**\r\n     * Returns the elements of an array that meet the condition specified in a callback function.\r\n     * @param predicate A function that accepts up to three arguments. The filter method calls\r\n     * the predicate function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    filter(predicate: (value: number, index: number, array: Int16Array) => any, thisArg?: any): Int16Array;\r\n\r\n    /**\r\n     * Returns the value of the first element in the array where predicate is true, and undefined\r\n     * otherwise.\r\n     * @param predicate find calls predicate once for each element of the array, in ascending\r\n     * order, until it finds one where predicate returns true. If such an element is found, find\r\n     * immediately returns that element value. Otherwise, find returns undefined.\r\n     * @param thisArg If provided, it will be used as the this value for each invocation of\r\n     * predicate. If it is not provided, undefined is used instead.\r\n     */\r\n    find(predicate: (value: number, index: number, obj: Int16Array) => boolean, thisArg?: any): number | undefined;\r\n\r\n    /**\r\n     * Returns the index of the first element in the array where predicate is true, and -1\r\n     * otherwise.\r\n     * @param predicate find calls predicate once for each element of the array, in ascending\r\n     * order, until it finds one where predicate returns true. If such an element is found,\r\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\r\n     * @param thisArg If provided, it will be used as the this value for each invocation of\r\n     * predicate. If it is not provided, undefined is used instead.\r\n     */\r\n    findIndex(predicate: (value: number, index: number, obj: Int16Array) => boolean, thisArg?: any): number;\r\n\r\n    /**\r\n     * Performs the specified action for each element in an array.\r\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    forEach(callbackfn: (value: number, index: number, array: Int16Array) => void, thisArg?: any): void;\r\n    /**\r\n     * Returns the index of the first occurrence of a value in an array.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\r\n     *  search starts at index 0.\r\n     */\r\n    indexOf(searchElement: number, fromIndex?: number): number;\r\n\r\n    /**\r\n     * Adds all the elements of an array separated by the specified separator string.\r\n     * @param separator A string used to separate one element of an array from the next in the\r\n     * resulting String. If omitted, the array elements are separated with a comma.\r\n     */\r\n    join(separator?: string): string;\r\n\r\n    /**\r\n     * Returns the index of the last occurrence of a value in an array.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\r\n     * search starts at index 0.\r\n     */\r\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\r\n\r\n    /**\r\n     * The length of the array.\r\n     */\r\n    readonly length: number;\r\n\r\n    /**\r\n     * Calls a defined callback function on each element of an array, and returns an array that\r\n     * contains the results.\r\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    map(callbackfn: (value: number, index: number, array: Int16Array) => number, thisArg?: any): Int16Array;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array. The return value of\r\n     * the callback function is the accumulated result, and is provided as an argument in the next\r\n     * call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number): number;\r\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number, initialValue: number): number;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array. The return value of\r\n     * the callback function is the accumulated result, and is provided as an argument in the next\r\n     * call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array) => U, initialValue: U): U;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array, in descending order.\r\n     * The return value of the callback function is the accumulated result, and is provided as an\r\n     * argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\r\n     * the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an\r\n     * argument instead of an array value.\r\n     */\r\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number): number;\r\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number, initialValue: number): number;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array, in descending order.\r\n     * The return value of the callback function is the accumulated result, and is provided as an\r\n     * argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\r\n     * the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array) => U, initialValue: U): U;\r\n\r\n    /**\r\n     * Reverses the elements in an Array.\r\n     */\r\n    reverse(): Int16Array;\r\n\r\n    /**\r\n     * Sets a value or an array of values.\r\n     * @param array A typed or untyped array of values to set.\r\n     * @param offset The index in the current array at which the values are to be written.\r\n     */\r\n    set(array: ArrayLike<number>, offset?: number): void;\r\n\r\n    /**\r\n     * Returns a section of an array.\r\n     * @param start The beginning of the specified portion of the array.\r\n     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.\r\n     */\r\n    slice(start?: number, end?: number): Int16Array;\r\n\r\n    /**\r\n     * Determines whether the specified callback function returns true for any element of an array.\r\n     * @param predicate A function that accepts up to three arguments. The some method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value true, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    some(predicate: (value: number, index: number, array: Int16Array) => unknown, thisArg?: any): boolean;\r\n\r\n    /**\r\n     * Sorts an array.\r\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\r\n     * a negative value if first argument is less than second argument, zero if they're equal and a positive\r\n     * value otherwise. If omitted, the elements are sorted in ascending order.\r\n     * ```ts\r\n     * [11,2,22,1].sort((a, b) => a - b)\r\n     * ```\r\n     */\r\n    sort(compareFn?: (a: number, b: number) => number): this;\r\n\r\n    /**\r\n     * Gets a new Int16Array view of the ArrayBuffer store for this array, referencing the elements\r\n     * at begin, inclusive, up to end, exclusive.\r\n     * @param begin The index of the beginning of the array.\r\n     * @param end The index of the end of the array.\r\n     */\r\n    subarray(begin?: number, end?: number): Int16Array;\r\n\r\n    /**\r\n     * Converts a number to a string by using the current locale.\r\n     */\r\n    toLocaleString(): string;\r\n\r\n    /**\r\n     * Returns a string representation of an array.\r\n     */\r\n    toString(): string;\r\n\r\n    /** Returns the primitive value of the specified object. */\r\n    valueOf(): Int16Array;\r\n\r\n    [index: number]: number;\r\n}\r\n\r\ninterface Int16ArrayConstructor {\r\n    readonly prototype: Int16Array;\r\n    new(length: number): Int16Array;\r\n    new(array: ArrayLike<number> | ArrayBufferLike): Int16Array;\r\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Int16Array;\r\n\r\n    /**\r\n     * The size in bytes of each element in the array.\r\n     */\r\n    readonly BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n     * Returns a new array from a set of elements.\r\n     * @param items A set of elements to include in the new array object.\r\n     */\r\n    of(...items: number[]): Int16Array;\r\n\r\n    /**\r\n     * Creates an array from an array-like or iterable object.\r\n     * @param arrayLike An array-like or iterable object to convert to an array.\r\n     */\r\n    from(arrayLike: ArrayLike<number>): Int16Array;\r\n\r\n    /**\r\n     * Creates an array from an array-like or iterable object.\r\n     * @param arrayLike An array-like or iterable object to convert to an array.\r\n     * @param mapfn A mapping function to call on every element of the array.\r\n     * @param thisArg Value of 'this' used to invoke the mapfn.\r\n     */\r\n    from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number, thisArg?: any): Int16Array;\r\n\r\n\r\n}\r\ndeclare var Int16Array: Int16ArrayConstructor;\r\n\r\n/**\r\n * A typed array of 16-bit unsigned integer values. The contents are initialized to 0. If the\r\n * requested number of bytes could not be allocated an exception is raised.\r\n */\r\ninterface Uint16Array {\r\n    /**\r\n     * The size in bytes of each element in the array.\r\n     */\r\n    readonly BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n     * The ArrayBuffer instance referenced by the array.\r\n     */\r\n    readonly buffer: ArrayBufferLike;\r\n\r\n    /**\r\n     * The length in bytes of the array.\r\n     */\r\n    readonly byteLength: number;\r\n\r\n    /**\r\n     * The offset in bytes of the array.\r\n     */\r\n    readonly byteOffset: number;\r\n\r\n    /**\r\n     * Returns the this object after copying a section of the array identified by start and end\r\n     * to the same array starting at position target\r\n     * @param target If target is negative, it is treated as length+target where length is the\r\n     * length of the array.\r\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\r\n     * is treated as length+end.\r\n     * @param end If not specified, length of the this object is used as its default value.\r\n     */\r\n    copyWithin(target: number, start: number, end?: number): this;\r\n\r\n    /**\r\n     * Determines whether all the members of an array satisfy the specified test.\r\n     * @param predicate A function that accepts up to three arguments. The every method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value false, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    every(predicate: (value: number, index: number, array: Uint16Array) => unknown, thisArg?: any): boolean;\r\n\r\n    /**\r\n     * Changes all array elements from `start` to `end` index to a static `value` and returns the modified array\r\n     * @param value value to fill array section with\r\n     * @param start index to start filling the array at. If start is negative, it is treated as\r\n     * length+start where length is the length of the array.\r\n     * @param end index to stop filling the array at. If end is negative, it is treated as\r\n     * length+end.\r\n     */\r\n    fill(value: number, start?: number, end?: number): this;\r\n\r\n    /**\r\n     * Returns the elements of an array that meet the condition specified in a callback function.\r\n     * @param predicate A function that accepts up to three arguments. The filter method calls\r\n     * the predicate function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    filter(predicate: (value: number, index: number, array: Uint16Array) => any, thisArg?: any): Uint16Array;\r\n\r\n    /**\r\n     * Returns the value of the first element in the array where predicate is true, and undefined\r\n     * otherwise.\r\n     * @param predicate find calls predicate once for each element of the array, in ascending\r\n     * order, until it finds one where predicate returns true. If such an element is found, find\r\n     * immediately returns that element value. Otherwise, find returns undefined.\r\n     * @param thisArg If provided, it will be used as the this value for each invocation of\r\n     * predicate. If it is not provided, undefined is used instead.\r\n     */\r\n    find(predicate: (value: number, index: number, obj: Uint16Array) => boolean, thisArg?: any): number | undefined;\r\n\r\n    /**\r\n     * Returns the index of the first element in the array where predicate is true, and -1\r\n     * otherwise.\r\n     * @param predicate find calls predicate once for each element of the array, in ascending\r\n     * order, until it finds one where predicate returns true. If such an element is found,\r\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\r\n     * @param thisArg If provided, it will be used as the this value for each invocation of\r\n     * predicate. If it is not provided, undefined is used instead.\r\n     */\r\n    findIndex(predicate: (value: number, index: number, obj: Uint16Array) => boolean, thisArg?: any): number;\r\n\r\n    /**\r\n     * Performs the specified action for each element in an array.\r\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    forEach(callbackfn: (value: number, index: number, array: Uint16Array) => void, thisArg?: any): void;\r\n\r\n    /**\r\n     * Returns the index of the first occurrence of a value in an array.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\r\n     *  search starts at index 0.\r\n     */\r\n    indexOf(searchElement: number, fromIndex?: number): number;\r\n\r\n    /**\r\n     * Adds all the elements of an array separated by the specified separator string.\r\n     * @param separator A string used to separate one element of an array from the next in the\r\n     * resulting String. If omitted, the array elements are separated with a comma.\r\n     */\r\n    join(separator?: string): string;\r\n\r\n    /**\r\n     * Returns the index of the last occurrence of a value in an array.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\r\n     * search starts at index 0.\r\n     */\r\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\r\n\r\n    /**\r\n     * The length of the array.\r\n     */\r\n    readonly length: number;\r\n\r\n    /**\r\n     * Calls a defined callback function on each element of an array, and returns an array that\r\n     * contains the results.\r\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    map(callbackfn: (value: number, index: number, array: Uint16Array) => number, thisArg?: any): Uint16Array;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array. The return value of\r\n     * the callback function is the accumulated result, and is provided as an argument in the next\r\n     * call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array) => number): number;\r\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array) => number, initialValue: number): number;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array. The return value of\r\n     * the callback function is the accumulated result, and is provided as an argument in the next\r\n     * call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array) => U, initialValue: U): U;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array, in descending order.\r\n     * The return value of the callback function is the accumulated result, and is provided as an\r\n     * argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\r\n     * the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an\r\n     * argument instead of an array value.\r\n     */\r\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array) => number): number;\r\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array) => number, initialValue: number): number;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array, in descending order.\r\n     * The return value of the callback function is the accumulated result, and is provided as an\r\n     * argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\r\n     * the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array) => U, initialValue: U): U;\r\n\r\n    /**\r\n     * Reverses the elements in an Array.\r\n     */\r\n    reverse(): Uint16Array;\r\n\r\n    /**\r\n     * Sets a value or an array of values.\r\n     * @param array A typed or untyped array of values to set.\r\n     * @param offset The index in the current array at which the values are to be written.\r\n     */\r\n    set(array: ArrayLike<number>, offset?: number): void;\r\n\r\n    /**\r\n     * Returns a section of an array.\r\n     * @param start The beginning of the specified portion of the array.\r\n     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.\r\n     */\r\n    slice(start?: number, end?: number): Uint16Array;\r\n\r\n    /**\r\n     * Determines whether the specified callback function returns true for any element of an array.\r\n     * @param predicate A function that accepts up to three arguments. The some method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value true, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    some(predicate: (value: number, index: number, array: Uint16Array) => unknown, thisArg?: any): boolean;\r\n\r\n    /**\r\n     * Sorts an array.\r\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\r\n     * a negative value if first argument is less than second argument, zero if they're equal and a positive\r\n     * value otherwise. If omitted, the elements are sorted in ascending order.\r\n     * ```ts\r\n     * [11,2,22,1].sort((a, b) => a - b)\r\n     * ```\r\n     */\r\n    sort(compareFn?: (a: number, b: number) => number): this;\r\n\r\n    /**\r\n     * Gets a new Uint16Array view of the ArrayBuffer store for this array, referencing the elements\r\n     * at begin, inclusive, up to end, exclusive.\r\n     * @param begin The index of the beginning of the array.\r\n     * @param end The index of the end of the array.\r\n     */\r\n    subarray(begin?: number, end?: number): Uint16Array;\r\n\r\n    /**\r\n     * Converts a number to a string by using the current locale.\r\n     */\r\n    toLocaleString(): string;\r\n\r\n    /**\r\n     * Returns a string representation of an array.\r\n     */\r\n    toString(): string;\r\n\r\n    /** Returns the primitive value of the specified object. */\r\n    valueOf(): Uint16Array;\r\n\r\n    [index: number]: number;\r\n}\r\n\r\ninterface Uint16ArrayConstructor {\r\n    readonly prototype: Uint16Array;\r\n    new(length: number): Uint16Array;\r\n    new(array: ArrayLike<number> | ArrayBufferLike): Uint16Array;\r\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Uint16Array;\r\n\r\n    /**\r\n     * The size in bytes of each element in the array.\r\n     */\r\n    readonly BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n     * Returns a new array from a set of elements.\r\n     * @param items A set of elements to include in the new array object.\r\n     */\r\n    of(...items: number[]): Uint16Array;\r\n\r\n    /**\r\n     * Creates an array from an array-like or iterable object.\r\n     * @param arrayLike An array-like or iterable object to convert to an array.\r\n     */\r\n    from(arrayLike: ArrayLike<number>): Uint16Array;\r\n\r\n    /**\r\n     * Creates an array from an array-like or iterable object.\r\n     * @param arrayLike An array-like or iterable object to convert to an array.\r\n     * @param mapfn A mapping function to call on every element of the array.\r\n     * @param thisArg Value of 'this' used to invoke the mapfn.\r\n     */\r\n    from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number, thisArg?: any): Uint16Array;\r\n\r\n\r\n}\r\ndeclare var Uint16Array: Uint16ArrayConstructor;\r\n/**\r\n * A typed array of 32-bit signed integer values. The contents are initialized to 0. If the\r\n * requested number of bytes could not be allocated an exception is raised.\r\n */\r\ninterface Int32Array {\r\n    /**\r\n     * The size in bytes of each element in the array.\r\n     */\r\n    readonly BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n     * The ArrayBuffer instance referenced by the array.\r\n     */\r\n    readonly buffer: ArrayBufferLike;\r\n\r\n    /**\r\n     * The length in bytes of the array.\r\n     */\r\n    readonly byteLength: number;\r\n\r\n    /**\r\n     * The offset in bytes of the array.\r\n     */\r\n    readonly byteOffset: number;\r\n\r\n    /**\r\n     * Returns the this object after copying a section of the array identified by start and end\r\n     * to the same array starting at position target\r\n     * @param target If target is negative, it is treated as length+target where length is the\r\n     * length of the array.\r\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\r\n     * is treated as length+end.\r\n     * @param end If not specified, length of the this object is used as its default value.\r\n     */\r\n    copyWithin(target: number, start: number, end?: number): this;\r\n\r\n    /**\r\n     * Determines whether all the members of an array satisfy the specified test.\r\n     * @param predicate A function that accepts up to three arguments. The every method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value false, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    every(predicate: (value: number, index: number, array: Int32Array) => unknown, thisArg?: any): boolean;\r\n\r\n    /**\r\n     * Changes all array elements from `start` to `end` index to a static `value` and returns the modified array\r\n     * @param value value to fill array section with\r\n     * @param start index to start filling the array at. If start is negative, it is treated as\r\n     * length+start where length is the length of the array.\r\n     * @param end index to stop filling the array at. If end is negative, it is treated as\r\n     * length+end.\r\n     */\r\n    fill(value: number, start?: number, end?: number): this;\r\n\r\n    /**\r\n     * Returns the elements of an array that meet the condition specified in a callback function.\r\n     * @param predicate A function that accepts up to three arguments. The filter method calls\r\n     * the predicate function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    filter(predicate: (value: number, index: number, array: Int32Array) => any, thisArg?: any): Int32Array;\r\n\r\n    /**\r\n     * Returns the value of the first element in the array where predicate is true, and undefined\r\n     * otherwise.\r\n     * @param predicate find calls predicate once for each element of the array, in ascending\r\n     * order, until it finds one where predicate returns true. If such an element is found, find\r\n     * immediately returns that element value. Otherwise, find returns undefined.\r\n     * @param thisArg If provided, it will be used as the this value for each invocation of\r\n     * predicate. If it is not provided, undefined is used instead.\r\n     */\r\n    find(predicate: (value: number, index: number, obj: Int32Array) => boolean, thisArg?: any): number | undefined;\r\n\r\n    /**\r\n     * Returns the index of the first element in the array where predicate is true, and -1\r\n     * otherwise.\r\n     * @param predicate find calls predicate once for each element of the array, in ascending\r\n     * order, until it finds one where predicate returns true. If such an element is found,\r\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\r\n     * @param thisArg If provided, it will be used as the this value for each invocation of\r\n     * predicate. If it is not provided, undefined is used instead.\r\n     */\r\n    findIndex(predicate: (value: number, index: number, obj: Int32Array) => boolean, thisArg?: any): number;\r\n\r\n    /**\r\n     * Performs the specified action for each element in an array.\r\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    forEach(callbackfn: (value: number, index: number, array: Int32Array) => void, thisArg?: any): void;\r\n\r\n    /**\r\n     * Returns the index of the first occurrence of a value in an array.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\r\n     *  search starts at index 0.\r\n     */\r\n    indexOf(searchElement: number, fromIndex?: number): number;\r\n\r\n    /**\r\n     * Adds all the elements of an array separated by the specified separator string.\r\n     * @param separator A string used to separate one element of an array from the next in the\r\n     * resulting String. If omitted, the array elements are separated with a comma.\r\n     */\r\n    join(separator?: string): string;\r\n\r\n    /**\r\n     * Returns the index of the last occurrence of a value in an array.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\r\n     * search starts at index 0.\r\n     */\r\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\r\n\r\n    /**\r\n     * The length of the array.\r\n     */\r\n    readonly length: number;\r\n\r\n    /**\r\n     * Calls a defined callback function on each element of an array, and returns an array that\r\n     * contains the results.\r\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    map(callbackfn: (value: number, index: number, array: Int32Array) => number, thisArg?: any): Int32Array;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array. The return value of\r\n     * the callback function is the accumulated result, and is provided as an argument in the next\r\n     * call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number): number;\r\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number, initialValue: number): number;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array. The return value of\r\n     * the callback function is the accumulated result, and is provided as an argument in the next\r\n     * call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array) => U, initialValue: U): U;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array, in descending order.\r\n     * The return value of the callback function is the accumulated result, and is provided as an\r\n     * argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\r\n     * the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an\r\n     * argument instead of an array value.\r\n     */\r\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number): number;\r\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number, initialValue: number): number;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array, in descending order.\r\n     * The return value of the callback function is the accumulated result, and is provided as an\r\n     * argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\r\n     * the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array) => U, initialValue: U): U;\r\n\r\n    /**\r\n     * Reverses the elements in an Array.\r\n     */\r\n    reverse(): Int32Array;\r\n\r\n    /**\r\n     * Sets a value or an array of values.\r\n     * @param array A typed or untyped array of values to set.\r\n     * @param offset The index in the current array at which the values are to be written.\r\n     */\r\n    set(array: ArrayLike<number>, offset?: number): void;\r\n\r\n    /**\r\n     * Returns a section of an array.\r\n     * @param start The beginning of the specified portion of the array.\r\n     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.\r\n     */\r\n    slice(start?: number, end?: number): Int32Array;\r\n\r\n    /**\r\n     * Determines whether the specified callback function returns true for any element of an array.\r\n     * @param predicate A function that accepts up to three arguments. The some method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value true, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    some(predicate: (value: number, index: number, array: Int32Array) => unknown, thisArg?: any): boolean;\r\n\r\n    /**\r\n     * Sorts an array.\r\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\r\n     * a negative value if first argument is less than second argument, zero if they're equal and a positive\r\n     * value otherwise. If omitted, the elements are sorted in ascending order.\r\n     * ```ts\r\n     * [11,2,22,1].sort((a, b) => a - b)\r\n     * ```\r\n     */\r\n    sort(compareFn?: (a: number, b: number) => number): this;\r\n\r\n    /**\r\n     * Gets a new Int32Array view of the ArrayBuffer store for this array, referencing the elements\r\n     * at begin, inclusive, up to end, exclusive.\r\n     * @param begin The index of the beginning of the array.\r\n     * @param end The index of the end of the array.\r\n     */\r\n    subarray(begin?: number, end?: number): Int32Array;\r\n\r\n    /**\r\n     * Converts a number to a string by using the current locale.\r\n     */\r\n    toLocaleString(): string;\r\n\r\n    /**\r\n     * Returns a string representation of an array.\r\n     */\r\n    toString(): string;\r\n\r\n    /** Returns the primitive value of the specified object. */\r\n    valueOf(): Int32Array;\r\n\r\n    [index: number]: number;\r\n}\r\n\r\ninterface Int32ArrayConstructor {\r\n    readonly prototype: Int32Array;\r\n    new(length: number): Int32Array;\r\n    new(array: ArrayLike<number> | ArrayBufferLike): Int32Array;\r\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Int32Array;\r\n\r\n    /**\r\n     * The size in bytes of each element in the array.\r\n     */\r\n    readonly BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n     * Returns a new array from a set of elements.\r\n     * @param items A set of elements to include in the new array object.\r\n     */\r\n    of(...items: number[]): Int32Array;\r\n\r\n    /**\r\n     * Creates an array from an array-like or iterable object.\r\n     * @param arrayLike An array-like or iterable object to convert to an array.\r\n     */\r\n    from(arrayLike: ArrayLike<number>): Int32Array;\r\n\r\n    /**\r\n     * Creates an array from an array-like or iterable object.\r\n     * @param arrayLike An array-like or iterable object to convert to an array.\r\n     * @param mapfn A mapping function to call on every element of the array.\r\n     * @param thisArg Value of 'this' used to invoke the mapfn.\r\n     */\r\n    from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number, thisArg?: any): Int32Array;\r\n\r\n}\r\ndeclare var Int32Array: Int32ArrayConstructor;\r\n\r\n/**\r\n * A typed array of 32-bit unsigned integer values. The contents are initialized to 0. If the\r\n * requested number of bytes could not be allocated an exception is raised.\r\n */\r\ninterface Uint32Array {\r\n    /**\r\n     * The size in bytes of each element in the array.\r\n     */\r\n    readonly BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n     * The ArrayBuffer instance referenced by the array.\r\n     */\r\n    readonly buffer: ArrayBufferLike;\r\n\r\n    /**\r\n     * The length in bytes of the array.\r\n     */\r\n    readonly byteLength: number;\r\n\r\n    /**\r\n     * The offset in bytes of the array.\r\n     */\r\n    readonly byteOffset: number;\r\n\r\n    /**\r\n     * Returns the this object after copying a section of the array identified by start and end\r\n     * to the same array starting at position target\r\n     * @param target If target is negative, it is treated as length+target where length is the\r\n     * length of the array.\r\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\r\n     * is treated as length+end.\r\n     * @param end If not specified, length of the this object is used as its default value.\r\n     */\r\n    copyWithin(target: number, start: number, end?: number): this;\r\n\r\n    /**\r\n     * Determines whether all the members of an array satisfy the specified test.\r\n     * @param predicate A function that accepts up to three arguments. The every method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value false, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    every(predicate: (value: number, index: number, array: Uint32Array) => unknown, thisArg?: any): boolean;\r\n\r\n    /**\r\n     * Changes all array elements from `start` to `end` index to a static `value` and returns the modified array\r\n     * @param value value to fill array section with\r\n     * @param start index to start filling the array at. If start is negative, it is treated as\r\n     * length+start where length is the length of the array.\r\n     * @param end index to stop filling the array at. If end is negative, it is treated as\r\n     * length+end.\r\n     */\r\n    fill(value: number, start?: number, end?: number): this;\r\n\r\n    /**\r\n     * Returns the elements of an array that meet the condition specified in a callback function.\r\n     * @param predicate A function that accepts up to three arguments. The filter method calls\r\n     * the predicate function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    filter(predicate: (value: number, index: number, array: Uint32Array) => any, thisArg?: any): Uint32Array;\r\n\r\n    /**\r\n     * Returns the value of the first element in the array where predicate is true, and undefined\r\n     * otherwise.\r\n     * @param predicate find calls predicate once for each element of the array, in ascending\r\n     * order, until it finds one where predicate returns true. If such an element is found, find\r\n     * immediately returns that element value. Otherwise, find returns undefined.\r\n     * @param thisArg If provided, it will be used as the this value for each invocation of\r\n     * predicate. If it is not provided, undefined is used instead.\r\n     */\r\n    find(predicate: (value: number, index: number, obj: Uint32Array) => boolean, thisArg?: any): number | undefined;\r\n\r\n    /**\r\n     * Returns the index of the first element in the array where predicate is true, and -1\r\n     * otherwise.\r\n     * @param predicate find calls predicate once for each element of the array, in ascending\r\n     * order, until it finds one where predicate returns true. If such an element is found,\r\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\r\n     * @param thisArg If provided, it will be used as the this value for each invocation of\r\n     * predicate. If it is not provided, undefined is used instead.\r\n     */\r\n    findIndex(predicate: (value: number, index: number, obj: Uint32Array) => boolean, thisArg?: any): number;\r\n\r\n    /**\r\n     * Performs the specified action for each element in an array.\r\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    forEach(callbackfn: (value: number, index: number, array: Uint32Array) => void, thisArg?: any): void;\r\n    /**\r\n     * Returns the index of the first occurrence of a value in an array.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\r\n     *  search starts at index 0.\r\n     */\r\n    indexOf(searchElement: number, fromIndex?: number): number;\r\n\r\n    /**\r\n     * Adds all the elements of an array separated by the specified separator string.\r\n     * @param separator A string used to separate one element of an array from the next in the\r\n     * resulting String. If omitted, the array elements are separated with a comma.\r\n     */\r\n    join(separator?: string): string;\r\n\r\n    /**\r\n     * Returns the index of the last occurrence of a value in an array.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\r\n     * search starts at index 0.\r\n     */\r\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\r\n\r\n    /**\r\n     * The length of the array.\r\n     */\r\n    readonly length: number;\r\n\r\n    /**\r\n     * Calls a defined callback function on each element of an array, and returns an array that\r\n     * contains the results.\r\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    map(callbackfn: (value: number, index: number, array: Uint32Array) => number, thisArg?: any): Uint32Array;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array. The return value of\r\n     * the callback function is the accumulated result, and is provided as an argument in the next\r\n     * call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array) => number): number;\r\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array) => number, initialValue: number): number;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array. The return value of\r\n     * the callback function is the accumulated result, and is provided as an argument in the next\r\n     * call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array) => U, initialValue: U): U;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array, in descending order.\r\n     * The return value of the callback function is the accumulated result, and is provided as an\r\n     * argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\r\n     * the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an\r\n     * argument instead of an array value.\r\n     */\r\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array) => number): number;\r\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array) => number, initialValue: number): number;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array, in descending order.\r\n     * The return value of the callback function is the accumulated result, and is provided as an\r\n     * argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\r\n     * the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array) => U, initialValue: U): U;\r\n\r\n    /**\r\n     * Reverses the elements in an Array.\r\n     */\r\n    reverse(): Uint32Array;\r\n\r\n    /**\r\n     * Sets a value or an array of values.\r\n     * @param array A typed or untyped array of values to set.\r\n     * @param offset The index in the current array at which the values are to be written.\r\n     */\r\n    set(array: ArrayLike<number>, offset?: number): void;\r\n\r\n    /**\r\n     * Returns a section of an array.\r\n     * @param start The beginning of the specified portion of the array.\r\n     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.\r\n     */\r\n    slice(start?: number, end?: number): Uint32Array;\r\n\r\n    /**\r\n     * Determines whether the specified callback function returns true for any element of an array.\r\n     * @param predicate A function that accepts up to three arguments. The some method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value true, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    some(predicate: (value: number, index: number, array: Uint32Array) => unknown, thisArg?: any): boolean;\r\n\r\n    /**\r\n     * Sorts an array.\r\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\r\n     * a negative value if first argument is less than second argument, zero if they're equal and a positive\r\n     * value otherwise. If omitted, the elements are sorted in ascending order.\r\n     * ```ts\r\n     * [11,2,22,1].sort((a, b) => a - b)\r\n     * ```\r\n     */\r\n    sort(compareFn?: (a: number, b: number) => number): this;\r\n\r\n    /**\r\n     * Gets a new Uint32Array view of the ArrayBuffer store for this array, referencing the elements\r\n     * at begin, inclusive, up to end, exclusive.\r\n     * @param begin The index of the beginning of the array.\r\n     * @param end The index of the end of the array.\r\n     */\r\n    subarray(begin?: number, end?: number): Uint32Array;\r\n\r\n    /**\r\n     * Converts a number to a string by using the current locale.\r\n     */\r\n    toLocaleString(): string;\r\n\r\n    /**\r\n     * Returns a string representation of an array.\r\n     */\r\n    toString(): string;\r\n\r\n    /** Returns the primitive value of the specified object. */\r\n    valueOf(): Uint32Array;\r\n\r\n    [index: number]: number;\r\n}\r\n\r\ninterface Uint32ArrayConstructor {\r\n    readonly prototype: Uint32Array;\r\n    new(length: number): Uint32Array;\r\n    new(array: ArrayLike<number> | ArrayBufferLike): Uint32Array;\r\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Uint32Array;\r\n\r\n    /**\r\n     * The size in bytes of each element in the array.\r\n     */\r\n    readonly BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n     * Returns a new array from a set of elements.\r\n     * @param items A set of elements to include in the new array object.\r\n     */\r\n    of(...items: number[]): Uint32Array;\r\n\r\n    /**\r\n     * Creates an array from an array-like or iterable object.\r\n     * @param arrayLike An array-like or iterable object to convert to an array.\r\n     */\r\n    from(arrayLike: ArrayLike<number>): Uint32Array;\r\n\r\n    /**\r\n     * Creates an array from an array-like or iterable object.\r\n     * @param arrayLike An array-like or iterable object to convert to an array.\r\n     * @param mapfn A mapping function to call on every element of the array.\r\n     * @param thisArg Value of 'this' used to invoke the mapfn.\r\n     */\r\n    from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number, thisArg?: any): Uint32Array;\r\n\r\n}\r\ndeclare var Uint32Array: Uint32ArrayConstructor;\r\n\r\n/**\r\n * A typed array of 32-bit float values. The contents are initialized to 0. If the requested number\r\n * of bytes could not be allocated an exception is raised.\r\n */\r\ninterface Float32Array {\r\n    /**\r\n     * The size in bytes of each element in the array.\r\n     */\r\n    readonly BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n     * The ArrayBuffer instance referenced by the array.\r\n     */\r\n    readonly buffer: ArrayBufferLike;\r\n\r\n    /**\r\n     * The length in bytes of the array.\r\n     */\r\n    readonly byteLength: number;\r\n\r\n    /**\r\n     * The offset in bytes of the array.\r\n     */\r\n    readonly byteOffset: number;\r\n\r\n    /**\r\n     * Returns the this object after copying a section of the array identified by start and end\r\n     * to the same array starting at position target\r\n     * @param target If target is negative, it is treated as length+target where length is the\r\n     * length of the array.\r\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\r\n     * is treated as length+end.\r\n     * @param end If not specified, length of the this object is used as its default value.\r\n     */\r\n    copyWithin(target: number, start: number, end?: number): this;\r\n\r\n    /**\r\n     * Determines whether all the members of an array satisfy the specified test.\r\n     * @param predicate A function that accepts up to three arguments. The every method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value false, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    every(predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): boolean;\r\n\r\n    /**\r\n     * Changes all array elements from `start` to `end` index to a static `value` and returns the modified array\r\n     * @param value value to fill array section with\r\n     * @param start index to start filling the array at. If start is negative, it is treated as\r\n     * length+start where length is the length of the array.\r\n     * @param end index to stop filling the array at. If end is negative, it is treated as\r\n     * length+end.\r\n     */\r\n    fill(value: number, start?: number, end?: number): this;\r\n\r\n    /**\r\n     * Returns the elements of an array that meet the condition specified in a callback function.\r\n     * @param predicate A function that accepts up to three arguments. The filter method calls\r\n     * the predicate function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    filter(predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any): Float32Array;\r\n\r\n    /**\r\n     * Returns the value of the first element in the array where predicate is true, and undefined\r\n     * otherwise.\r\n     * @param predicate find calls predicate once for each element of the array, in ascending\r\n     * order, until it finds one where predicate returns true. If such an element is found, find\r\n     * immediately returns that element value. Otherwise, find returns undefined.\r\n     * @param thisArg If provided, it will be used as the this value for each invocation of\r\n     * predicate. If it is not provided, undefined is used instead.\r\n     */\r\n    find(predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any): number | undefined;\r\n\r\n    /**\r\n     * Returns the index of the first element in the array where predicate is true, and -1\r\n     * otherwise.\r\n     * @param predicate find calls predicate once for each element of the array, in ascending\r\n     * order, until it finds one where predicate returns true. If such an element is found,\r\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\r\n     * @param thisArg If provided, it will be used as the this value for each invocation of\r\n     * predicate. If it is not provided, undefined is used instead.\r\n     */\r\n    findIndex(predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any): number;\r\n\r\n    /**\r\n     * Performs the specified action for each element in an array.\r\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    forEach(callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any): void;\r\n\r\n    /**\r\n     * Returns the index of the first occurrence of a value in an array.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\r\n     *  search starts at index 0.\r\n     */\r\n    indexOf(searchElement: number, fromIndex?: number): number;\r\n\r\n    /**\r\n     * Adds all the elements of an array separated by the specified separator string.\r\n     * @param separator A string used to separate one element of an array from the next in the\r\n     * resulting String. If omitted, the array elements are separated with a comma.\r\n     */\r\n    join(separator?: string): string;\r\n\r\n    /**\r\n     * Returns the index of the last occurrence of a value in an array.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\r\n     * search starts at index 0.\r\n     */\r\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\r\n\r\n    /**\r\n     * The length of the array.\r\n     */\r\n    readonly length: number;\r\n\r\n    /**\r\n     * Calls a defined callback function on each element of an array, and returns an array that\r\n     * contains the results.\r\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    map(callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any): Float32Array;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array. The return value of\r\n     * the callback function is the accumulated result, and is provided as an argument in the next\r\n     * call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;\r\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array. The return value of\r\n     * the callback function is the accumulated result, and is provided as an argument in the next\r\n     * call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array, in descending order.\r\n     * The return value of the callback function is the accumulated result, and is provided as an\r\n     * argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\r\n     * the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an\r\n     * argument instead of an array value.\r\n     */\r\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;\r\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array, in descending order.\r\n     * The return value of the callback function is the accumulated result, and is provided as an\r\n     * argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\r\n     * the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;\r\n\r\n    /**\r\n     * Reverses the elements in an Array.\r\n     */\r\n    reverse(): Float32Array;\r\n\r\n    /**\r\n     * Sets a value or an array of values.\r\n     * @param array A typed or untyped array of values to set.\r\n     * @param offset The index in the current array at which the values are to be written.\r\n     */\r\n    set(array: ArrayLike<number>, offset?: number): void;\r\n\r\n    /**\r\n     * Returns a section of an array.\r\n     * @param start The beginning of the specified portion of the array.\r\n     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.\r\n     */\r\n    slice(start?: number, end?: number): Float32Array;\r\n\r\n    /**\r\n     * Determines whether the specified callback function returns true for any element of an array.\r\n     * @param predicate A function that accepts up to three arguments. The some method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value true, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    some(predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): boolean;\r\n\r\n    /**\r\n     * Sorts an array.\r\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\r\n     * a negative value if first argument is less than second argument, zero if they're equal and a positive\r\n     * value otherwise. If omitted, the elements are sorted in ascending order.\r\n     * ```ts\r\n     * [11,2,22,1].sort((a, b) => a - b)\r\n     * ```\r\n     */\r\n    sort(compareFn?: (a: number, b: number) => number): this;\r\n\r\n    /**\r\n     * Gets a new Float32Array view of the ArrayBuffer store for this array, referencing the elements\r\n     * at begin, inclusive, up to end, exclusive.\r\n     * @param begin The index of the beginning of the array.\r\n     * @param end The index of the end of the array.\r\n     */\r\n    subarray(begin?: number, end?: number): Float32Array;\r\n\r\n    /**\r\n     * Converts a number to a string by using the current locale.\r\n     */\r\n    toLocaleString(): string;\r\n\r\n    /**\r\n     * Returns a string representation of an array.\r\n     */\r\n    toString(): string;\r\n\r\n    /** Returns the primitive value of the specified object. */\r\n    valueOf(): Float32Array;\r\n\r\n    [index: number]: number;\r\n}\r\n\r\ninterface Float32ArrayConstructor {\r\n    readonly prototype: Float32Array;\r\n    new(length: number): Float32Array;\r\n    new(array: ArrayLike<number> | ArrayBufferLike): Float32Array;\r\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Float32Array;\r\n\r\n    /**\r\n     * The size in bytes of each element in the array.\r\n     */\r\n    readonly BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n     * Returns a new array from a set of elements.\r\n     * @param items A set of elements to include in the new array object.\r\n     */\r\n    of(...items: number[]): Float32Array;\r\n\r\n    /**\r\n     * Creates an array from an array-like or iterable object.\r\n     * @param arrayLike An array-like or iterable object to convert to an array.\r\n     */\r\n    from(arrayLike: ArrayLike<number>): Float32Array;\r\n\r\n    /**\r\n     * Creates an array from an array-like or iterable object.\r\n     * @param arrayLike An array-like or iterable object to convert to an array.\r\n     * @param mapfn A mapping function to call on every element of the array.\r\n     * @param thisArg Value of 'this' used to invoke the mapfn.\r\n     */\r\n    from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number, thisArg?: any): Float32Array;\r\n\r\n\r\n}\r\ndeclare var Float32Array: Float32ArrayConstructor;\r\n\r\n/**\r\n * A typed array of 64-bit float values. The contents are initialized to 0. If the requested\r\n * number of bytes could not be allocated an exception is raised.\r\n */\r\ninterface Float64Array {\r\n    /**\r\n     * The size in bytes of each element in the array.\r\n     */\r\n    readonly BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n     * The ArrayBuffer instance referenced by the array.\r\n     */\r\n    readonly buffer: ArrayBufferLike;\r\n\r\n    /**\r\n     * The length in bytes of the array.\r\n     */\r\n    readonly byteLength: number;\r\n\r\n    /**\r\n     * The offset in bytes of the array.\r\n     */\r\n    readonly byteOffset: number;\r\n\r\n    /**\r\n     * Returns the this object after copying a section of the array identified by start and end\r\n     * to the same array starting at position target\r\n     * @param target If target is negative, it is treated as length+target where length is the\r\n     * length of the array.\r\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\r\n     * is treated as length+end.\r\n     * @param end If not specified, length of the this object is used as its default value.\r\n     */\r\n    copyWithin(target: number, start: number, end?: number): this;\r\n\r\n    /**\r\n     * Determines whether all the members of an array satisfy the specified test.\r\n     * @param predicate A function that accepts up to three arguments. The every method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value false, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    every(predicate: (value: number, index: number, array: Float64Array) => unknown, thisArg?: any): boolean;\r\n\r\n    /**\r\n     * Changes all array elements from `start` to `end` index to a static `value` and returns the modified array\r\n     * @param value value to fill array section with\r\n     * @param start index to start filling the array at. If start is negative, it is treated as\r\n     * length+start where length is the length of the array.\r\n     * @param end index to stop filling the array at. If end is negative, it is treated as\r\n     * length+end.\r\n     */\r\n    fill(value: number, start?: number, end?: number): this;\r\n\r\n    /**\r\n     * Returns the elements of an array that meet the condition specified in a callback function.\r\n     * @param predicate A function that accepts up to three arguments. The filter method calls\r\n     * the predicate function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    filter(predicate: (value: number, index: number, array: Float64Array) => any, thisArg?: any): Float64Array;\r\n\r\n    /**\r\n     * Returns the value of the first element in the array where predicate is true, and undefined\r\n     * otherwise.\r\n     * @param predicate find calls predicate once for each element of the array, in ascending\r\n     * order, until it finds one where predicate returns true. If such an element is found, find\r\n     * immediately returns that element value. Otherwise, find returns undefined.\r\n     * @param thisArg If provided, it will be used as the this value for each invocation of\r\n     * predicate. If it is not provided, undefined is used instead.\r\n     */\r\n    find(predicate: (value: number, index: number, obj: Float64Array) => boolean, thisArg?: any): number | undefined;\r\n\r\n    /**\r\n     * Returns the index of the first element in the array where predicate is true, and -1\r\n     * otherwise.\r\n     * @param predicate find calls predicate once for each element of the array, in ascending\r\n     * order, until it finds one where predicate returns true. If such an element is found,\r\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\r\n     * @param thisArg If provided, it will be used as the this value for each invocation of\r\n     * predicate. If it is not provided, undefined is used instead.\r\n     */\r\n    findIndex(predicate: (value: number, index: number, obj: Float64Array) => boolean, thisArg?: any): number;\r\n\r\n    /**\r\n     * Performs the specified action for each element in an array.\r\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    forEach(callbackfn: (value: number, index: number, array: Float64Array) => void, thisArg?: any): void;\r\n\r\n    /**\r\n     * Returns the index of the first occurrence of a value in an array.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\r\n     *  search starts at index 0.\r\n     */\r\n    indexOf(searchElement: number, fromIndex?: number): number;\r\n\r\n    /**\r\n     * Adds all the elements of an array separated by the specified separator string.\r\n     * @param separator A string used to separate one element of an array from the next in the\r\n     * resulting String. If omitted, the array elements are separated with a comma.\r\n     */\r\n    join(separator?: string): string;\r\n\r\n    /**\r\n     * Returns the index of the last occurrence of a value in an array.\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\r\n     * search starts at index 0.\r\n     */\r\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\r\n\r\n    /**\r\n     * The length of the array.\r\n     */\r\n    readonly length: number;\r\n\r\n    /**\r\n     * Calls a defined callback function on each element of an array, and returns an array that\r\n     * contains the results.\r\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    map(callbackfn: (value: number, index: number, array: Float64Array) => number, thisArg?: any): Float64Array;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array. The return value of\r\n     * the callback function is the accumulated result, and is provided as an argument in the next\r\n     * call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number): number;\r\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number, initialValue: number): number;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array. The return value of\r\n     * the callback function is the accumulated result, and is provided as an argument in the next\r\n     * call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\r\n     * callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array) => U, initialValue: U): U;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array, in descending order.\r\n     * The return value of the callback function is the accumulated result, and is provided as an\r\n     * argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\r\n     * the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an\r\n     * argument instead of an array value.\r\n     */\r\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number): number;\r\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number, initialValue: number): number;\r\n\r\n    /**\r\n     * Calls the specified callback function for all the elements in an array, in descending order.\r\n     * The return value of the callback function is the accumulated result, and is provided as an\r\n     * argument in the next call to the callback function.\r\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\r\n     * the callbackfn function one time for each element in the array.\r\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\r\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\r\n     * instead of an array value.\r\n     */\r\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array) => U, initialValue: U): U;\r\n\r\n    /**\r\n     * Reverses the elements in an Array.\r\n     */\r\n    reverse(): Float64Array;\r\n\r\n    /**\r\n     * Sets a value or an array of values.\r\n     * @param array A typed or untyped array of values to set.\r\n     * @param offset The index in the current array at which the values are to be written.\r\n     */\r\n    set(array: ArrayLike<number>, offset?: number): void;\r\n\r\n    /**\r\n     * Returns a section of an array.\r\n     * @param start The beginning of the specified portion of the array.\r\n     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.\r\n     */\r\n    slice(start?: number, end?: number): Float64Array;\r\n\r\n    /**\r\n     * Determines whether the specified callback function returns true for any element of an array.\r\n     * @param predicate A function that accepts up to three arguments. The some method calls\r\n     * the predicate function for each element in the array until the predicate returns a value\r\n     * which is coercible to the Boolean value true, or until the end of the array.\r\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\r\n     * If thisArg is omitted, undefined is used as the this value.\r\n     */\r\n    some(predicate: (value: number, index: number, array: Float64Array) => unknown, thisArg?: any): boolean;\r\n\r\n    /**\r\n     * Sorts an array.\r\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\r\n     * a negative value if first argument is less than second argument, zero if they're equal and a positive\r\n     * value otherwise. If omitted, the elements are sorted in ascending order.\r\n     * ```ts\r\n     * [11,2,22,1].sort((a, b) => a - b)\r\n     * ```\r\n     */\r\n    sort(compareFn?: (a: number, b: number) => number): this;\r\n\r\n    /**\r\n     * at begin, inclusive, up to end, exclusive.\r\n     * @param begin The index of the beginning of the array.\r\n     * @param end The index of the end of the array.\r\n     */\r\n    subarray(begin?: number, end?: number): Float64Array;\r\n\r\n    toString(): string;\r\n\r\n    /** Returns the primitive value of the specified object. */\r\n    valueOf(): Float64Array;\r\n\r\n    [index: number]: number;\r\n}\r\n\r\ninterface Float64ArrayConstructor {\r\n    readonly prototype: Float64Array;\r\n    new(length: number): Float64Array;\r\n    new(array: ArrayLike<number> | ArrayBufferLike): Float64Array;\r\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Float64Array;\r\n\r\n    /**\r\n     * The size in bytes of each element in the array.\r\n     */\r\n    readonly BYTES_PER_ELEMENT: number;\r\n\r\n    /**\r\n     * Returns a new array from a set of elements.\r\n     * @param items A set of elements to include in the new array object.\r\n     */\r\n    of(...items: number[]): Float64Array;\r\n\r\n    /**\r\n     * Creates an array from an array-like or iterable object.\r\n     * @param arrayLike An array-like or iterable object to convert to an array.\r\n     */\r\n    from(arrayLike: ArrayLike<number>): Float64Array;\r\n\r\n    /**\r\n     * Creates an array from an array-like or iterable object.\r\n     * @param arrayLike An array-like or iterable object to convert to an array.\r\n     * @param mapfn A mapping function to call on every element of the array.\r\n     * @param thisArg Value of 'this' used to invoke the mapfn.\r\n     */\r\n    from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number, thisArg?: any): Float64Array;\r\n\r\n}\r\ndeclare var Float64Array: Float64ArrayConstructor;\r\n\r\n/////////////////////////////\r\n/// ECMAScript Internationalization API\r\n/////////////////////////////\r\n\r\ndeclare namespace Intl {\r\n    interface CollatorOptions {\r\n        usage?: string | undefined;\r\n        localeMatcher?: string | undefined;\r\n        numeric?: boolean | undefined;\r\n        caseFirst?: string | undefined;\r\n        sensitivity?: string | undefined;\r\n        ignorePunctuation?: boolean | undefined;\r\n    }\r\n\r\n    interface ResolvedCollatorOptions {\r\n        locale: string;\r\n        usage: string;\r\n        sensitivity: string;\r\n        ignorePunctuation: boolean;\r\n        collation: string;\r\n        caseFirst: string;\r\n        numeric: boolean;\r\n    }\r\n\r\n    interface Collator {\r\n        compare(x: string, y: string): number;\r\n        resolvedOptions(): ResolvedCollatorOptions;\r\n    }\r\n    var Collator: {\r\n        new(locales?: string | string[], options?: CollatorOptions): Collator;\r\n        (locales?: string | string[], options?: CollatorOptions): Collator;\r\n        supportedLocalesOf(locales: string | string[], options?: CollatorOptions): string[];\r\n    };\r\n\r\n    interface NumberFormatOptions {\r\n        localeMatcher?: string | undefined;\r\n        style?: string | undefined;\r\n        currency?: string | undefined;\r\n        currencySign?: string | undefined;\r\n        useGrouping?: boolean | undefined;\r\n        minimumIntegerDigits?: number | undefined;\r\n        minimumFractionDigits?: number | undefined;\r\n        maximumFractionDigits?: number | undefined;\r\n        minimumSignificantDigits?: number | undefined;\r\n        maximumSignificantDigits?: number | undefined;\r\n    }\r\n\r\n    interface ResolvedNumberFormatOptions {\r\n        locale: string;\r\n        numberingSystem: string;\r\n        style: string;\r\n        currency?: string;\r\n        minimumIntegerDigits: number;\r\n        minimumFractionDigits: number;\r\n        maximumFractionDigits: number;\r\n        minimumSignificantDigits?: number;\r\n        maximumSignificantDigits?: number;\r\n        useGrouping: boolean;\r\n    }\r\n\r\n    interface NumberFormat {\r\n        format(value: number): string;\r\n        resolvedOptions(): ResolvedNumberFormatOptions;\r\n    }\r\n    var NumberFormat: {\r\n        new(locales?: string | string[], options?: NumberFormatOptions): NumberFormat;\r\n        (locales?: string | string[], options?: NumberFormatOptions): NumberFormat;\r\n        supportedLocalesOf(locales: string | string[], options?: NumberFormatOptions): string[];\r\n        readonly prototype: NumberFormat;\r\n    };\r\n\r\n    interface DateTimeFormatOptions {\r\n        localeMatcher?: \"best fit\" | \"lookup\" | undefined;\r\n        weekday?: \"long\" | \"short\" | \"narrow\" | undefined;\r\n        era?: \"long\" | \"short\" | \"narrow\" | undefined;\r\n        year?: \"numeric\" | \"2-digit\" | undefined;\r\n        month?: \"numeric\" | \"2-digit\" | \"long\" | \"short\" | \"narrow\" | undefined;\r\n        day?: \"numeric\" | \"2-digit\" | undefined;\r\n        hour?: \"numeric\" | \"2-digit\" | undefined;\r\n        minute?: \"numeric\" | \"2-digit\" | undefined;\r\n        second?: \"numeric\" | \"2-digit\" | undefined;\r\n        timeZoneName?: \"long\" | \"short\" | undefined;\r\n        formatMatcher?: \"best fit\" | \"basic\" | undefined;\r\n        hour12?: boolean | undefined;\r\n        timeZone?: string | undefined;\r\n    }\r\n\r\n    interface ResolvedDateTimeFormatOptions {\r\n        locale: string;\r\n        calendar: string;\r\n        numberingSystem: string;\r\n        timeZone: string;\r\n        hour12?: boolean;\r\n        weekday?: string;\r\n        era?: string;\r\n        year?: string;\r\n        month?: string;\r\n        day?: string;\r\n        hour?: string;\r\n        minute?: string;\r\n        second?: string;\r\n        timeZoneName?: string;\r\n    }\r\n\r\n    interface DateTimeFormat {\r\n        format(date?: Date | number): string;\r\n        resolvedOptions(): ResolvedDateTimeFormatOptions;\r\n    }\r\n    var DateTimeFormat: {\r\n        new(locales?: string | string[], options?: DateTimeFormatOptions): DateTimeFormat;\r\n        (locales?: string | string[], options?: DateTimeFormatOptions): DateTimeFormat;\r\n        supportedLocalesOf(locales: string | string[], options?: DateTimeFormatOptions): string[];\r\n        readonly prototype: DateTimeFormat;\r\n    };\r\n}\r\n\r\ninterface String {\r\n    /**\r\n     * Determines whether two strings are equivalent in the current or specified locale.\r\n     * @param that String to compare to target string\r\n     * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used. This parameter must conform to BCP 47 standards; see the Intl.Collator object for details.\r\n     * @param options An object that contains one or more properties that specify comparison options. see the Intl.Collator object for details.\r\n     */\r\n    localeCompare(that: string, locales?: string | string[], options?: Intl.CollatorOptions): number;\r\n}\r\n\r\ninterface Number {\r\n    /**\r\n     * Converts a number to a string by using the current or specified locale.\r\n     * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\r\n     * @param options An object that contains one or more properties that specify comparison options.\r\n     */\r\n    toLocaleString(locales?: string | string[], options?: Intl.NumberFormatOptions): string;\r\n}\r\n\r\ninterface Date {\r\n    /**\r\n     * Converts a date and time to a string by using the current or specified locale.\r\n     * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\r\n     * @param options An object that contains one or more properties that specify comparison options.\r\n     */\r\n    toLocaleString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;\r\n    /**\r\n     * Converts a date to a string by using the current or specified locale.\r\n     * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\r\n     * @param options An object that contains one or more properties that specify comparison options.\r\n     */\r\n    toLocaleDateString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;\r\n\r\n    /**\r\n     * Converts a time to a string by using the current or specified locale.\r\n     * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\r\n     * @param options An object that contains one or more properties that specify comparison options.\r\n     */\r\n    toLocaleTimeString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;\r\n}\r\n\r\n```\r\n","children":[]},{"name":"index.md","path":"../guanruihua.github.io/TypeScript/内置API","data":"# 内置\r\n\r\n```ts\r\n/// <reference no-default-lib=\"true\"/>\r\n```\r\n","children":[]},{"name":"lib.dom.md","path":"../guanruihua.github.io/TypeScript/内置API","data":"","children":[]}]},{"name":"声明文件.md","path":"../guanruihua.github.io/TypeScript","data":"# 声明文件\r\n\r\n> `*.d.ts` 的使\r\n\r\n## 语法\r\n\r\n```ts\r\ndeclare var 声明全局变量\r\ndeclare function 声明全局方法\r\ndeclare class 声明全局类\r\ndeclare enum 声明全局枚举类型\r\ndeclare namespace 声明（含有子属性的）全局对象\r\ninterface 和 type 声明全局类型\r\nexport 导出变量\r\nexport namespace 导出（含有子属性的）对象\r\nexport default ES6 默认导出\r\nexport = commonjs 导出模块\r\nexport as namespace UMD 库声明全局变量\r\ndeclare global 扩展全局变量\r\ndeclare module 扩展模块\r\n`/// <reference />` 三斜线指令\r\n```\r\n\r\n## 模块化（CommonJS）\r\n\r\n> 通过require的方式引入模块化的代码\r\n\r\n```ts\r\n\r\n// d.ts\r\ndeclare module \"ever\" {\r\n    export type a: number\r\n    export function b(): number\r\n    export namespace c{\r\n        let c: string\r\n    }\r\n }\r\n // 引用\r\n cosnt ever = require('ever')\r\n ever.a = 100\r\n ever.b = function() {\r\n     return 100 + 300\r\n }\r\n\r\n```\r\n\r\n## ES6的模块化方式（import export）\r\n\r\n```ts\r\n\r\nexport declare let a1: 1\r\nexport declare let a2: 2\r\n// 或\r\ndeclare let a1: 1\r\ndeclare let a2: 2\r\n\r\nexport { a1,a2 }\r\n\r\n```\r\n\r\n## UMD\r\n\r\n> 有一种代码，既可以通过全局变量访问到，也可以通过require的方式访问到。\r\n\r\n```ts\r\n\r\ndeclare namespace ${\r\n    let a:number\r\n}\r\n\r\ndeclare module \"$\" {\r\n    export = $\r\n}\r\n```\r\n\r\n## 引入其他模块\r\n\r\n```ts\r\nimport { FormProps } from 'antd'\r\n\r\nexport = Group\r\nexport as namespace GroupAlias\r\n\r\ndeclare namespace Group {\r\n  interface FilterProps extends FormProps {\r\n    isShowResetBtn?: boolean //是否显示重置按钮，默认显示\r\n    onReset?: (values?: any) => void\r\n    onFinishWithForm?: (params: any) => void //需要返回form的onFinish函数\r\n    refForm?: any //class组件传进来的form\r\n  }\r\n}\r\n\r\n// 使用 GroupAlias.FilterProps 就是当前写的 FilterProps\r\n```\r\n\r\n## 其他\r\n\r\n> 有时候我们扩展了一些内置对象。给Date的内置对象扩展方法\r\n\r\n```ts\r\ninterface Date {\r\n    format(f: string): string\r\n}\r\n\r\n```\r\n","children":[]},{"name":"特性.md","path":"../guanruihua.github.io/TypeScript","data":"# 特性\n\n## 交叉类型和联合类型\n\n### 交叉类型 （& 相当于与）代表多个类型的合并\n\n```ts\ninterface IDog {\n    name: string,\n    age: number,\n}\ninterface ICat {\n    love: string,\n    age: number,\n}\n// 必须两个同时满足\nconst firstObj: IDog & ICat= {  \n    name: 'mini',\n    age: 24,\n    love: 'haha',\n}\n```\n\n### 联合类型 （｜相当于或）代表多个类型中的一个或多个\n\n```ts\nlet secondObj: IDog | ICat = { // 只需满足其中一个类型，或者两个都满足\n    name: 'mini',\n    age: 56,\n    love: 'haha',\n} \nconsole.log(secondObj.age);\nconsole.log(secondObj.name); // 不允许\n```\n\n上面对象具有联合类型，且满足联合类型中多个类型的情况，此时TS无法准确推断类型，就只能访问他们之间共有的部分age，怎么解决这个问题呢？\n\n1、使用typeof或者instanceof，typeof用于基本类型，instanceof用于引用类型\n\n2、使用类型断言\n\n```ts\nif ((secondObj as IDog).name) {\n  console.log((secondObj as IDog).name);\n}\n```\n\n3、使用类型保护，这种 param is SomeType 的形式\n\n```ts\nfunction isIPerson(obj: IDog | ICat): obj is IDog {\n  return (obj as IDog).name !== undefined;\n}\nif (isPerson(secondObj)){\n  console.log(secondObj.name);\n}\n```\n\n## 泛型\n\n> 泛型使得类型可以编程，可以抽象出适用更加广泛的类型，可以与函数做类比，类型参数就像函数参数一样，可以有默认值，除此之外，还可以用extends对参数本身需要满足的条件进行限制\n\n用法：在定义一个`function`、`type`、`interface`、`class`时，名称后面加上<>表示接受类型参数\n\n```js\nfunction swap<T, K>(v1: T, v2: K) {\n    return [v2, v1];\n}  \n// 此时结果没有按照我们预期的被推断成 [K, T]，而是被推断成了 (K | T)[]，这是不符合要求的\n// 这是因为 TypeScript 默认我们数组中的元素是可变的，所以它会「推断我们可能会改变元素的顺序\n\nfunction swap<T, K>(v1: T, v2: K) {\n    return [v2, v1] as const; // 加上 as const 来声明它为常量，严格保证顺序\n}\n\nfunction swap1<T, K>(v1: T, v2: K): readonly [K, T]{\n    return [v2, v1];\n```\n\n## nfer、extends关键字\n\n### infer\n\n> infer 的作用是让TypeScript自己推断，并将推断的结果存储到一个临时名字中，且只能用于extends语句中\n\n注意⚠️：ReturnType可以获取函数返回值的类型。但要注意不要滥用这个工具类型，这个工具类型是由实现反推约定，容易出错，另外ReturnType过多也会降低代码可读性\n\n```ts\n// btain the return type of a function type\ntype ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;  // 给函数的返回值类型定义为R临时变量\n// 示例\nfunction f() { return { a: 3, b: 2}; }\n/*\n{\n    a: number\n    b: number\n}\n */\ntype FReturn = ReturnType<typeof f>;\n```\n\n### 2、extends\n\n> 既可当作一个动词来扩展已有类型（接口扩展），也可当作一个形容词来对类型进行条件限定（常常用在泛型中）\n\n```js\nT extends U ? T : U    判断有条件类型\n```\n\n![img](https://pic3.zhimg.com/50/v2-26555ba7f0a83a5c8410161a45b00f35_720w.jpg?source=1940ef5c)\n\n![img](https://pic3.zhimg.com/80/v2-26555ba7f0a83a5c8410161a45b00f35_720w.jpg?source=1940ef5c)\n\n- Exclude(排除): 属于T不属于U的类型联合，不存在时为never\n- Extract(抽取): 属于T且属于U的类型联合，不存在时为never\n\ndemo：\n\n```ts\ntype A = Exclude<'x' | 'b', 'x' | 'y' | 'z'>\nconst aValue: A = 'b';  // aValue的值只能是'b'\n```\n\n## 索引签名 & 索引类型\n\n### 索引签名\n\nJavaScript 在一个对象类型的索引签名上会隐式调用 toString 方法，无论哪种类型本质上都是字符串的形式存储\n\n而在TS中，索引签名的类型必须是string或者number, 且强制用户必须明确的写出 toString()方法（除了number类型以外）\n\n```js\n/ 写法1:索引可以是string或者number\ninterface Demo1{\n    [key: string]: string;\n}\n//写法2:索引只能是number\ninterface Demo2 {\n    [key: number]: string;\n}\n\nconst res: Demo1 = {0 : 'def'};  // JS隐式调用toString()方法\nconst res: Demo1 = {name : 'def'}; // 或者 {'name' : 'def'}\nconst res: Demo2 = {name : 'def'}; // 或者 {'name' : 'def'}  //不允许，报错\n```\n\n当声明一个索引签名时，所有明确的成员都必须符合索引签名\n\n```js\ninterface Bar {\n    [key: string]: number;\n    x: number;\n    y: string; // Error: y 属性必须为 number 类型\n}\n```\n\n### 索引类型-keyof\n\n> **keyof  interfaceName | typeName**: 获取接口或类型上的所有已知属性名的联合，跟Object.keys()有点像，但是keyof取类型的键。容易跟TS中typeof混淆，**typeof后面跟的是值变量, keyof后面是类型变量，他们的返回值都是类型变量**\n\n```ts\ninterface Person {\n    name: string\n    age: number\n}\n\n// type keys = 'name' | 'age';\ntype keys = keyof Person;\n```\n\n看下如下demo，定义拿到对象中一部分键值的函数：\n\n```ts\nfunction pluck<T, K extends keyof T>(o: T, names: K[]): T[K][] {\n    return names.map(n => o[n])\n}\n\n// keyof T 表示  'name' | 'age'\n// K extends keyof T 表示  K 的取值继承自  'name'  |  'age' \n// K[]  表示 数组中的数据类型只能为常量类型 'name' ｜ 'age'\n\n// T[K]  表示  Person[name] | Person[age] ，也就是 string  |  number，\n// 因此 T[K][ ]  表示  string[ ] | number[ ]  或者  Array<string | number>\n\n\ninterface Person {\n    name: string\n    age: number\n}\nlet p: Person = {\n  name: 'funlee',\n  age: 21\n}\nlet res = pluck(p, ['name', 'age']) // 允许\n```\n\n## 映射类型\n\n你是如何将一个现有类型的每个属性都变为可选的或者部分可选的的？是不是像下面这样\n\n```ts\ninterface PersonPartial {\n  name?: string\n  age?: number\n}\n// 或者\ninterface PersonPartial {\n  name : string\n  age?: number\n}\n```\n\n将每个属性都变为只读的呢？\n\n```ts\ninterface IPersonReadonly {\n  readonly name: string\n  readonly age: number\n}\n```\n\n上面的用法如果参数很多的时候就不方便了。我们可以利用ts提供的映射类型简写\n\n```ts\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P]\n}\ntype Partial<T> = {\n  [P in keyof T]?: T[P]\n}\ntype PersonReadonly = Readonly<Person>\ntype PersonPartial = Partial<Person>\n\n// 或者\n// 声明可选参数\ntype PersonPartial = { \n  age: number;\n}\n //声明必填参数\ntype Person = {\n  name: string;\n} & Partial<PersonPartial>\n```\n\n通过这种映射的方式，我们可以将组件的参数进行更好的分类声明，同时也可以避免写多个？或者readonly这种声明方式\n\n同理定义可以为空的类型：\n\n```ts\ntype Nullrable<T> = {\n    [P in keyof T]: T[P] | null;\n}\n```\n\n## 类型推论 & 类型断言\n\n### 类型推论\n\n如果变量在定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查\n\n### 类型断言\n\n```ts\n语法：值 as 类型  或者  <类型>值\n```\n\n类型断言的限制总的来说就是：若 A 兼容 B，那么 A 能够被断言为 B，B 也能被断言为 A\n\n- 联合类型可以被断言为其中一个类型\n- 父类可以被断言为子类，子类也可以被断言为父类\n- 任何类型都可以被断言为 any，any 可以被断言为任何类型\n\n```ts\ninterface Animal {\n    name: string;\n}\ninterface Cat {\n    name: string;\n    run(): void;\n}\n// 等同于\ninterface Animal {\n    name: string;\n}\ninterface Cat extends Animal {\n    run(): void;\n}\n```\n","children":[]},{"name":"类型体操.md","path":"../guanruihua.github.io/TypeScript","data":"# 类型体操\r\n\r\n- 不建议开发使用\r\n- 可读性很低\r\n- 主要是为了锻炼ts类型的阅读&书写技巧\r\n\r\n## 基础类型\r\n\r\n```ts\r\ntype atype = number\r\ninterface btype{}\r\n// 常用基础类型\r\ntype num = number\r\ntype stri = string\r\ntype func = ()=>void\r\ntype arr = any[]\r\n```\r\n\r\n## 类型体操\r\n\r\n- 前面懂了 ? 开始造飞机 !\r\n\r\n## 运算\r\n\r\n### 与\r\n\r\n- 同真反真\r\n\r\n```ts\r\nexport type And<C1 extends boolean, C2 extends boolean> = C1 extends true\r\n  ? C2 extends true\r\n    ? true\r\n    : false\r\n  : false\r\n\r\nexport type And3<C1 extends boolean, C2 extends boolean, C3 extends boolean> = And<\r\n  And<C1, C2>,\r\n  C3\r\n>\r\n\r\nexport type And4<\r\n  C1 extends boolean,\r\n  C2 extends boolean,\r\n  C3 extends boolean,\r\n  C4 extends boolean\r\n> = And<And3<C1, C2, C3>, C4>\r\n```\r\n\r\n### 或\r\n\r\n- 有真为真\r\n\r\n```ts\r\nexport type Or<C1 extends boolean, C2 extends boolean> = C1 extends true\r\n  ? true\r\n  : C2 extends true\r\n  ? true\r\n  : false\r\n```\r\n\r\n### 非\r\n\r\n- 真假反转\r\n\r\n```ts\r\nexport type Not<C extends boolean> = C extends true ? false : true\r\n\r\n```\r\n\r\n### 并集\r\n\r\n- 并集\r\n\r\n```ts\r\nexport type SumAggregate<T, U> = T | U\r\n```\r\n\r\n- 其他的可以自行补充\r\n\r\n## `number`\r\n\r\n### 可转换为`number`的类型\r\n\r\n```ts\r\n/**\r\n * 类 number\r\n */\r\nexport type NumberLike = number | `${number}`\r\n```\r\n\r\n### 为零\r\n\r\n```ts\r\nexport type CheckLeftIsExtendsRight<T, R> = T extends R ? true : false\r\n\r\nexport type IsZero<N extends NumberLike> = CheckLeftIsExtendsRight<N, 0 | '0'>\r\n\r\n```\r\n\r\n### 大于零\r\n\r\n```ts\r\nexport type IsOverZero<N extends NumberLike> = IsZero<N> extends true\r\n  ? false\r\n  : Stringify<N> extends `${'-'}${infer Rest}` ? false : true\r\n```\r\n\r\n### 小于零\r\n\r\n```ts\r\nexport type IsLessZero<N extends NumberLike> = Not<IsOverZero<N>>\r\n```\r\n\r\n### 数字相等\r\n\r\n```ts\r\nexport type CheckLeftIsExtendsRight<T, R> = T extends R ? true : false\r\nexport type Stringify<T extends CanStringified> = `${T}`\r\n\r\nexport type IsNumberEqual<\r\n  L extends NumberLike,\r\n  R extends NumberLike,\r\n  Strict extends boolean = true\r\n> = Strict extends true\r\n  ? CheckLeftIsExtendsRight<L, R>\r\n  : CheckLeftIsExtendsRight<Stringify<L>, Stringify<R>>\r\n```\r\n\r\n### 数字不相等\r\n\r\n```ts\r\nexport type IsNumberNotEqual<\r\n  L extends NumberLike,\r\n  R extends NumberLike,\r\n  Strict extends boolean = true\r\n> = Not<IsNumberEqual<L, R, Strict>>\r\n```\r\n\r\n### 两数相加\r\n\r\n```ts\r\nexport type GetTupleHelper<\r\n  Length extends number = 0,\r\n  R extends unknown[] = []\r\n> = R['length'] extends Length ? R : GetTupleHelper<Length, [...R, unknown]>\r\n\r\n// 构造长度一定（Length）的元组\r\nexport type GetTuple<Length extends number = 0> = GetTupleHelper<Length>\r\nexport type IntAddSingleHepler<N1 extends number, N2 extends number> = [\r\n  ...GetTuple<N1>,\r\n  ...GetTuple<N2>\r\n]['length']\r\n\r\n// N1和N2 最大支持999\r\nexport type IntAddSingle<\r\n  N1 extends number,\r\n  N2 extends number\r\n> = IntAddSingleHepler<N1, N2> extends number\r\n  ? IntAddSingleHepler<N1, N2>\r\n  : number\r\n```\r\n\r\n### 两数相减\r\n\r\n```ts\r\nexport type Pop<T extends unknown[]> = T extends [...infer rest, infer R]\r\n  ? rest\r\n  : never\r\nexport type GetTupleHelper<\r\n  Length extends number = 0,\r\n  R extends unknown[] = []\r\n> = R['length'] extends Length ? R : GetTupleHelper<Length, [...R, unknown]>\r\n\r\nexport type GetTuple<Length extends number = 0> = GetTupleHelper<Length>\r\n\r\nexport type IntMinusSingleAbsHelper<\r\n  N1 extends number,\r\n  N2 extends number,\r\n  T1 extends unknown[] = GetTuple<N1>,\r\n  T2 extends unknown[] = GetTuple<N2>\r\n> = IsNotEqual<N1, N2, true> extends true\r\n  ? Or<IsZero<T1['length']>, IsZero<T2['length']>> extends true\r\n    ? IsZero<T1['length']> extends true\r\n      ? T2['length']\r\n      : T1['length']\r\n    : IntMinusSingleAbsHelper<Pop<T1>['length'], Pop<T2>['length']>\r\n  : 0\r\n\r\n// 由于元组长度只能为正, 所以结果只能拿到绝对值\r\nexport type IntMinusSingleAbs<\r\n  N1 extends number,\r\n  N2 extends number\r\n> = IntMinusSingleAbsHelper<N1, N2>\r\n```\r\n\r\n## `Array`\r\n\r\n### 生成指定长度的数组\r\n\r\n```ts\r\ntype GetTupleHelper<\r\n  Length extends number = 0,\r\n  R extends unknown[] = []\r\n> = R[\"length\"] extends Length ? R : GetTupleHelper<Length, [...R, unknown]>\r\n\r\nexport type GetTuple<Length extends number = 0> = GetTupleHelper<Length>\r\n\r\n```\r\n\r\n### Filter\r\n\r\n```ts\r\nexport type Filter<\r\n  T extends unknown[],\r\n  C,\r\n  Strict extends boolean = false\r\n> = FilterHelper<T, C, Strict>\r\n\r\ntype FilterHelper<\r\n  T extends unknown[],\r\n  C,\r\n  Strict extends boolean,\r\n  Offset extends number = 0,\r\n  Cache extends unknown[] = []\r\n> = Offset extends T['length']\r\n  ? Cache\r\n  : FilterHelper<\r\n      T,\r\n      C,\r\n      Strict,\r\n      IntAddSingle<Offset, 1>,\r\n      And<Strict, IsTempEqual<T[Offset], C>> extends true\r\n        ? Push<Cache, T[Offset]>\r\n        : And<Not<Strict>, CheckLeftIsExtendsRight<T[Offset], C>> extends true\r\n        ? Push<Cache, T[Offset]>\r\n        : Cache\r\n    >\r\n```\r\n\r\n### Fill\r\n\r\n```ts\r\n\r\n/**\r\n * 以指定类型填充元组类型\r\n * @example\r\n * type Result = Fill<['1', '2', 3, any], 1> // [1, 1, 1, 1]\r\n */\r\nexport type Fill<T extends unknown[], F = undefined> = FillHelper<T, F>\r\ntype FillHelper<\r\n  T extends unknown[],\r\n  F,\r\n  Offset extends number = 0\r\n> = T[\"length\"] extends 0\r\n  ? F[]\r\n  : Offset extends T[\"length\"]\r\n  ? IsTempEqual<T, F[]> extends true /** any[] -> T[] */\r\n    ? T\r\n    : F[]\r\n  : FillHelper<Push<Shift<T>, F>, F, IntAddSingle<Offset, 1>>\r\n```\r\n\r\n### Some\r\n\r\n```ts\r\n\r\ntype SomeHelper<\r\n  T extends unknown[],\r\n  Check,\r\n  Offset extends number = 0,\r\n  CacheBool extends boolean = false\r\n> = T['length'] extends Offset\r\n  ? CacheBool\r\n  : SomeHelper<\r\n      T,\r\n      Check,\r\n      IntAddSingle<Offset, 1>,\r\n      Or<CheckLeftIsExtendsRight<T[Offset], Check>, CacheBool>\r\n    >\r\n\r\n/**\r\n * 校验元组中是否有类型符合条件\r\n * @example\r\n * type Result = Every<['1', '2', 3], number> // true\r\n */\r\nexport type Some<T extends unknown[], Check> = SomeHelper<T, Check>\r\n\r\n```\r\n\r\n### Every\r\n\r\n```ts\r\ntype EveryHelper<\r\n  T extends unknown[],\r\n  Check,\r\n  Offset extends number = 0,\r\n  CacheBool extends boolean = true\r\n> = T['length'] extends Offset\r\n  ? CacheBool\r\n  : EveryHelper<\r\n      T,\r\n      Check,\r\n      IntAddSingle<Offset, 1>,\r\n      And<CheckLeftIsExtendsRight<T[Offset], Check>, CacheBool>\r\n    >\r\n\r\n/**\r\n * 校验元组中每个类型是否都符合条件\r\n * @example\r\n * type Result = Every<[1, 2, 3], number> // true\r\n */\r\nexport type Every<T extends unknown[], Check> = T['length'] extends 0\r\n  ? false\r\n  : EveryHelper<T, Check>\r\n\r\n```\r\n\r\n### TupleToUnion\r\n\r\n```ts\r\n\r\n/**\r\n * @description 从数组类型构造联合型\r\n * [number, string] => number | string\r\n */\r\n\r\nexport type TupleToUnion<T extends unknown[]> = T[number]\r\n\r\n```\r\n\r\n### Pop\r\n\r\n```ts\r\n\r\nexport type Pop<T extends unknown[]> = T extends [...infer rest, infer R]\r\n  ? rest\r\n  : never\r\n\r\n```\r\n\r\n### Push\r\n\r\n```ts\r\n/**\r\n * 在元组最后插入一位\r\n * @example\r\n * type Result = Push<[1, 2, 3], 4> // [1, 2, 3， 4]\r\n */\r\nexport type Push<T extends unknown[], Item> = [...T, Item]\r\n```\r\n\r\n### Shift\r\n\r\n```ts\r\n/**\r\n * 去除元组最开始元素\r\n */\r\nexport type Shift<T extends unknown[]> = T extends [infer R, ...infer rest]\r\n  ? rest\r\n  : never\r\n\r\n```\r\n\r\n### UnShift\r\n\r\n```ts\r\n/**\r\n * 在元组最开始插入元素\r\n */\r\nexport type UnShift<T extends unknown[], Item> = [Item, ...T]\r\n\r\ntype SetHelper<\r\n  T extends unknown[],\r\n  Index extends number,\r\n  Value,\r\n  Offset extends number = 0,\r\n  Cache extends unknown[] = []\r\n> = Offset extends T['length']\r\n  ? Cache\r\n  : SetHelper<\r\n      T,\r\n      Index,\r\n      Value,\r\n      IntAddSingle<Offset, 1>,\r\n      Push<Cache, Offset extends Index ? Value : T[Offset]>\r\n    >\r\n\r\n```\r\n\r\n### ArraySet\r\n\r\n```ts\r\n/**\r\n * 更改元组中指定索引位的类型\r\n * @example\r\n * type Result = ArraySet<[1, 2, 3], 2, 4> // [1, 2, 4]\r\n */\r\nexport type ArraySet<\r\n  T extends unknown[],\r\n  Index extends number,\r\n  Value\r\n> = SetHelper<T, Index, Value>\r\n\r\n```\r\n\r\n### Concat\r\n\r\n```ts\r\n// 连接两个数组\r\nexport type Concat<T extends unknown[], R extends unknown[]> = [...T, ...R]\r\n```\r\n\r\n### Join\r\n\r\n```ts\r\n/**\r\n * 将元组类型拼接成字符串类型\r\n * @example\r\n * type Result = Join<[1, 2, 3]> // \"1,2,3\"\r\n */\r\nexport type Join<\r\n  T extends CanStringified[],\r\n  SplitStr extends CanStringified = ','\r\n> = T['length'] extends 0\r\n  ? ''\r\n  : T extends [infer Left, ...infer RightRest]\r\n  ? Left extends CanStringified\r\n    ? RightRest extends CanStringified[]\r\n      ? `${Left}${T['length'] extends 1 ? '' : SplitStr}${Join<\r\n          RightRest,\r\n          SplitStr\r\n        >}`\r\n      : never\r\n    : never\r\n  : never  \r\n```\r\n\r\n## funtion\r\n\r\n```ts\r\n// 任意 普通 function\r\nexport type Noop = (...args: any[]) => any\r\nexport type Func = (...args: any[]) => any\r\nexport type AsyncFunc = (...args:any[]) => any\r\n\r\n\r\n// 获取异步函数的返回值\r\nexport type GetAsyncFunctionReturnType<F extends Noop> = Awaited<ReturnType<F>>\r\n\r\n// 获取参数长度\r\nexport type GetFunctionLength<F extends Noop> = F extends (\r\n  ...args: infer P\r\n) => any\r\n  ? P['length']\r\n  : never\r\n\r\n// 获取function参数\r\nexport type GetParams<Func extends Noop> = Func extends (\r\n  ...args: infer args\r\n) => any\r\n  ? args\r\n  : never\r\n\r\n// 获取function返回值\r\nexport type GetReturnType<Func extends Noop> = Func extends (\r\n  ...args: any\r\n) => infer Return\r\n  ? Return\r\n  : never\r\n\r\n```\r\n\r\n## string\r\n\r\n```ts\r\n\r\nimport { IntAddSingle } from './number'\r\nimport { Compare } from './helper'\r\nimport { Push, Or, IsEqual, And3, Join } from './index'\r\n\r\n// 将类型转为字符串有一定的限制，仅支持下面的类型\r\nexport type CanStringified = string\r\n  | number\r\n  | bigint\r\n  | boolean\r\n  | null\r\n  | undefined\r\n\r\n// 将支持的类型转化为字符串\r\nexport type Stringify<T extends CanStringified> = `${T}`\r\n\r\n\r\nexport type ToUpperCase<S extends string> = Uppercase<S> // 转大写\r\nexport type ToLowerCase<S extends string> = Lowercase<S> // 转小写\r\n\r\ntype SubStringHelper<\r\n  S extends string,\r\n  Start extends number,\r\n  End extends number,\r\n  Offset extends number = 0,\r\n  Cache extends string[] = []\r\n> = IsEqual<Offset, End> extends true\r\n  ? Join<Cache, ''>\r\n  : SubStringHelper<\r\n      S,\r\n      Start,\r\n      End,\r\n      IntAddSingle<Offset, 1>,\r\n      And3<\r\n        Or<Compare<Offset, Start>, IsEqual<Offset, Start>>,\r\n        Or<Compare<End, Offset>, IsEqual<Offset, End>>,\r\n        CharAt<S, Offset> extends string ? true : false\r\n      > extends true\r\n        ? Push<Cache, CharAt<S, Offset>>\r\n        : Cache\r\n    >\r\n\r\n/**\r\n * 在字符串中抽取从 开始 下标开始的指定数目的字符\r\n * @example\r\n * type Result = SubStr<'123', 1, 3> // '23'\r\n */\r\nexport type SubString<\r\n  S extends string,\r\n  Start extends number,\r\n  End extends number\r\n> = SubStringHelper<S, Start, End>\r\n\r\n\r\nexport type SubStr<\r\n  S extends string,\r\n  Start extends number,\r\n  Len extends number\r\n> = SubStringHelper<S, Start, IntAddSingle<Start, Len>>\r\n\r\n\r\n\r\n/**\r\n * 去除左空格\r\n */\r\nexport type TrimLeft<str extends string> = str extends `${| ' ' | '\\t' | '\\n' | '\\n'}${infer rest}`\r\n  ? TrimLeft<rest>\r\n  : str\r\n\r\n/**\r\n * 去除右空格\r\n */\r\nexport type TrimRight<str extends string> = str extends `${infer rest}${| ' ' | '\\t' | '\\n' | '\\n'}`\r\n  ? TrimRight<rest>\r\n  : str\r\n\r\n/**\r\n * 去除左右空格\r\n */\r\nexport type Trim<str extends string> = TrimLeft<TrimRight<str>>\r\n\r\ntype SplitHelper<\r\n  S extends string,\r\n  SplitStr extends string = '',\r\n  T extends string[] = []\r\n> = S extends `${infer Char}${SplitStr}${infer Rest}`\r\n  ? SplitHelper<Rest, SplitStr, Push<T, Char>>\r\n  : S extends string\r\n  ? S extends ''\r\n  ? T : Push<T, S>\r\n  : never\r\n\r\n/**\r\n * 拆分字符串变为一个元组\r\n * @example\r\n * type Result = Split<'1,2,3', ','> // [1, 2, 3]\r\n */\r\nexport type Split<S extends string, SplitStr extends string = ''> = SplitHelper<\r\n  S,\r\n  SplitStr\r\n>\r\n\r\n/**\r\n * 获取模板字符串类型中的字符\r\n */\r\nexport type GetChars<S> = GetCharsHelper<S, never>\r\n\r\ntype GetCharsHelper<S, Acc> = S extends `${infer Char}${infer Rest}` ? GetCharsHelper<Rest, Char | Acc> : Acc\r\n\r\n/**\r\n * 获取字符串的长度\r\n * @example\r\n * type Result = GetStringLength<\"123\"> // 3\r\n */\r\nexport type GetStringLength<S extends string> = Split<S>['length']\r\n\r\n/**\r\n * 获取字符串在索引位 I 下的 字符\r\n * @example\r\n * type Result = CharAt<\"123\", 1> // \"2\"\r\n */\r\nexport type CharAt<S extends string, I extends number> = Split<S>[I]\r\n\r\n/**\r\n * 拼接两个字符串\r\n * @example\r\n * type Result = ConcatString<\"123\", \"456\"> // \"123456\"\r\n */\r\nexport type ConcatString<S1 extends string, S2 extends string> = `${S1}${S2}`\r\n\r\n/**\r\n * 判断字符串是否包含子串\r\n * @example\r\n */\r\nexport type IncludeString<\r\n  S1 extends string,\r\n  S2 extends string\r\n> = S1 extends `${infer Left}${S2}${infer Right}` ? true : false //  eslint-disable-line\r\n\r\n/**\r\n * 判断字符串是否以子串为起始\r\n * @example\r\n * type Result = StartsWith<\"123\", \"12\"> // true\r\n */\r\nexport type StartsWith<\r\n  S1 extends string,\r\n  S2 extends string\r\n> = S1 extends `${S2}${infer Right}` ? true : false // eslint-disable-line\r\n\r\n/**\r\n * 判断字符串是否以子串为结束\r\n * @example\r\n * type Result = EndsWith<\"123\", \"23\"> // true\r\n */\r\nexport type EndsWith<\r\n  S1 extends string,\r\n  S2 extends string\r\n> = S1 extends `${infer Left}${S2}` ? true : false // eslint-disable-line\r\n\r\ntype IndexOfHelper<\r\n  S1 extends string,\r\n  S2 extends string,\r\n  Len1 extends number = GetStringLength<S1>,\r\n  Len2 extends number = GetStringLength<S2>\r\n> = Or<Compare<Len1, Len2>, IsEqual<Len1, Len2>> extends true\r\n  ? S1 extends `${infer Left}${S2}${infer Right}` // eslint-disable-line\r\n  ? GetStringLength<Left>\r\n  : -1\r\n  : -1\r\n\r\n/**\r\n * 从左往右查找子串的位置\r\n * @example\r\n * type Result = IndexOf<\"123\", \"23\"> // 1\r\n */\r\nexport type IndexOf<S1 extends string, S2 extends string> = IndexOfHelper<\r\n  S1,\r\n  S2\r\n>\r\n\r\n/**\r\n * 在字符串中查找并替换一处子串\r\n * MatchStr 不支持 正则\r\n * @example\r\n * type Result = Replace<\"23123\", \"23\", \"xx\"> // \"xx123\"\r\n */\r\nexport type Replace<\r\n  S extends string,\r\n  MatchStr extends string,\r\n  ReplaceStr extends string\r\n> = S extends `${infer Left}${MatchStr}${infer Right}`\r\n  ? `${Left}${ReplaceStr}${Right}`\r\n  : S\r\n\r\n/**\r\n * 在字符串中查找并替换所有子串\r\n * @example\r\n * type Result = Replace<\"23123\", \"23\", \"xx\"> // \"xx1xx\"\r\n */\r\nexport type ReplaceAll<\r\n  S extends string,\r\n  MatchStr extends string,\r\n  ReplaceStr extends string\r\n> = IncludeString<S, MatchStr> extends true\r\n  ? ReplaceAll<Replace<S, MatchStr, ReplaceStr>, MatchStr, ReplaceStr>\r\n  : S\r\n\r\ntype LastIndexOfHelper<\r\n  S1 extends string,\r\n  S2 extends string,\r\n  Index extends number = -1 /** 当前从左往右匹配最大的值，匹配不到以后，上一次匹配的索引就是从右往左第一个的索引 */,\r\n  AddOffset extends number = 0 /** 每次从左往右匹配并替换成空串后，下次循序需要累加的值 */\r\n> = S1 extends `${infer Left}${S2}${infer Right}` // eslint-disable-line\r\n  ? LastIndexOfHelper<\r\n    Replace<S1, S2, ''>,\r\n    S2,\r\n    IntAddSingle<GetStringLength<Left>, AddOffset>,\r\n    IntAddSingle<AddOffset, GetStringLength<S2>>\r\n  >\r\n  : Index\r\n\r\n/**\r\n * 从右往左查找子串的位置\r\n * @example\r\n * type Result = LastIndexOf<\"23123\", \"23\"> // 3\r\n */\r\nexport type LastIndexOf<\r\n  S1 extends string,\r\n  S2 extends string\r\n> = LastIndexOfHelper<S1, S2>\r\n\r\n\r\ntype RepeatHelper<\r\n  S extends string,\r\n  Times extends number,\r\n  OriginStr extends string = S,\r\n  Offset extends number = 1\r\n> = Times extends 0\r\n  ? \"\"\r\n  : IsEqual<Times, Offset> extends true\r\n  ? S\r\n  : `${OriginStr}${RepeatHelper<\r\n    S,\r\n    Times,\r\n    OriginStr,\r\n    IntAddSingle<Offset, 1>\r\n  >}`\r\n\r\n/**\r\n * 重复 Times 次数的字符串\r\n * @example\r\n * type Result = Repeat<\"1\", 5> // \"11111\"\r\n */\r\nexport type Repeat<S extends string, Times extends number = 1> = RepeatHelper<S, Times>\r\n\r\n\r\ntype PadHelper<\r\n  S extends string,\r\n  N extends number = 0,\r\n  FillS extends string = \" \",\r\n  IsStart extends boolean = true,\r\n  Len extends number = GetStringLength<S>,\r\n  Offset extends number = Len\r\n> = Compare<N, Len> extends true\r\n  ? IsEqual<N, Offset> extends true\r\n  ? S\r\n  : PadHelper<\r\n    `${IsStart extends true ? FillS : \"\"}${S}${IsStart extends false\r\n    ? FillS\r\n    : \"\"}`,\r\n    N,\r\n    FillS,\r\n    IsStart,\r\n    Len,\r\n    IntAddSingle<Offset, 1>\r\n  >\r\n  : S\r\n\r\n/**\r\n * 当字符串不满足给定的长度时，在字符串前面填充使其满足长度\r\n * @example\r\n * type Result = PadStart<'0123', 10> // '      0123'\r\n */\r\nexport type PadStart<\r\n  S extends string,\r\n  N extends number = 0,\r\n  FillS extends string = \" \"\r\n> = PadHelper<S, N, FillS>\r\n\r\n\r\n/**\r\n * 当字符串不满足给定的长度时，在字符串后面填充使其满足长度\r\n * @example\r\n * type Result = PadStart<'0123', 10> // '0123      '\r\n */\r\nexport type PadEnd<\r\n  S extends string,\r\n  N extends number = 0,\r\n  FillS extends string = \" \"\r\n> = PadHelper<S, N, FillS, false>\r\n\r\n```\r\n\r\n## 总结\r\n\r\n- 巧用泛型里面的属性可以当做临时变量使用\r\n- `infer`关键字类似正则的断言, 具体的可以自己看上面栗子了解\r\n","children":[]},{"name":"类型工具.md","path":"../guanruihua.github.io/TypeScript","data":"# type 类型 工具\n\n## 获取types类型的key合集\n\n```ts\nexport type Clothes<source, types> = {\n  [K in keyof source]: source[K] extends types ? K : never\n}[keyof source]\n```\n\n## 挑选指定类型成为新的类型\n\n```ts\n\nexport type Pick<T, K extends keyof T> = {\n  [P in K]: T[P]\n}\n```\n\n## 过滤类型\n\n```ts\n\nexport type FilterType<Source, Types> = Pick<\n  Source,\n  {\n    [K in keyof Source]: Source[K] extends Types ? K : never\n  }[keyof Source]\n>\n```\n\n## 删除类型\n\n```ts\n/**\n* T : 待编辑的基本类型\n* K : 要删除的类型\n */\nexport type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>\n\n// 将属性变成可选\nexport type Partial<T> = {\n  [P in keyof T]?: T[P]\n}\n```\n\n## 删除类型集合\n\n```ts\nexport type Exclude<T, U> = T extends U ? never : T\n```\n\n## 所有属性变成只读\n\n```ts!\nexport type Readonly<T> = {\n  readonly [P in keyof T]: T[P]\n}\n```\n\n## 获取函数 T 的返回类型\n\n```ts\nexport type ReturnType<T = any> = T extends (...args: any) => infer R ? R : any\n```\n\n## 获取函数参数数组\n\n```ts\nexport type Parameters<T> = T extends (...arg: infer P) => void ? P : string\n```\n","children":[]},{"name":"类型过滤.md","path":"../guanruihua.github.io/TypeScript","data":"# 类型过滤\n\n![](/__assets__/img/2022-02-09-14-14-49.png)\n\n```ts\ninterface Example{\n    a:string;\n    b:number;\n    c:number;\n    d:string;\n    ...   \n}\n```\n\n> 有一个Example的接口，但是咱们现在想对这个接口做一些处理，只希望留下类型为string的属性\n> 就可以使用咱们自己定义的FilterType\n\n```ts\n type newExample = FilterType<Example,string> // {a:string;d:string;...}\n```\n\n```ts\ntype FilterType<Source, Types> = Pick<\n Source, \n {\n  [K in keyof Source]: Source[K] extends Types ? K : never\n }[keyof Source]\n>;\n```\n\n## in\n\n> in 遍历枚举类型\n\n```ts\ntype Example = 'a' | 'b' | 'c' | 'd'\ntype Obj = {\n  [T in Example]: string;  // 遍历Example，把每个key都赋值string类型\n}\n/* 等价于 \n  type Obj = {\n    a: string;\n    b: string;\n    c: string;\n    d: string;\n  }\n*/\n```\n\n## keyof\n\n> 索引类型查询操作符: 获取到类型的key 类似Object.keys()\n\n```ts\ninterface Example {\n    a: string;\n    b: string;\n    c: number;\n    d: boolean;\n}\ntype Keys = keyof Example   // 等价于 type Keys = 'a' | 'b' | 'c' | 'd'\n```\n\n## 条件判断\n\n```ts\ninterface A {\n    a:string;\n}\n\ninterface B extends A {\n    b:string;\n} \n\n// B是否继承于A？若是，则为number类型；若不是，则为string类型\ntype C = B extends A ? number : string  // 等价于 type C = number\n\n```\n\n## 索引访问接口属性\n\n```ts\ntype person = { \n    name:\"Angus\";\n    height:185;\n}[\"name\" | \"height\"]\n```\n\n等价于\n\n```ts\ntype person = \"Angus\" | 185\n```\n\n```ts\ntype person = { \n    name:\"Angus\";\n    height:185;\n    girlFriend:never;\n}[\"name\" | \"height\" | \"girlFriend\"]\n```\n\n等价于\n\n```ts\ntype person = \"Angus\" | 185\n```\n","children":[]},{"name":"错误","path":"../guanruihua.github.io/TypeScript","data":"","children":[{"name":"2709.md","path":"../guanruihua.github.io/TypeScript/错误","data":"# 2709\r\n\r\n- 非类型模块应该和类型模块分开导出, 和使用\r\n","children":[]}]}]}]