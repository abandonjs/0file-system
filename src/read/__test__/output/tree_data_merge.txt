export declare const CSVLikeDefault: string[];
{"data":"export declare const CSVLikeDefault: string[];\r\n"}export * from './write';
export * from './remove';
export * from './read';
export * from './util';
export * from './config';
export * from './type';
export * from './copy';
{"data":"export * from './write';\r\nexport * from './remove';\r\nexport * from './read';\r\nexport * from './util';\r\nexport * from './config';\r\nexport * from './type';\r\nexport * from './copy';\r\n"}import n from"fs";import t from"path";async function r(t,r={}){try{return n.mkdirSync(t,{recursive:!0,...r}),!0}catch(n){return console.error(n),!1}}function e(t,e,i){try{const o=t.split(/\/|\\/);o.pop();const c=o.join("/");return n.existsSync(c)||r(c),n.writeFileSync(t,e,i),!0}catch(n){return console.error(n),!1}}const i=Array.isArray;function o(n){try{if("object"==typeof(t=n)&&!function(n){return null==n||n!=n}(t)&&/Iterator\]$/.test(t.toString()))return"Iterator";const r=Object.prototype.toString.call(n).match(/\[object (\w+)\]/)[1];return"Number"===r&&isNaN(n)?"NaN":r}catch(n){return"Undefined"}var t}function c(n,t=!1){return t?"function"==typeof n:"Function"===o(n)}function s(n,t){Array.isArray(t)||(t=[t]);for(let r=0;r<t.length;r++)if("string"==typeof t[r]&&new RegExp(`^${t[r].replaceAll("*",".*")}$`).test(n))return!0;return!1}function f(t){return n.lstatSync(t).isDirectory()}function u(t,r){if(l(t))return!1;const e=i(r)?r:[r];return 0===n.readdirSync(t).filter((n=>!s(n,e))).length}function l(n){return!f(n)}"undefined"!=typeof window&&window?.navigator?.userAgent&&/iP(ad|hone|od)/.test(window.navigator.userAgent);const a=(...n)=>t.resolve(...n),d=n=>(...r)=>t.resolve(n,...r),y=process.version,h=["*.csv","*.xls","*.xlsx"],g=[];function p(t,r={encoding:"utf8",flag:"r"}){if(g.length>0)for(let n=0;n<g.length;n++){const{test:e,loader:i}=g[n];if("RegExp"===o(e)&&c(i)&&e.test(t))return i(t,r)}return n.readFileSync(t,r)}function S(t,r){return n.readdirSync(t,r)||[]}function w(n,t){const{depth:r="auto",ignore:e=[],readData:i=!0,use:o=[],files:c=[],dirs:s=[],encoding:u="utf8",flag:l="r",withFileTypes:a}=t||{},d=[];let y=[];return y=0===c.length&&0===s.length?function(n=[],t){return n.filter(((n="")=>{for(let r=0;r<t.length;r++){const e=t[r];if(e===n)return!1;if(e.indexOf("*")>-1){const[t="",r=""]=e.split("*")||["",""];if(""!==t&&0===n.indexOf(t)||""!==r&&n.indexOf(r)>-1)return!1}}return!0}))}(S(n,{encoding:u,withFileTypes:a}),e)||[]:c.concat(y),y.forEach((e=>{const c=n+"/"+e,s=f(c),a=[],y=[];(s?S(c):[]).forEach((n=>{f(c+"/"+n)?a.push(n):y.push(n)}));const h={name:e,path:n,isDir:s,files:y,dirs:a,data:"",children:[]};s?(t.dirs=a,t.files=y,"auto"===r?h.children=w(c,t):r>0&&(t.depth=r-1,h.children=w(c,t))):i&&(0===o.length||o.filter((n=>e.indexOf(n)>-1)).length>0)&&(h.data=p(c,{encoding:u,flag:l})),d.push(h)})),d}function F(n,t){const{tree:r=!1,encoding:e="utf8",flag:i="r",withFileTypes:o}=t||{};return f(n)?r?w(n,t):S(n,{encoding:e,withFileTypes:o}):p(n,{encoding:e,flag:i})}function m(t){if(!f(t)){try{n.unlinkSync(t)}catch(n){return console.error(n),!1}return!0}return!1}function x(t,r){if(!f(t))return;const e=[t];let o=!0;!function n(t,r){const c=S(t);i(c)&&c.length>0&&c.forEach((i=>{try{const o=t+"/"+i;return f(o)?(e.push(o),n(o,r)):m(o)}catch(n){console.error(n),o=!1}}))}(t,r);let c=e.length;for(;--c;)if(f(e[c]))try{n.rmdirSync(e[c],r)}catch(n){return console.log(n),!1}return o}function E(t,r,e={}){const{ignore:i,clearEmptyDir:o=!0}=e;if(!f(t)){if(s(t,i))return;return void n.copyFileSync(t,r,n.constants.COPYFILE_FICLONE)}const c=n.readdirSync(t,{withFileTypes:!0});for(const f of c){const c=a(t,f.name),l=a(r,f.name);if(!s(c,i))if(!f.isDirectory()||n.existsSync(l))f.isDirectory()&&n.existsSync(l)?E(c,l,e):!f.isDirectory()&&n.copyFileSync(c,l,n.constants.COPYFILE_FICLONE);else{if(o&&u(c,i))continue;n.mkdirSync(l),E(c,l,e)}}}export{h as CSVLikeDefault,g as ReadFileRules,y as __node_version,E as copy,f as isDirectory,u as isEmptyDirectory,l as isFile,s as match,r as mkdir,a as path,d as pathResolve,F as read,S as readDir,p as readFile,w as readTree,m as rmFile,x as rmdir,e as writeFile};
//# sourceMappingURL=index.esm.js.map
{"data":"import n from\"fs\";import t from\"path\";async function r(t,r={}){try{return n.mkdirSync(t,{recursive:!0,...r}),!0}catch(n){return console.error(n),!1}}function e(t,e,i){try{const o=t.split(/\\/|\\\\/);o.pop();const c=o.join(\"/\");return n.existsSync(c)||r(c),n.writeFileSync(t,e,i),!0}catch(n){return console.error(n),!1}}const i=Array.isArray;function o(n){try{if(\"object\"==typeof(t=n)&&!function(n){return null==n||n!=n}(t)&&/Iterator\\]$/.test(t.toString()))return\"Iterator\";const r=Object.prototype.toString.call(n).match(/\\[object (\\w+)\\]/)[1];return\"Number\"===r&&isNaN(n)?\"NaN\":r}catch(n){return\"Undefined\"}var t}function c(n,t=!1){return t?\"function\"==typeof n:\"Function\"===o(n)}function s(n,t){Array.isArray(t)||(t=[t]);for(let r=0;r<t.length;r++)if(\"string\"==typeof t[r]&&new RegExp(`^${t[r].replaceAll(\"*\",\".*\")}$`).test(n))return!0;return!1}function f(t){return n.lstatSync(t).isDirectory()}function u(t,r){if(l(t))return!1;const e=i(r)?r:[r];return 0===n.readdirSync(t).filter((n=>!s(n,e))).length}function l(n){return!f(n)}\"undefined\"!=typeof window&&window?.navigator?.userAgent&&/iP(ad|hone|od)/.test(window.navigator.userAgent);const a=(...n)=>t.resolve(...n),d=n=>(...r)=>t.resolve(n,...r),y=process.version,h=[\"*.csv\",\"*.xls\",\"*.xlsx\"],g=[];function p(t,r={encoding:\"utf8\",flag:\"r\"}){if(g.length>0)for(let n=0;n<g.length;n++){const{test:e,loader:i}=g[n];if(\"RegExp\"===o(e)&&c(i)&&e.test(t))return i(t,r)}return n.readFileSync(t,r)}function S(t,r){return n.readdirSync(t,r)||[]}function w(n,t){const{depth:r=\"auto\",ignore:e=[],readData:i=!0,use:o=[],files:c=[],dirs:s=[],encoding:u=\"utf8\",flag:l=\"r\",withFileTypes:a}=t||{},d=[];let y=[];return y=0===c.length&&0===s.length?function(n=[],t){return n.filter(((n=\"\")=>{for(let r=0;r<t.length;r++){const e=t[r];if(e===n)return!1;if(e.indexOf(\"*\")>-1){const[t=\"\",r=\"\"]=e.split(\"*\")||[\"\",\"\"];if(\"\"!==t&&0===n.indexOf(t)||\"\"!==r&&n.indexOf(r)>-1)return!1}}return!0}))}(S(n,{encoding:u,withFileTypes:a}),e)||[]:c.concat(y),y.forEach((e=>{const c=n+\"/\"+e,s=f(c),a=[],y=[];(s?S(c):[]).forEach((n=>{f(c+\"/\"+n)?a.push(n):y.push(n)}));const h={name:e,path:n,isDir:s,files:y,dirs:a,data:\"\",children:[]};s?(t.dirs=a,t.files=y,\"auto\"===r?h.children=w(c,t):r>0&&(t.depth=r-1,h.children=w(c,t))):i&&(0===o.length||o.filter((n=>e.indexOf(n)>-1)).length>0)&&(h.data=p(c,{encoding:u,flag:l})),d.push(h)})),d}function F(n,t){const{tree:r=!1,encoding:e=\"utf8\",flag:i=\"r\",withFileTypes:o}=t||{};return f(n)?r?w(n,t):S(n,{encoding:e,withFileTypes:o}):p(n,{encoding:e,flag:i})}function m(t){if(!f(t)){try{n.unlinkSync(t)}catch(n){return console.error(n),!1}return!0}return!1}function x(t,r){if(!f(t))return;const e=[t];let o=!0;!function n(t,r){const c=S(t);i(c)&&c.length>0&&c.forEach((i=>{try{const o=t+\"/\"+i;return f(o)?(e.push(o),n(o,r)):m(o)}catch(n){console.error(n),o=!1}}))}(t,r);let c=e.length;for(;--c;)if(f(e[c]))try{n.rmdirSync(e[c],r)}catch(n){return console.log(n),!1}return o}function E(t,r,e={}){const{ignore:i,clearEmptyDir:o=!0}=e;if(!f(t)){if(s(t,i))return;return void n.copyFileSync(t,r,n.constants.COPYFILE_FICLONE)}const c=n.readdirSync(t,{withFileTypes:!0});for(const f of c){const c=a(t,f.name),l=a(r,f.name);if(!s(c,i))if(!f.isDirectory()||n.existsSync(l))f.isDirectory()&&n.existsSync(l)?E(c,l,e):!f.isDirectory()&&n.copyFileSync(c,l,n.constants.COPYFILE_FICLONE);else{if(o&&u(c,i))continue;n.mkdirSync(l),E(c,l,e)}}}export{h as CSVLikeDefault,g as ReadFileRules,y as __node_version,E as copy,f as isDirectory,u as isEmptyDirectory,l as isFile,s as match,r as mkdir,a as path,d as pathResolve,F as read,S as readDir,p as readFile,w as readTree,m as rmFile,x as rmdir,e as writeFile};\n//# sourceMappingURL=index.esm.js.map\n"}"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("fs"),t=require("path");function r(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var n=r(e),o=r(t);async function i(e,t={}){try{return n.default.mkdirSync(e,{recursive:!0,...t}),!0}catch(e){return console.error(e),!1}}const c=Array.isArray;function s(e){try{if("object"==typeof(t=e)&&!function(e){return null==e||e!=e}(t)&&/Iterator\]$/.test(t.toString()))return"Iterator";const r=Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1];return"Number"===r&&isNaN(e)?"NaN":r}catch(e){return"Undefined"}var t}function u(e,t=!1){return t?"function"==typeof e:"Function"===s(e)}function l(e,t){Array.isArray(t)||(t=[t]);for(let r=0;r<t.length;r++)if("string"==typeof t[r]&&new RegExp(`^${t[r].replaceAll("*",".*")}$`).test(e))return!0;return!1}function f(e){return n.default.lstatSync(e).isDirectory()}function a(e,t){if(d(e))return!1;const r=c(t)?t:[t];return 0===n.default.readdirSync(e).filter((e=>!l(e,r))).length}function d(e){return!f(e)}"undefined"!=typeof window&&window?.navigator?.userAgent&&/iP(ad|hone|od)/.test(window.navigator.userAgent);const p=(...e)=>o.default.resolve(...e),y=process.version,h=[];function g(e,t={encoding:"utf8",flag:"r"}){if(h.length>0)for(let r=0;r<h.length;r++){const{test:n,loader:o}=h[r];if("RegExp"===s(n)&&u(o)&&n.test(e))return o(e,t)}return n.default.readFileSync(e,t)}function x(e,t){return n.default.readdirSync(e,t)||[]}function F(e,t){const{depth:r="auto",ignore:n=[],readData:o=!0,use:i=[],files:c=[],dirs:s=[],encoding:u="utf8",flag:l="r",withFileTypes:a}=t||{},d=[];let p=[];return p=0===c.length&&0===s.length?function(e=[],t){return e.filter(((e="")=>{for(let r=0;r<t.length;r++){const n=t[r];if(n===e)return!1;if(n.indexOf("*")>-1){const[t="",r=""]=n.split("*")||["",""];if(""!==t&&0===e.indexOf(t)||""!==r&&e.indexOf(r)>-1)return!1}}return!0}))}(x(e,{encoding:u,withFileTypes:a}),n)||[]:c.concat(p),p.forEach((n=>{const c=e+"/"+n,s=f(c),a=[],p=[];(s?x(c):[]).forEach((e=>{f(c+"/"+e)?a.push(e):p.push(e)}));const y={name:n,path:e,isDir:s,files:p,dirs:a,data:"",children:[]};s?(t.dirs=a,t.files=p,"auto"===r?y.children=F(c,t):r>0&&(t.depth=r-1,y.children=F(c,t))):o&&(0===i.length||i.filter((e=>n.indexOf(e)>-1)).length>0)&&(y.data=g(c,{encoding:u,flag:l})),d.push(y)})),d}function S(e){if(!f(e)){try{n.default.unlinkSync(e)}catch(e){return console.error(e),!1}return!0}return!1}exports.CSVLikeDefault=["*.csv","*.xls","*.xlsx"],exports.ReadFileRules=h,exports.__node_version=y,exports.copy=function e(t,r,o={}){const{ignore:i,clearEmptyDir:c=!0}=o;if(!f(t)){if(l(t,i))return;return void n.default.copyFileSync(t,r,n.default.constants.COPYFILE_FICLONE)}const s=n.default.readdirSync(t,{withFileTypes:!0});for(const u of s){const s=p(t,u.name),f=p(r,u.name);if(!l(s,i))if(!u.isDirectory()||n.default.existsSync(f))u.isDirectory()&&n.default.existsSync(f)?e(s,f,o):!u.isDirectory()&&n.default.copyFileSync(s,f,n.default.constants.COPYFILE_FICLONE);else{if(c&&a(s,i))continue;n.default.mkdirSync(f),e(s,f,o)}}},exports.isDirectory=f,exports.isEmptyDirectory=a,exports.isFile=d,exports.match=l,exports.mkdir=i,exports.path=p,exports.pathResolve=e=>(...t)=>o.default.resolve(e,...t),exports.read=function(e,t){const{tree:r=!1,encoding:n="utf8",flag:o="r",withFileTypes:i}=t||{};return f(e)?r?F(e,t):x(e,{encoding:n,withFileTypes:i}):g(e,{encoding:n,flag:o})},exports.readDir=x,exports.readFile=g,exports.readTree=F,exports.rmFile=S,exports.rmdir=function(e,t){if(!f(e))return;const r=[e];let o=!0;!function e(t,n){const i=x(t);c(i)&&i.length>0&&i.forEach((i=>{try{const o=t+"/"+i;return f(o)?(r.push(o),e(o,n)):S(o)}catch(e){console.error(e),o=!1}}))}(e,t);let i=r.length;for(;--i;)if(f(r[i]))try{n.default.rmdirSync(r[i],t)}catch(e){return console.log(e),!1}return o},exports.writeFile=function(e,t,r){try{const o=e.split(/\/|\\/);o.pop();const c=o.join("/");return n.default.existsSync(c)||i(c),n.default.writeFileSync(e,t,r),!0}catch(e){return console.error(e),!1}};
//# sourceMappingURL=index.js.map
{"data":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0});var e=require(\"fs\"),t=require(\"path\");function r(e){return e&&\"object\"==typeof e&&\"default\"in e?e:{default:e}}var n=r(e),o=r(t);async function i(e,t={}){try{return n.default.mkdirSync(e,{recursive:!0,...t}),!0}catch(e){return console.error(e),!1}}const c=Array.isArray;function s(e){try{if(\"object\"==typeof(t=e)&&!function(e){return null==e||e!=e}(t)&&/Iterator\\]$/.test(t.toString()))return\"Iterator\";const r=Object.prototype.toString.call(e).match(/\\[object (\\w+)\\]/)[1];return\"Number\"===r&&isNaN(e)?\"NaN\":r}catch(e){return\"Undefined\"}var t}function u(e,t=!1){return t?\"function\"==typeof e:\"Function\"===s(e)}function l(e,t){Array.isArray(t)||(t=[t]);for(let r=0;r<t.length;r++)if(\"string\"==typeof t[r]&&new RegExp(`^${t[r].replaceAll(\"*\",\".*\")}$`).test(e))return!0;return!1}function f(e){return n.default.lstatSync(e).isDirectory()}function a(e,t){if(d(e))return!1;const r=c(t)?t:[t];return 0===n.default.readdirSync(e).filter((e=>!l(e,r))).length}function d(e){return!f(e)}\"undefined\"!=typeof window&&window?.navigator?.userAgent&&/iP(ad|hone|od)/.test(window.navigator.userAgent);const p=(...e)=>o.default.resolve(...e),y=process.version,h=[];function g(e,t={encoding:\"utf8\",flag:\"r\"}){if(h.length>0)for(let r=0;r<h.length;r++){const{test:n,loader:o}=h[r];if(\"RegExp\"===s(n)&&u(o)&&n.test(e))return o(e,t)}return n.default.readFileSync(e,t)}function x(e,t){return n.default.readdirSync(e,t)||[]}function F(e,t){const{depth:r=\"auto\",ignore:n=[],readData:o=!0,use:i=[],files:c=[],dirs:s=[],encoding:u=\"utf8\",flag:l=\"r\",withFileTypes:a}=t||{},d=[];let p=[];return p=0===c.length&&0===s.length?function(e=[],t){return e.filter(((e=\"\")=>{for(let r=0;r<t.length;r++){const n=t[r];if(n===e)return!1;if(n.indexOf(\"*\")>-1){const[t=\"\",r=\"\"]=n.split(\"*\")||[\"\",\"\"];if(\"\"!==t&&0===e.indexOf(t)||\"\"!==r&&e.indexOf(r)>-1)return!1}}return!0}))}(x(e,{encoding:u,withFileTypes:a}),n)||[]:c.concat(p),p.forEach((n=>{const c=e+\"/\"+n,s=f(c),a=[],p=[];(s?x(c):[]).forEach((e=>{f(c+\"/\"+e)?a.push(e):p.push(e)}));const y={name:n,path:e,isDir:s,files:p,dirs:a,data:\"\",children:[]};s?(t.dirs=a,t.files=p,\"auto\"===r?y.children=F(c,t):r>0&&(t.depth=r-1,y.children=F(c,t))):o&&(0===i.length||i.filter((e=>n.indexOf(e)>-1)).length>0)&&(y.data=g(c,{encoding:u,flag:l})),d.push(y)})),d}function S(e){if(!f(e)){try{n.default.unlinkSync(e)}catch(e){return console.error(e),!1}return!0}return!1}exports.CSVLikeDefault=[\"*.csv\",\"*.xls\",\"*.xlsx\"],exports.ReadFileRules=h,exports.__node_version=y,exports.copy=function e(t,r,o={}){const{ignore:i,clearEmptyDir:c=!0}=o;if(!f(t)){if(l(t,i))return;return void n.default.copyFileSync(t,r,n.default.constants.COPYFILE_FICLONE)}const s=n.default.readdirSync(t,{withFileTypes:!0});for(const u of s){const s=p(t,u.name),f=p(r,u.name);if(!l(s,i))if(!u.isDirectory()||n.default.existsSync(f))u.isDirectory()&&n.default.existsSync(f)?e(s,f,o):!u.isDirectory()&&n.default.copyFileSync(s,f,n.default.constants.COPYFILE_FICLONE);else{if(c&&a(s,i))continue;n.default.mkdirSync(f),e(s,f,o)}}},exports.isDirectory=f,exports.isEmptyDirectory=a,exports.isFile=d,exports.match=l,exports.mkdir=i,exports.path=p,exports.pathResolve=e=>(...t)=>o.default.resolve(e,...t),exports.read=function(e,t){const{tree:r=!1,encoding:n=\"utf8\",flag:o=\"r\",withFileTypes:i}=t||{};return f(e)?r?F(e,t):x(e,{encoding:n,withFileTypes:i}):g(e,{encoding:n,flag:o})},exports.readDir=x,exports.readFile=g,exports.readTree=F,exports.rmFile=S,exports.rmdir=function(e,t){if(!f(e))return;const r=[e];let o=!0;!function e(t,n){const i=x(t);c(i)&&i.length>0&&i.forEach((i=>{try{const o=t+\"/\"+i;return f(o)?(r.push(o),e(o,n)):S(o)}catch(e){console.error(e),o=!1}}))}(e,t);let i=r.length;for(;--i;)if(f(r[i]))try{n.default.rmdirSync(r[i],t)}catch(e){return console.log(e),!1}return o},exports.writeFile=function(e,t,r){try{const o=e.split(/\\/|\\\\/);o.pop();const c=o.join(\"/\");return n.default.existsSync(c)||i(c),n.default.writeFileSync(e,t,r),!0}catch(e){return console.error(e),!1}};\n//# sourceMappingURL=index.js.map\n"}/// <reference types="node" />
type Path = string;
type Options = {
    recursive?: boolean;
    mode?: string | number;
};
export declare function mkdir(path: Path, options?: Options): Promise<NodeJS.ErrnoException | null>;
export {};
{"data":"/// <reference types=\"node\" />\r\ntype Path = string;\r\ntype Options = {\r\n    recursive?: boolean;\r\n    mode?: string | number;\r\n};\r\nexport declare function mkdir(path: Path, options?: Options): Promise<NodeJS.ErrnoException | null>;\r\nexport {};\r\n"}import { MathchLike } from './util';
export declare function readXlsx(path: string): {
    name: string;
    data: unknown[];
}[];
export declare function xlsxFormat(xData: any[]): {
    [key: string]: any[];
};
export declare function readdir(path: string): string[];
export declare function readFile(path: string): string;
export declare function read(path: string, ignore?: MathchLike, matchs?: {
    [key: string]: MathchLike;
}): string | {
    [key: string]: any;
};
{"data":"import { MathchLike } from './util';\r\nexport declare function readXlsx(path: string): {\r\n    name: string;\r\n    data: unknown[];\r\n}[];\r\nexport declare function xlsxFormat(xData: any[]): {\r\n    [key: string]: any[];\r\n};\r\nexport declare function readdir(path: string): string[];\r\nexport declare function readFile(path: string): string;\r\nexport declare function read(path: string, ignore?: MathchLike, matchs?: {\r\n    [key: string]: MathchLike;\r\n}): string | {\r\n    [key: string]: any;\r\n};\r\n"}export declare function rmdir(path: string): Promise<any>;
{"data":"export declare function rmdir(path: string): Promise<any>;\r\n"}/// <reference types="node" />
export type FsFileData = string | Buffer | DataView;
{"data":"/// <reference types=\"node\" />\r\nexport type FsFileData = string | Buffer | DataView;\r\n"}export declare function isDirectory(path: string): boolean;
export type MathchLike = string | string[];
export declare function match(str: string, matchs: MathchLike): boolean;
{"data":"export declare function isDirectory(path: string): boolean;\r\nexport type MathchLike = string | string[];\r\nexport declare function match(str: string, matchs: MathchLike): boolean;\r\n"}export declare function writeXlsx(path: string, data: any[], options?: any): void;
{"data":"export declare function writeXlsx(path: string, data: any[], options?: any): void;\r\n"}